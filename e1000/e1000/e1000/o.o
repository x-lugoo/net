
e1000_jeff.ko:     file format elf64-x86-64


Disassembly of section .text:

0000000000000000 <e1000_alloc_dummy_rx_buffers>:
				     struct e1000_rx_ring *rx_ring,
				     int *work_done, int work_to_do);
static void e1000_alloc_dummy_rx_buffers(struct e1000_adapter *adapter,
					 struct e1000_rx_ring *rx_ring,
					 int cleaned_count)
{
       0:	e8 00 00 00 00       	callq  5 <e1000_alloc_dummy_rx_buffers+0x5>
       5:	55                   	push   %rbp
       6:	48 89 e5             	mov    %rsp,%rbp
}
       9:	5d                   	pop    %rbp
       a:	c3                   	retq   
       b:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)

0000000000000010 <e1000_fix_features>:
	}
}

static netdev_features_t e1000_fix_features(struct net_device *netdev,
	netdev_features_t features)
{
      10:	e8 00 00 00 00       	callq  15 <e1000_fix_features+0x5>
      15:	55                   	push   %rbp
	/* Since there is no support for separate Rx/Tx vlan accel
	 * enable/disable make sure Tx flag is always in same state as Rx.
	 */
	if (features & NETIF_F_HW_VLAN_CTAG_RX)
		features |= NETIF_F_HW_VLAN_CTAG_TX;
      16:	48 89 f0             	mov    %rsi,%rax
      19:	48 89 f2             	mov    %rsi,%rdx
      1c:	0c 80                	or     $0x80,%al
      1e:	80 e2 7f             	and    $0x7f,%dl
      21:	f7 c6 00 01 00 00    	test   $0x100,%esi
	}
}

static netdev_features_t e1000_fix_features(struct net_device *netdev,
	netdev_features_t features)
{
      27:	48 89 e5             	mov    %rsp,%rbp
	/* Since there is no support for separate Rx/Tx vlan accel
	 * enable/disable make sure Tx flag is always in same state as Rx.
	 */
	if (features & NETIF_F_HW_VLAN_CTAG_RX)
		features |= NETIF_F_HW_VLAN_CTAG_TX;
      2a:	48 0f 44 c2          	cmove  %rdx,%rax
	else
		features &= ~NETIF_F_HW_VLAN_CTAG_TX;

	return features;
}
      2e:	5d                   	pop    %rbp
      2f:	c3                   	retq   

0000000000000030 <e1000_setup_rctl>:
/**
 * e1000_setup_rctl - configure the receive control registers
 * @adapter: Board private structure
 **/
static void e1000_setup_rctl(struct e1000_adapter *adapter)
{
      30:	e8 00 00 00 00       	callq  35 <e1000_setup_rctl+0x5>
      35:	55                   	push   %rbp
	struct e1000_hw *hw = &adapter->hw;
	u32 rctl;

	rctl = er32(RCTL);
      36:	48 8b 87 c0 03 00 00 	mov    0x3c0(%rdi),%rax
/**
 * e1000_setup_rctl - configure the receive control registers
 * @adapter: Board private structure
 **/
static void e1000_setup_rctl(struct e1000_adapter *adapter)
{
      3d:	48 89 e5             	mov    %rsp,%rbp
{ asm volatile("mov" size " %0,%1": :reg (val), \
"m" (*(volatile type __force *)addr) barrier); }

build_mmio_read(readb, "b", unsigned char, "=q", :"memory")
build_mmio_read(readw, "w", unsigned short, "=r", :"memory")
build_mmio_read(readl, "l", unsigned int, "=r", :"memory")
      40:	8b 80 00 01 00 00    	mov    0x100(%rax),%eax

	rctl &= ~(3 << E1000_RCTL_MO_SHIFT);

	rctl |= E1000_RCTL_BAM | E1000_RCTL_LBM_NO |
		E1000_RCTL_RDMTS_HALF |
		(hw->mc_filter_type << E1000_RCTL_MO_SHIFT);
      46:	8b 97 60 04 00 00    	mov    0x460(%rdi),%edx
	struct e1000_hw *hw = &adapter->hw;
	u32 rctl;

	rctl = er32(RCTL);

	rctl &= ~(3 << E1000_RCTL_MO_SHIFT);
      4c:	80 e4 cf             	and    $0xcf,%ah

	rctl |= E1000_RCTL_BAM | E1000_RCTL_LBM_NO |
		E1000_RCTL_RDMTS_HALF |
		(hw->mc_filter_type << E1000_RCTL_MO_SHIFT);
      4f:	c1 e2 0c             	shl    $0xc,%edx

	rctl = er32(RCTL);

	rctl &= ~(3 << E1000_RCTL_MO_SHIFT);

	rctl |= E1000_RCTL_BAM | E1000_RCTL_LBM_NO |
      52:	09 d0                	or     %edx,%eax
		E1000_RCTL_RDMTS_HALF |
		(hw->mc_filter_type << E1000_RCTL_MO_SHIFT);

	if (hw->tbi_compatibility_on == 1)
      54:	80 bf cf 04 00 00 00 	cmpb   $0x0,0x4cf(%rdi)
      5b:	0f 84 87 00 00 00    	je     e8 <e1000_setup_rctl+0xb8>
		rctl |= E1000_RCTL_SBP;
      61:	0d 04 80 00 00       	or     $0x8004,%eax
	else
		rctl &= ~E1000_RCTL_SBP;

	if (adapter->netdev->mtu <= ETH_DATA_LEN)
      66:	4c 8b 87 b0 03 00 00 	mov    0x3b0(%rdi),%r8
		rctl &= ~E1000_RCTL_LPE;
      6d:	89 c2                	mov    %eax,%edx
      6f:	83 c8 20             	or     $0x20,%eax
      72:	83 e2 df             	and    $0xffffffdf,%edx
		rctl |= E1000_RCTL_LPE;

	/* Setup buffer sizes */
	rctl &= ~E1000_RCTL_SZ_4096;
	rctl |= E1000_RCTL_BSEX;
	switch (adapter->rx_buffer_len) {
      75:	8b 8f 08 02 00 00    	mov    0x208(%rdi),%ecx
		rctl |= E1000_RCTL_SBP;
	else
		rctl &= ~E1000_RCTL_SBP;

	if (adapter->netdev->mtu <= ETH_DATA_LEN)
		rctl &= ~E1000_RCTL_LPE;
      7b:	41 81 b8 30 02 00 00 	cmpl   $0x5dc,0x230(%r8)
      82:	dc 05 00 00 
      86:	0f 47 d0             	cmova  %eax,%edx
	else
		rctl |= E1000_RCTL_LPE;

	/* Setup buffer sizes */
	rctl &= ~E1000_RCTL_SZ_4096;
      89:	89 d6                	mov    %edx,%esi
      8b:	81 e6 ff ff fc ff    	and    $0xfffcffff,%esi
			break;
		case E1000_RXBUFFER_4096:
			rctl |= E1000_RCTL_SZ_4096;
			break;
		case E1000_RXBUFFER_8192:
			rctl |= E1000_RCTL_SZ_8192;
      91:	89 f0                	mov    %esi,%eax
      93:	0d 00 00 02 02       	or     $0x2020000,%eax
		rctl |= E1000_RCTL_LPE;

	/* Setup buffer sizes */
	rctl &= ~E1000_RCTL_SZ_4096;
	rctl |= E1000_RCTL_BSEX;
	switch (adapter->rx_buffer_len) {
      98:	81 f9 00 20 00 00    	cmp    $0x2000,%ecx
      9e:	74 25                	je     c5 <e1000_setup_rctl+0x95>
			break;
		case E1000_RXBUFFER_8192:
			rctl |= E1000_RCTL_SZ_8192;
			break;
		case E1000_RXBUFFER_16384:
			rctl |= E1000_RCTL_SZ_16384;
      a0:	89 f0                	mov    %esi,%eax
      a2:	0d 00 00 01 02       	or     $0x2010000,%eax
		rctl |= E1000_RCTL_LPE;

	/* Setup buffer sizes */
	rctl &= ~E1000_RCTL_SZ_4096;
	rctl |= E1000_RCTL_BSEX;
	switch (adapter->rx_buffer_len) {
      a7:	81 f9 00 40 00 00    	cmp    $0x4000,%ecx
      ad:	74 16                	je     c5 <e1000_setup_rctl+0x95>
		case E1000_RXBUFFER_2048:
		default:
			rctl |= E1000_RCTL_SZ_2048;
			rctl &= ~E1000_RCTL_BSEX;
      af:	89 d0                	mov    %edx,%eax
      b1:	81 ce 00 00 03 02    	or     $0x2030000,%esi
      b7:	25 ff ff fc fd       	and    $0xfdfcffff,%eax
      bc:	81 f9 00 10 00 00    	cmp    $0x1000,%ecx
      c2:	0f 44 c6             	cmove  %esi,%eax
			rctl |= E1000_RCTL_SZ_16384;
			break;
	}

	/* This is useful for sniffing bad packets. */
	if (adapter->netdev->features & NETIF_F_RXALL) {
      c5:	41 f6 80 f4 00 00 00 	testb  $0x40,0xf4(%r8)
      cc:	40 
      cd:	74 0a                	je     d9 <e1000_setup_rctl+0xa9>
		 */
		rctl |= (E1000_RCTL_SBP | /* Receive bad packets */
			 E1000_RCTL_BAM | /* RX All Bcast Pkts */
			 E1000_RCTL_PMCF); /* RX All MAC Ctrl Pkts */

		rctl &= ~(E1000_RCTL_VFE | /* Disable VLAN filter */
      cf:	25 ff ff b3 ff       	and    $0xffb3ffff,%eax
      d4:	0d 04 80 80 00       	or     $0x808004,%eax
		/* Do not mess with E1000_CTRL_VME, it affects transmit as well,
		 * and that breaks VLANs.
		 */
	}

	ew32(RCTL, rctl);
      d9:	48 8b 97 c0 03 00 00 	mov    0x3c0(%rdi),%rdx
build_mmio_read(__readw, "w", unsigned short, "=r", )
build_mmio_read(__readl, "l", unsigned int, "=r", )

build_mmio_write(writeb, "b", unsigned char, "q", :"memory")
build_mmio_write(writew, "w", unsigned short, "r", :"memory")
build_mmio_write(writel, "l", unsigned int, "r", :"memory")
      e0:	89 82 00 01 00 00    	mov    %eax,0x100(%rdx)
}
      e6:	5d                   	pop    %rbp
      e7:	c3                   	retq   
		(hw->mc_filter_type << E1000_RCTL_MO_SHIFT);

	if (hw->tbi_compatibility_on == 1)
		rctl |= E1000_RCTL_SBP;
	else
		rctl &= ~E1000_RCTL_SBP;
      e8:	83 e0 fb             	and    $0xfffffffb,%eax
      eb:	80 cc 80             	or     $0x80,%ah
      ee:	e9 73 ff ff ff       	jmpq   66 <e1000_setup_rctl+0x36>
      f3:	66 66 66 66 2e 0f 1f 	data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
      fa:	84 00 00 00 00 00 

0000000000000100 <e1000_configure_rx>:
 * @adapter: board private structure
 *
 * Configure the Rx unit of the MAC after a reset.
 **/
static void e1000_configure_rx(struct e1000_adapter *adapter)
{
     100:	e8 00 00 00 00       	callq  105 <e1000_configure_rx+0x5>
     105:	55                   	push   %rbp
	u64 rdba;
	struct e1000_hw *hw = &adapter->hw;
	u32 rdlen, rctl, rxcsum;

	if (adapter->netdev->mtu > ETH_DATA_LEN) {
     106:	48 8b 87 b0 03 00 00 	mov    0x3b0(%rdi),%rax
 * @adapter: board private structure
 *
 * Configure the Rx unit of the MAC after a reset.
 **/
static void e1000_configure_rx(struct e1000_adapter *adapter)
{
     10d:	48 89 e5             	mov    %rsp,%rbp
	u64 rdba;
	struct e1000_hw *hw = &adapter->hw;
	u32 rdlen, rctl, rxcsum;

	if (adapter->netdev->mtu > ETH_DATA_LEN) {
     110:	81 b8 30 02 00 00 dc 	cmpl   $0x5dc,0x230(%rax)
     117:	05 00 00 
		rdlen = adapter->rx_ring[0].count *
     11a:	48 8b 87 a8 02 00 00 	mov    0x2a8(%rdi),%rax
     121:	8b 48 14             	mov    0x14(%rax),%ecx
{
	u64 rdba;
	struct e1000_hw *hw = &adapter->hw;
	u32 rdlen, rctl, rxcsum;

	if (adapter->netdev->mtu > ETH_DATA_LEN) {
     124:	0f 86 b9 01 00 00    	jbe    2e3 <e1000_configure_rx+0x1e3>
		rdlen = adapter->rx_ring[0].count *
     12a:	c1 e1 04             	shl    $0x4,%ecx
		        sizeof(struct e1000_rx_desc);
		adapter->clean_rx = e1000_clean_jumbo_rx_irq;
     12d:	48 c7 87 98 02 00 00 	movq   $0x0,0x298(%rdi)
     134:	00 00 00 00 
		adapter->alloc_rx_buf = e1000_alloc_jumbo_rx_buffers;
     138:	48 c7 87 a0 02 00 00 	movq   $0x0,0x2a0(%rdi)
     13f:	00 00 00 00 
		adapter->clean_rx = e1000_clean_rx_irq;
		adapter->alloc_rx_buf = e1000_alloc_rx_buffers;
	}

	/* disable receives while setting up the descriptors */
	rctl = er32(RCTL);
     143:	48 8b 87 c0 03 00 00 	mov    0x3c0(%rdi),%rax
{ asm volatile("mov" size " %0,%1": :reg (val), \
"m" (*(volatile type __force *)addr) barrier); }

build_mmio_read(readb, "b", unsigned char, "=q", :"memory")
build_mmio_read(readw, "w", unsigned short, "=r", :"memory")
build_mmio_read(readl, "l", unsigned int, "=r", :"memory")
     14a:	8b b0 00 01 00 00    	mov    0x100(%rax),%esi
	ew32(RCTL, rctl & ~E1000_RCTL_EN);
     150:	89 f0                	mov    %esi,%eax
     152:	48 8b 97 c0 03 00 00 	mov    0x3c0(%rdi),%rdx
     159:	83 e0 fd             	and    $0xfffffffd,%eax
build_mmio_read(__readw, "w", unsigned short, "=r", )
build_mmio_read(__readl, "l", unsigned int, "=r", )

build_mmio_write(writeb, "b", unsigned char, "q", :"memory")
build_mmio_write(writew, "w", unsigned short, "r", :"memory")
build_mmio_write(writel, "l", unsigned int, "r", :"memory")
     15c:	89 82 00 01 00 00    	mov    %eax,0x100(%rdx)

	/* set the Receive Delay Timer Register */
	ew32(RDTR, adapter->rx_int_delay);
     162:	83 bf d8 03 00 00 03 	cmpl   $0x3,0x3d8(%rdi)
     169:	8b 97 94 03 00 00    	mov    0x394(%rdi),%edx
     16f:	48 19 c0             	sbb    %rax,%rax
     172:	48 25 e8 d8 ff ff    	and    $0xffffffffffffd8e8,%rax
     178:	48 05 20 28 00 00    	add    $0x2820,%rax
     17e:	48 03 87 c0 03 00 00 	add    0x3c0(%rdi),%rax
     185:	89 10                	mov    %edx,(%rax)

	if (hw->mac_type >= e1000_82540) {
     187:	8b 87 d8 03 00 00    	mov    0x3d8(%rdi),%eax
     18d:	83 f8 04             	cmp    $0x4,%eax
     190:	76 27                	jbe    1b9 <e1000_configure_rx+0xb9>
		ew32(RADV, adapter->rx_abs_int_delay);
     192:	48 8b 97 c0 03 00 00 	mov    0x3c0(%rdi),%rdx
     199:	8b 87 98 03 00 00    	mov    0x398(%rdi),%eax
     19f:	89 82 2c 28 00 00    	mov    %eax,0x282c(%rdx)
		if (adapter->itr_setting != 0)
     1a5:	8b 87 34 02 00 00    	mov    0x234(%rdi),%eax
     1ab:	85 c0                	test   %eax,%eax
     1ad:	0f 85 4e 01 00 00    	jne    301 <e1000_configure_rx+0x201>
     1b3:	8b 87 d8 03 00 00    	mov    0x3d8(%rdi),%eax
	 */
	switch (adapter->num_rx_queues) {
	case 1:
	default:
		rdba = adapter->rx_ring[0].dma;
		ew32(RDLEN, rdlen);
     1b9:	83 f8 03             	cmp    $0x3,%eax
	 * the Base and Length of the Rx Descriptor Ring
	 */
	switch (adapter->num_rx_queues) {
	case 1:
	default:
		rdba = adapter->rx_ring[0].dma;
     1bc:	48 8b 97 a8 02 00 00 	mov    0x2a8(%rdi),%rdx
		ew32(RDLEN, rdlen);
     1c3:	48 19 c0             	sbb    %rax,%rax
     1c6:	48 25 10 d9 ff ff    	and    $0xffffffffffffd910,%rax
     1cc:	48 05 08 28 00 00    	add    $0x2808,%rax
	 * the Base and Length of the Rx Descriptor Ring
	 */
	switch (adapter->num_rx_queues) {
	case 1:
	default:
		rdba = adapter->rx_ring[0].dma;
     1d2:	48 8b 52 08          	mov    0x8(%rdx),%rdx
		ew32(RDLEN, rdlen);
     1d6:	48 03 87 c0 03 00 00 	add    0x3c0(%rdi),%rax
     1dd:	89 08                	mov    %ecx,(%rax)
		ew32(RDBAH, (rdba >> 32));
     1df:	83 bf d8 03 00 00 03 	cmpl   $0x3,0x3d8(%rdi)
     1e6:	48 89 d1             	mov    %rdx,%rcx
     1e9:	48 19 c0             	sbb    %rax,%rax
     1ec:	48 c1 e9 20          	shr    $0x20,%rcx
     1f0:	48 25 10 d9 ff ff    	and    $0xffffffffffffd910,%rax
     1f6:	48 05 04 28 00 00    	add    $0x2804,%rax
     1fc:	48 03 87 c0 03 00 00 	add    0x3c0(%rdi),%rax
     203:	89 08                	mov    %ecx,(%rax)
		ew32(RDBAL, (rdba & 0x00000000ffffffffULL));
     205:	83 bf d8 03 00 00 03 	cmpl   $0x3,0x3d8(%rdi)
     20c:	48 19 c0             	sbb    %rax,%rax
     20f:	48 25 10 d9 ff ff    	and    $0xffffffffffffd910,%rax
     215:	48 05 00 28 00 00    	add    $0x2800,%rax
     21b:	48 03 87 c0 03 00 00 	add    0x3c0(%rdi),%rax
     222:	89 10                	mov    %edx,(%rax)
		ew32(RDT, 0);
     224:	83 bf d8 03 00 00 03 	cmpl   $0x3,0x3d8(%rdi)
     22b:	48 19 c0             	sbb    %rax,%rax
     22e:	31 d2                	xor    %edx,%edx
     230:	48 25 10 d9 ff ff    	and    $0xffffffffffffd910,%rax
     236:	48 05 18 28 00 00    	add    $0x2818,%rax
     23c:	48 03 87 c0 03 00 00 	add    0x3c0(%rdi),%rax
     243:	89 10                	mov    %edx,(%rax)
		ew32(RDH, 0);
     245:	83 bf d8 03 00 00 03 	cmpl   $0x3,0x3d8(%rdi)
     24c:	48 19 c0             	sbb    %rax,%rax
     24f:	48 25 10 d9 ff ff    	and    $0xffffffffffffd910,%rax
     255:	48 05 10 28 00 00    	add    $0x2810,%rax
     25b:	48 03 87 c0 03 00 00 	add    0x3c0(%rdi),%rax
     262:	89 10                	mov    %edx,(%rax)
		adapter->rx_ring[0].rdh = ((hw->mac_type >= e1000_82543) ?
     264:	83 bf d8 03 00 00 03 	cmpl   $0x3,0x3d8(%rdi)
     26b:	48 8b 97 a8 02 00 00 	mov    0x2a8(%rdi),%rdx
     272:	19 c0                	sbb    %eax,%eax
     274:	66 25 10 d9          	and    $0xd910,%ax
     278:	66 05 10 28          	add    $0x2810,%ax
     27c:	66 89 42 34          	mov    %ax,0x34(%rdx)
					   E1000_RDH : E1000_82542_RDH);
		adapter->rx_ring[0].rdt = ((hw->mac_type >= e1000_82543) ?
     280:	83 bf d8 03 00 00 03 	cmpl   $0x3,0x3d8(%rdi)
     287:	48 8b 97 a8 02 00 00 	mov    0x2a8(%rdi),%rdx
     28e:	19 c0                	sbb    %eax,%eax
     290:	66 25 10 d9          	and    $0xd910,%ax
     294:	66 05 18 28          	add    $0x2818,%ax
     298:	66 89 42 36          	mov    %ax,0x36(%rdx)
					   E1000_RDT : E1000_82542_RDT);
		break;
	}

	/* Enable 82543 Receive Checksum Offload for TCP and UDP */
	if (hw->mac_type >= e1000_82543) {
     29c:	83 bf d8 03 00 00 02 	cmpl   $0x2,0x3d8(%rdi)
     2a3:	76 2c                	jbe    2d1 <e1000_configure_rx+0x1d1>
		rxcsum = er32(RXCSUM);
     2a5:	48 8b 87 c0 03 00 00 	mov    0x3c0(%rdi),%rax
{ asm volatile("mov" size " %0,%1": :reg (val), \
"m" (*(volatile type __force *)addr) barrier); }

build_mmio_read(readb, "b", unsigned char, "=q", :"memory")
build_mmio_read(readw, "w", unsigned short, "=r", :"memory")
build_mmio_read(readl, "l", unsigned int, "=r", :"memory")
     2ac:	8b 90 00 50 00 00    	mov    0x5000(%rax),%edx
		if (adapter->rx_csum)
			rxcsum |= E1000_RXCSUM_TUOFL;
     2b2:	89 d0                	mov    %edx,%eax
     2b4:	80 e6 fd             	and    $0xfd,%dh
     2b7:	80 cc 02             	or     $0x2,%ah
     2ba:	80 bf 9c 03 00 00 00 	cmpb   $0x0,0x39c(%rdi)
     2c1:	0f 44 c2             	cmove  %edx,%eax
		else
			/* don't need to clear IPPCSE as it defaults to 0 */
			rxcsum &= ~E1000_RXCSUM_TUOFL;
		ew32(RXCSUM, rxcsum);
     2c4:	48 8b 97 c0 03 00 00 	mov    0x3c0(%rdi),%rdx
build_mmio_read(__readw, "w", unsigned short, "=r", )
build_mmio_read(__readl, "l", unsigned int, "=r", )

build_mmio_write(writeb, "b", unsigned char, "q", :"memory")
build_mmio_write(writew, "w", unsigned short, "r", :"memory")
build_mmio_write(writel, "l", unsigned int, "r", :"memory")
     2cb:	89 82 00 50 00 00    	mov    %eax,0x5000(%rdx)
	}

	/* Enable Receives */
	ew32(RCTL, rctl | E1000_RCTL_EN);
     2d1:	48 8b 87 c0 03 00 00 	mov    0x3c0(%rdi),%rax
     2d8:	83 ce 02             	or     $0x2,%esi
     2db:	89 b0 00 01 00 00    	mov    %esi,0x100(%rax)
}
     2e1:	5d                   	pop    %rbp
     2e2:	c3                   	retq   
		rdlen = adapter->rx_ring[0].count *
		        sizeof(struct e1000_rx_desc);
		adapter->clean_rx = e1000_clean_jumbo_rx_irq;
		adapter->alloc_rx_buf = e1000_alloc_jumbo_rx_buffers;
	} else {
		rdlen = adapter->rx_ring[0].count *
     2e3:	c1 e1 04             	shl    $0x4,%ecx
		        sizeof(struct e1000_rx_desc);
		adapter->clean_rx = e1000_clean_rx_irq;
     2e6:	48 c7 87 98 02 00 00 	movq   $0x0,0x298(%rdi)
     2ed:	00 00 00 00 
		adapter->alloc_rx_buf = e1000_alloc_rx_buffers;
     2f1:	48 c7 87 a0 02 00 00 	movq   $0x0,0x2a0(%rdi)
     2f8:	00 00 00 00 
     2fc:	e9 42 fe ff ff       	jmpq   143 <e1000_configure_rx+0x43>
	ew32(RDTR, adapter->rx_int_delay);

	if (hw->mac_type >= e1000_82540) {
		ew32(RADV, adapter->rx_abs_int_delay);
		if (adapter->itr_setting != 0)
			ew32(ITR, 1000000000 / (adapter->itr * 256));
     301:	44 8b 87 30 02 00 00 	mov    0x230(%rdi),%r8d
     308:	31 d2                	xor    %edx,%edx
     30a:	b8 00 ca 9a 3b       	mov    $0x3b9aca00,%eax
     30f:	4c 8b 8f c0 03 00 00 	mov    0x3c0(%rdi),%r9
     316:	41 c1 e0 08          	shl    $0x8,%r8d
     31a:	41 f7 f0             	div    %r8d
     31d:	41 89 81 c4 00 00 00 	mov    %eax,0xc4(%r9)
     324:	e9 8a fe ff ff       	jmpq   1b3 <e1000_configure_rx+0xb3>
     329:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)

0000000000000330 <e1000_get_stats>:
 *
 * Returns the address of the device statistics structure.
 * The statistics are actually updated from the watchdog.
 **/
static struct net_device_stats *e1000_get_stats(struct net_device *netdev)
{
     330:	e8 00 00 00 00       	callq  335 <e1000_get_stats+0x5>
     335:	55                   	push   %rbp
	/* only return the current stats */
	return &netdev->stats;
     336:	48 8d 87 28 01 00 00 	lea    0x128(%rdi),%rax
 *
 * Returns the address of the device statistics structure.
 * The statistics are actually updated from the watchdog.
 **/
static struct net_device_stats *e1000_get_stats(struct net_device *netdev)
{
     33d:	48 89 e5             	mov    %rsp,%rbp
	/* only return the current stats */
	return &netdev->stats;
}
     340:	5d                   	pop    %rbp
     341:	c3                   	retq   
     342:	66 66 66 66 66 2e 0f 	data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
     349:	1f 84 00 00 00 00 00 

0000000000000350 <e1000_update_itr>:
 *      this functionality is controlled by the InterruptThrottleRate module
 *      parameter (see e1000_param.c)
 **/
static unsigned int e1000_update_itr(struct e1000_adapter *adapter,
				     u16 itr_setting, int packets, int bytes)
{
     350:	e8 00 00 00 00       	callq  355 <e1000_update_itr+0x5>
     355:	55                   	push   %rbp
	unsigned int retval = itr_setting;
	struct e1000_hw *hw = &adapter->hw;

	if (unlikely(hw->mac_type < e1000_82540))
     356:	83 bf d8 03 00 00 04 	cmpl   $0x4,0x3d8(%rdi)
 *      parameter (see e1000_param.c)
 **/
static unsigned int e1000_update_itr(struct e1000_adapter *adapter,
				     u16 itr_setting, int packets, int bytes)
{
	unsigned int retval = itr_setting;
     35d:	44 0f b7 ce          	movzwl %si,%r9d
 *      this functionality is controlled by the InterruptThrottleRate module
 *      parameter (see e1000_param.c)
 **/
static unsigned int e1000_update_itr(struct e1000_adapter *adapter,
				     u16 itr_setting, int packets, int bytes)
{
     361:	48 89 e5             	mov    %rsp,%rbp
	unsigned int retval = itr_setting;
	struct e1000_hw *hw = &adapter->hw;

	if (unlikely(hw->mac_type < e1000_82540))
     364:	76 29                	jbe    38f <e1000_update_itr+0x3f>
		goto update_itr_done;

	if (packets == 0)
     366:	85 d2                	test   %edx,%edx
     368:	41 89 d0             	mov    %edx,%r8d
     36b:	74 22                	je     38f <e1000_update_itr+0x3f>
		goto update_itr_done;

	switch (itr_setting) {
     36d:	66 83 fe 01          	cmp    $0x1,%si
     371:	74 21                	je     394 <e1000_update_itr+0x44>
     373:	72 37                	jb     3ac <e1000_update_itr+0x5c>
     375:	66 83 fe 02          	cmp    $0x2,%si
     379:	75 14                	jne    38f <e1000_update_itr+0x3f>
			retval = bulk_latency;
		else if (packets <= 2 && bytes < 512)
			retval = lowest_latency;
		break;
	case bulk_latency: /* 250 usec aka 4000 ints/s */
		if (bytes > 25000) {
     37b:	81 f9 a8 61 00 00    	cmp    $0x61a8,%ecx
     381:	7e 4d                	jle    3d0 <e1000_update_itr+0x80>
	case lowest_latency:
		/* jumbo frames get bulk treatment*/
		if (bytes/packets > 8000)
			retval = bulk_latency;
		else if ((packets < 5) && (bytes > 512))
			retval = low_latency;
     383:	83 fa 24             	cmp    $0x24,%edx
     386:	b8 01 00 00 00       	mov    $0x1,%eax
     38b:	44 0f 4d c8          	cmovge %eax,%r9d
		break;
	}

update_itr_done:
	return retval;
}
     38f:	44 89 c8             	mov    %r9d,%eax
     392:	5d                   	pop    %rbp
     393:	c3                   	retq   
			retval = bulk_latency;
		else if ((packets < 5) && (bytes > 512))
			retval = low_latency;
		break;
	case low_latency:  /* 50 usec aka 20000 ints/s */
		if (bytes > 10000) {
     394:	81 f9 10 27 00 00    	cmp    $0x2710,%ecx
     39a:	7e 45                	jle    3e1 <e1000_update_itr+0x91>
			/* jumbo frames need bulk latency setting */
			if (bytes/packets > 8000)
				retval = bulk_latency;
			else if ((packets < 10) || ((bytes/packets) > 1200))
     39c:	83 fa 09             	cmp    $0x9,%edx
     39f:	7f 64                	jg     405 <e1000_update_itr+0xb5>

	switch (itr_setting) {
	case lowest_latency:
		/* jumbo frames get bulk treatment*/
		if (bytes/packets > 8000)
			retval = bulk_latency;
     3a1:	41 b9 02 00 00 00    	mov    $0x2,%r9d
		break;
	}

update_itr_done:
	return retval;
}
     3a7:	44 89 c8             	mov    %r9d,%eax
     3aa:	5d                   	pop    %rbp
     3ab:	c3                   	retq   
		goto update_itr_done;

	switch (itr_setting) {
	case lowest_latency:
		/* jumbo frames get bulk treatment*/
		if (bytes/packets > 8000)
     3ac:	89 c8                	mov    %ecx,%eax
     3ae:	99                   	cltd   
     3af:	41 f7 f8             	idiv   %r8d
     3b2:	3d 40 1f 00 00       	cmp    $0x1f40,%eax
     3b7:	7f e8                	jg     3a1 <e1000_update_itr+0x51>
			retval = bulk_latency;
		else if ((packets < 5) && (bytes > 512))
     3b9:	41 83 f8 04          	cmp    $0x4,%r8d
     3bd:	7f d0                	jg     38f <e1000_update_itr+0x3f>
			retval = low_latency;
     3bf:	81 f9 00 02 00 00    	cmp    $0x200,%ecx
     3c5:	b8 01 00 00 00       	mov    $0x1,%eax
     3ca:	44 0f 4f c8          	cmovg  %eax,%r9d
     3ce:	eb bf                	jmp    38f <e1000_update_itr+0x3f>
     3d0:	81 f9 6f 17 00 00    	cmp    $0x176f,%ecx
     3d6:	b8 01 00 00 00       	mov    $0x1,%eax
     3db:	44 0f 4e c8          	cmovle %eax,%r9d
     3df:	eb ae                	jmp    38f <e1000_update_itr+0x3f>
				retval = bulk_latency;
			else if ((packets < 10) || ((bytes/packets) > 1200))
				retval = bulk_latency;
			else if ((packets > 35))
				retval = lowest_latency;
		} else if (bytes/packets > 2000)
     3e1:	89 c8                	mov    %ecx,%eax
     3e3:	99                   	cltd   
     3e4:	41 f7 f8             	idiv   %r8d
     3e7:	3d d0 07 00 00       	cmp    $0x7d0,%eax
     3ec:	7f b3                	jg     3a1 <e1000_update_itr+0x51>
			retval = bulk_latency;
		else if (packets <= 2 && bytes < 512)
     3ee:	41 83 f8 02          	cmp    $0x2,%r8d
     3f2:	7f 9b                	jg     38f <e1000_update_itr+0x3f>
			if (bytes/packets > 8000)
				retval = bulk_latency;
			else if ((packets < 10) || ((bytes/packets) > 1200))
				retval = bulk_latency;
			else if ((packets > 35))
				retval = lowest_latency;
     3f4:	81 f9 ff 01 00 00    	cmp    $0x1ff,%ecx
     3fa:	b8 00 00 00 00       	mov    $0x0,%eax
     3ff:	44 0f 4e c8          	cmovle %eax,%r9d
     403:	eb 8a                	jmp    38f <e1000_update_itr+0x3f>
			retval = low_latency;
		break;
	case low_latency:  /* 50 usec aka 20000 ints/s */
		if (bytes > 10000) {
			/* jumbo frames need bulk latency setting */
			if (bytes/packets > 8000)
     405:	89 c8                	mov    %ecx,%eax
     407:	99                   	cltd   
     408:	41 f7 f8             	idiv   %r8d
				retval = bulk_latency;
			else if ((packets < 10) || ((bytes/packets) > 1200))
     40b:	3d b0 04 00 00       	cmp    $0x4b0,%eax
     410:	7f 8f                	jg     3a1 <e1000_update_itr+0x51>
				retval = bulk_latency;
			else if ((packets > 35))
				retval = lowest_latency;
     412:	41 83 f8 24          	cmp    $0x24,%r8d
     416:	b8 00 00 00 00       	mov    $0x0,%eax
     41b:	44 0f 4d c8          	cmovge %eax,%r9d
     41f:	e9 6b ff ff ff       	jmpq   38f <e1000_update_itr+0x3f>
     424:	66 66 66 2e 0f 1f 84 	data32 data32 nopw %cs:0x0(%rax,%rax,1)
     42b:	00 00 00 00 00 

0000000000000430 <e1000_alloc_frag>:
	return SKB_DATA_ALIGN(a->rx_buffer_len + E1000_HEADROOM) +
		SKB_DATA_ALIGN(sizeof(struct skb_shared_info));
}

static void *e1000_alloc_frag(const struct e1000_adapter *a)
{
     430:	e8 00 00 00 00       	callq  435 <e1000_alloc_frag+0x5>
     435:	55                   	push   %rbp
}

#define E1000_HEADROOM (NET_SKB_PAD + NET_IP_ALIGN)
static unsigned int e1000_frag_len(const struct e1000_adapter *a)
{
	return SKB_DATA_ALIGN(a->rx_buffer_len + E1000_HEADROOM) +
     436:	8b bf 08 02 00 00    	mov    0x208(%rdi),%edi
		SKB_DATA_ALIGN(sizeof(struct skb_shared_info));
}

static void *e1000_alloc_frag(const struct e1000_adapter *a)
{
     43c:	48 89 e5             	mov    %rsp,%rbp
}

#define E1000_HEADROOM (NET_SKB_PAD + NET_IP_ALIGN)
static unsigned int e1000_frag_len(const struct e1000_adapter *a)
{
	return SKB_DATA_ALIGN(a->rx_buffer_len + E1000_HEADROOM) +
     43f:	83 c7 7f             	add    $0x7f,%edi
     442:	83 e7 c0             	and    $0xffffffc0,%edi
     445:	81 c7 40 01 00 00    	add    $0x140,%edi
}

static void *e1000_alloc_frag(const struct e1000_adapter *a)
{
	unsigned int len = e1000_frag_len(a);
	u8 *data = netdev_alloc_frag(len);
     44b:	e8 00 00 00 00       	callq  450 <e1000_alloc_frag+0x20>

	if (likely(data))
     450:	48 85 c0             	test   %rax,%rax
     453:	74 04                	je     459 <e1000_alloc_frag+0x29>
		data += E1000_HEADROOM;
     455:	48 83 c0 40          	add    $0x40,%rax
	return data;
}
     459:	5d                   	pop    %rbp
     45a:	c3                   	retq   
     45b:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)

0000000000000460 <print_once>:
}
 

	    
static void  print_once(int *i,char *s,...)
{
     460:	e8 00 00 00 00       	callq  465 <print_once+0x5>
     465:	55                   	push   %rbp
     466:	48 89 e5             	mov    %rsp,%rbp
     469:	48 83 ec 48          	sub    $0x48,%rsp
     46d:	48 89 54 24 28       	mov    %rdx,0x28(%rsp)
     472:	48 89 4c 24 30       	mov    %rcx,0x30(%rsp)
     477:	4c 89 44 24 38       	mov    %r8,0x38(%rsp)
     47c:	4c 89 4c 24 40       	mov    %r9,0x40(%rsp)
	if(*i == 1){
     481:	83 3f 01             	cmpl   $0x1,(%rdi)
     484:	74 02                	je     488 <print_once+0x28>
	va_list args;
	va_start(args,s);
	vprintk(s,args);
	va_end(args);
}
}
     486:	c9                   	leaveq 
     487:	c3                   	retq   
     488:	48 89 f0             	mov    %rsi,%rax
static void  print_once(int *i,char *s,...)
{
	if(*i == 1){
	*i = 2;
	va_list args;
	va_start(args,s);
     48b:	48 8d 55 10          	lea    0x10(%rbp),%rdx
     48f:	48 8d 4c 24 18       	lea    0x18(%rsp),%rcx

	    
static void  print_once(int *i,char *s,...)
{
	if(*i == 1){
	*i = 2;
     494:	c7 07 02 00 00 00    	movl   $0x2,(%rdi)
	va_list args;
	va_start(args,s);
	vprintk(s,args);
     49a:	48 89 e6             	mov    %rsp,%rsi
     49d:	48 89 c7             	mov    %rax,%rdi
static void  print_once(int *i,char *s,...)
{
	if(*i == 1){
	*i = 2;
	va_list args;
	va_start(args,s);
     4a0:	c7 04 24 10 00 00 00 	movl   $0x10,(%rsp)
     4a7:	48 89 54 24 08       	mov    %rdx,0x8(%rsp)
     4ac:	48 89 4c 24 10       	mov    %rcx,0x10(%rsp)
	vprintk(s,args);
     4b1:	e8 00 00 00 00       	callq  4b6 <print_once+0x56>
	va_end(args);
}
}
     4b6:	c9                   	leaveq 
     4b7:	c3                   	retq   
     4b8:	0f 1f 84 00 00 00 00 	nopl   0x0(%rax,%rax,1)
     4bf:	00 

00000000000004c0 <e1000_intr>:
 * e1000_intr - Interrupt Handler
 * @irq: interrupt number
 * @data: pointer to a network interface device structure
 **/
static irqreturn_t e1000_intr(int irq, void *data)
{
     4c0:	e8 00 00 00 00       	callq  4c5 <e1000_intr+0x5>
     4c5:	55                   	push   %rbp
     4c6:	48 89 e5             	mov    %rsp,%rbp
     4c9:	41 54                	push   %r12
     4cb:	53                   	push   %rbx
     4cc:	48 89 f3             	mov    %rsi,%rbx
	struct net_device *netdev = data;
	struct e1000_adapter *adapter = netdev_priv(netdev);
	struct e1000_hw *hw = &adapter->hw;
	static 	int i = 1,i1 = 1,i2 = 1,i3 = 1;
	u32 icr = er32(ICR);
     4cf:	48 8b 86 00 0c 00 00 	mov    0xc00(%rsi),%rax
{ asm volatile("mov" size " %0,%1": :reg (val), \
"m" (*(volatile type __force *)addr) barrier); }

build_mmio_read(readb, "b", unsigned char, "=q", :"memory")
build_mmio_read(readw, "w", unsigned short, "=r", :"memory")
build_mmio_read(readl, "l", unsigned int, "=r", :"memory")
     4d6:	44 8b a0 c0 00 00 00 	mov    0xc0(%rax),%r12d

		
	print_once(&i,"e1000_intr,test\n");
     4dd:	31 c0                	xor    %eax,%eax
     4df:	48 c7 c6 00 00 00 00 	mov    $0x0,%rsi
     4e6:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
     4ed:	e8 6e ff ff ff       	callq  460 <print_once>
	if (unlikely((!icr)))
     4f2:	45 85 e4             	test   %r12d,%r12d
     4f5:	0f 84 39 01 00 00    	je     634 <e1000_intr+0x174>
}

static __always_inline int constant_test_bit(long nr, const volatile unsigned long *addr)
{
	return ((1UL << (nr & (BITS_PER_LONG-1))) &
		(addr[nr >> _BITOPS_LONG_SHIFT])) != 0;
     4fb:	48 8b 83 e8 0f 00 00 	mov    0xfe8(%rbx),%rax

	/* we might have caused the interrupt, but the above
	 * read cleared it, and just in case the driver is
	 * down there is nothing to do so return handled
	 */
	if (unlikely(test_bit(__E1000_DOWN, &adapter->flags)))
     502:	a8 04                	test   $0x4,%al
     504:	0f 85 20 01 00 00    	jne    62a <e1000_intr+0x16a>
		return IRQ_HANDLED;

	if (unlikely(icr & (E1000_ICR_RXSEQ | E1000_ICR_LSC))) {
     50a:	41 83 e4 0c          	and    $0xc,%r12d
     50e:	0f 85 de 00 00 00    	jne    5f2 <e1000_intr+0x132>
		if (!test_bit(__E1000_DOWN, &adapter->flags))
			schedule_delayed_work(&adapter->watchdog_task, 1);
	}

	/* disable interrupts, without the synchronize_irq bit */
	ew32(IMC, ~0);
     514:	48 8b 93 00 0c 00 00 	mov    0xc00(%rbx),%rdx
build_mmio_read(__readw, "w", unsigned short, "=r", )
build_mmio_read(__readl, "l", unsigned int, "=r", )

build_mmio_write(writeb, "b", unsigned char, "q", :"memory")
build_mmio_write(writew, "w", unsigned short, "r", :"memory")
build_mmio_write(writel, "l", unsigned int, "r", :"memory")
     51b:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
     520:	89 82 d8 00 00 00    	mov    %eax,0xd8(%rdx)
	E1000_WRITE_FLUSH();
     526:	48 8b 83 00 0c 00 00 	mov    0xc00(%rbx),%rax
{ asm volatile("mov" size " %0,%1": :reg (val), \
"m" (*(volatile type __force *)addr) barrier); }

build_mmio_read(readb, "b", unsigned char, "=q", :"memory")
build_mmio_read(readw, "w", unsigned short, "=r", :"memory")
build_mmio_read(readl, "l", unsigned int, "=r", :"memory")
     52d:	8b 40 08             	mov    0x8(%rax),%eax
     530:	48 8b 83 00 0b 00 00 	mov    0xb00(%rbx),%rax
 * insure only one NAPI poll instance runs.  We also make
 * sure there is no pending NAPI disable.
 */
static inline bool napi_schedule_prep(struct napi_struct *n)
{
	return !napi_disable_pending(n) &&
     537:	a8 02                	test   $0x2,%al
     539:	75 79                	jne    5b4 <e1000_intr+0xf4>
 * This operation is atomic and cannot be reordered.
 * It also implies a memory barrier.
 */
static inline int test_and_set_bit(long nr, volatile unsigned long *addr)
{
	GEN_BINARY_RMWcc(LOCK_PREFIX "bts", *addr, "Ir", nr, "%0", "c");
     53b:	f0 0f ba ab 00 0b 00 	lock btsl $0x0,0xb00(%rbx)
     542:	00 00 
     544:	72 6e                	jb     5b4 <e1000_intr+0xf4>

	if (likely(napi_schedule_prep(&adapter->napi))) {
		print_once(&i1,"e1000_intr,testi1\n");
     546:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
     54d:	48 c7 c6 00 00 00 00 	mov    $0x0,%rsi
     554:	31 c0                	xor    %eax,%eax
     556:	e8 05 ff ff ff       	callq  460 <print_once>

	/* disable interrupts, without the synchronize_irq bit */
	ew32(IMC, ~0);
	E1000_WRITE_FLUSH();

	if (likely(napi_schedule_prep(&adapter->napi))) {
     55b:	48 8d bb f0 0a 00 00 	lea    0xaf0(%rbx),%rdi
		print_once(&i1,"e1000_intr,testi1\n");
		adapter->total_tx_bytes = 0;
     562:	c7 83 60 0a 00 00 00 	movl   $0x0,0xa60(%rbx)
     569:	00 00 00 
		adapter->total_tx_packets = 0;
     56c:	c7 83 64 0a 00 00 00 	movl   $0x0,0xa64(%rbx)
     573:	00 00 00 
		adapter->total_rx_bytes = 0;
     576:	c7 83 68 0a 00 00 00 	movl   $0x0,0xa68(%rbx)
     57d:	00 00 00 
		adapter->total_rx_packets = 0;
     580:	c7 83 6c 0a 00 00 00 	movl   $0x0,0xa6c(%rbx)
     587:	00 00 00 
		__napi_schedule(&adapter->napi);
     58a:	e8 00 00 00 00       	callq  58f <e1000_intr+0xcf>
		print_once(&i2,"e1000_intr,testi2\n");
		if (!test_bit(__E1000_DOWN, &adapter->flags))
			e1000_irq_enable(adapter);
	}

	print_once(&i3,",test3 tx_bytes=%ld",adapter->total_tx_bytes);
     58f:	8b 93 60 0a 00 00    	mov    0xa60(%rbx),%edx
     595:	31 c0                	xor    %eax,%eax
     597:	48 c7 c6 00 00 00 00 	mov    $0x0,%rsi
     59e:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
     5a5:	e8 b6 fe ff ff       	callq  460 <print_once>
	return IRQ_HANDLED;
     5aa:	b8 01 00 00 00       	mov    $0x1,%eax
}
     5af:	5b                   	pop    %rbx
     5b0:	41 5c                	pop    %r12
     5b2:	5d                   	pop    %rbp
     5b3:	c3                   	retq   
		__napi_schedule(&adapter->napi);
	} else {
		/* this really should not happen! if it does it is basically a
		 * bug, but not a hard error, so enable ints and continue
		 */
		print_once(&i2,"e1000_intr,testi2\n");
     5b4:	31 c0                	xor    %eax,%eax
     5b6:	48 c7 c6 00 00 00 00 	mov    $0x0,%rsi
     5bd:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
     5c4:	e8 97 fe ff ff       	callq  460 <print_once>
}

static __always_inline int constant_test_bit(long nr, const volatile unsigned long *addr)
{
	return ((1UL << (nr & (BITS_PER_LONG-1))) &
		(addr[nr >> _BITOPS_LONG_SHIFT])) != 0;
     5c9:	48 8b 83 e8 0f 00 00 	mov    0xfe8(%rbx),%rax
		if (!test_bit(__E1000_DOWN, &adapter->flags))
     5d0:	a8 04                	test   $0x4,%al
     5d2:	75 bb                	jne    58f <e1000_intr+0xcf>
 **/
static void e1000_irq_enable(struct e1000_adapter *adapter)
{
	struct e1000_hw *hw = &adapter->hw;

	ew32(IMS, IMS_ENABLE_MASK);
     5d4:	48 8b 93 00 0c 00 00 	mov    0xc00(%rbx),%rdx
build_mmio_read(__readw, "w", unsigned short, "=r", )
build_mmio_read(__readl, "l", unsigned int, "=r", )

build_mmio_write(writeb, "b", unsigned char, "q", :"memory")
build_mmio_write(writew, "w", unsigned short, "r", :"memory")
build_mmio_write(writel, "l", unsigned int, "r", :"memory")
     5db:	b8 9d 00 00 00       	mov    $0x9d,%eax
     5e0:	89 82 d0 00 00 00    	mov    %eax,0xd0(%rdx)
	E1000_WRITE_FLUSH();
     5e6:	48 8b 83 00 0c 00 00 	mov    0xc00(%rbx),%rax
{ asm volatile("mov" size " %0,%1": :reg (val), \
"m" (*(volatile type __force *)addr) barrier); }

build_mmio_read(readb, "b", unsigned char, "=q", :"memory")
build_mmio_read(readw, "w", unsigned short, "=r", :"memory")
build_mmio_read(readl, "l", unsigned int, "=r", :"memory")
     5ed:	8b 40 08             	mov    0x8(%rax),%eax
     5f0:	eb 9d                	jmp    58f <e1000_intr+0xcf>
     5f2:	48 8b 83 e8 0f 00 00 	mov    0xfe8(%rbx),%rax
	 */
	if (unlikely(test_bit(__E1000_DOWN, &adapter->flags)))
		return IRQ_HANDLED;

	if (unlikely(icr & (E1000_ICR_RXSEQ | E1000_ICR_LSC))) {
		hw->get_link_status = 1;
     5f9:	c6 83 0c 0d 00 00 01 	movb   $0x1,0xd0c(%rbx)
		/* guard against interrupt when we're going down */
		if (!test_bit(__E1000_DOWN, &adapter->flags))
     600:	a8 04                	test   $0x4,%al
     602:	0f 85 0c ff ff ff    	jne    514 <e1000_intr+0x54>
 */
static inline bool queue_delayed_work(struct workqueue_struct *wq,
				      struct delayed_work *dwork,
				      unsigned long delay)
{
	return queue_delayed_work_on(WORK_CPU_UNBOUND, wq, dwork, delay);
     608:	48 8b 35 00 00 00 00 	mov    0x0(%rip),%rsi        # 60f <e1000_intr+0x14f>
			schedule_delayed_work(&adapter->watchdog_task, 1);
     60f:	48 8d 93 20 10 00 00 	lea    0x1020(%rbx),%rdx
     616:	b9 01 00 00 00       	mov    $0x1,%ecx
     61b:	bf 00 01 00 00       	mov    $0x100,%edi
     620:	e8 00 00 00 00       	callq  625 <e1000_intr+0x165>
     625:	e9 ea fe ff ff       	jmpq   514 <e1000_intr+0x54>
	/* we might have caused the interrupt, but the above
	 * read cleared it, and just in case the driver is
	 * down there is nothing to do so return handled
	 */
	if (unlikely(test_bit(__E1000_DOWN, &adapter->flags)))
		return IRQ_HANDLED;
     62a:	b8 01 00 00 00       	mov    $0x1,%eax
     62f:	e9 7b ff ff ff       	jmpq   5af <e1000_intr+0xef>
	u32 icr = er32(ICR);

		
	print_once(&i,"e1000_intr,test\n");
	if (unlikely((!icr)))
		return IRQ_NONE;  /* Not our interrupt */
     634:	31 c0                	xor    %eax,%eax
     636:	e9 74 ff ff ff       	jmpq   5af <e1000_intr+0xef>
     63b:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)

0000000000000640 <e1000_request_irq>:
}

module_exit(e1000_exit_module);

static int e1000_request_irq(struct e1000_adapter *adapter)
{
     640:	e8 00 00 00 00       	callq  645 <e1000_request_irq+0x5>
     645:	55                   	push   %rbp

static inline int __must_check
request_irq(unsigned int irq, irq_handler_t handler, unsigned long flags,
	    const char *name, void *dev)
{
	return request_threaded_irq(irq, handler, NULL, flags, name, dev);
     646:	31 d2                	xor    %edx,%edx
     648:	b9 80 00 00 00       	mov    $0x80,%ecx
     64d:	48 c7 c6 00 00 00 00 	mov    $0x0,%rsi
     654:	48 89 e5             	mov    %rsp,%rbp
     657:	41 54                	push   %r12
     659:	53                   	push   %rbx
	struct net_device *netdev = adapter->netdev;
	irq_handler_t handler = e1000_intr;
	int irq_flags = IRQF_SHARED;
	int err;

	err = request_irq(adapter->pdev->irq, handler, irq_flags, netdev->name,
     65a:	48 8b 87 b8 03 00 00 	mov    0x3b8(%rdi),%rax
}

module_exit(e1000_exit_module);

static int e1000_request_irq(struct e1000_adapter *adapter)
{
     661:	48 89 fb             	mov    %rdi,%rbx
	struct net_device *netdev = adapter->netdev;
     664:	4c 8b 87 b0 03 00 00 	mov    0x3b0(%rdi),%r8
     66b:	8b b8 74 03 00 00    	mov    0x374(%rax),%edi
     671:	4d 89 c1             	mov    %r8,%r9
     674:	e8 00 00 00 00       	callq  679 <e1000_request_irq+0x39>
	int irq_flags = IRQF_SHARED;
	int err;

	err = request_irq(adapter->pdev->irq, handler, irq_flags, netdev->name,
	                  netdev);
	if (err) {
     679:	85 c0                	test   %eax,%eax
     67b:	41 89 c4             	mov    %eax,%r12d
     67e:	74 09                	je     689 <e1000_request_irq+0x49>
		e_err(probe, "Unable to allocate interrupt Error: %d\n", err);
     680:	f6 83 a0 07 00 00 02 	testb  $0x2,0x7a0(%rbx)
     687:	75 08                	jne    691 <e1000_request_irq+0x51>
	}

	return err;
}
     689:	5b                   	pop    %rbx
     68a:	44 89 e0             	mov    %r12d,%eax
     68d:	41 5c                	pop    %r12
     68f:	5d                   	pop    %rbp
     690:	c3                   	retq   
	int err;

	err = request_irq(adapter->pdev->irq, handler, irq_flags, netdev->name,
	                  netdev);
	if (err) {
		e_err(probe, "Unable to allocate interrupt Error: %d\n", err);
     691:	48 8b bb b0 03 00 00 	mov    0x3b0(%rbx),%rdi
     698:	89 c2                	mov    %eax,%edx
     69a:	48 c7 c6 00 00 00 00 	mov    $0x0,%rsi
     6a1:	31 c0                	xor    %eax,%eax
     6a3:	e8 00 00 00 00       	callq  6a8 <e1000_request_irq+0x68>
	}

	return err;
}
     6a8:	5b                   	pop    %rbx
     6a9:	44 89 e0             	mov    %r12d,%eax
     6ac:	41 5c                	pop    %r12
     6ae:	5d                   	pop    %rbp
     6af:	c3                   	retq   

00000000000006b0 <e1000_down_and_stop>:
out:
	return;
}

static void e1000_down_and_stop(struct e1000_adapter *adapter)
{
     6b0:	e8 00 00 00 00       	callq  6b5 <e1000_down_and_stop+0x5>
     6b5:	55                   	push   %rbp
     6b6:	48 89 e5             	mov    %rsp,%rbp
     6b9:	53                   	push   %rbx
     6ba:	48 89 fb             	mov    %rdi,%rbx
 */
static __always_inline void
set_bit(long nr, volatile unsigned long *addr)
{
	if (IS_IMMEDIATE(nr)) {
		asm volatile(LOCK_PREFIX "orb %1,%0"
     6bd:	f0 80 8f a8 07 00 00 	lock orb $0x4,0x7a8(%rdi)
     6c4:	04 
	set_bit(__E1000_DOWN, &adapter->flags);

	cancel_delayed_work_sync(&adapter->watchdog_task);
     6c5:	48 8d bf e0 07 00 00 	lea    0x7e0(%rdi),%rdi
     6cc:	e8 00 00 00 00       	callq  6d1 <e1000_down_and_stop+0x21>
	 * Since the watchdog task can reschedule other tasks, we should cancel
	 * it first, otherwise we can run into the situation when a work is
	 * still running after the adapter has been turned down.
	 */

	cancel_delayed_work_sync(&adapter->phy_info_task);
     6d1:	48 8d bb e0 08 00 00 	lea    0x8e0(%rbx),%rdi
     6d8:	e8 00 00 00 00       	callq  6dd <e1000_down_and_stop+0x2d>
	cancel_delayed_work_sync(&adapter->fifo_stall_task);
     6dd:	48 8d bb 60 08 00 00 	lea    0x860(%rbx),%rdi
     6e4:	e8 00 00 00 00       	callq  6e9 <e1000_down_and_stop+0x39>
}

static __always_inline int constant_test_bit(long nr, const volatile unsigned long *addr)
{
	return ((1UL << (nr & (BITS_PER_LONG-1))) &
		(addr[nr >> _BITOPS_LONG_SHIFT])) != 0;
     6e9:	48 8b 83 a8 07 00 00 	mov    0x7a8(%rbx),%rax

	/* Only kill reset task if adapter is not resetting */
	if (!test_bit(__E1000_RESETTING, &adapter->flags))
     6f0:	a8 02                	test   $0x2,%al
     6f2:	75 0c                	jne    700 <e1000_down_and_stop+0x50>
		cancel_work_sync(&adapter->reset_task);
     6f4:	48 8d bb c0 07 00 00 	lea    0x7c0(%rbx),%rdi
     6fb:	e8 00 00 00 00       	callq  700 <e1000_down_and_stop+0x50>
}
     700:	5b                   	pop    %rbx
     701:	5d                   	pop    %rbp
     702:	c3                   	retq   
     703:	66 66 66 66 2e 0f 1f 	data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
     70a:	84 00 00 00 00 00 

0000000000000710 <e1000_update_phy_info_task>:
 *
 * Need to wait a few seconds after link up to get diagnostic information from
 * the phy
 */
static void e1000_update_phy_info_task(struct work_struct *work)
{
     710:	e8 00 00 00 00       	callq  715 <e1000_update_phy_info_task+0x5>
     715:	55                   	push   %rbp
	struct e1000_adapter *adapter = container_of(work,
						     struct e1000_adapter,
						     phy_info_task.work);

	e1000_phy_get_info(&adapter->hw, &adapter->phy_info);
     716:	48 81 ef e0 08 00 00 	sub    $0x8e0,%rdi
     71d:	48 8d b7 08 07 00 00 	lea    0x708(%rdi),%rsi
     724:	48 81 c7 c0 03 00 00 	add    $0x3c0,%rdi
 *
 * Need to wait a few seconds after link up to get diagnostic information from
 * the phy
 */
static void e1000_update_phy_info_task(struct work_struct *work)
{
     72b:	48 89 e5             	mov    %rsp,%rbp
	struct e1000_adapter *adapter = container_of(work,
						     struct e1000_adapter,
						     phy_info_task.work);

	e1000_phy_get_info(&adapter->hw, &adapter->phy_info);
     72e:	e8 00 00 00 00       	callq  733 <e1000_update_phy_info_task+0x23>
}
     733:	5d                   	pop    %rbp
     734:	c3                   	retq   
     735:	66 66 2e 0f 1f 84 00 	data32 nopw %cs:0x0(%rax,%rax,1)
     73c:	00 00 00 00 

0000000000000740 <e1000_82547_tx_fifo_stall_task>:
/**
 * e1000_82547_tx_fifo_stall_task - task to complete work
 * @work: work struct contained inside adapter struct
 **/
static void e1000_82547_tx_fifo_stall_task(struct work_struct *work)
{
     740:	e8 00 00 00 00       	callq  745 <e1000_82547_tx_fifo_stall_task+0x5>
     745:	55                   	push   %rbp
})

static __always_inline
void __read_once_size(const volatile void *p, void *res, int size)
{
	__READ_ONCE_SIZE;
     746:	8b 87 2c fa ff ff    	mov    -0x5d4(%rdi),%eax
	struct e1000_adapter *adapter = container_of(work,
						     struct e1000_adapter,
						     fifo_stall_task.work);
	struct e1000_hw *hw = &adapter->hw;
	struct net_device *netdev = adapter->netdev;
     74c:	48 8b 8f 50 fb ff ff 	mov    -0x4b0(%rdi),%rcx
/**
 * e1000_82547_tx_fifo_stall_task - task to complete work
 * @work: work struct contained inside adapter struct
 **/
static void e1000_82547_tx_fifo_stall_task(struct work_struct *work)
{
     753:	48 89 e5             	mov    %rsp,%rbp
						     fifo_stall_task.work);
	struct e1000_hw *hw = &adapter->hw;
	struct net_device *netdev = adapter->netdev;
	u32 tctl;

	if (atomic_read(&adapter->tx_fifo_stall)) {
     756:	85 c0                	test   %eax,%eax
     758:	74 4d                	je     7a7 <e1000_82547_tx_fifo_stall_task+0x67>
		if ((er32(TDT) == er32(TDH)) &&
     75a:	83 bf 78 fb ff ff 03 	cmpl   $0x3,-0x488(%rdi)
     761:	48 19 c0             	sbb    %rax,%rax
     764:	48 25 20 cc ff ff    	and    $0xffffffffffffcc20,%rax
     76a:	48 05 18 38 00 00    	add    $0x3818,%rax
     770:	48 03 87 60 fb ff ff 	add    -0x4a0(%rdi),%rax
     777:	8b 10                	mov    (%rax),%edx
     779:	83 bf 78 fb ff ff 03 	cmpl   $0x3,-0x488(%rdi)
     780:	48 19 c0             	sbb    %rax,%rax
     783:	48 25 20 cc ff ff    	and    $0xffffffffffffcc20,%rax
     789:	48 05 10 38 00 00    	add    $0x3810,%rax
     78f:	48 03 87 60 fb ff ff 	add    -0x4a0(%rdi),%rax
     796:	8b 00                	mov    (%rax),%eax
     798:	39 c2                	cmp    %eax,%edx
     79a:	74 28                	je     7c4 <e1000_82547_tx_fifo_stall_task+0x84>
     79c:	48 8b 87 48 ff ff ff 	mov    -0xb8(%rdi),%rax
			E1000_WRITE_FLUSH();

			adapter->tx_fifo_head = 0;
			atomic_set(&adapter->tx_fifo_stall, 0);
			netif_wake_queue(netdev);
		} else if (!test_bit(__E1000_DOWN, &adapter->flags)) {
     7a3:	a8 04                	test   $0x4,%al
     7a5:	74 02                	je     7a9 <e1000_82547_tx_fifo_stall_task+0x69>
			schedule_delayed_work(&adapter->fifo_stall_task, 1);
		}
	}
}
     7a7:	5d                   	pop    %rbp
     7a8:	c3                   	retq   
     7a9:	48 8b 35 00 00 00 00 	mov    0x0(%rip),%rsi        # 7b0 <e1000_82547_tx_fifo_stall_task+0x70>
     7b0:	48 89 fa             	mov    %rdi,%rdx
     7b3:	b9 01 00 00 00       	mov    $0x1,%ecx
     7b8:	bf 00 01 00 00       	mov    $0x100,%edi
     7bd:	e8 00 00 00 00       	callq  7c2 <e1000_82547_tx_fifo_stall_task+0x82>
     7c2:	5d                   	pop    %rbp
     7c3:	c3                   	retq   
	struct net_device *netdev = adapter->netdev;
	u32 tctl;

	if (atomic_read(&adapter->tx_fifo_stall)) {
		if ((er32(TDT) == er32(TDH)) &&
		   (er32(TDFT) == er32(TDFH)) &&
     7c4:	83 bf 78 fb ff ff 03 	cmpl   $0x3,-0x488(%rdi)
     7cb:	48 19 c0             	sbb    %rax,%rax
     7ce:	25 00 4c 00 00       	and    $0x4c00,%eax
     7d3:	48 05 18 34 00 00    	add    $0x3418,%rax
     7d9:	48 03 87 60 fb ff ff 	add    -0x4a0(%rdi),%rax
     7e0:	8b 10                	mov    (%rax),%edx
     7e2:	83 bf 78 fb ff ff 03 	cmpl   $0x3,-0x488(%rdi)
     7e9:	48 19 c0             	sbb    %rax,%rax
     7ec:	25 00 4c 00 00       	and    $0x4c00,%eax
     7f1:	48 05 10 34 00 00    	add    $0x3410,%rax
     7f7:	48 03 87 60 fb ff ff 	add    -0x4a0(%rdi),%rax
     7fe:	8b 00                	mov    (%rax),%eax
	struct e1000_hw *hw = &adapter->hw;
	struct net_device *netdev = adapter->netdev;
	u32 tctl;

	if (atomic_read(&adapter->tx_fifo_stall)) {
		if ((er32(TDT) == er32(TDH)) &&
     800:	39 c2                	cmp    %eax,%edx
     802:	75 98                	jne    79c <e1000_82547_tx_fifo_stall_task+0x5c>
		   (er32(TDFT) == er32(TDFH)) &&
		   (er32(TDFTS) == er32(TDFHS))) {
     804:	48 8b 87 60 fb ff ff 	mov    -0x4a0(%rdi),%rax
     80b:	8b 90 28 34 00 00    	mov    0x3428(%rax),%edx
     811:	48 8b 87 60 fb ff ff 	mov    -0x4a0(%rdi),%rax
     818:	8b 80 20 34 00 00    	mov    0x3420(%rax),%eax
	struct net_device *netdev = adapter->netdev;
	u32 tctl;

	if (atomic_read(&adapter->tx_fifo_stall)) {
		if ((er32(TDT) == er32(TDH)) &&
		   (er32(TDFT) == er32(TDFH)) &&
     81e:	39 c2                	cmp    %eax,%edx
     820:	0f 85 76 ff ff ff    	jne    79c <e1000_82547_tx_fifo_stall_task+0x5c>
		   (er32(TDFTS) == er32(TDFHS))) {
			tctl = er32(TCTL);
     826:	48 8b 87 60 fb ff ff 	mov    -0x4a0(%rdi),%rax
     82d:	8b 90 00 04 00 00    	mov    0x400(%rax),%edx
			ew32(TCTL, tctl & ~E1000_TCTL_EN);
     833:	89 d0                	mov    %edx,%eax
     835:	48 8b b7 60 fb ff ff 	mov    -0x4a0(%rdi),%rsi
     83c:	83 e0 fd             	and    $0xfffffffd,%eax
build_mmio_read(__readw, "w", unsigned short, "=r", )
build_mmio_read(__readl, "l", unsigned int, "=r", )

build_mmio_write(writeb, "b", unsigned char, "q", :"memory")
build_mmio_write(writew, "w", unsigned short, "r", :"memory")
build_mmio_write(writel, "l", unsigned int, "r", :"memory")
     83f:	89 86 00 04 00 00    	mov    %eax,0x400(%rsi)
			ew32(TDFT, adapter->tx_head_addr);
     845:	83 bf 78 fb ff ff 03 	cmpl   $0x3,-0x488(%rdi)
     84c:	8b b7 20 fa ff ff    	mov    -0x5e0(%rdi),%esi
     852:	48 19 c0             	sbb    %rax,%rax
     855:	25 00 4c 00 00       	and    $0x4c00,%eax
     85a:	48 05 18 34 00 00    	add    $0x3418,%rax
     860:	48 03 87 60 fb ff ff 	add    -0x4a0(%rdi),%rax
     867:	89 30                	mov    %esi,(%rax)
			ew32(TDFH, adapter->tx_head_addr);
     869:	83 bf 78 fb ff ff 03 	cmpl   $0x3,-0x488(%rdi)
     870:	8b b7 20 fa ff ff    	mov    -0x5e0(%rdi),%esi
     876:	48 19 c0             	sbb    %rax,%rax
     879:	25 00 4c 00 00       	and    $0x4c00,%eax
     87e:	48 05 10 34 00 00    	add    $0x3410,%rax
     884:	48 03 87 60 fb ff ff 	add    -0x4a0(%rdi),%rax
     88b:	89 30                	mov    %esi,(%rax)
			ew32(TDFTS, adapter->tx_head_addr);
     88d:	48 8b b7 60 fb ff ff 	mov    -0x4a0(%rdi),%rsi
     894:	8b 87 20 fa ff ff    	mov    -0x5e0(%rdi),%eax
     89a:	89 86 28 34 00 00    	mov    %eax,0x3428(%rsi)
			ew32(TDFHS, adapter->tx_head_addr);
     8a0:	48 8b b7 60 fb ff ff 	mov    -0x4a0(%rdi),%rsi
     8a7:	8b 87 20 fa ff ff    	mov    -0x5e0(%rdi),%eax
     8ad:	89 86 20 34 00 00    	mov    %eax,0x3420(%rsi)
			ew32(TCTL, tctl);
     8b3:	48 8b 87 60 fb ff ff 	mov    -0x4a0(%rdi),%rax
     8ba:	89 90 00 04 00 00    	mov    %edx,0x400(%rax)
			E1000_WRITE_FLUSH();
     8c0:	48 8b 87 60 fb ff ff 	mov    -0x4a0(%rdi),%rax
{ asm volatile("mov" size " %0,%1": :reg (val), \
"m" (*(volatile type __force *)addr) barrier); }

build_mmio_read(readb, "b", unsigned char, "=q", :"memory")
build_mmio_read(readw, "w", unsigned short, "=r", :"memory")
build_mmio_read(readl, "l", unsigned int, "=r", :"memory")
     8c7:	8b 40 08             	mov    0x8(%rax),%eax

			adapter->tx_fifo_head = 0;
     8ca:	c7 87 1c fa ff ff 00 	movl   $0x0,-0x5e4(%rdi)
     8d1:	00 00 00 
static __always_inline void __write_once_size(volatile void *p, void *res, int size)
{
	switch (size) {
	case 1: *(volatile __u8 *)p = *(__u8 *)res; break;
	case 2: *(volatile __u16 *)p = *(__u16 *)res; break;
	case 4: *(volatile __u32 *)p = *(__u32 *)res; break;
     8d4:	c7 87 2c fa ff ff 00 	movl   $0x0,-0x5d4(%rdi)
     8db:	00 00 00 
 *	Allow upper layers to call the device hard_start_xmit routine.
 *	Used for flow control when transmit resources are available.
 */
static inline void netif_wake_queue(struct net_device *dev)
{
	netif_tx_wake_queue(netdev_get_tx_queue(dev, 0));
     8de:	48 8b b9 c0 03 00 00 	mov    0x3c0(%rcx),%rdi
     8e5:	e8 00 00 00 00       	callq  8ea <e1000_82547_tx_fifo_stall_task+0x1aa>
			netif_wake_queue(netdev);
		} else if (!test_bit(__E1000_DOWN, &adapter->flags)) {
			schedule_delayed_work(&adapter->fifo_stall_task, 1);
		}
	}
}
     8ea:	5d                   	pop    %rbp
     8eb:	c3                   	retq   
     8ec:	0f 1f 40 00          	nopl   0x0(%rax)

00000000000008f0 <e1000_tx_timeout>:
/**
 * e1000_tx_timeout - Respond to a Tx Hang
 * @netdev: network interface device structure
 **/
static void e1000_tx_timeout(struct net_device *netdev)
{
     8f0:	e8 00 00 00 00       	callq  8f5 <e1000_tx_timeout+0x5>
     8f5:	55                   	push   %rbp
	struct e1000_adapter *adapter = netdev_priv(netdev);

	/* Do the reset outside of interrupt context */
	adapter->tx_timeout_count++;
     8f6:	83 87 b8 0a 00 00 01 	addl   $0x1,0xab8(%rdi)
	schedule_work(&adapter->reset_task);
     8fd:	48 8d 97 00 10 00 00 	lea    0x1000(%rdi),%rdx
 * it can be processed by another CPU.
 */
static inline bool queue_work(struct workqueue_struct *wq,
			      struct work_struct *work)
{
	return queue_work_on(WORK_CPU_UNBOUND, wq, work);
     904:	48 8b 35 00 00 00 00 	mov    0x0(%rip),%rsi        # 90b <e1000_tx_timeout+0x1b>
     90b:	bf 00 01 00 00       	mov    $0x100,%edi
/**
 * e1000_tx_timeout - Respond to a Tx Hang
 * @netdev: network interface device structure
 **/
static void e1000_tx_timeout(struct net_device *netdev)
{
     910:	48 89 e5             	mov    %rsp,%rbp
     913:	e8 00 00 00 00       	callq  918 <e1000_tx_timeout+0x28>
	struct e1000_adapter *adapter = netdev_priv(netdev);

	/* Do the reset outside of interrupt context */
	adapter->tx_timeout_count++;
	schedule_work(&adapter->reset_task);
}
     918:	5d                   	pop    %rbp
     919:	c3                   	retq   
     91a:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)

0000000000000920 <e1000_irq_disable>:
/**
 * e1000_irq_disable - Mask off interrupt generation on the NIC
 * @adapter: board private structure
 **/
static void e1000_irq_disable(struct e1000_adapter *adapter)
{
     920:	e8 00 00 00 00       	callq  925 <e1000_irq_disable+0x5>
     925:	55                   	push   %rbp
build_mmio_read(__readw, "w", unsigned short, "=r", )
build_mmio_read(__readl, "l", unsigned int, "=r", )

build_mmio_write(writeb, "b", unsigned char, "q", :"memory")
build_mmio_write(writew, "w", unsigned short, "r", :"memory")
build_mmio_write(writel, "l", unsigned int, "r", :"memory")
     926:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
	struct e1000_hw *hw = &adapter->hw;

	ew32(IMC, ~0);
     92b:	48 8b 97 c0 03 00 00 	mov    0x3c0(%rdi),%rdx
/**
 * e1000_irq_disable - Mask off interrupt generation on the NIC
 * @adapter: board private structure
 **/
static void e1000_irq_disable(struct e1000_adapter *adapter)
{
     932:	48 89 e5             	mov    %rsp,%rbp
     935:	89 82 d8 00 00 00    	mov    %eax,0xd8(%rdx)
	struct e1000_hw *hw = &adapter->hw;

	ew32(IMC, ~0);
	E1000_WRITE_FLUSH();
     93b:	48 8b 87 c0 03 00 00 	mov    0x3c0(%rdi),%rax
{ asm volatile("mov" size " %0,%1": :reg (val), \
"m" (*(volatile type __force *)addr) barrier); }

build_mmio_read(readb, "b", unsigned char, "=q", :"memory")
build_mmio_read(readw, "w", unsigned short, "=r", :"memory")
build_mmio_read(readl, "l", unsigned int, "=r", :"memory")
     942:	8b 40 08             	mov    0x8(%rax),%eax
	synchronize_irq(adapter->pdev->irq);
     945:	48 8b 87 b8 03 00 00 	mov    0x3b8(%rdi),%rax
     94c:	8b b8 74 03 00 00    	mov    0x374(%rax),%edi
     952:	e8 00 00 00 00       	callq  957 <e1000_irq_disable+0x37>
}
     957:	5d                   	pop    %rbp
     958:	c3                   	retq   
     959:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)

0000000000000960 <e1000_netpoll>:
/* Polling 'interrupt' - used by things like netconsole to send skbs
 * without having to re-enable interrupts. It's not called while
 * the interrupt routine is executing.
 */
static void e1000_netpoll(struct net_device *netdev)
{
     960:	e8 00 00 00 00       	callq  965 <e1000_netpoll+0x5>
     965:	55                   	push   %rbp
	struct e1000_adapter *adapter = netdev_priv(netdev);
	printk("xiehuan,poll\n");
     966:	31 c0                	xor    %eax,%eax
/* Polling 'interrupt' - used by things like netconsole to send skbs
 * without having to re-enable interrupts. It's not called while
 * the interrupt routine is executing.
 */
static void e1000_netpoll(struct net_device *netdev)
{
     968:	48 89 e5             	mov    %rsp,%rbp
     96b:	53                   	push   %rbx
     96c:	48 89 fb             	mov    %rdi,%rbx
	struct e1000_adapter *adapter = netdev_priv(netdev);
	printk("xiehuan,poll\n");
     96f:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
     976:	e8 00 00 00 00       	callq  97b <e1000_netpoll+0x1b>

	disable_irq(adapter->pdev->irq);
     97b:	48 8b 83 f8 0b 00 00 	mov    0xbf8(%rbx),%rax
     982:	8b b8 74 03 00 00    	mov    0x374(%rax),%edi
     988:	e8 00 00 00 00       	callq  98d <e1000_netpoll+0x2d>
	e1000_intr(adapter->pdev->irq, netdev);
     98d:	48 8b 83 f8 0b 00 00 	mov    0xbf8(%rbx),%rax
     994:	48 89 de             	mov    %rbx,%rsi
     997:	8b b8 74 03 00 00    	mov    0x374(%rax),%edi
     99d:	e8 1e fb ff ff       	callq  4c0 <e1000_intr>
	enable_irq(adapter->pdev->irq);
     9a2:	48 8b 83 f8 0b 00 00 	mov    0xbf8(%rbx),%rax
     9a9:	8b b8 74 03 00 00    	mov    0x374(%rax),%edi
     9af:	e8 00 00 00 00       	callq  9b4 <e1000_netpoll+0x54>
}
     9b4:	5b                   	pop    %rbx
     9b5:	5d                   	pop    %rbp
     9b6:	c3                   	retq   
     9b7:	66 0f 1f 84 00 00 00 	nopw   0x0(%rax,%rax,1)
     9be:	00 00 

00000000000009c0 <e1000_vlan_rx_kill_vid>:
	return 0;
}

static int e1000_vlan_rx_kill_vid(struct net_device *netdev,
				  __be16 proto, u16 vid)
{
     9c0:	e8 00 00 00 00       	callq  9c5 <e1000_vlan_rx_kill_vid+0x5>
     9c5:	55                   	push   %rbp
     9c6:	48 89 e5             	mov    %rsp,%rbp
     9c9:	41 57                	push   %r15
	struct e1000_adapter *adapter = netdev_priv(netdev);
	struct e1000_hw *hw = &adapter->hw;
     9cb:	4c 8d bf 00 0c 00 00 	lea    0xc00(%rdi),%r15
	return 0;
}

static int e1000_vlan_rx_kill_vid(struct net_device *netdev,
				  __be16 proto, u16 vid)
{
     9d2:	41 56                	push   %r14
     9d4:	41 89 d6             	mov    %edx,%r14d
     9d7:	41 55                	push   %r13
     9d9:	44 0f b7 ea          	movzwl %dx,%r13d
     9dd:	41 54                	push   %r12
	struct e1000_adapter *adapter = netdev_priv(netdev);
     9df:	4c 8d a7 40 08 00 00 	lea    0x840(%rdi),%r12
	return 0;
}

static int e1000_vlan_rx_kill_vid(struct net_device *netdev,
				  __be16 proto, u16 vid)
{
     9e6:	53                   	push   %rbx
     9e7:	48 8b 87 e8 0f 00 00 	mov    0xfe8(%rdi),%rax
     9ee:	48 89 fb             	mov    %rdi,%rbx
	struct e1000_adapter *adapter = netdev_priv(netdev);
	struct e1000_hw *hw = &adapter->hw;
	u32 vfta, index;

	if (!test_bit(__E1000_DOWN, &adapter->flags))
     9f1:	a8 04                	test   $0x4,%al
     9f3:	0f 84 a2 00 00 00    	je     a9b <e1000_vlan_rx_kill_vid+0xdb>
     9f9:	48 8b 83 e8 0f 00 00 	mov    0xfe8(%rbx),%rax
		e1000_irq_disable(adapter);
	if (!test_bit(__E1000_DOWN, &adapter->flags))
     a00:	a8 04                	test   $0x4,%al
     a02:	75 1c                	jne    a20 <e1000_vlan_rx_kill_vid+0x60>
 **/
static void e1000_irq_enable(struct e1000_adapter *adapter)
{
	struct e1000_hw *hw = &adapter->hw;

	ew32(IMS, IMS_ENABLE_MASK);
     a04:	48 8b 93 00 0c 00 00 	mov    0xc00(%rbx),%rdx
build_mmio_read(__readw, "w", unsigned short, "=r", )
build_mmio_read(__readl, "l", unsigned int, "=r", )

build_mmio_write(writeb, "b", unsigned char, "q", :"memory")
build_mmio_write(writew, "w", unsigned short, "r", :"memory")
build_mmio_write(writel, "l", unsigned int, "r", :"memory")
     a0b:	b8 9d 00 00 00       	mov    $0x9d,%eax
     a10:	89 82 d0 00 00 00    	mov    %eax,0xd0(%rdx)
	E1000_WRITE_FLUSH();
     a16:	48 8b 83 00 0c 00 00 	mov    0xc00(%rbx),%rax
{ asm volatile("mov" size " %0,%1": :reg (val), \
"m" (*(volatile type __force *)addr) barrier); }

build_mmio_read(readb, "b", unsigned char, "=q", :"memory")
build_mmio_read(readw, "w", unsigned short, "=r", :"memory")
build_mmio_read(readl, "l", unsigned int, "=r", :"memory")
     a1d:	8b 40 08             	mov    0x8(%rax),%eax
		e1000_irq_disable(adapter);
	if (!test_bit(__E1000_DOWN, &adapter->flags))
		e1000_irq_enable(adapter);

	/* remove VID from filter table */
	index = (vid >> 5) & 0x7F;
     a20:	44 89 f6             	mov    %r14d,%esi
     a23:	66 c1 ee 05          	shr    $0x5,%si
     a27:	83 e6 7f             	and    $0x7f,%esi
	vfta = E1000_READ_REG_ARRAY(hw, VFTA, index);
     a2a:	83 bb 18 0c 00 00 03 	cmpl   $0x3,0xc18(%rbx)
     a31:	8d 14 b5 00 00 00 00 	lea    0x0(,%rsi,4),%edx
     a38:	48 19 c0             	sbb    %rax,%rax
     a3b:	48 25 00 b0 ff ff    	and    $0xffffffffffffb000,%rax
     a41:	48 8d 84 10 00 56 00 	lea    0x5600(%rax,%rdx,1),%rax
     a48:	00 
     a49:	48 03 83 00 0c 00 00 	add    0xc00(%rbx),%rax
     a50:	8b 10                	mov    (%rax),%edx
	vfta &= ~(1 << (vid & 0x1F));
     a52:	b8 01 00 00 00       	mov    $0x1,%eax
     a57:	44 89 f1             	mov    %r14d,%ecx
	e1000_write_vfta(hw, index, vfta);
     a5a:	4c 89 ff             	mov    %r15,%rdi
		e1000_irq_enable(adapter);

	/* remove VID from filter table */
	index = (vid >> 5) & 0x7F;
	vfta = E1000_READ_REG_ARRAY(hw, VFTA, index);
	vfta &= ~(1 << (vid & 0x1F));
     a5d:	d3 e0                	shl    %cl,%eax
     a5f:	f7 d0                	not    %eax
     a61:	21 c2                	and    %eax,%edx
	e1000_write_vfta(hw, index, vfta);
     a63:	e8 00 00 00 00       	callq  a68 <e1000_vlan_rx_kill_vid+0xa8>
	if (IS_IMMEDIATE(nr)) {
		asm volatile(LOCK_PREFIX "andb %1,%0"
			: CONST_MASK_ADDR(nr, addr)
			: "iq" ((u8)~CONST_MASK(nr)));
	} else {
		asm volatile(LOCK_PREFIX "btr %1,%0"
     a68:	f0 4c 0f b3 ab 40 08 	lock btr %r13,0x840(%rbx)
     a6f:	00 00 

static bool e1000_vlan_used(struct e1000_adapter *adapter)
{
	u16 vid;

	for_each_set_bit(vid, adapter->active_vlans, VLAN_N_VID)
     a71:	be 00 10 00 00       	mov    $0x1000,%esi
     a76:	4c 89 e7             	mov    %r12,%rdi
     a79:	e8 00 00 00 00       	callq  a7e <e1000_vlan_rx_kill_vid+0xbe>
     a7e:	66 3d ff 0f          	cmp    $0xfff,%ax
     a82:	76 0a                	jbe    a8e <e1000_vlan_rx_kill_vid+0xce>
	e1000_write_vfta(hw, index, vfta);

	clear_bit(vid, adapter->active_vlans);

	if (!e1000_vlan_used(adapter))
		e1000_vlan_filter_on_off(adapter, false);
     a84:	31 f6                	xor    %esi,%esi
     a86:	4c 89 e7             	mov    %r12,%rdi
     a89:	e8 e2 00 00 00       	callq  b70 <e1000_vlan_filter_on_off>

	return 0;
}
     a8e:	5b                   	pop    %rbx
     a8f:	41 5c                	pop    %r12
     a91:	41 5d                	pop    %r13
     a93:	41 5e                	pop    %r14
     a95:	41 5f                	pop    %r15
     a97:	31 c0                	xor    %eax,%eax
     a99:	5d                   	pop    %rbp
     a9a:	c3                   	retq   
	struct e1000_adapter *adapter = netdev_priv(netdev);
	struct e1000_hw *hw = &adapter->hw;
	u32 vfta, index;

	if (!test_bit(__E1000_DOWN, &adapter->flags))
		e1000_irq_disable(adapter);
     a9b:	4c 89 e7             	mov    %r12,%rdi
     a9e:	e8 7d fe ff ff       	callq  920 <e1000_irq_disable>
     aa3:	e9 51 ff ff ff       	jmpq   9f9 <e1000_vlan_rx_kill_vid+0x39>
     aa8:	0f 1f 84 00 00 00 00 	nopl   0x0(%rax,%rax,1)
     aaf:	00 

0000000000000ab0 <e1000_update_mng_vlan>:
	ew32(IMS, IMS_ENABLE_MASK);
	E1000_WRITE_FLUSH();
}

static void e1000_update_mng_vlan(struct e1000_adapter *adapter)
{
     ab0:	e8 00 00 00 00       	callq  ab5 <e1000_update_mng_vlan+0x5>
     ab5:	55                   	push   %rbp

static bool e1000_vlan_used(struct e1000_adapter *adapter)
{
	u16 vid;

	for_each_set_bit(vid, adapter->active_vlans, VLAN_N_VID)
     ab6:	be 00 10 00 00       	mov    $0x1000,%esi
	ew32(IMS, IMS_ENABLE_MASK);
	E1000_WRITE_FLUSH();
}

static void e1000_update_mng_vlan(struct e1000_adapter *adapter)
{
     abb:	48 89 e5             	mov    %rsp,%rbp
     abe:	41 56                	push   %r14
     ac0:	41 55                	push   %r13
     ac2:	41 54                	push   %r12
     ac4:	53                   	push   %rbx
     ac5:	48 89 fb             	mov    %rdi,%rbx
	struct e1000_hw *hw = &adapter->hw;
	struct net_device *netdev = adapter->netdev;
     ac8:	4c 8b b7 b0 03 00 00 	mov    0x3b0(%rdi),%r14
	u16 vid = hw->mng_cookie.vlan_id;
     acf:	44 0f b7 a7 86 04 00 	movzwl 0x486(%rdi),%r12d
     ad6:	00 
	u16 old_vid = adapter->mng_vlan_id;
     ad7:	44 0f b7 af 00 02 00 	movzwl 0x200(%rdi),%r13d
     ade:	00 

static bool e1000_vlan_used(struct e1000_adapter *adapter)
{
	u16 vid;

	for_each_set_bit(vid, adapter->active_vlans, VLAN_N_VID)
     adf:	e8 00 00 00 00       	callq  ae4 <e1000_update_mng_vlan+0x34>
     ae4:	66 3d ff 0f          	cmp    $0xfff,%ax
     ae8:	77 4f                	ja     b39 <e1000_update_mng_vlan+0x89>
	u16 old_vid = adapter->mng_vlan_id;

	if (!e1000_vlan_used(adapter))
		return;

	if (!test_bit(vid, adapter->active_vlans)) {
     aea:	41 0f b7 c4          	movzwl %r12w,%eax

static inline int variable_test_bit(long nr, volatile const unsigned long *addr)
{
	int oldbit;

	asm volatile("bt %2,%1\n\t"
     aee:	48 0f a3 03          	bt     %rax,(%rbx)
     af2:	19 c0                	sbb    %eax,%eax
     af4:	85 c0                	test   %eax,%eax
     af6:	75 4a                	jne    b42 <e1000_update_mng_vlan+0x92>
		if (hw->mng_cookie.status &
     af8:	f6 83 84 04 00 00 02 	testb  $0x2,0x484(%rbx)
     aff:	75 52                	jne    b53 <e1000_update_mng_vlan+0xa3>
		    E1000_MNG_DHCP_COOKIE_STATUS_VLAN_SUPPORT) {
			e1000_vlan_rx_add_vid(netdev, htons(ETH_P_8021Q), vid);
			adapter->mng_vlan_id = vid;
		} else {
			adapter->mng_vlan_id = E1000_MNG_VLAN_NONE;
     b01:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
     b06:	66 89 83 00 02 00 00 	mov    %ax,0x200(%rbx)
		}
		if ((old_vid != (u16)E1000_MNG_VLAN_NONE) &&
     b0d:	66 45 39 ec          	cmp    %r13w,%r12w
     b11:	74 26                	je     b39 <e1000_update_mng_vlan+0x89>
     b13:	66 41 83 fd ff       	cmp    $0xffff,%r13w
     b18:	74 1f                	je     b39 <e1000_update_mng_vlan+0x89>
		    (vid != old_vid) &&
		    !test_bit(old_vid, adapter->active_vlans))
     b1a:	41 0f b7 c5          	movzwl %r13w,%eax
     b1e:	48 0f a3 03          	bt     %rax,(%rbx)
     b22:	19 c0                	sbb    %eax,%eax
			adapter->mng_vlan_id = vid;
		} else {
			adapter->mng_vlan_id = E1000_MNG_VLAN_NONE;
		}
		if ((old_vid != (u16)E1000_MNG_VLAN_NONE) &&
		    (vid != old_vid) &&
     b24:	85 c0                	test   %eax,%eax
     b26:	75 11                	jne    b39 <e1000_update_mng_vlan+0x89>
		    !test_bit(old_vid, adapter->active_vlans))
     b28:	41 0f b7 d5          	movzwl %r13w,%edx
			e1000_vlan_rx_kill_vid(netdev, htons(ETH_P_8021Q),
     b2c:	be 81 00 00 00       	mov    $0x81,%esi
     b31:	4c 89 f7             	mov    %r14,%rdi
     b34:	e8 87 fe ff ff       	callq  9c0 <e1000_vlan_rx_kill_vid>
					       old_vid);
	} else {
		adapter->mng_vlan_id = vid;
	}
}
     b39:	5b                   	pop    %rbx
     b3a:	41 5c                	pop    %r12
     b3c:	41 5d                	pop    %r13
     b3e:	41 5e                	pop    %r14
     b40:	5d                   	pop    %rbp
     b41:	c3                   	retq   
		    (vid != old_vid) &&
		    !test_bit(old_vid, adapter->active_vlans))
			e1000_vlan_rx_kill_vid(netdev, htons(ETH_P_8021Q),
					       old_vid);
	} else {
		adapter->mng_vlan_id = vid;
     b42:	66 44 89 a3 00 02 00 	mov    %r12w,0x200(%rbx)
     b49:	00 
	}
}
     b4a:	5b                   	pop    %rbx
     b4b:	41 5c                	pop    %r12
     b4d:	41 5d                	pop    %r13
     b4f:	41 5e                	pop    %r14
     b51:	5d                   	pop    %rbp
     b52:	c3                   	retq   
	u16 old_vid = adapter->mng_vlan_id;

	if (!e1000_vlan_used(adapter))
		return;

	if (!test_bit(vid, adapter->active_vlans)) {
     b53:	41 0f b7 d4          	movzwl %r12w,%edx
		if (hw->mng_cookie.status &
		    E1000_MNG_DHCP_COOKIE_STATUS_VLAN_SUPPORT) {
			e1000_vlan_rx_add_vid(netdev, htons(ETH_P_8021Q), vid);
     b57:	be 81 00 00 00       	mov    $0x81,%esi
     b5c:	4c 89 f7             	mov    %r14,%rdi
     b5f:	e8 fc 00 00 00       	callq  c60 <e1000_vlan_rx_add_vid>
			adapter->mng_vlan_id = vid;
     b64:	66 44 89 a3 00 02 00 	mov    %r12w,0x200(%rbx)
     b6b:	00 
     b6c:	eb 9f                	jmp    b0d <e1000_update_mng_vlan+0x5d>
     b6e:	66 90                	xchg   %ax,%ax

0000000000000b70 <e1000_vlan_filter_on_off>:
	}
	ew32(CTRL, ctrl);
}
static void e1000_vlan_filter_on_off(struct e1000_adapter *adapter,
				     bool filter_on)
{
     b70:	e8 00 00 00 00       	callq  b75 <e1000_vlan_filter_on_off+0x5>
     b75:	55                   	push   %rbp
     b76:	48 89 e5             	mov    %rsp,%rbp
     b79:	53                   	push   %rbx
     b7a:	48 89 fb             	mov    %rdi,%rbx
     b7d:	48 83 ec 08          	sub    $0x8,%rsp
}

static __always_inline int constant_test_bit(long nr, const volatile unsigned long *addr)
{
	return ((1UL << (nr & (BITS_PER_LONG-1))) &
		(addr[nr >> _BITOPS_LONG_SHIFT])) != 0;
     b81:	48 8b 87 a8 07 00 00 	mov    0x7a8(%rdi),%rax
	struct e1000_hw *hw = &adapter->hw;
	u32 rctl;

	if (!test_bit(__E1000_DOWN, &adapter->flags))
     b88:	a8 04                	test   $0x4,%al
     b8a:	0f 84 c0 00 00 00    	je     c50 <e1000_vlan_filter_on_off+0xe0>
		e1000_irq_disable(adapter);

	__e1000_vlan_mode(adapter, adapter->netdev->features);
     b90:	48 8b 83 b0 03 00 00 	mov    0x3b0(%rbx),%rax
     b97:	48 8b 88 f0 00 00 00 	mov    0xf0(%rax),%rcx
			      netdev_features_t features)
{
	struct e1000_hw *hw = &adapter->hw;
	u32 ctrl;

	ctrl = er32(CTRL);
     b9e:	48 8b 83 c0 03 00 00 	mov    0x3c0(%rbx),%rax
     ba5:	8b 10                	mov    (%rax),%edx
	if (features & NETIF_F_HW_VLAN_CTAG_RX) {
		/* enable VLAN tag insert/strip */
		ctrl |= E1000_CTRL_VME;
     ba7:	89 d0                	mov    %edx,%eax
     ba9:	81 e2 ff ff ff bf    	and    $0xbfffffff,%edx
     baf:	0d 00 00 00 40       	or     $0x40000000,%eax
     bb4:	80 e5 01             	and    $0x1,%ch
     bb7:	0f 44 c2             	cmove  %edx,%eax
	} else {
		/* disable VLAN tag insert/strip */
		ctrl &= ~E1000_CTRL_VME;
	}
	ew32(CTRL, ctrl);
     bba:	48 8b 93 c0 03 00 00 	mov    0x3c0(%rbx),%rdx
build_mmio_read(__readw, "w", unsigned short, "=r", )
build_mmio_read(__readl, "l", unsigned int, "=r", )

build_mmio_write(writeb, "b", unsigned char, "q", :"memory")
build_mmio_write(writew, "w", unsigned short, "r", :"memory")
build_mmio_write(writel, "l", unsigned int, "r", :"memory")
     bc1:	89 02                	mov    %eax,(%rdx)

	if (!test_bit(__E1000_DOWN, &adapter->flags))
		e1000_irq_disable(adapter);

	__e1000_vlan_mode(adapter, adapter->netdev->features);
	if (filter_on) {
     bc3:	40 84 f6             	test   %sil,%sil
		/* enable VLAN receive filtering */
		rctl = er32(RCTL);
     bc6:	48 8b 83 c0 03 00 00 	mov    0x3c0(%rbx),%rax

	if (!test_bit(__E1000_DOWN, &adapter->flags))
		e1000_irq_disable(adapter);

	__e1000_vlan_mode(adapter, adapter->netdev->features);
	if (filter_on) {
     bcd:	74 67                	je     c36 <e1000_vlan_filter_on_off+0xc6>
{ asm volatile("mov" size " %0,%1": :reg (val), \
"m" (*(volatile type __force *)addr) barrier); }

build_mmio_read(readb, "b", unsigned char, "=q", :"memory")
build_mmio_read(readw, "w", unsigned short, "=r", :"memory")
build_mmio_read(readl, "l", unsigned int, "=r", :"memory")
     bcf:	8b 80 00 01 00 00    	mov    0x100(%rax),%eax
		/* enable VLAN receive filtering */
		rctl = er32(RCTL);
		rctl &= ~E1000_RCTL_CFIEN;
		if (!(adapter->netdev->flags & IFF_PROMISC))
     bd5:	48 8b 8b b0 03 00 00 	mov    0x3b0(%rbx),%rcx

	__e1000_vlan_mode(adapter, adapter->netdev->features);
	if (filter_on) {
		/* enable VLAN receive filtering */
		rctl = er32(RCTL);
		rctl &= ~E1000_RCTL_CFIEN;
     bdc:	25 ff ff f7 ff       	and    $0xfff7ffff,%eax
		if (!(adapter->netdev->flags & IFF_PROMISC))
			rctl |= E1000_RCTL_VFE;
     be1:	89 c2                	mov    %eax,%edx
     be3:	81 ca 00 00 04 00    	or     $0x40000,%edx
     be9:	f6 81 21 02 00 00 01 	testb  $0x1,0x221(%rcx)
     bf0:	0f 44 c2             	cmove  %edx,%eax
		ew32(RCTL, rctl);
     bf3:	48 8b 93 c0 03 00 00 	mov    0x3c0(%rbx),%rdx
build_mmio_read(__readw, "w", unsigned short, "=r", )
build_mmio_read(__readl, "l", unsigned int, "=r", )

build_mmio_write(writeb, "b", unsigned char, "q", :"memory")
build_mmio_write(writew, "w", unsigned short, "r", :"memory")
build_mmio_write(writel, "l", unsigned int, "r", :"memory")
     bfa:	89 82 00 01 00 00    	mov    %eax,0x100(%rdx)
		e1000_update_mng_vlan(adapter);
     c00:	48 89 df             	mov    %rbx,%rdi
     c03:	e8 a8 fe ff ff       	callq  ab0 <e1000_update_mng_vlan>
     c08:	48 8b 83 a8 07 00 00 	mov    0x7a8(%rbx),%rax
		rctl = er32(RCTL);
		rctl &= ~E1000_RCTL_VFE;
		ew32(RCTL, rctl);
	}

	if (!test_bit(__E1000_DOWN, &adapter->flags))
     c0f:	a8 04                	test   $0x4,%al
     c11:	75 1c                	jne    c2f <e1000_vlan_filter_on_off+0xbf>
 **/
static void e1000_irq_enable(struct e1000_adapter *adapter)
{
	struct e1000_hw *hw = &adapter->hw;

	ew32(IMS, IMS_ENABLE_MASK);
     c13:	48 8b 93 c0 03 00 00 	mov    0x3c0(%rbx),%rdx
     c1a:	b8 9d 00 00 00       	mov    $0x9d,%eax
     c1f:	89 82 d0 00 00 00    	mov    %eax,0xd0(%rdx)
	E1000_WRITE_FLUSH();
     c25:	48 8b 83 c0 03 00 00 	mov    0x3c0(%rbx),%rax
{ asm volatile("mov" size " %0,%1": :reg (val), \
"m" (*(volatile type __force *)addr) barrier); }

build_mmio_read(readb, "b", unsigned char, "=q", :"memory")
build_mmio_read(readw, "w", unsigned short, "=r", :"memory")
build_mmio_read(readl, "l", unsigned int, "=r", :"memory")
     c2c:	8b 40 08             	mov    0x8(%rax),%eax
		ew32(RCTL, rctl);
	}

	if (!test_bit(__E1000_DOWN, &adapter->flags))
		e1000_irq_enable(adapter);
}
     c2f:	48 83 c4 08          	add    $0x8,%rsp
     c33:	5b                   	pop    %rbx
     c34:	5d                   	pop    %rbp
     c35:	c3                   	retq   
     c36:	8b 80 00 01 00 00    	mov    0x100(%rax),%eax
		ew32(RCTL, rctl);
		e1000_update_mng_vlan(adapter);
	} else {
		/* disable VLAN receive filtering */
		rctl = er32(RCTL);
		rctl &= ~E1000_RCTL_VFE;
     c3c:	25 ff ff fb ff       	and    $0xfffbffff,%eax
		ew32(RCTL, rctl);
     c41:	48 8b 93 c0 03 00 00 	mov    0x3c0(%rbx),%rdx
build_mmio_read(__readw, "w", unsigned short, "=r", )
build_mmio_read(__readl, "l", unsigned int, "=r", )

build_mmio_write(writeb, "b", unsigned char, "q", :"memory")
build_mmio_write(writew, "w", unsigned short, "r", :"memory")
build_mmio_write(writel, "l", unsigned int, "r", :"memory")
     c48:	89 82 00 01 00 00    	mov    %eax,0x100(%rdx)
     c4e:	eb b8                	jmp    c08 <e1000_vlan_filter_on_off+0x98>
     c50:	89 75 f4             	mov    %esi,-0xc(%rbp)
{
	struct e1000_hw *hw = &adapter->hw;
	u32 rctl;

	if (!test_bit(__E1000_DOWN, &adapter->flags))
		e1000_irq_disable(adapter);
     c53:	e8 c8 fc ff ff       	callq  920 <e1000_irq_disable>
     c58:	8b 75 f4             	mov    -0xc(%rbp),%esi
     c5b:	e9 30 ff ff ff       	jmpq   b90 <e1000_vlan_filter_on_off+0x20>

0000000000000c60 <e1000_vlan_rx_add_vid>:
		e1000_irq_enable(adapter);
}

static int e1000_vlan_rx_add_vid(struct net_device *netdev,
				 __be16 proto, u16 vid)
{
     c60:	e8 00 00 00 00       	callq  c65 <e1000_vlan_rx_add_vid+0x5>
     c65:	55                   	push   %rbp
     c66:	48 89 e5             	mov    %rsp,%rbp
     c69:	41 57                	push   %r15
	struct e1000_adapter *adapter = netdev_priv(netdev);
     c6b:	4c 8d bf 40 08 00 00 	lea    0x840(%rdi),%r15
		e1000_irq_enable(adapter);
}

static int e1000_vlan_rx_add_vid(struct net_device *netdev,
				 __be16 proto, u16 vid)
{
     c72:	41 56                	push   %r14
     c74:	44 0f b7 f2          	movzwl %dx,%r14d
     c78:	41 55                	push   %r13
	struct e1000_adapter *adapter = netdev_priv(netdev);
	struct e1000_hw *hw = &adapter->hw;
     c7a:	4c 8d af 00 0c 00 00 	lea    0xc00(%rdi),%r13
		e1000_irq_enable(adapter);
}

static int e1000_vlan_rx_add_vid(struct net_device *netdev,
				 __be16 proto, u16 vid)
{
     c81:	41 54                	push   %r12
     c83:	41 89 d4             	mov    %edx,%r12d
     c86:	53                   	push   %rbx
	struct e1000_adapter *adapter = netdev_priv(netdev);
	struct e1000_hw *hw = &adapter->hw;
	u32 vfta, index;

	if ((hw->mng_cookie.status &
     c87:	f6 87 c4 0c 00 00 02 	testb  $0x2,0xcc4(%rdi)
		e1000_irq_enable(adapter);
}

static int e1000_vlan_rx_add_vid(struct net_device *netdev,
				 __be16 proto, u16 vid)
{
     c8e:	48 89 fb             	mov    %rdi,%rbx
	struct e1000_adapter *adapter = netdev_priv(netdev);
	struct e1000_hw *hw = &adapter->hw;
	u32 vfta, index;

	if ((hw->mng_cookie.status &
     c91:	74 09                	je     c9c <e1000_vlan_rx_add_vid+0x3c>
	     E1000_MNG_DHCP_COOKIE_STATUS_VLAN_SUPPORT) &&
     c93:	66 39 97 40 0a 00 00 	cmp    %dx,0xa40(%rdi)
     c9a:	74 62                	je     cfe <e1000_vlan_rx_add_vid+0x9e>

static bool e1000_vlan_used(struct e1000_adapter *adapter)
{
	u16 vid;

	for_each_set_bit(vid, adapter->active_vlans, VLAN_N_VID)
     c9c:	be 00 10 00 00       	mov    $0x1000,%esi
     ca1:	4c 89 ff             	mov    %r15,%rdi
     ca4:	e8 00 00 00 00       	callq  ca9 <e1000_vlan_rx_add_vid+0x49>
     ca9:	66 3d ff 0f          	cmp    $0xfff,%ax
     cad:	77 5c                	ja     d0b <e1000_vlan_rx_add_vid+0xab>

	if (!e1000_vlan_used(adapter))
		e1000_vlan_filter_on_off(adapter, true);

	/* add VID to filter table */
	index = (vid >> 5) & 0x7F;
     caf:	44 89 e6             	mov    %r12d,%esi
     cb2:	66 c1 ee 05          	shr    $0x5,%si
     cb6:	83 e6 7f             	and    $0x7f,%esi
	vfta = E1000_READ_REG_ARRAY(hw, VFTA, index);
     cb9:	83 bb 18 0c 00 00 03 	cmpl   $0x3,0xc18(%rbx)
     cc0:	8d 14 b5 00 00 00 00 	lea    0x0(,%rsi,4),%edx
     cc7:	48 19 c0             	sbb    %rax,%rax
     cca:	48 25 00 b0 ff ff    	and    $0xffffffffffffb000,%rax
     cd0:	48 8d 84 10 00 56 00 	lea    0x5600(%rax,%rdx,1),%rax
     cd7:	00 
     cd8:	48 03 83 00 0c 00 00 	add    0xc00(%rbx),%rax
{ asm volatile("mov" size " %0,%1": :reg (val), \
"m" (*(volatile type __force *)addr) barrier); }

build_mmio_read(readb, "b", unsigned char, "=q", :"memory")
build_mmio_read(readw, "w", unsigned short, "=r", :"memory")
build_mmio_read(readl, "l", unsigned int, "=r", :"memory")
     cdf:	8b 10                	mov    (%rax),%edx
	vfta |= (1 << (vid & 0x1F));
     ce1:	b8 01 00 00 00       	mov    $0x1,%eax
     ce6:	44 89 e1             	mov    %r12d,%ecx
	e1000_write_vfta(hw, index, vfta);
     ce9:	4c 89 ef             	mov    %r13,%rdi
		e1000_vlan_filter_on_off(adapter, true);

	/* add VID to filter table */
	index = (vid >> 5) & 0x7F;
	vfta = E1000_READ_REG_ARRAY(hw, VFTA, index);
	vfta |= (1 << (vid & 0x1F));
     cec:	d3 e0                	shl    %cl,%eax
     cee:	09 c2                	or     %eax,%edx
	e1000_write_vfta(hw, index, vfta);
     cf0:	e8 00 00 00 00       	callq  cf5 <e1000_vlan_rx_add_vid+0x95>
		asm volatile(LOCK_PREFIX "orb %1,%0"
			: CONST_MASK_ADDR(nr, addr)
			: "iq" ((u8)CONST_MASK(nr))
			: "memory");
	} else {
		asm volatile(LOCK_PREFIX "bts %1,%0"
     cf5:	f0 4c 0f ab b3 40 08 	lock bts %r14,0x840(%rbx)
     cfc:	00 00 

	set_bit(vid, adapter->active_vlans);

	return 0;
}
     cfe:	5b                   	pop    %rbx
     cff:	41 5c                	pop    %r12
     d01:	41 5d                	pop    %r13
     d03:	41 5e                	pop    %r14
     d05:	41 5f                	pop    %r15
     d07:	31 c0                	xor    %eax,%eax
     d09:	5d                   	pop    %rbp
     d0a:	c3                   	retq   
	     E1000_MNG_DHCP_COOKIE_STATUS_VLAN_SUPPORT) &&
	    (vid == adapter->mng_vlan_id))
		return 0;

	if (!e1000_vlan_used(adapter))
		e1000_vlan_filter_on_off(adapter, true);
     d0b:	be 01 00 00 00       	mov    $0x1,%esi
     d10:	4c 89 ff             	mov    %r15,%rdi
     d13:	e8 58 fe ff ff       	callq  b70 <e1000_vlan_filter_on_off>
     d18:	eb 95                	jmp    caf <e1000_vlan_rx_add_vid+0x4f>
     d1a:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)

0000000000000d20 <e1000_power_down_phy>:
		e1000_write_phy_reg(hw, PHY_CTRL, mii_reg);
	}
}

static void e1000_power_down_phy(struct e1000_adapter *adapter)
{
     d20:	e8 00 00 00 00       	callq  d25 <e1000_power_down_phy+0x5>
	 * The PHY cannot be powered down if any of the following is true *
	 * (a) WoL is enabled
	 * (b) AMT is active
	 * (c) SoL/IDER session is active
	 */
	if (!adapter->wol && hw->mac_type >= e1000_82540 &&
     d25:	8b b7 0c 02 00 00    	mov    0x20c(%rdi),%esi
     d2b:	85 f6                	test   %esi,%esi
     d2d:	75 32                	jne    d61 <e1000_power_down_phy+0x41>
     d2f:	8b 87 d8 03 00 00    	mov    0x3d8(%rdi),%eax
     d35:	83 f8 04             	cmp    $0x4,%eax
     d38:	76 27                	jbe    d61 <e1000_power_down_phy+0x41>
     d3a:	8b 8f e4 03 00 00    	mov    0x3e4(%rdi),%ecx
     d40:	85 c9                	test   %ecx,%ecx
     d42:	75 1d                	jne    d61 <e1000_power_down_phy+0x41>
		e1000_write_phy_reg(hw, PHY_CTRL, mii_reg);
	}
}

static void e1000_power_down_phy(struct e1000_adapter *adapter)
{
     d44:	55                   	push   %rbp
	 */
	if (!adapter->wol && hw->mac_type >= e1000_82540 &&
	   hw->media_type == e1000_media_type_copper) {
		u16 mii_reg = 0;

		switch (hw->mac_type) {
     d45:	83 e8 05             	sub    $0x5,%eax
	 * (b) AMT is active
	 * (c) SoL/IDER session is active
	 */
	if (!adapter->wol && hw->mac_type >= e1000_82540 &&
	   hw->media_type == e1000_media_type_copper) {
		u16 mii_reg = 0;
     d48:	31 d2                	xor    %edx,%edx
		e1000_write_phy_reg(hw, PHY_CTRL, mii_reg);
	}
}

static void e1000_power_down_phy(struct e1000_adapter *adapter)
{
     d4a:	48 89 e5             	mov    %rsp,%rbp
     d4d:	53                   	push   %rbx
     d4e:	48 83 ec 08          	sub    $0x8,%rsp
	 */
	if (!adapter->wol && hw->mac_type >= e1000_82540 &&
	   hw->media_type == e1000_media_type_copper) {
		u16 mii_reg = 0;

		switch (hw->mac_type) {
     d52:	83 f8 09             	cmp    $0x9,%eax
	 * (b) AMT is active
	 * (c) SoL/IDER session is active
	 */
	if (!adapter->wol && hw->mac_type >= e1000_82540 &&
	   hw->media_type == e1000_media_type_copper) {
		u16 mii_reg = 0;
     d55:	66 89 55 f6          	mov    %dx,-0xa(%rbp)

		switch (hw->mac_type) {
     d59:	76 08                	jbe    d63 <e1000_power_down_phy+0x43>
		e1000_write_phy_reg(hw, PHY_CTRL, mii_reg);
		msleep(1);
	}
out:
	return;
}
     d5b:	48 83 c4 08          	add    $0x8,%rsp
     d5f:	5b                   	pop    %rbx
     d60:	5d                   	pop    %rbp
     d61:	f3 c3                	repz retq 
		case e1000_82546_rev_3:
		case e1000_82541:
		case e1000_82541_rev_2:
		case e1000_82547:
		case e1000_82547_rev_2:
			if (er32(MANC) & E1000_MANC_SMBUS_EN)
     d63:	48 8b 87 c0 03 00 00 	mov    0x3c0(%rdi),%rax
     d6a:	8b 80 20 58 00 00    	mov    0x5820(%rax),%eax
     d70:	a8 01                	test   $0x1,%al
     d72:	75 e7                	jne    d5b <e1000_power_down_phy+0x3b>
	}
}

static void e1000_power_down_phy(struct e1000_adapter *adapter)
{
	struct e1000_hw *hw = &adapter->hw;
     d74:	48 8d 9f c0 03 00 00 	lea    0x3c0(%rdi),%rbx
				goto out;
			break;
		default:
			goto out;
		}
		e1000_read_phy_reg(hw, PHY_CTRL, &mii_reg);
     d7b:	48 8d 55 f6          	lea    -0xa(%rbp),%rdx
     d7f:	31 f6                	xor    %esi,%esi
     d81:	48 89 df             	mov    %rbx,%rdi
     d84:	e8 00 00 00 00       	callq  d89 <e1000_power_down_phy+0x69>
		mii_reg |= MII_CR_POWER_DOWN;
     d89:	0f b7 55 f6          	movzwl -0xa(%rbp),%edx
		e1000_write_phy_reg(hw, PHY_CTRL, mii_reg);
     d8d:	48 89 df             	mov    %rbx,%rdi
     d90:	31 f6                	xor    %esi,%esi
			break;
		default:
			goto out;
		}
		e1000_read_phy_reg(hw, PHY_CTRL, &mii_reg);
		mii_reg |= MII_CR_POWER_DOWN;
     d92:	80 ce 08             	or     $0x8,%dh
     d95:	66 89 55 f6          	mov    %dx,-0xa(%rbp)
		e1000_write_phy_reg(hw, PHY_CTRL, mii_reg);
     d99:	0f b7 d2             	movzwl %dx,%edx
     d9c:	e8 00 00 00 00       	callq  da1 <e1000_power_down_phy+0x81>
		msleep(1);
     da1:	bf 01 00 00 00       	mov    $0x1,%edi
     da6:	e8 00 00 00 00       	callq  dab <e1000_power_down_phy+0x8b>
     dab:	eb ae                	jmp    d5b <e1000_power_down_phy+0x3b>
     dad:	0f 1f 00             	nopl   (%rax)

0000000000000db0 <e1000_init_manageability.part.31>:
	} else {
		adapter->mng_vlan_id = vid;
	}
}

static void e1000_init_manageability(struct e1000_adapter *adapter)
     db0:	e8 00 00 00 00       	callq  db5 <e1000_init_manageability.part.31+0x5>
     db5:	55                   	push   %rbp
{
	struct e1000_hw *hw = &adapter->hw;

	if (adapter->en_mng_pt) {
		u32 manc = er32(MANC);
     db6:	48 8b 87 c0 03 00 00 	mov    0x3c0(%rdi),%rax
	} else {
		adapter->mng_vlan_id = vid;
	}
}

static void e1000_init_manageability(struct e1000_adapter *adapter)
     dbd:	48 89 e5             	mov    %rsp,%rbp
     dc0:	8b 80 20 58 00 00    	mov    0x5820(%rax),%eax

	if (adapter->en_mng_pt) {
		u32 manc = er32(MANC);

		/* disable hardware interception of ARP */
		manc &= ~(E1000_MANC_ARP_EN);
     dc6:	80 e4 df             	and    $0xdf,%ah

		ew32(MANC, manc);
     dc9:	48 8b 97 c0 03 00 00 	mov    0x3c0(%rdi),%rdx
build_mmio_read(__readw, "w", unsigned short, "=r", )
build_mmio_read(__readl, "l", unsigned int, "=r", )

build_mmio_write(writeb, "b", unsigned char, "q", :"memory")
build_mmio_write(writew, "w", unsigned short, "r", :"memory")
build_mmio_write(writel, "l", unsigned int, "r", :"memory")
     dd0:	89 82 20 58 00 00    	mov    %eax,0x5820(%rdx)
	}
}
     dd6:	5d                   	pop    %rbp
     dd7:	c3                   	retq   
     dd8:	0f 1f 84 00 00 00 00 	nopl   0x0(%rax,%rax,1)
     ddf:	00 

0000000000000de0 <e1000_release_manageability.part.32>:

static void e1000_release_manageability(struct e1000_adapter *adapter)
     de0:	e8 00 00 00 00       	callq  de5 <e1000_release_manageability.part.32+0x5>
     de5:	55                   	push   %rbp
{
	struct e1000_hw *hw = &adapter->hw;

	if (adapter->en_mng_pt) {
		u32 manc = er32(MANC);
     de6:	48 8b 87 c0 03 00 00 	mov    0x3c0(%rdi),%rax

		ew32(MANC, manc);
	}
}

static void e1000_release_manageability(struct e1000_adapter *adapter)
     ded:	48 89 e5             	mov    %rsp,%rbp
{ asm volatile("mov" size " %0,%1": :reg (val), \
"m" (*(volatile type __force *)addr) barrier); }

build_mmio_read(readb, "b", unsigned char, "=q", :"memory")
build_mmio_read(readw, "w", unsigned short, "=r", :"memory")
build_mmio_read(readl, "l", unsigned int, "=r", :"memory")
     df0:	8b 80 20 58 00 00    	mov    0x5820(%rax),%eax

	if (adapter->en_mng_pt) {
		u32 manc = er32(MANC);

		/* re-enable hardware interception of ARP */
		manc |= E1000_MANC_ARP_EN;
     df6:	80 cc 20             	or     $0x20,%ah

		ew32(MANC, manc);
     df9:	48 8b 97 c0 03 00 00 	mov    0x3c0(%rdi),%rdx
build_mmio_read(__readw, "w", unsigned short, "=r", )
build_mmio_read(__readl, "l", unsigned int, "=r", )

build_mmio_write(writeb, "b", unsigned char, "q", :"memory")
build_mmio_write(writew, "w", unsigned short, "r", :"memory")
build_mmio_write(writel, "l", unsigned int, "r", :"memory")
     e00:	89 82 20 58 00 00    	mov    %eax,0x5820(%rdx)
	}
}
     e06:	5d                   	pop    %rbp
     e07:	c3                   	retq   
     e08:	0f 1f 84 00 00 00 00 	nopl   0x0(%rax,%rax,1)
     e0f:	00 

0000000000000e10 <e1000_remove>:
 * that it should release a PCI device.  The could be caused by a
 * Hot-Plug event, or because the driver is going to be removed from
 * memory.
 **/
static void e1000_remove(struct pci_dev *pdev)
{
     e10:	e8 00 00 00 00       	callq  e15 <e1000_remove+0x5>
     e15:	55                   	push   %rbp
     e16:	48 89 e5             	mov    %rsp,%rbp
     e19:	41 56                	push   %r14
     e1b:	41 55                	push   %r13
     e1d:	41 54                	push   %r12
     e1f:	49 89 fc             	mov    %rdi,%r12
     e22:	53                   	push   %rbx
 * driver-specific data.  They are really just a wrapper around
 * the generic device structure functions of these calls.
 */
static inline void *pci_get_drvdata(struct pci_dev *pdev)
{
	return dev_get_drvdata(&pdev->dev);
     e23:	48 8b 9f 38 01 00 00 	mov    0x138(%rdi),%rbx
	struct net_device *netdev = pci_get_drvdata(pdev);
	struct e1000_adapter *adapter = netdev_priv(netdev);
     e2a:	4c 8d ab 40 08 00 00 	lea    0x840(%rbx),%r13
	struct e1000_hw *hw = &adapter->hw;
     e31:	4c 8d b3 00 0c 00 00 	lea    0xc00(%rbx),%r14

	e1000_down_and_stop(adapter);
     e38:	4c 89 ef             	mov    %r13,%rdi
     e3b:	e8 70 f8 ff ff       	callq  6b0 <e1000_down_and_stop>

static void e1000_release_manageability(struct e1000_adapter *adapter)
{
	struct e1000_hw *hw = &adapter->hw;

	if (adapter->en_mng_pt) {
     e40:	8b 83 54 0a 00 00    	mov    0xa54(%rbx),%eax
     e46:	85 c0                	test   %eax,%eax
     e48:	75 75                	jne    ebf <e1000_remove+0xaf>
	struct e1000_hw *hw = &adapter->hw;

	e1000_down_and_stop(adapter);
	e1000_release_manageability(adapter);

	unregister_netdev(netdev);
     e4a:	48 89 df             	mov    %rbx,%rdi
     e4d:	e8 00 00 00 00       	callq  e52 <e1000_remove+0x42>

	e1000_phy_hw_reset(hw);
     e52:	4c 89 f7             	mov    %r14,%rdi
     e55:	e8 00 00 00 00       	callq  e5a <e1000_remove+0x4a>

	kfree(adapter->tx_ring);
     e5a:	48 8b bb 80 0a 00 00 	mov    0xa80(%rbx),%rdi
     e61:	e8 00 00 00 00       	callq  e66 <e1000_remove+0x56>
	kfree(adapter->rx_ring);
     e66:	48 8b bb e8 0a 00 00 	mov    0xae8(%rbx),%rdi
     e6d:	e8 00 00 00 00       	callq  e72 <e1000_remove+0x62>

	if (hw->mac_type == e1000_ce4100)
     e72:	83 bb 18 0c 00 00 09 	cmpl   $0x9,0xc18(%rbx)
     e79:	74 4e                	je     ec9 <e1000_remove+0xb9>
		iounmap(hw->ce4100_gbe_mdio_base_virt);
	iounmap(hw->hw_addr);
     e7b:	48 8b bb 00 0c 00 00 	mov    0xc00(%rbx),%rdi
     e82:	e8 00 00 00 00       	callq  e87 <e1000_remove+0x77>
	if (hw->flash_address)
     e87:	48 8b bb 08 0c 00 00 	mov    0xc08(%rbx),%rdi
     e8e:	48 85 ff             	test   %rdi,%rdi
     e91:	74 05                	je     e98 <e1000_remove+0x88>
		iounmap(hw->flash_address);
     e93:	e8 00 00 00 00       	callq  e98 <e1000_remove+0x88>
	pci_release_selected_regions(pdev, adapter->bars);
     e98:	8b b3 f4 0f 00 00    	mov    0xff4(%rbx),%esi
     e9e:	4c 89 e7             	mov    %r12,%rdi
     ea1:	e8 00 00 00 00       	callq  ea6 <e1000_remove+0x96>

	free_netdev(netdev);
     ea6:	48 89 df             	mov    %rbx,%rdi
     ea9:	e8 00 00 00 00       	callq  eae <e1000_remove+0x9e>

	pci_disable_device(pdev);
     eae:	4c 89 e7             	mov    %r12,%rdi
     eb1:	e8 00 00 00 00       	callq  eb6 <e1000_remove+0xa6>
}
     eb6:	5b                   	pop    %rbx
     eb7:	41 5c                	pop    %r12
     eb9:	41 5d                	pop    %r13
     ebb:	41 5e                	pop    %r14
     ebd:	5d                   	pop    %rbp
     ebe:	c3                   	retq   
     ebf:	4c 89 ef             	mov    %r13,%rdi
     ec2:	e8 19 ff ff ff       	callq  de0 <e1000_release_manageability.part.32>
     ec7:	eb 81                	jmp    e4a <e1000_remove+0x3a>

	kfree(adapter->tx_ring);
	kfree(adapter->rx_ring);

	if (hw->mac_type == e1000_ce4100)
		iounmap(hw->ce4100_gbe_mdio_base_virt);
     ec9:	48 8b bb 10 0c 00 00 	mov    0xc10(%rbx),%rdi
     ed0:	e8 00 00 00 00       	callq  ed5 <e1000_remove+0xc5>
     ed5:	eb a4                	jmp    e7b <e1000_remove+0x6b>
     ed7:	66 0f 1f 84 00 00 00 	nopw   0x0(%rax,%rax,1)
     ede:	00 00 

0000000000000ee0 <e1000_rx_checksum.isra.38>:
 * @adapter:     board private structure
 * @status_err:  receive descriptor status and error fields
 * @csum:        receive descriptor csum field
 * @sk_buff:     socket buffer with received data
 **/
static void e1000_rx_checksum(struct e1000_adapter *adapter, u32 status_err,
     ee0:	e8 00 00 00 00       	callq  ee5 <e1000_rx_checksum.isra.38+0x5>
			      u32 csum, struct sk_buff *skb)
{
	struct e1000_hw *hw = &adapter->hw;
	u16 status = (u16)status_err;
	u8 errors = (u8)(status_err >> 24);
     ee5:	89 f0                	mov    %esi,%eax
 * @adapter:     board private structure
 * @status_err:  receive descriptor status and error fields
 * @csum:        receive descriptor csum field
 * @sk_buff:     socket buffer with received data
 **/
static void e1000_rx_checksum(struct e1000_adapter *adapter, u32 status_err,
     ee7:	55                   	push   %rbp
			      u32 csum, struct sk_buff *skb)
{
	struct e1000_hw *hw = &adapter->hw;
	u16 status = (u16)status_err;
	u8 errors = (u8)(status_err >> 24);
     ee8:	c1 e8 18             	shr    $0x18,%eax

	skb_checksum_none_assert(skb);

	/* 82543 or newer only */
	if (unlikely(hw->mac_type < e1000_82543)) return;
     eeb:	83 bf d8 03 00 00 02 	cmpl   $0x2,0x3d8(%rdi)
 * @adapter:     board private structure
 * @status_err:  receive descriptor status and error fields
 * @csum:        receive descriptor csum field
 * @sk_buff:     socket buffer with received data
 **/
static void e1000_rx_checksum(struct e1000_adapter *adapter, u32 status_err,
     ef2:	48 89 e5             	mov    %rsp,%rbp
	u8 errors = (u8)(status_err >> 24);

	skb_checksum_none_assert(skb);

	/* 82543 or newer only */
	if (unlikely(hw->mac_type < e1000_82543)) return;
     ef5:	76 2d                	jbe    f24 <e1000_rx_checksum.isra.38+0x44>
     ef7:	0f b7 f6             	movzwl %si,%esi
	/* Ignore Checksum bit is set */
	if (unlikely(status & E1000_RXD_STAT_IXSM)) return;
     efa:	40 f6 c6 04          	test   $0x4,%sil
     efe:	75 24                	jne    f24 <e1000_rx_checksum.isra.38+0x44>
	/* TCP/UDP checksum error bit is set */
	if (unlikely(errors & E1000_RXD_ERR_TCPE)) {
     f00:	a8 20                	test   $0x20,%al
     f02:	75 22                	jne    f26 <e1000_rx_checksum.isra.38+0x46>
		/* let the stack verify checksum errors */
		adapter->hw_csum_err++;
		return;
	}
	/* TCP/UDP Checksum has not been calculated */
	if (!(status & E1000_RXD_STAT_TCPCS))
     f04:	83 e6 20             	and    $0x20,%esi
     f07:	74 1b                	je     f24 <e1000_rx_checksum.isra.38+0x44>
		return;

	/* It must be a TCP or UDP packet with a valid checksum */
	if (likely(status & E1000_RXD_STAT_TCPCS)) {
		/* TCP checksum is good */
		skb->ip_summed = CHECKSUM_UNNECESSARY;
     f09:	0f b6 82 91 00 00 00 	movzbl 0x91(%rdx),%eax
     f10:	83 e0 f9             	and    $0xfffffff9,%eax
     f13:	83 c8 02             	or     $0x2,%eax
     f16:	88 82 91 00 00 00    	mov    %al,0x91(%rdx)
	}
	adapter->hw_csum_good++;
     f1c:	48 83 87 88 03 00 00 	addq   $0x1,0x388(%rdi)
     f23:	01 
}
     f24:	5d                   	pop    %rbp
     f25:	c3                   	retq   
	/* Ignore Checksum bit is set */
	if (unlikely(status & E1000_RXD_STAT_IXSM)) return;
	/* TCP/UDP checksum error bit is set */
	if (unlikely(errors & E1000_RXD_ERR_TCPE)) {
		/* let the stack verify checksum errors */
		adapter->hw_csum_err++;
     f26:	48 83 87 80 03 00 00 	addq   $0x1,0x380(%rdi)
     f2d:	01 
	if (likely(status & E1000_RXD_STAT_TCPCS)) {
		/* TCP checksum is good */
		skb->ip_summed = CHECKSUM_UNNECESSARY;
	}
	adapter->hw_csum_good++;
}
     f2e:	5d                   	pop    %rbp
     f2f:	c3                   	retq   

0000000000000f30 <e1000_tbi_should_accept>:
}

static bool e1000_tbi_should_accept(struct e1000_adapter *adapter,
				    u8 status, u8 errors,
				    u32 length, const u8 *data)
{
     f30:	e8 00 00 00 00       	callq  f35 <e1000_tbi_should_accept+0x5>
     f35:	55                   	push   %rbp
	struct e1000_hw *hw = &adapter->hw;
	u8 last_byte = *(data + length - 1);
     f36:	89 c8                	mov    %ecx,%eax
}

static bool e1000_tbi_should_accept(struct e1000_adapter *adapter,
				    u8 status, u8 errors,
				    u32 length, const u8 *data)
{
     f38:	48 89 e5             	mov    %rsp,%rbp
     f3b:	41 54                	push   %r12
     f3d:	53                   	push   %rbx
     f3e:	48 89 fb             	mov    %rdi,%rbx
     f41:	48 83 ec 10          	sub    $0x10,%rsp
	struct e1000_hw *hw = &adapter->hw;
	u8 last_byte = *(data + length - 1);
     f45:	41 0f b6 7c 00 ff    	movzbl -0x1(%r8,%rax,1),%edi
		spin_unlock_irqrestore(&adapter->stats_lock, irq_flags);

		return true;
	}

	return false;
     f4b:	31 c0                	xor    %eax,%eax
				    u32 length, const u8 *data)
{
	struct e1000_hw *hw = &adapter->hw;
	u8 last_byte = *(data + length - 1);

	if (TBI_ACCEPT(hw, status, errors, length, last_byte)) {
     f4d:	80 bb cf 04 00 00 00 	cmpb   $0x0,0x4cf(%rbx)
     f54:	74 08                	je     f5e <e1000_tbi_should_accept+0x2e>
     f56:	83 e2 97             	and    $0xffffff97,%edx
     f59:	80 fa 01             	cmp    $0x1,%dl
     f5c:	74 09                	je     f67 <e1000_tbi_should_accept+0x37>

		return true;
	}

	return false;
}
     f5e:	48 83 c4 10          	add    $0x10,%rsp
     f62:	5b                   	pop    %rbx
     f63:	41 5c                	pop    %r12
     f65:	5d                   	pop    %rbp
     f66:	c3                   	retq   
				    u32 length, const u8 *data)
{
	struct e1000_hw *hw = &adapter->hw;
	u8 last_byte = *(data + length - 1);

	if (TBI_ACCEPT(hw, status, errors, length, last_byte)) {
     f67:	40 80 ff 0f          	cmp    $0xf,%dil
     f6b:	75 f1                	jne    f5e <e1000_tbi_should_accept+0x2e>
     f6d:	83 e6 08             	and    $0x8,%esi
     f70:	0f 85 06 01 00 00    	jne    107c <e1000_tbi_should_accept+0x14c>
     f76:	31 d2                	xor    %edx,%edx
     f78:	3b 8b 5c 04 00 00    	cmp    0x45c(%rbx),%ecx
     f7e:	76 0e                	jbe    f8e <e1000_tbi_should_accept+0x5e>
     f80:	8b 83 58 04 00 00    	mov    0x458(%rbx),%eax
     f86:	83 c0 05             	add    $0x5,%eax
     f89:	39 c1                	cmp    %eax,%ecx
     f8b:	0f 96 c2             	setbe  %dl
		spin_unlock_irqrestore(&adapter->stats_lock, irq_flags);

		return true;
	}

	return false;
     f8e:	31 c0                	xor    %eax,%eax
				    u32 length, const u8 *data)
{
	struct e1000_hw *hw = &adapter->hw;
	u8 last_byte = *(data + length - 1);

	if (TBI_ACCEPT(hw, status, errors, length, last_byte)) {
     f90:	84 d2                	test   %dl,%dl
     f92:	74 ca                	je     f5e <e1000_tbi_should_accept+0x2e>
		unsigned long irq_flags;

		spin_lock_irqsave(&adapter->stats_lock, irq_flags);
     f94:	4c 8d a3 1c 02 00 00 	lea    0x21c(%rbx),%r12
     f9b:	4c 89 45 e0          	mov    %r8,-0x20(%rbp)
     f9f:	89 4d ec             	mov    %ecx,-0x14(%rbp)
     fa2:	4c 89 e7             	mov    %r12,%rdi
     fa5:	e8 00 00 00 00       	callq  faa <e1000_tbi_should_accept+0x7a>
				   u32 frame_len, const u8 *mac_addr)
{
	u64 carry_bit;

	/* First adjust the frame length. */
	frame_len--;
     faa:	8b 4d ec             	mov    -0x14(%rbp),%ecx
	stats->crcerrs--;
	/* This packet does count as a Good Packet Received. */
	stats->gprc++;

	/* Adjust the Good Octets received counters */
	carry_bit = 0x80000000 & stats->gorcl;
     fad:	48 8b 93 d8 05 00 00 	mov    0x5d8(%rbx),%rdx
	/* We need to adjust the statistics counters, since the hardware
	 * counters overcount this packet as a CRC error and undercount
	 * the packet as a good packet
	 */
	/* This packet should not be counted as a CRC error. */
	stats->crcerrs--;
     fb4:	48 83 ab e0 04 00 00 	subq   $0x1,0x4e0(%rbx)
     fbb:	01 
	/* This packet does count as a Good Packet Received. */
	stats->gprc++;
     fbc:	48 83 83 b8 05 00 00 	addq   $0x1,0x5b8(%rbx)
     fc3:	01 
	 * AND it is zero after, then we lost the carry out,
	 * need to add one to Gorch (Good Octets Received Count High).
	 * This could be simplified if all environments supported
	 * 64-bit integers.
	 */
	if (carry_bit && ((stats->gorcl & 0x80000000) == 0))
     fc4:	4c 8b 45 e0          	mov    -0x20(%rbp),%r8
				   u32 frame_len, const u8 *mac_addr)
{
	u64 carry_bit;

	/* First adjust the frame length. */
	frame_len--;
     fc8:	83 e9 01             	sub    $0x1,%ecx
	/* This packet does count as a Good Packet Received. */
	stats->gprc++;

	/* Adjust the Good Octets received counters */
	carry_bit = 0x80000000 & stats->gorcl;
	stats->gorcl += frame_len;
     fcb:	89 cf                	mov    %ecx,%edi
     fcd:	48 01 d7             	add    %rdx,%rdi
	 * AND it is zero after, then we lost the carry out,
	 * need to add one to Gorch (Good Octets Received Count High).
	 * This could be simplified if all environments supported
	 * 64-bit integers.
	 */
	if (carry_bit && ((stats->gorcl & 0x80000000) == 0))
     fd0:	f7 c2 00 00 00 80    	test   $0x80000000,%edx
	/* This packet does count as a Good Packet Received. */
	stats->gprc++;

	/* Adjust the Good Octets received counters */
	carry_bit = 0x80000000 & stats->gorcl;
	stats->gorcl += frame_len;
     fd6:	48 89 bb d8 05 00 00 	mov    %rdi,0x5d8(%rbx)
	 * AND it is zero after, then we lost the carry out,
	 * need to add one to Gorch (Good Octets Received Count High).
	 * This could be simplified if all environments supported
	 * 64-bit integers.
	 */
	if (carry_bit && ((stats->gorcl & 0x80000000) == 0))
     fdd:	74 10                	je     fef <e1000_tbi_should_accept+0xbf>
     fdf:	f7 c7 00 00 00 80    	test   $0x80000000,%edi
     fe5:	75 08                	jne    fef <e1000_tbi_should_accept+0xbf>
		stats->gorch++;
     fe7:	48 83 83 e0 05 00 00 	addq   $0x1,0x5e0(%rbx)
     fee:	01 
 */
static inline bool is_broadcast_ether_addr(const u8 *addr)
{
	return (*(const u16 *)(addr + 0) &
		*(const u16 *)(addr + 2) &
		*(const u16 *)(addr + 4)) == 0xffff;
     fef:	41 0f b7 50 02       	movzwl 0x2(%r8),%edx
     ff4:	66 41 23 10          	and    (%r8),%dx
     ff8:	66 41 23 50 04       	and    0x4(%r8),%dx
	/* Is this a broadcast or multicast?  Check broadcast first,
	 * since the test for a multicast frame will test positive on
	 * a broadcast frame.
	 */
	if (is_broadcast_ether_addr(mac_addr))
     ffd:	66 83 fa ff          	cmp    $0xffff,%dx
    1001:	0f 84 9b 00 00 00    	je     10a2 <e1000_tbi_should_accept+0x172>
		stats->bprc++;
	else if (is_multicast_ether_addr(mac_addr))
    1007:	41 f6 00 01          	testb  $0x1,(%r8)
    100b:	74 08                	je     1015 <e1000_tbi_should_accept+0xe5>
		stats->mprc++;
    100d:	48 83 83 c8 05 00 00 	addq   $0x1,0x5c8(%rbx)
    1014:	01 

	if (frame_len == hw->max_frame_size) {
    1015:	3b 8b 58 04 00 00    	cmp    0x458(%rbx),%ecx
    101b:	0f 84 8e 00 00 00    	je     10af <e1000_tbi_should_accept+0x17f>
	}

	/* Adjust the bin counters when the extra byte put the frame in the
	 * wrong bin. Remember that the frame_len was adjusted above.
	 */
	if (frame_len == 64) {
    1021:	83 f9 40             	cmp    $0x40,%ecx
    1024:	0f 84 a5 00 00 00    	je     10cf <e1000_tbi_should_accept+0x19f>
		stats->prc64++;
		stats->prc127--;
	} else if (frame_len == 127) {
    102a:	83 f9 7f             	cmp    $0x7f,%ecx
    102d:	0f 84 ae 00 00 00    	je     10e1 <e1000_tbi_should_accept+0x1b1>
		stats->prc127++;
		stats->prc255--;
	} else if (frame_len == 255) {
    1033:	81 f9 ff 00 00 00    	cmp    $0xff,%ecx
    1039:	0f 84 b7 00 00 00    	je     10f6 <e1000_tbi_should_accept+0x1c6>
		stats->prc255++;
		stats->prc511--;
	} else if (frame_len == 511) {
    103f:	81 f9 ff 01 00 00    	cmp    $0x1ff,%ecx
    1045:	0f 84 c0 00 00 00    	je     110b <e1000_tbi_should_accept+0x1db>
		stats->prc511++;
		stats->prc1023--;
	} else if (frame_len == 1023) {
    104b:	81 f9 ff 03 00 00    	cmp    $0x3ff,%ecx
    1051:	0f 84 c9 00 00 00    	je     1120 <e1000_tbi_should_accept+0x1f0>
		stats->prc1023++;
		stats->prc1522--;
	} else if (frame_len == 1522) {
    1057:	81 f9 f2 05 00 00    	cmp    $0x5f2,%ecx
    105d:	75 08                	jne    1067 <e1000_tbi_should_accept+0x137>
		stats->prc1522++;
    105f:	48 83 83 b0 05 00 00 	addq   $0x1,0x5b0(%rbx)
    1066:	01 
	raw_spin_unlock_irq(&lock->rlock);
}

static __always_inline void spin_unlock_irqrestore(spinlock_t *lock, unsigned long flags)
{
	raw_spin_unlock_irqrestore(&lock->rlock, flags);
    1067:	48 89 c6             	mov    %rax,%rsi
    106a:	4c 89 e7             	mov    %r12,%rdi
    106d:	e8 00 00 00 00       	callq  1072 <e1000_tbi_should_accept+0x142>
    1072:	b8 01 00 00 00       	mov    $0x1,%eax
    1077:	e9 e2 fe ff ff       	jmpq   f5e <e1000_tbi_should_accept+0x2e>
				    u32 length, const u8 *data)
{
	struct e1000_hw *hw = &adapter->hw;
	u8 last_byte = *(data + length - 1);

	if (TBI_ACCEPT(hw, status, errors, length, last_byte)) {
    107c:	8b 83 5c 04 00 00    	mov    0x45c(%rbx),%eax
    1082:	31 d2                	xor    %edx,%edx
    1084:	83 e8 04             	sub    $0x4,%eax
    1087:	39 c1                	cmp    %eax,%ecx
    1089:	0f 86 ff fe ff ff    	jbe    f8e <e1000_tbi_should_accept+0x5e>
    108f:	8b 83 58 04 00 00    	mov    0x458(%rbx),%eax
    1095:	83 c0 01             	add    $0x1,%eax
    1098:	39 c1                	cmp    %eax,%ecx
    109a:	0f 96 c2             	setbe  %dl
    109d:	e9 ec fe ff ff       	jmpq   f8e <e1000_tbi_should_accept+0x5e>
	/* Is this a broadcast or multicast?  Check broadcast first,
	 * since the test for a multicast frame will test positive on
	 * a broadcast frame.
	 */
	if (is_broadcast_ether_addr(mac_addr))
		stats->bprc++;
    10a2:	48 83 83 c0 05 00 00 	addq   $0x1,0x5c0(%rbx)
    10a9:	01 
    10aa:	e9 66 ff ff ff       	jmpq   1015 <e1000_tbi_should_accept+0xe5>

	if (frame_len == hw->max_frame_size) {
		/* In this case, the hardware has overcounted the number of
		 * oversize frames.
		 */
		if (stats->roc > 0)
    10af:	48 8b 93 10 06 00 00 	mov    0x610(%rbx),%rdx
    10b6:	48 85 d2             	test   %rdx,%rdx
    10b9:	0f 84 62 ff ff ff    	je     1021 <e1000_tbi_should_accept+0xf1>
			stats->roc--;
    10bf:	48 83 ea 01          	sub    $0x1,%rdx
    10c3:	48 89 93 10 06 00 00 	mov    %rdx,0x610(%rbx)
    10ca:	e9 52 ff ff ff       	jmpq   1021 <e1000_tbi_should_accept+0xf1>

	/* Adjust the bin counters when the extra byte put the frame in the
	 * wrong bin. Remember that the frame_len was adjusted above.
	 */
	if (frame_len == 64) {
		stats->prc64++;
    10cf:	48 83 83 88 05 00 00 	addq   $0x1,0x588(%rbx)
    10d6:	01 
		stats->prc127--;
    10d7:	48 83 ab 90 05 00 00 	subq   $0x1,0x590(%rbx)
    10de:	01 
    10df:	eb 86                	jmp    1067 <e1000_tbi_should_accept+0x137>
	} else if (frame_len == 127) {
		stats->prc127++;
    10e1:	48 83 83 90 05 00 00 	addq   $0x1,0x590(%rbx)
    10e8:	01 
		stats->prc255--;
    10e9:	48 83 ab 98 05 00 00 	subq   $0x1,0x598(%rbx)
    10f0:	01 
    10f1:	e9 71 ff ff ff       	jmpq   1067 <e1000_tbi_should_accept+0x137>
	} else if (frame_len == 255) {
		stats->prc255++;
    10f6:	48 83 83 98 05 00 00 	addq   $0x1,0x598(%rbx)
    10fd:	01 
		stats->prc511--;
    10fe:	48 83 ab a0 05 00 00 	subq   $0x1,0x5a0(%rbx)
    1105:	01 
    1106:	e9 5c ff ff ff       	jmpq   1067 <e1000_tbi_should_accept+0x137>
	} else if (frame_len == 511) {
		stats->prc511++;
    110b:	48 83 83 a0 05 00 00 	addq   $0x1,0x5a0(%rbx)
    1112:	01 
		stats->prc1023--;
    1113:	48 83 ab a8 05 00 00 	subq   $0x1,0x5a8(%rbx)
    111a:	01 
    111b:	e9 47 ff ff ff       	jmpq   1067 <e1000_tbi_should_accept+0x137>
	} else if (frame_len == 1023) {
		stats->prc1023++;
    1120:	48 83 83 a8 05 00 00 	addq   $0x1,0x5a8(%rbx)
    1127:	01 
		stats->prc1522--;
    1128:	48 83 ab b0 05 00 00 	subq   $0x1,0x5b0(%rbx)
    112f:	01 
    1130:	e9 32 ff ff ff       	jmpq   1067 <e1000_tbi_should_accept+0x137>
    1135:	66 66 2e 0f 1f 84 00 	data32 nopw %cs:0x0(%rax,%rax,1)
    113c:	00 00 00 00 

0000000000001140 <e1000_clean_jumbo_rx_irq>:
 * is no guarantee that everything was cleaned
 */
static bool e1000_clean_jumbo_rx_irq(struct e1000_adapter *adapter,
				     struct e1000_rx_ring *rx_ring,
				     int *work_done, int work_to_do)
{
    1140:	e8 00 00 00 00       	callq  1145 <e1000_clean_jumbo_rx_irq+0x5>
    1145:	55                   	push   %rbp
    1146:	48 89 e5             	mov    %rsp,%rbp
    1149:	41 57                	push   %r15
    114b:	41 56                	push   %r14
    114d:	41 55                	push   %r13
    114f:	41 54                	push   %r12
    1151:	49 89 f4             	mov    %rsi,%r12
    1154:	53                   	push   %rbx
    1155:	48 89 fb             	mov    %rdi,%rbx
    1158:	48 83 ec 78          	sub    $0x78,%rsp
	struct net_device *netdev = adapter->netdev;
	struct pci_dev *pdev = adapter->pdev;
    115c:	48 8b 87 b8 03 00 00 	mov    0x3b8(%rdi),%rax
	unsigned int i;
	int cleaned_count = 0;
	bool cleaned = false;
	unsigned int total_rx_bytes=0, total_rx_packets=0;

	i = rx_ring->next_to_clean;
    1163:	44 8b 6e 1c          	mov    0x1c(%rsi),%r13d
 */
static bool e1000_clean_jumbo_rx_irq(struct e1000_adapter *adapter,
				     struct e1000_rx_ring *rx_ring,
				     int *work_done, int work_to_do)
{
	struct net_device *netdev = adapter->netdev;
    1167:	4c 8b bf b0 03 00 00 	mov    0x3b0(%rdi),%r15

	i = rx_ring->next_to_clean;
	rx_desc = E1000_RX_DESC(*rx_ring, i);
	buffer_info = &rx_ring->buffer_info[i];

	printk("xiehuan,rx_irq\n");
    116e:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
 * is no guarantee that everything was cleaned
 */
static bool e1000_clean_jumbo_rx_irq(struct e1000_adapter *adapter,
				     struct e1000_rx_ring *rx_ring,
				     int *work_done, int work_to_do)
{
    1175:	48 89 55 c0          	mov    %rdx,-0x40(%rbp)
    1179:	89 4d bc             	mov    %ecx,-0x44(%rbp)
	struct net_device *netdev = adapter->netdev;
	struct pci_dev *pdev = adapter->pdev;
    117c:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
	int cleaned_count = 0;
	bool cleaned = false;
	unsigned int total_rx_bytes=0, total_rx_packets=0;

	i = rx_ring->next_to_clean;
	rx_desc = E1000_RX_DESC(*rx_ring, i);
    1180:	44 89 e8             	mov    %r13d,%eax
    1183:	48 c1 e0 04          	shl    $0x4,%rax
    1187:	48 89 c6             	mov    %rax,%rsi
	buffer_info = &rx_ring->buffer_info[i];
    118a:	49 03 44 24 20       	add    0x20(%r12),%rax
	int cleaned_count = 0;
	bool cleaned = false;
	unsigned int total_rx_bytes=0, total_rx_packets=0;

	i = rx_ring->next_to_clean;
	rx_desc = E1000_RX_DESC(*rx_ring, i);
    118f:	49 03 34 24          	add    (%r12),%rsi
	buffer_info = &rx_ring->buffer_info[i];
    1193:	48 89 45 b0          	mov    %rax,-0x50(%rbp)

	printk("xiehuan,rx_irq\n");
    1197:	31 c0                	xor    %eax,%eax
	int cleaned_count = 0;
	bool cleaned = false;
	unsigned int total_rx_bytes=0, total_rx_packets=0;

	i = rx_ring->next_to_clean;
	rx_desc = E1000_RX_DESC(*rx_ring, i);
    1199:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
	buffer_info = &rx_ring->buffer_info[i];

	printk("xiehuan,rx_irq\n");
    119d:	e8 00 00 00 00       	callq  11a2 <e1000_clean_jumbo_rx_irq+0x62>
	e_err(drv,"xiehuan,rx_irq,err\n");
    11a2:	f6 83 a0 07 00 00 01 	testb  $0x1,0x7a0(%rbx)
    11a9:	0f 85 af 00 00 00    	jne    125e <e1000_clean_jumbo_rx_irq+0x11e>
		next_buffer = &rx_ring->buffer_info[i];

		cleaned = true;
		cleaned_count++;
		printk("xiehuan,adapter->rx_buffer_len=%08X\n",adapter->rx_buffer_len);
		dma_unmap_page(&pdev->dev, buffer_info->dma,
    11af:	48 8b 7d c8          	mov    -0x38(%rbp),%rdi
process_skb:
		if (!(status & E1000_RXD_STAT_EOP)) {
			/* this descriptor is only the beginning (or middle) */
			if (!rxtop) {
				/* this is the beginning of a chain */
				rxtop = napi_get_frags(&adapter->napi);
    11b3:	48 8d 8b b0 02 00 00 	lea    0x2b0(%rbx),%rcx
		rx_desc->status = 0;

		/* return some buffers to hardware, one at a time is too slow */
		if (unlikely(cleaned_count >= E1000_RX_BUFFER_WRITE)) {
			adapter->alloc_rx_buf(adapter, rx_ring, cleaned_count);
			cleaned_count = 0;
    11ba:	45 31 f6             	xor    %r14d,%r14d
    11bd:	45 31 db             	xor    %r11d,%r11d
    11c0:	31 c0                	xor    %eax,%eax
    11c2:	45 31 d2             	xor    %r10d,%r10d
process_skb:
		if (!(status & E1000_RXD_STAT_EOP)) {
			/* this descriptor is only the beginning (or middle) */
			if (!rxtop) {
				/* this is the beginning of a chain */
				rxtop = napi_get_frags(&adapter->napi);
    11c5:	48 89 4d a8          	mov    %rcx,-0x58(%rbp)
		next_buffer = &rx_ring->buffer_info[i];

		cleaned = true;
		cleaned_count++;
		printk("xiehuan,adapter->rx_buffer_len=%08X\n",adapter->rx_buffer_len);
		dma_unmap_page(&pdev->dev, buffer_info->dma,
    11c9:	48 8d b7 98 00 00 00 	lea    0x98(%rdi),%rsi

DECLARE_PER_CPU(struct task_struct *, current_task);

static __always_inline struct task_struct *get_current(void)
{
	return this_cpu_read_stable(current_task);
    11d0:	65 4c 8b 0c 25 00 00 	mov    %gs:0x0,%r9
    11d7:	00 00 
    11d9:	48 89 75 a0          	mov    %rsi,-0x60(%rbp)
	rx_desc = E1000_RX_DESC(*rx_ring, i);
	buffer_info = &rx_ring->buffer_info[i];

	printk("xiehuan,rx_irq\n");
	e_err(drv,"xiehuan,rx_irq,err\n");
	while (rx_desc->status & E1000_RXD_STAT_DD) {
    11dd:	48 8b 7d d0          	mov    -0x30(%rbp),%rdi
    11e1:	f6 47 0c 01          	testb  $0x1,0xc(%rdi)
    11e5:	74 0f                	je     11f6 <e1000_clean_jumbo_rx_irq+0xb6>
		struct sk_buff *skb;
		u8 status;

		if (*work_done >= work_to_do)
    11e7:	48 8b 75 c0          	mov    -0x40(%rbp),%rsi
    11eb:	8b 16                	mov    (%rsi),%edx
    11ed:	3b 55 bc             	cmp    -0x44(%rbp),%edx
    11f0:	0f 8c 82 00 00 00    	jl     1278 <e1000_clean_jumbo_rx_irq+0x138>
		rx_desc = next_rxd;
		buffer_info = next_buffer;
	}
	rx_ring->next_to_clean = i;

	cleaned_count = E1000_DESC_UNUSED(rx_ring);
    11f6:	41 8b 4c 24 18       	mov    0x18(%r12),%ecx
    11fb:	31 d2                	xor    %edx,%edx

		/* use prefetched values */
		rx_desc = next_rxd;
		buffer_info = next_buffer;
	}
	rx_ring->next_to_clean = i;
    11fd:	45 89 6c 24 1c       	mov    %r13d,0x1c(%r12)

	cleaned_count = E1000_DESC_UNUSED(rx_ring);
    1202:	41 39 cd             	cmp    %ecx,%r13d
    1205:	77 05                	ja     120c <e1000_clean_jumbo_rx_irq+0xcc>
    1207:	41 8b 54 24 14       	mov    0x14(%r12),%edx
    120c:	f7 d1                	not    %ecx
    120e:	41 01 cd             	add    %ecx,%r13d
	if (cleaned_count)
    1211:	44 01 ea             	add    %r13d,%edx
    1214:	74 1a                	je     1230 <e1000_clean_jumbo_rx_irq+0xf0>
    1216:	44 89 5d c8          	mov    %r11d,-0x38(%rbp)
    121a:	89 45 d0             	mov    %eax,-0x30(%rbp)
		adapter->alloc_rx_buf(adapter, rx_ring, cleaned_count);
    121d:	4c 89 e6             	mov    %r12,%rsi
    1220:	48 89 df             	mov    %rbx,%rdi
    1223:	ff 93 a0 02 00 00    	callq  *0x2a0(%rbx)
    1229:	44 8b 5d c8          	mov    -0x38(%rbp),%r11d
    122d:	8b 45 d0             	mov    -0x30(%rbp),%eax

	adapter->total_rx_packets += total_rx_packets;
    1230:	44 01 b3 2c 02 00 00 	add    %r14d,0x22c(%rbx)
	adapter->total_rx_bytes += total_rx_bytes;
    1237:	44 01 9b 28 02 00 00 	add    %r11d,0x228(%rbx)
	netdev->stats.rx_bytes += total_rx_bytes;
	netdev->stats.rx_packets += total_rx_packets;
    123e:	45 89 f2             	mov    %r14d,%r10d
	if (cleaned_count)
		adapter->alloc_rx_buf(adapter, rx_ring, cleaned_count);

	adapter->total_rx_packets += total_rx_packets;
	adapter->total_rx_bytes += total_rx_bytes;
	netdev->stats.rx_bytes += total_rx_bytes;
    1241:	4d 01 9f 38 01 00 00 	add    %r11,0x138(%r15)
	netdev->stats.rx_packets += total_rx_packets;
    1248:	4d 01 97 28 01 00 00 	add    %r10,0x128(%r15)
	return cleaned;
}
    124f:	48 83 c4 78          	add    $0x78,%rsp
    1253:	5b                   	pop    %rbx
    1254:	41 5c                	pop    %r12
    1256:	41 5d                	pop    %r13
    1258:	41 5e                	pop    %r14
    125a:	41 5f                	pop    %r15
    125c:	5d                   	pop    %rbp
    125d:	c3                   	retq   
	i = rx_ring->next_to_clean;
	rx_desc = E1000_RX_DESC(*rx_ring, i);
	buffer_info = &rx_ring->buffer_info[i];

	printk("xiehuan,rx_irq\n");
	e_err(drv,"xiehuan,rx_irq,err\n");
    125e:	48 8b bb b0 03 00 00 	mov    0x3b0(%rbx),%rdi
    1265:	48 c7 c6 00 00 00 00 	mov    $0x0,%rsi
    126c:	31 c0                	xor    %eax,%eax
    126e:	e8 00 00 00 00       	callq  1273 <e1000_clean_jumbo_rx_irq+0x133>
    1273:	e9 37 ff ff ff       	jmpq   11af <e1000_clean_jumbo_rx_irq+0x6f>
		struct sk_buff *skb;
		u8 status;

		if (*work_done >= work_to_do)
			break;
		(*work_done)++;
    1278:	83 c2 01             	add    $0x1,%edx
    127b:	4c 89 8d 70 ff ff ff 	mov    %r9,-0x90(%rbp)
    1282:	44 89 5d 88          	mov    %r11d,-0x78(%rbp)
    1286:	89 16                	mov    %edx,(%rsi)
		dma_rmb(); /* read descriptor and rx_buffer_info after status DD */

		status = rx_desc->status;
    1288:	48 8b 45 d0          	mov    -0x30(%rbp),%rax

		if (++i == rx_ring->count) i = 0;
    128c:	41 83 c5 01          	add    $0x1,%r13d
    1290:	45 3b 6c 24 14       	cmp    0x14(%r12),%r13d

		next_buffer = &rx_ring->buffer_info[i];

		cleaned = true;
		cleaned_count++;
		printk("xiehuan,adapter->rx_buffer_len=%08X\n",adapter->rx_buffer_len);
    1295:	8b b3 08 02 00 00    	mov    0x208(%rbx),%esi
    129b:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
		if (*work_done >= work_to_do)
			break;
		(*work_done)++;
		dma_rmb(); /* read descriptor and rx_buffer_info after status DD */

		status = rx_desc->status;
    12a2:	0f b6 40 0c          	movzbl 0xc(%rax),%eax
    12a6:	88 45 90             	mov    %al,-0x70(%rbp)

		if (++i == rx_ring->count) i = 0;
    12a9:	b8 00 00 00 00       	mov    $0x0,%eax
    12ae:	44 0f 44 e8          	cmove  %eax,%r13d
		prefetch(next_rxd);

		next_buffer = &rx_ring->buffer_info[i];

		cleaned = true;
		cleaned_count++;
    12b2:	41 83 c2 01          	add    $0x1,%r10d
		dma_rmb(); /* read descriptor and rx_buffer_info after status DD */

		status = rx_desc->status;

		if (++i == rx_ring->count) i = 0;
		next_rxd = E1000_RX_DESC(*rx_ring, i);
    12b6:	44 89 e8             	mov    %r13d,%eax
    12b9:	48 c1 e0 04          	shl    $0x4,%rax
    12bd:	48 89 c2             	mov    %rax,%rdx
		prefetch(next_rxd);

		next_buffer = &rx_ring->buffer_info[i];
    12c0:	49 03 44 24 20       	add    0x20(%r12),%rax
		dma_rmb(); /* read descriptor and rx_buffer_info after status DD */

		status = rx_desc->status;

		if (++i == rx_ring->count) i = 0;
		next_rxd = E1000_RX_DESC(*rx_ring, i);
    12c5:	49 03 14 24          	add    (%r12),%rdx
		prefetch(next_rxd);
    12c9:	0f 18 0a             	prefetcht0 (%rdx)

		next_buffer = &rx_ring->buffer_info[i];
    12cc:	48 89 85 78 ff ff ff 	mov    %rax,-0x88(%rbp)

		cleaned = true;
		cleaned_count++;
		printk("xiehuan,adapter->rx_buffer_len=%08X\n",adapter->rx_buffer_len);
    12d3:	31 c0                	xor    %eax,%eax
		dma_rmb(); /* read descriptor and rx_buffer_info after status DD */

		status = rx_desc->status;

		if (++i == rx_ring->count) i = 0;
		next_rxd = E1000_RX_DESC(*rx_ring, i);
    12d5:	48 89 55 80          	mov    %rdx,-0x80(%rbp)
		prefetch(next_rxd);

		next_buffer = &rx_ring->buffer_info[i];

		cleaned = true;
		cleaned_count++;
    12d9:	44 89 55 98          	mov    %r10d,-0x68(%rbp)
		printk("xiehuan,adapter->rx_buffer_len=%08X\n",adapter->rx_buffer_len);
    12dd:	e8 00 00 00 00       	callq  12e2 <e1000_clean_jumbo_rx_irq+0x1a2>
static inline struct dma_map_ops *get_dma_ops(struct device *dev)
{
#ifndef CONFIG_X86_DEV_DMA_OPS
	return dma_ops;
#else
	if (unlikely(!dev) || !dev->archdata.dma_ops)
    12e2:	48 83 7d a0 00       	cmpq   $0x0,-0x60(%rbp)
		dma_unmap_page(&pdev->dev, buffer_info->dma,
    12e7:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
    12eb:	8b 93 08 02 00 00    	mov    0x208(%rbx),%edx
    12f1:	44 8b 55 98          	mov    -0x68(%rbp),%r10d
    12f5:	44 8b 5d 88          	mov    -0x78(%rbp),%r11d
    12f9:	4c 8b 8d 70 ff ff ff 	mov    -0x90(%rbp),%r9
    1300:	48 8b 70 08          	mov    0x8(%rax),%rsi
    1304:	0f 84 0a 01 00 00    	je     1414 <e1000_clean_jumbo_rx_irq+0x2d4>
    130a:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
    130e:	48 8b 80 e8 02 00 00 	mov    0x2e8(%rax),%rax
    1315:	48 85 c0             	test   %rax,%rax
    1318:	0f 84 f6 00 00 00    	je     1414 <e1000_clean_jumbo_rx_irq+0x2d4>
				  size_t size, enum dma_data_direction dir)
{
	struct dma_map_ops *ops = get_dma_ops(dev);

	BUG_ON(!valid_dma_direction(dir));
	if (ops->unmap_page)
    131e:	48 8b 40 28          	mov    0x28(%rax),%rax
    1322:	48 85 c0             	test   %rax,%rax
    1325:	74 2c                	je     1353 <e1000_clean_jumbo_rx_irq+0x213>
    1327:	4c 89 8d 70 ff ff ff 	mov    %r9,-0x90(%rbp)
    132e:	44 89 55 88          	mov    %r10d,-0x78(%rbp)
		ops->unmap_page(dev, addr, size, dir, NULL);
    1332:	45 31 c0             	xor    %r8d,%r8d
    1335:	44 89 5d 98          	mov    %r11d,-0x68(%rbp)
    1339:	b9 02 00 00 00       	mov    $0x2,%ecx
    133e:	48 8b 7d a0          	mov    -0x60(%rbp),%rdi
    1342:	ff d0                	callq  *%rax
    1344:	4c 8b 8d 70 ff ff ff 	mov    -0x90(%rbp),%r9
    134b:	44 8b 55 88          	mov    -0x78(%rbp),%r10d
    134f:	44 8b 5d 98          	mov    -0x68(%rbp),%r11d
			       adapter->rx_buffer_len, DMA_FROM_DEVICE);
		buffer_info->dma = 0;
    1353:	48 8b 45 b0          	mov    -0x50(%rbp),%rax

		length = le16_to_cpu(rx_desc->length);

		/* errors is only valid for DD + EOP descriptors */
		if (unlikely((status & E1000_RXD_STAT_EOP) &&
    1357:	f6 45 90 02          	testb  $0x2,-0x70(%rbp)
		cleaned = true;
		cleaned_count++;
		printk("xiehuan,adapter->rx_buffer_len=%08X\n",adapter->rx_buffer_len);
		dma_unmap_page(&pdev->dev, buffer_info->dma,
			       adapter->rx_buffer_len, DMA_FROM_DEVICE);
		buffer_info->dma = 0;
    135b:	48 c7 40 08 00 00 00 	movq   $0x0,0x8(%rax)
    1362:	00 

		length = le16_to_cpu(rx_desc->length);
    1363:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
    1367:	0f b7 40 08          	movzwl 0x8(%rax),%eax
    136b:	89 45 98             	mov    %eax,-0x68(%rbp)

		/* errors is only valid for DD + EOP descriptors */
		if (unlikely((status & E1000_RXD_STAT_EOP) &&
    136e:	0f 85 22 01 00 00    	jne    1496 <e1000_clean_jumbo_rx_irq+0x356>

#define rxtop rx_ring->rx_skb_top
process_skb:
		if (!(status & E1000_RXD_STAT_EOP)) {
			/* this descriptor is only the beginning (or middle) */
			if (!rxtop) {
    1374:	49 8b 7c 24 28       	mov    0x28(%r12),%rdi
    1379:	48 85 ff             	test   %rdi,%rdi
    137c:	0f 84 c2 00 00 00    	je     1444 <e1000_clean_jumbo_rx_irq+0x304>
}

#ifdef NET_SKBUFF_DATA_USES_OFFSET
static inline unsigned char *skb_end_pointer(const struct sk_buff *skb)
{
	return skb->head + skb->end;
    1382:	8b 87 cc 00 00 00    	mov    0xcc(%rdi),%eax
						   buffer_info->rxbuf.page,
						   0, length);
			} else {
				/* this is the middle of a chain */
				skb_fill_page_desc(rxtop,
				    skb_shinfo(rxtop)->nr_frags,
    1388:	48 8b 97 d0 00 00 00 	mov    0xd0(%rdi),%rdx
				skb_fill_page_desc(rxtop, 0,
						   buffer_info->rxbuf.page,
						   0, length);
			} else {
				/* this is the middle of a chain */
				skb_fill_page_desc(rxtop,
    138f:	8b 4d 98             	mov    -0x68(%rbp),%ecx
    1392:	4c 89 8d 70 ff ff ff 	mov    %r9,-0x90(%rbp)
    1399:	44 89 55 88          	mov    %r10d,-0x78(%rbp)
    139d:	44 89 5d 90          	mov    %r11d,-0x70(%rbp)
    13a1:	0f b6 34 02          	movzbl (%rdx,%rax,1),%esi
    13a5:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
    13a9:	48 8b 10             	mov    (%rax),%rdx
    13ac:	e8 00 00 00 00       	callq  13b1 <e1000_clean_jumbo_rx_irq+0x271>
    13b1:	44 8b 5d 90          	mov    -0x70(%rbp),%r11d
    13b5:	4c 8b 8d 70 ff ff ff 	mov    -0x90(%rbp),%r9
    13bc:	44 8b 55 88          	mov    -0x78(%rbp),%r10d
				    skb_shinfo(rxtop)->nr_frags,
				    buffer_info->rxbuf.page, 0, length);
			}
			e1000_consume_page(buffer_info, rxtop, length);
    13c0:	49 8b 44 24 28       	mov    0x28(%r12),%rax
 * e1000_consume_page - helper function for jumbo Rx path
 **/
static void e1000_consume_page(struct e1000_rx_buffer *bi, struct sk_buff *skb,
			       u16 length)
{
	bi->rxbuf.page = NULL;
    13c5:	48 8b 55 b0          	mov    -0x50(%rbp),%rdx
    13c9:	48 c7 02 00 00 00 00 	movq   $0x0,(%rdx)
	skb->len += length;
    13d0:	8b 55 98             	mov    -0x68(%rbp),%edx
	skb->data_len += length;
	skb->truesize += PAGE_SIZE;
    13d3:	81 80 e0 00 00 00 00 	addl   $0x1000,0xe0(%rax)
    13da:	10 00 00 
 **/
static void e1000_consume_page(struct e1000_rx_buffer *bi, struct sk_buff *skb,
			       u16 length)
{
	bi->rxbuf.page = NULL;
	skb->len += length;
    13dd:	01 90 80 00 00 00    	add    %edx,0x80(%rax)
	skb->data_len += length;
    13e3:	01 90 84 00 00 00    	add    %edx,0x84(%rax)

next_desc:
		rx_desc->status = 0;

		/* return some buffers to hardware, one at a time is too slow */
		if (unlikely(cleaned_count >= E1000_RX_BUFFER_WRITE)) {
    13e9:	41 83 fa 0f          	cmp    $0xf,%r10d
		}

		napi_gro_frags(&adapter->napi);

next_desc:
		rx_desc->status = 0;
    13ed:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
    13f1:	c6 40 0c 00          	movb   $0x0,0xc(%rax)

		/* return some buffers to hardware, one at a time is too slow */
		if (unlikely(cleaned_count >= E1000_RX_BUFFER_WRITE)) {
    13f5:	7f 29                	jg     1420 <e1000_clean_jumbo_rx_irq+0x2e0>
			adapter->alloc_rx_buf(adapter, rx_ring, cleaned_count);
			cleaned_count = 0;
    13f7:	48 8b 95 78 ff ff ff 	mov    -0x88(%rbp),%rdx
    13fe:	b8 01 00 00 00       	mov    $0x1,%eax
    1403:	48 89 55 b0          	mov    %rdx,-0x50(%rbp)
    1407:	48 8b 55 80          	mov    -0x80(%rbp),%rdx
    140b:	48 89 55 d0          	mov    %rdx,-0x30(%rbp)
    140f:	e9 c9 fd ff ff       	jmpq   11dd <e1000_clean_jumbo_rx_irq+0x9d>
		return dma_ops;
    1414:	48 8b 05 00 00 00 00 	mov    0x0(%rip),%rax        # 141b <e1000_clean_jumbo_rx_irq+0x2db>
    141b:	e9 fe fe ff ff       	jmpq   131e <e1000_clean_jumbo_rx_irq+0x1de>
    1420:	4c 89 4d b0          	mov    %r9,-0x50(%rbp)
    1424:	44 89 5d d0          	mov    %r11d,-0x30(%rbp)
next_desc:
		rx_desc->status = 0;

		/* return some buffers to hardware, one at a time is too slow */
		if (unlikely(cleaned_count >= E1000_RX_BUFFER_WRITE)) {
			adapter->alloc_rx_buf(adapter, rx_ring, cleaned_count);
    1428:	44 89 d2             	mov    %r10d,%edx
    142b:	4c 89 e6             	mov    %r12,%rsi
    142e:	48 89 df             	mov    %rbx,%rdi
    1431:	ff 93 a0 02 00 00    	callq  *0x2a0(%rbx)
			cleaned_count = 0;
    1437:	45 31 d2             	xor    %r10d,%r10d
    143a:	4c 8b 4d b0          	mov    -0x50(%rbp),%r9
    143e:	44 8b 5d d0          	mov    -0x30(%rbp),%r11d
    1442:	eb b3                	jmp    13f7 <e1000_clean_jumbo_rx_irq+0x2b7>
process_skb:
		if (!(status & E1000_RXD_STAT_EOP)) {
			/* this descriptor is only the beginning (or middle) */
			if (!rxtop) {
				/* this is the beginning of a chain */
				rxtop = napi_get_frags(&adapter->napi);
    1444:	48 8b 7d a8          	mov    -0x58(%rbp),%rdi
    1448:	44 89 5d 90          	mov    %r11d,-0x70(%rbp)
    144c:	4c 89 8d 70 ff ff ff 	mov    %r9,-0x90(%rbp)
    1453:	44 89 55 88          	mov    %r10d,-0x78(%rbp)
    1457:	e8 00 00 00 00       	callq  145c <e1000_clean_jumbo_rx_irq+0x31c>
				if (!rxtop)
    145c:	48 85 c0             	test   %rax,%rax
process_skb:
		if (!(status & E1000_RXD_STAT_EOP)) {
			/* this descriptor is only the beginning (or middle) */
			if (!rxtop) {
				/* this is the beginning of a chain */
				rxtop = napi_get_frags(&adapter->napi);
    145f:	49 89 44 24 28       	mov    %rax,0x28(%r12)
				if (!rxtop)
    1464:	44 8b 5d 90          	mov    -0x70(%rbp),%r11d
    1468:	0f 84 ae 04 00 00    	je     191c <e1000_clean_jumbo_rx_irq+0x7dc>
					break;

				skb_fill_page_desc(rxtop, 0,
    146e:	48 8b 55 b0          	mov    -0x50(%rbp),%rdx
    1472:	8b 4d 98             	mov    -0x68(%rbp),%ecx
    1475:	31 f6                	xor    %esi,%esi
    1477:	48 89 c7             	mov    %rax,%rdi
    147a:	48 8b 12             	mov    (%rdx),%rdx
    147d:	e8 00 00 00 00       	callq  1482 <e1000_clean_jumbo_rx_irq+0x342>
    1482:	44 8b 5d 90          	mov    -0x70(%rbp),%r11d
    1486:	44 8b 55 88          	mov    -0x78(%rbp),%r10d
    148a:	4c 8b 8d 70 ff ff ff 	mov    -0x90(%rbp),%r9
    1491:	e9 2a ff ff ff       	jmpq   13c0 <e1000_clean_jumbo_rx_irq+0x280>
		buffer_info->dma = 0;

		length = le16_to_cpu(rx_desc->length);

		/* errors is only valid for DD + EOP descriptors */
		if (unlikely((status & E1000_RXD_STAT_EOP) &&
    1496:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
    149a:	0f b6 50 0d          	movzbl 0xd(%rax),%edx
    149e:	f6 c2 97             	test   $0x97,%dl
    14a1:	0f 85 0e 04 00 00    	jne    18b5 <e1000_clean_jumbo_rx_irq+0x775>
				    buffer_info->rxbuf.page, 0, length);
			}
			e1000_consume_page(buffer_info, rxtop, length);
			goto next_desc;
		} else {
			if (rxtop) {
    14a7:	49 8b 7c 24 28       	mov    0x28(%r12),%rdi
    14ac:	48 85 ff             	test   %rdi,%rdi
    14af:	0f 84 35 01 00 00    	je     15ea <e1000_clean_jumbo_rx_irq+0x4aa>
    14b5:	8b 87 cc 00 00 00    	mov    0xcc(%rdi),%eax
				/* end of the chain */
				skb_fill_page_desc(rxtop,
				    skb_shinfo(rxtop)->nr_frags,
    14bb:	48 8b 97 d0 00 00 00 	mov    0xd0(%rdi),%rdx
			e1000_consume_page(buffer_info, rxtop, length);
			goto next_desc;
		} else {
			if (rxtop) {
				/* end of the chain */
				skb_fill_page_desc(rxtop,
    14c2:	8b 4d 98             	mov    -0x68(%rbp),%ecx
    14c5:	4c 89 8d 68 ff ff ff 	mov    %r9,-0x98(%rbp)
    14cc:	44 89 95 70 ff ff ff 	mov    %r10d,-0x90(%rbp)
    14d3:	44 89 5d 88          	mov    %r11d,-0x78(%rbp)
    14d7:	0f b6 34 02          	movzbl (%rdx,%rax,1),%esi
    14db:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
    14df:	48 8b 10             	mov    (%rax),%rdx
    14e2:	e8 00 00 00 00       	callq  14e7 <e1000_clean_jumbo_rx_irq+0x3a7>
				    skb_shinfo(rxtop)->nr_frags,
				    buffer_info->rxbuf.page, 0, length);
				skb = rxtop;
    14e7:	4d 8b 44 24 28       	mov    0x28(%r12),%r8
 * e1000_consume_page - helper function for jumbo Rx path
 **/
static void e1000_consume_page(struct e1000_rx_buffer *bi, struct sk_buff *skb,
			       u16 length)
{
	bi->rxbuf.page = NULL;
    14ec:	48 8b 55 b0          	mov    -0x50(%rbp),%rdx
    14f0:	0f b7 45 98          	movzwl -0x68(%rbp),%eax
				/* end of the chain */
				skb_fill_page_desc(rxtop,
				    skb_shinfo(rxtop)->nr_frags,
				    buffer_info->rxbuf.page, 0, length);
				skb = rxtop;
				rxtop = NULL;
    14f4:	49 c7 44 24 28 00 00 	movq   $0x0,0x28(%r12)
    14fb:	00 00 
    14fd:	44 8b 5d 88          	mov    -0x78(%rbp),%r11d
    1501:	44 8b 95 70 ff ff ff 	mov    -0x90(%rbp),%r10d
 * e1000_consume_page - helper function for jumbo Rx path
 **/
static void e1000_consume_page(struct e1000_rx_buffer *bi, struct sk_buff *skb,
			       u16 length)
{
	bi->rxbuf.page = NULL;
    1508:	48 c7 02 00 00 00 00 	movq   $0x0,(%rdx)
	skb->len += length;
    150f:	41 01 80 80 00 00 00 	add    %eax,0x80(%r8)
	skb->data_len += length;
    1516:	41 01 80 84 00 00 00 	add    %eax,0x84(%r8)
    151d:	4c 8b 8d 68 ff ff ff 	mov    -0x98(%rbp),%r9
	skb->truesize += PAGE_SIZE;
    1524:	41 81 80 e0 00 00 00 	addl   $0x1000,0xe0(%r8)
    152b:	00 10 00 00 
		}

		/* Receive Checksum Offload XXX recompute due to CRC strip? */
		e1000_rx_checksum(adapter,
				  (u32)(status) |
				  ((u32)(rx_desc->errors) << 24),
    152f:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
				}
			}
		}

		/* Receive Checksum Offload XXX recompute due to CRC strip? */
		e1000_rx_checksum(adapter,
    1533:	4c 89 c2             	mov    %r8,%rdx
    1536:	48 89 df             	mov    %rbx,%rdi
				  (u32)(status) |
				  ((u32)(rx_desc->errors) << 24),
    1539:	0f b6 70 0d          	movzbl 0xd(%rax),%esi
			}
		}

		/* Receive Checksum Offload XXX recompute due to CRC strip? */
		e1000_rx_checksum(adapter,
				  (u32)(status) |
    153d:	0f b6 45 90          	movzbl -0x70(%rbp),%eax
    1541:	4c 89 8d 70 ff ff ff 	mov    %r9,-0x90(%rbp)
    1548:	44 89 55 88          	mov    %r10d,-0x78(%rbp)
    154c:	44 89 5d 98          	mov    %r11d,-0x68(%rbp)
				}
			}
		}

		/* Receive Checksum Offload XXX recompute due to CRC strip? */
		e1000_rx_checksum(adapter,
    1550:	4c 89 45 b0          	mov    %r8,-0x50(%rbp)
				  (u32)(status) |
				  ((u32)(rx_desc->errors) << 24),
    1554:	c1 e6 18             	shl    $0x18,%esi
				}
			}
		}

		/* Receive Checksum Offload XXX recompute due to CRC strip? */
		e1000_rx_checksum(adapter,
    1557:	09 c6                	or     %eax,%esi
    1559:	e8 82 f9 ff ff       	callq  ee0 <e1000_rx_checksum.isra.38>
				  (u32)(status) |
				  ((u32)(rx_desc->errors) << 24),
				  le16_to_cpu(rx_desc->csum), skb);

		total_rx_bytes += (skb->len - 4); /* don't count FCS */
    155e:	4c 8b 45 b0          	mov    -0x50(%rbp),%r8
    1562:	44 8b 5d 98          	mov    -0x68(%rbp),%r11d
		if (likely(!(netdev->features & NETIF_F_RXFCS)))
    1566:	48 ba 00 00 00 00 20 	movabs $0x2000000000,%rdx
    156d:	00 00 00 
    1570:	44 8b 55 88          	mov    -0x78(%rbp),%r10d
    1574:	4c 8b 8d 70 ff ff ff 	mov    -0x90(%rbp),%r9
		e1000_rx_checksum(adapter,
				  (u32)(status) |
				  ((u32)(rx_desc->errors) << 24),
				  le16_to_cpu(rx_desc->csum), skb);

		total_rx_bytes += (skb->len - 4); /* don't count FCS */
    157b:	41 8b 80 80 00 00 00 	mov    0x80(%r8),%eax
    1582:	8d 70 fc             	lea    -0x4(%rax),%esi
    1585:	41 01 f3             	add    %esi,%r11d
		if (likely(!(netdev->features & NETIF_F_RXFCS)))
    1588:	49 85 97 f0 00 00 00 	test   %rdx,0xf0(%r15)
    158f:	75 08                	jne    1599 <e1000_clean_jumbo_rx_irq+0x459>
	return 0;
}

static inline int pskb_trim(struct sk_buff *skb, unsigned int len)
{
	return (len < skb->len) ? __pskb_trim(skb, len) : 0;
    1591:	39 f0                	cmp    %esi,%eax
    1593:	0f 87 8d 03 00 00    	ja     1926 <e1000_clean_jumbo_rx_irq+0x7e6>
			pskb_trim(skb, skb->len - 4);
		total_rx_packets++;
    1599:	41 83 c6 01          	add    $0x1,%r14d

		if (status & E1000_RXD_STAT_VP) {
    159d:	f6 45 90 08          	testb  $0x8,-0x70(%rbp)
    15a1:	74 21                	je     15c4 <e1000_clean_jumbo_rx_irq+0x484>
			__le16 vlan = rx_desc->special;
			u16 vid = le16_to_cpu(vlan) & E1000_RXD_SPC_VLAN_MASK;
    15a3:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
    15a7:	0f b7 40 0e          	movzwl 0xe(%rax),%eax
 * Puts the VLAN TCI in @skb->vlan_tci and lets the device do the rest
 */
static inline void __vlan_hwaccel_put_tag(struct sk_buff *skb,
					  __be16 vlan_proto, u16 vlan_tci)
{
	skb->vlan_proto = vlan_proto;
    15ab:	66 41 c7 80 a8 00 00 	movw   $0x81,0xa8(%r8)
    15b2:	00 81 00 
    15b5:	66 25 ff 0f          	and    $0xfff,%ax
	skb->vlan_tci = VLAN_TAG_PRESENT | vlan_tci;
    15b9:	80 cc 10             	or     $0x10,%ah
    15bc:	66 41 89 80 aa 00 00 	mov    %ax,0xaa(%r8)
    15c3:	00 

			__vlan_hwaccel_put_tag(skb, htons(ETH_P_8021Q), vid);
		}

		napi_gro_frags(&adapter->napi);
    15c4:	48 8b 7d a8          	mov    -0x58(%rbp),%rdi
    15c8:	4c 89 4d 90          	mov    %r9,-0x70(%rbp)
    15cc:	44 89 55 98          	mov    %r10d,-0x68(%rbp)
    15d0:	44 89 5d b0          	mov    %r11d,-0x50(%rbp)
    15d4:	e8 00 00 00 00       	callq  15d9 <e1000_clean_jumbo_rx_irq+0x499>
    15d9:	4c 8b 4d 90          	mov    -0x70(%rbp),%r9
    15dd:	44 8b 55 98          	mov    -0x68(%rbp),%r10d
    15e1:	44 8b 5d b0          	mov    -0x50(%rbp),%r11d
    15e5:	e9 ff fd ff ff       	jmpq   13e9 <e1000_clean_jumbo_rx_irq+0x2a9>
			} else {
				struct page *p;
				/* no chain, got EOP, this buf is the packet
				 * copybreak to save the put_page/alloc_page
				 */
				p = buffer_info->rxbuf.page;
    15ea:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
				if (length <= copybreak) {
    15ee:	8b 55 98             	mov    -0x68(%rbp),%edx
    15f1:	39 15 00 00 00 00    	cmp    %edx,0x0(%rip)        # 15f7 <e1000_clean_jumbo_rx_irq+0x4b7>
			} else {
				struct page *p;
				/* no chain, got EOP, this buf is the packet
				 * copybreak to save the put_page/alloc_page
				 */
				p = buffer_info->rxbuf.page;
    15f7:	48 8b 00             	mov    (%rax),%rax
    15fa:	48 89 45 88          	mov    %rax,-0x78(%rbp)
				if (length <= copybreak) {
    15fe:	89 d0                	mov    %edx,%eax
    1600:	0f 82 07 02 00 00    	jb     180d <e1000_clean_jumbo_rx_irq+0x6cd>
					u8 *vaddr;

					if (likely(!(netdev->features & NETIF_F_RXFCS)))
						length -= 4;
    1606:	83 e8 04             	sub    $0x4,%eax
    1609:	48 bf 00 00 00 00 20 	movabs $0x2000000000,%rdi
    1610:	00 00 00 
    1613:	49 85 bf f0 00 00 00 	test   %rdi,0xf0(%r15)
struct sk_buff *__napi_alloc_skb(struct napi_struct *napi,
				 unsigned int length, gfp_t gfp_mask);
static inline struct sk_buff *napi_alloc_skb(struct napi_struct *napi,
					     unsigned int length)
{
	return __napi_alloc_skb(napi, length, GFP_ATOMIC);
    161a:	48 8b 7d a8          	mov    -0x58(%rbp),%rdi
    161e:	4c 89 8d 68 ff ff ff 	mov    %r9,-0x98(%rbp)
    1625:	44 89 95 70 ff ff ff 	mov    %r10d,-0x90(%rbp)
    162c:	44 89 5d b0          	mov    %r11d,-0x50(%rbp)
    1630:	0f 45 c2             	cmovne %edx,%eax
    1633:	ba 20 00 08 02       	mov    $0x2080020,%edx
    1638:	89 c6                	mov    %eax,%esi
    163a:	89 45 98             	mov    %eax,-0x68(%rbp)
    163d:	e8 00 00 00 00       	callq  1642 <e1000_clean_jumbo_rx_irq+0x502>
static struct sk_buff *e1000_alloc_rx_skb(struct e1000_adapter *adapter,
					  unsigned int bufsz)
{
	struct sk_buff *skb = napi_alloc_skb(&adapter->napi, bufsz);

	if (unlikely(!skb))
    1642:	48 85 c0             	test   %rax,%rax
    1645:	44 8b 5d b0          	mov    -0x50(%rbp),%r11d
    1649:	44 8b 95 70 ff ff ff 	mov    -0x90(%rbp),%r10d
    1650:	4c 8b 8d 68 ff ff ff 	mov    -0x98(%rbp),%r9
    1657:	0f 84 9f 01 00 00    	je     17fc <e1000_clean_jumbo_rx_irq+0x6bc>
    165d:	44 89 95 60 ff ff ff 	mov    %r10d,-0xa0(%rbp)
    1664:	44 89 9d 68 ff ff ff 	mov    %r11d,-0x98(%rbp)
#include <linux/sched.h>
#include <asm/uaccess.h>

static __always_inline void pagefault_disabled_inc(void)
{
	current->pagefault_disabled++;
    166b:	41 83 81 68 09 00 00 	addl   $0x1,0x968(%r9)
    1672:	01 
    1673:	4c 89 8d 70 ff ff ff 	mov    %r9,-0x90(%rbp)
#define SKB_LINEAR_ASSERT(skb)  BUG_ON(skb_is_nonlinear(skb))

#ifdef NET_SKBUFF_DATA_USES_OFFSET
static inline unsigned char *skb_tail_pointer(const struct sk_buff *skb)
{
	return skb->head + skb->tail;
    167a:	8b b8 c8 00 00 00    	mov    0xc8(%rax),%edi
    1680:	48 89 45 b0          	mov    %rax,-0x50(%rbp)
 */
#include <linux/vmstat.h>

static __always_inline void *lowmem_page_address(const struct page *page)
{
	return __va(PFN_PHYS(page_to_pfn(page)));
    1684:	48 be 00 00 00 00 00 	movabs $0xffff880000000000,%rsi
    168b:	88 ff ff 
    168e:	48 03 b8 d0 00 00 00 	add    0xd0(%rax),%rdi
    1695:	48 b8 00 00 00 00 00 	movabs $0x160000000000,%rax
    169c:	16 00 00 
    169f:	48 03 45 88          	add    -0x78(%rbp),%rax
								 length);
					if (!skb)
						break;

					vaddr = kmap_atomic(p);
					memcpy(skb_tail_pointer(skb), vaddr,
    16a3:	8b 55 98             	mov    -0x68(%rbp),%edx
    16a6:	48 c1 f8 06          	sar    $0x6,%rax
    16aa:	48 c1 e0 0c          	shl    $0xc,%rax
    16ae:	48 01 c6             	add    %rax,%rsi
    16b1:	e8 00 00 00 00       	callq  16b6 <e1000_clean_jumbo_rx_irq+0x576>
}

static __always_inline void pagefault_disabled_dec(void)
{
	current->pagefault_disabled--;
    16b6:	4c 8b 8d 70 ff ff ff 	mov    -0x90(%rbp),%r9
	WARN_ON(current->pagefault_disabled < 0);
    16bd:	48 8b 4d b0          	mov    -0x50(%rbp),%rcx
    16c1:	44 8b 9d 68 ff ff ff 	mov    -0x98(%rbp),%r11d
    16c8:	44 8b 95 60 ff ff ff 	mov    -0xa0(%rbp),%r10d
	current->pagefault_disabled++;
}

static __always_inline void pagefault_disabled_dec(void)
{
	current->pagefault_disabled--;
    16cf:	41 83 a9 68 09 00 00 	subl   $0x1,0x968(%r9)
    16d6:	01 
	WARN_ON(current->pagefault_disabled < 0);
    16d7:	41 83 b9 68 09 00 00 	cmpl   $0x0,0x968(%r9)
    16de:	00 
    16df:	79 3d                	jns    171e <e1000_clean_jumbo_rx_irq+0x5de>
    16e1:	be 0f 00 00 00       	mov    $0xf,%esi
    16e6:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
    16ed:	4c 89 8d 68 ff ff ff 	mov    %r9,-0x98(%rbp)
    16f4:	44 89 95 70 ff ff ff 	mov    %r10d,-0x90(%rbp)
    16fb:	44 89 5d 88          	mov    %r11d,-0x78(%rbp)
    16ff:	48 89 4d b0          	mov    %rcx,-0x50(%rbp)
    1703:	e8 00 00 00 00       	callq  1708 <e1000_clean_jumbo_rx_irq+0x5c8>
    1708:	4c 8b 8d 68 ff ff ff 	mov    -0x98(%rbp),%r9
    170f:	44 8b 95 70 ff ff ff 	mov    -0x90(%rbp),%r10d
    1716:	44 8b 5d 88          	mov    -0x78(%rbp),%r11d
    171a:	48 8b 4d b0          	mov    -0x50(%rbp),%rcx
    171e:	4c 89 8d 68 ff ff ff 	mov    %r9,-0x98(%rbp)
    1725:	44 89 95 70 ff ff ff 	mov    %r10d,-0x90(%rbp)
    172c:	44 89 5d 88          	mov    %r11d,-0x78(%rbp)
					       length);
					kunmap_atomic(vaddr);
					/* re-use the page, so don't erase
					 * buffer_info->rxbuf.page
					 */
					skb_put(skb, length);
    1730:	8b 75 98             	mov    -0x68(%rbp),%esi
    1733:	48 89 cf             	mov    %rcx,%rdi
    1736:	48 89 4d b0          	mov    %rcx,-0x50(%rbp)
					e1000_rx_checksum(adapter,
							  status | rx_desc->errors << 24,
							  le16_to_cpu(rx_desc->csum), skb);

					total_rx_bytes += skb->len;
					total_rx_packets++;
    173a:	41 83 c6 01          	add    $0x1,%r14d
					       length);
					kunmap_atomic(vaddr);
					/* re-use the page, so don't erase
					 * buffer_info->rxbuf.page
					 */
					skb_put(skb, length);
    173e:	e8 00 00 00 00       	callq  1743 <e1000_clean_jumbo_rx_irq+0x603>
					e1000_rx_checksum(adapter,
							  status | rx_desc->errors << 24,
    1743:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
					kunmap_atomic(vaddr);
					/* re-use the page, so don't erase
					 * buffer_info->rxbuf.page
					 */
					skb_put(skb, length);
					e1000_rx_checksum(adapter,
    1747:	48 8b 4d b0          	mov    -0x50(%rbp),%rcx
    174b:	48 89 df             	mov    %rbx,%rdi
							  status | rx_desc->errors << 24,
    174e:	0f b6 70 0d          	movzbl 0xd(%rax),%esi
    1752:	0f b6 45 90          	movzbl -0x70(%rbp),%eax
					kunmap_atomic(vaddr);
					/* re-use the page, so don't erase
					 * buffer_info->rxbuf.page
					 */
					skb_put(skb, length);
					e1000_rx_checksum(adapter,
    1756:	48 89 ca             	mov    %rcx,%rdx
							  status | rx_desc->errors << 24,
    1759:	c1 e6 18             	shl    $0x18,%esi
    175c:	09 c6                	or     %eax,%esi
					kunmap_atomic(vaddr);
					/* re-use the page, so don't erase
					 * buffer_info->rxbuf.page
					 */
					skb_put(skb, length);
					e1000_rx_checksum(adapter,
    175e:	e8 7d f7 ff ff       	callq  ee0 <e1000_rx_checksum.isra.38>
							  status | rx_desc->errors << 24,
							  le16_to_cpu(rx_desc->csum), skb);

					total_rx_bytes += skb->len;
    1763:	48 8b 4d b0          	mov    -0x50(%rbp),%rcx
					total_rx_packets++;

					e1000_receive_skb(adapter, status,
							  rx_desc->special, skb);
    1767:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
					skb_put(skb, length);
					e1000_rx_checksum(adapter,
							  status | rx_desc->errors << 24,
							  le16_to_cpu(rx_desc->csum), skb);

					total_rx_bytes += skb->len;
    176b:	44 8b 5d 88          	mov    -0x78(%rbp),%r11d
 * @skb: pointer to sk_buff to be indicated to stack
 */
static void e1000_receive_skb(struct e1000_adapter *adapter, u8 status,
			      __le16 vlan, struct sk_buff *skb)
{
	skb->protocol = eth_type_trans(skb, adapter->netdev);
    176f:	48 8b b3 b0 03 00 00 	mov    0x3b0(%rbx),%rsi
					skb_put(skb, length);
					e1000_rx_checksum(adapter,
							  status | rx_desc->errors << 24,
							  le16_to_cpu(rx_desc->csum), skb);

					total_rx_bytes += skb->len;
    1776:	44 03 99 80 00 00 00 	add    0x80(%rcx),%r11d
					total_rx_packets++;

					e1000_receive_skb(adapter, status,
							  rx_desc->special, skb);
    177d:	0f b7 40 0e          	movzwl 0xe(%rax),%eax
 * @skb: pointer to sk_buff to be indicated to stack
 */
static void e1000_receive_skb(struct e1000_adapter *adapter, u8 status,
			      __le16 vlan, struct sk_buff *skb)
{
	skb->protocol = eth_type_trans(skb, adapter->netdev);
    1781:	48 89 cf             	mov    %rcx,%rdi
    1784:	48 89 4d 98          	mov    %rcx,-0x68(%rbp)
					skb_put(skb, length);
					e1000_rx_checksum(adapter,
							  status | rx_desc->errors << 24,
							  le16_to_cpu(rx_desc->csum), skb);

					total_rx_bytes += skb->len;
    1788:	44 89 5d 88          	mov    %r11d,-0x78(%rbp)
					total_rx_packets++;

					e1000_receive_skb(adapter, status,
							  rx_desc->special, skb);
    178c:	66 89 45 b0          	mov    %ax,-0x50(%rbp)
 * @skb: pointer to sk_buff to be indicated to stack
 */
static void e1000_receive_skb(struct e1000_adapter *adapter, u8 status,
			      __le16 vlan, struct sk_buff *skb)
{
	skb->protocol = eth_type_trans(skb, adapter->netdev);
    1790:	e8 00 00 00 00       	callq  1795 <e1000_clean_jumbo_rx_irq+0x655>

	if (status & E1000_RXD_STAT_VP) {
    1795:	f6 45 90 08          	testb  $0x8,-0x70(%rbp)
 * @skb: pointer to sk_buff to be indicated to stack
 */
static void e1000_receive_skb(struct e1000_adapter *adapter, u8 status,
			      __le16 vlan, struct sk_buff *skb)
{
	skb->protocol = eth_type_trans(skb, adapter->netdev);
    1799:	48 8b 4d 98          	mov    -0x68(%rbp),%rcx

	if (status & E1000_RXD_STAT_VP) {
    179d:	44 8b 5d 88          	mov    -0x78(%rbp),%r11d
    17a1:	44 8b 95 70 ff ff ff 	mov    -0x90(%rbp),%r10d
    17a8:	4c 8b 8d 68 ff ff ff 	mov    -0x98(%rbp),%r9
 * @skb: pointer to sk_buff to be indicated to stack
 */
static void e1000_receive_skb(struct e1000_adapter *adapter, u8 status,
			      __le16 vlan, struct sk_buff *skb)
{
	skb->protocol = eth_type_trans(skb, adapter->netdev);
    17af:	66 89 81 c0 00 00 00 	mov    %ax,0xc0(%rcx)

	if (status & E1000_RXD_STAT_VP) {
    17b6:	74 1b                	je     17d3 <e1000_clean_jumbo_rx_irq+0x693>
		u16 vid = le16_to_cpu(vlan) & E1000_RXD_SPC_VLAN_MASK;
    17b8:	0f b7 45 b0          	movzwl -0x50(%rbp),%eax
 * Puts the VLAN TCI in @skb->vlan_tci and lets the device do the rest
 */
static inline void __vlan_hwaccel_put_tag(struct sk_buff *skb,
					  __be16 vlan_proto, u16 vlan_tci)
{
	skb->vlan_proto = vlan_proto;
    17bc:	66 c7 81 a8 00 00 00 	movw   $0x81,0xa8(%rcx)
    17c3:	81 00 
    17c5:	66 25 ff 0f          	and    $0xfff,%ax
	skb->vlan_tci = VLAN_TAG_PRESENT | vlan_tci;
    17c9:	80 cc 10             	or     $0x10,%ah
    17cc:	66 89 81 aa 00 00 00 	mov    %ax,0xaa(%rcx)

		__vlan_hwaccel_put_tag(skb, htons(ETH_P_8021Q), vid);
	}
	napi_gro_receive(&adapter->napi, skb);
    17d3:	48 8b 7d a8          	mov    -0x58(%rbp),%rdi
    17d7:	48 89 ce             	mov    %rcx,%rsi
    17da:	4c 89 4d 90          	mov    %r9,-0x70(%rbp)
    17de:	44 89 55 98          	mov    %r10d,-0x68(%rbp)
    17e2:	44 89 5d b0          	mov    %r11d,-0x50(%rbp)
    17e6:	e8 00 00 00 00       	callq  17eb <e1000_clean_jumbo_rx_irq+0x6ab>
    17eb:	44 8b 5d b0          	mov    -0x50(%rbp),%r11d
    17ef:	44 8b 55 98          	mov    -0x68(%rbp),%r10d
    17f3:	4c 8b 4d 90          	mov    -0x70(%rbp),%r9
    17f7:	e9 ed fb ff ff       	jmpq   13e9 <e1000_clean_jumbo_rx_irq+0x2a9>
							  rx_desc->special, skb);
					goto next_desc;
				} else {
					skb = napi_get_frags(&adapter->napi);
					if (!skb) {
						adapter->alloc_rx_buff_failed++;
    17fc:	83 83 90 03 00 00 01 	addl   $0x1,0x390(%rbx)
		next_rxd = E1000_RX_DESC(*rx_ring, i);
		prefetch(next_rxd);

		next_buffer = &rx_ring->buffer_info[i];

		cleaned = true;
    1803:	b8 01 00 00 00       	mov    $0x1,%eax
					goto next_desc;
				} else {
					skb = napi_get_frags(&adapter->napi);
					if (!skb) {
						adapter->alloc_rx_buff_failed++;
						break;
    1808:	e9 e9 f9 ff ff       	jmpq   11f6 <e1000_clean_jumbo_rx_irq+0xb6>

					e1000_receive_skb(adapter, status,
							  rx_desc->special, skb);
					goto next_desc;
				} else {
					skb = napi_get_frags(&adapter->napi);
    180d:	48 8b 7d a8          	mov    -0x58(%rbp),%rdi
    1811:	4c 89 8d 60 ff ff ff 	mov    %r9,-0xa0(%rbp)
    1818:	44 89 95 68 ff ff ff 	mov    %r10d,-0x98(%rbp)
    181f:	44 89 9d 70 ff ff ff 	mov    %r11d,-0x90(%rbp)
    1826:	e8 00 00 00 00       	callq  182b <e1000_clean_jumbo_rx_irq+0x6eb>
					if (!skb) {
    182b:	48 85 c0             	test   %rax,%rax
    182e:	44 8b 9d 70 ff ff ff 	mov    -0x90(%rbp),%r11d
    1835:	44 8b 95 68 ff ff ff 	mov    -0x98(%rbp),%r10d
    183c:	4c 8b 8d 60 ff ff ff 	mov    -0xa0(%rbp),%r9
    1843:	74 b7                	je     17fc <e1000_clean_jumbo_rx_irq+0x6bc>
						adapter->alloc_rx_buff_failed++;
						break;
					}
					skb_fill_page_desc(skb, 0, p, 0,
    1845:	48 8b 55 88          	mov    -0x78(%rbp),%rdx
    1849:	8b 4d 98             	mov    -0x68(%rbp),%ecx
    184c:	48 89 c7             	mov    %rax,%rdi
    184f:	31 f6                	xor    %esi,%esi
    1851:	4c 89 8d 60 ff ff ff 	mov    %r9,-0xa0(%rbp)
    1858:	44 89 95 68 ff ff ff 	mov    %r10d,-0x98(%rbp)
    185f:	44 89 9d 70 ff ff ff 	mov    %r11d,-0x90(%rbp)
    1866:	48 89 45 88          	mov    %rax,-0x78(%rbp)
    186a:	e8 00 00 00 00       	callq  186f <e1000_clean_jumbo_rx_irq+0x72f>
 **/
static void e1000_consume_page(struct e1000_rx_buffer *bi, struct sk_buff *skb,
			       u16 length)
{
	bi->rxbuf.page = NULL;
	skb->len += length;
    186f:	4c 8b 45 88          	mov    -0x78(%rbp),%r8
 * e1000_consume_page - helper function for jumbo Rx path
 **/
static void e1000_consume_page(struct e1000_rx_buffer *bi, struct sk_buff *skb,
			       u16 length)
{
	bi->rxbuf.page = NULL;
    1873:	48 8b 55 b0          	mov    -0x50(%rbp),%rdx
    1877:	0f b7 45 98          	movzwl -0x68(%rbp),%eax
	skb->len += length;
	skb->data_len += length;
	skb->truesize += PAGE_SIZE;
    187b:	4c 8b 8d 60 ff ff ff 	mov    -0xa0(%rbp),%r9
    1882:	44 8b 95 68 ff ff ff 	mov    -0x98(%rbp),%r10d
    1889:	44 8b 9d 70 ff ff ff 	mov    -0x90(%rbp),%r11d
 * e1000_consume_page - helper function for jumbo Rx path
 **/
static void e1000_consume_page(struct e1000_rx_buffer *bi, struct sk_buff *skb,
			       u16 length)
{
	bi->rxbuf.page = NULL;
    1890:	48 c7 02 00 00 00 00 	movq   $0x0,(%rdx)
	skb->len += length;
    1897:	41 01 80 80 00 00 00 	add    %eax,0x80(%r8)
	skb->data_len += length;
    189e:	41 01 80 84 00 00 00 	add    %eax,0x84(%r8)
	skb->truesize += PAGE_SIZE;
    18a5:	41 81 80 e0 00 00 00 	addl   $0x1000,0xe0(%r8)
    18ac:	00 10 00 00 
    18b0:	e9 7a fc ff ff       	jmpq   152f <e1000_clean_jumbo_rx_irq+0x3ef>
    18b5:	48 8b 7d b0          	mov    -0x50(%rbp),%rdi
    18b9:	48 b8 00 00 00 00 00 	movabs $0x160000000000,%rax
    18c0:	16 00 00 
		/* errors is only valid for DD + EOP descriptors */
		if (unlikely((status & E1000_RXD_STAT_EOP) &&
		    (rx_desc->errors & E1000_RXD_ERR_FRAME_ERR_MASK))) {
			u8 *mapped = page_address(buffer_info->rxbuf.page);

			if (e1000_tbi_should_accept(adapter, status,
    18c3:	48 b9 00 00 00 00 00 	movabs $0xffff880000000000,%rcx
    18ca:	88 ff ff 
    18cd:	0f b6 75 90          	movzbl -0x70(%rbp),%esi
    18d1:	4c 89 8d 68 ff ff ff 	mov    %r9,-0x98(%rbp)
    18d8:	44 89 95 70 ff ff ff 	mov    %r10d,-0x90(%rbp)
    18df:	44 89 5d 88          	mov    %r11d,-0x78(%rbp)
    18e3:	48 03 07             	add    (%rdi),%rax
    18e6:	48 89 df             	mov    %rbx,%rdi
    18e9:	48 c1 f8 06          	sar    $0x6,%rax
    18ed:	48 c1 e0 0c          	shl    $0xc,%rax
    18f1:	4c 8d 04 08          	lea    (%rax,%rcx,1),%r8
    18f5:	8b 4d 98             	mov    -0x68(%rbp),%ecx
    18f8:	e8 33 f6 ff ff       	callq  f30 <e1000_tbi_should_accept>
    18fd:	84 c0                	test   %al,%al
    18ff:	44 8b 5d 88          	mov    -0x78(%rbp),%r11d
    1903:	44 8b 95 70 ff ff ff 	mov    -0x90(%rbp),%r10d
    190a:	4c 8b 8d 68 ff ff ff 	mov    -0x98(%rbp),%r9
    1911:	74 40                	je     1953 <e1000_clean_jumbo_rx_irq+0x813>
						    rx_desc->errors,
						    length, mapped)) {
				length--;
    1913:	83 6d 98 01          	subl   $0x1,-0x68(%rbp)
    1917:	e9 8b fb ff ff       	jmpq   14a7 <e1000_clean_jumbo_rx_irq+0x367>
		next_rxd = E1000_RX_DESC(*rx_ring, i);
		prefetch(next_rxd);

		next_buffer = &rx_ring->buffer_info[i];

		cleaned = true;
    191c:	b8 01 00 00 00       	mov    $0x1,%eax
    1921:	e9 d0 f8 ff ff       	jmpq   11f6 <e1000_clean_jumbo_rx_irq+0xb6>

void skb_trim(struct sk_buff *skb, unsigned int len);

static inline int __pskb_trim(struct sk_buff *skb, unsigned int len)
{
	if (skb->data_len)
    1926:	41 83 b8 84 00 00 00 	cmpl   $0x0,0x84(%r8)
    192d:	00 
    192e:	75 66                	jne    1996 <e1000_clean_jumbo_rx_irq+0x856>
	return skb->head + skb->tail;
}

static inline void skb_reset_tail_pointer(struct sk_buff *skb)
{
	skb->tail = skb->data - skb->head;
    1930:	49 8b 80 d8 00 00 00 	mov    0xd8(%r8),%rax
    1937:	49 2b 80 d0 00 00 00 	sub    0xd0(%r8),%rax
{
	if (unlikely(skb_is_nonlinear(skb))) {
		WARN_ON(1);
		return;
	}
	skb->len = len;
    193e:	41 89 b0 80 00 00 00 	mov    %esi,0x80(%r8)
}

static inline void skb_set_tail_pointer(struct sk_buff *skb, const int offset)
{
	skb_reset_tail_pointer(skb);
	skb->tail += offset;
    1945:	01 f0                	add    %esi,%eax
    1947:	41 89 80 c8 00 00 00 	mov    %eax,0xc8(%r8)
    194e:	e9 46 fc ff ff       	jmpq   1599 <e1000_clean_jumbo_rx_irq+0x459>

			if (e1000_tbi_should_accept(adapter, status,
						    rx_desc->errors,
						    length, mapped)) {
				length--;
			} else if (netdev->features & NETIF_F_RXALL) {
    1953:	41 f6 87 f4 00 00 00 	testb  $0x40,0xf4(%r15)
    195a:	40 
    195b:	0f 85 46 fb ff ff    	jne    14a7 <e1000_clean_jumbo_rx_irq+0x367>
				goto process_skb;
			} else {
				/* an error means any chain goes out the window
				 * too
				 */
				if (rx_ring->rx_skb_top)
    1961:	49 8b 7c 24 28       	mov    0x28(%r12),%rdi
    1966:	48 85 ff             	test   %rdi,%rdi
    1969:	74 1d                	je     1988 <e1000_clean_jumbo_rx_irq+0x848>
    196b:	4c 89 4d 90          	mov    %r9,-0x70(%rbp)
    196f:	44 89 55 98          	mov    %r10d,-0x68(%rbp)
    1973:	44 89 5d b0          	mov    %r11d,-0x50(%rbp)
					dev_kfree_skb(rx_ring->rx_skb_top);
    1977:	e8 00 00 00 00       	callq  197c <e1000_clean_jumbo_rx_irq+0x83c>
    197c:	44 8b 5d b0          	mov    -0x50(%rbp),%r11d
    1980:	4c 8b 4d 90          	mov    -0x70(%rbp),%r9
    1984:	44 8b 55 98          	mov    -0x68(%rbp),%r10d
				rx_ring->rx_skb_top = NULL;
    1988:	49 c7 44 24 28 00 00 	movq   $0x0,0x28(%r12)
    198f:	00 00 
				goto next_desc;
    1991:	e9 53 fa ff ff       	jmpq   13e9 <e1000_clean_jumbo_rx_irq+0x2a9>
void skb_trim(struct sk_buff *skb, unsigned int len);

static inline int __pskb_trim(struct sk_buff *skb, unsigned int len)
{
	if (skb->data_len)
		return ___pskb_trim(skb, len);
    1996:	4c 89 c7             	mov    %r8,%rdi
    1999:	44 89 5d 98          	mov    %r11d,-0x68(%rbp)
    199d:	e8 00 00 00 00       	callq  19a2 <e1000_clean_jumbo_rx_irq+0x862>
    19a2:	4c 8b 45 b0          	mov    -0x50(%rbp),%r8
    19a6:	44 8b 5d 98          	mov    -0x68(%rbp),%r11d
    19aa:	44 8b 55 88          	mov    -0x78(%rbp),%r10d
    19ae:	4c 8b 8d 70 ff ff ff 	mov    -0x90(%rbp),%r9
    19b5:	e9 df fb ff ff       	jmpq   1599 <e1000_clean_jumbo_rx_irq+0x459>
    19ba:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)

00000000000019c0 <e1000_alloc_rx_buffers>:
 * @adapter: address of board private structure
 **/
static void e1000_alloc_rx_buffers(struct e1000_adapter *adapter,
				   struct e1000_rx_ring *rx_ring,
				   int cleaned_count)
{
    19c0:	e8 00 00 00 00       	callq  19c5 <e1000_alloc_rx_buffers+0x5>
    19c5:	55                   	push   %rbp
    19c6:	48 89 e5             	mov    %rsp,%rbp
    19c9:	41 57                	push   %r15
    19cb:	41 56                	push   %r14
    19cd:	49 89 fe             	mov    %rdi,%r14
    19d0:	41 55                	push   %r13
    19d2:	49 89 f5             	mov    %rsi,%r13
    19d5:	41 54                	push   %r12
    19d7:	53                   	push   %rbx
    19d8:	48 83 ec 28          	sub    $0x28,%rsp
	struct e1000_rx_desc *rx_desc;
	struct e1000_rx_buffer *buffer_info;
	unsigned int i;
	unsigned int bufsz = adapter->rx_buffer_len;

	i = rx_ring->next_to_use;
    19dc:	8b 5e 18             	mov    0x18(%rsi),%ebx
static void e1000_alloc_rx_buffers(struct e1000_adapter *adapter,
				   struct e1000_rx_ring *rx_ring,
				   int cleaned_count)
{
	struct e1000_hw *hw = &adapter->hw;
	struct pci_dev *pdev = adapter->pdev;
    19df:	48 8b 87 b8 03 00 00 	mov    0x3b8(%rdi),%rax
	struct e1000_rx_desc *rx_desc;
	struct e1000_rx_buffer *buffer_info;
	unsigned int i;
	unsigned int bufsz = adapter->rx_buffer_len;
    19e6:	8b 8f 08 02 00 00    	mov    0x208(%rdi),%ecx

	i = rx_ring->next_to_use;
	buffer_info = &rx_ring->buffer_info[i];
    19ec:	41 89 dc             	mov    %ebx,%r12d
static void e1000_alloc_rx_buffers(struct e1000_adapter *adapter,
				   struct e1000_rx_ring *rx_ring,
				   int cleaned_count)
{
	struct e1000_hw *hw = &adapter->hw;
	struct pci_dev *pdev = adapter->pdev;
    19ef:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
	struct e1000_rx_buffer *buffer_info;
	unsigned int i;
	unsigned int bufsz = adapter->rx_buffer_len;

	i = rx_ring->next_to_use;
	buffer_info = &rx_ring->buffer_info[i];
    19f3:	49 c1 e4 04          	shl    $0x4,%r12
    19f7:	4c 03 66 20          	add    0x20(%rsi),%r12

	while (cleaned_count--) {
    19fb:	85 d2                	test   %edx,%edx
	struct e1000_hw *hw = &adapter->hw;
	struct pci_dev *pdev = adapter->pdev;
	struct e1000_rx_desc *rx_desc;
	struct e1000_rx_buffer *buffer_info;
	unsigned int i;
	unsigned int bufsz = adapter->rx_buffer_len;
    19fd:	89 4d b4             	mov    %ecx,-0x4c(%rbp)

	i = rx_ring->next_to_use;
	buffer_info = &rx_ring->buffer_info[i];

	while (cleaned_count--) {
    1a00:	0f 84 a0 02 00 00    	je     1ca6 <e1000_alloc_rx_buffers+0x2e6>
			}

			/* Use new allocation */
			skb_free_frag(olddata);
		}
		buffer_info->dma = dma_map_single(&pdev->dev,
    1a06:	48 05 98 00 00 00    	add    $0x98,%rax
    1a0c:	41 89 d7             	mov    %edx,%r15d
    1a0f:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
			adapter->alloc_rx_buff_failed++;
			break;
		}

		/* Fix for errata 23, can't cross 64kB boundary */
		if (!e1000_check_64k_bound(adapter, data, bufsz)) {
    1a13:	89 c8                	mov    %ecx,%eax
static bool e1000_check_64k_bound(struct e1000_adapter *adapter, void *start,
				  unsigned long len)
{
	struct e1000_hw *hw = &adapter->hw;
	unsigned long begin = (unsigned long)start;
	unsigned long end = begin + len;
    1a15:	48 83 e8 01          	sub    $0x1,%rax
    1a19:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
    1a1d:	eb 34                	jmp    1a53 <e1000_alloc_rx_buffers+0x93>
    1a1f:	49 8b 54 24 08       	mov    0x8(%r12),%rdx
			adapter->alloc_rx_buff_failed++;
			break;
		}
		buffer_info->rxbuf.data = data;
 skip:
		rx_desc = E1000_RX_DESC(*rx_ring, i);
    1a24:	89 d8                	mov    %ebx,%eax
		rx_desc->buffer_addr = cpu_to_le64(buffer_info->dma);

		if (unlikely(++i == rx_ring->count))
    1a26:	83 c3 01             	add    $0x1,%ebx
			break;
		}
		buffer_info->rxbuf.data = data;
 skip:
		rx_desc = E1000_RX_DESC(*rx_ring, i);
		rx_desc->buffer_addr = cpu_to_le64(buffer_info->dma);
    1a29:	48 c1 e0 04          	shl    $0x4,%rax
    1a2d:	49 03 45 00          	add    0x0(%r13),%rax
    1a31:	48 89 10             	mov    %rdx,(%rax)

		if (unlikely(++i == rx_ring->count))
    1a34:	41 3b 5d 14          	cmp    0x14(%r13),%ebx
    1a38:	0f 84 7a 03 00 00    	je     1db8 <e1000_alloc_rx_buffers+0x3f8>
    1a3e:	41 89 dc             	mov    %ebx,%r12d
    1a41:	49 c1 e4 04          	shl    $0x4,%r12
			i = 0;
		buffer_info = &rx_ring->buffer_info[i];
    1a45:	4d 03 65 20          	add    0x20(%r13),%r12
	unsigned int bufsz = adapter->rx_buffer_len;

	i = rx_ring->next_to_use;
	buffer_info = &rx_ring->buffer_info[i];

	while (cleaned_count--) {
    1a49:	41 83 ef 01          	sub    $0x1,%r15d
    1a4d:	0f 84 2d 02 00 00    	je     1c80 <e1000_alloc_rx_buffers+0x2c0>
		void *data;

		if (buffer_info->rxbuf.data)
    1a53:	49 83 3c 24 00       	cmpq   $0x0,(%r12)
    1a58:	75 c5                	jne    1a1f <e1000_alloc_rx_buffers+0x5f>
			goto skip;

		data = e1000_alloc_frag(adapter);
    1a5a:	4c 89 f7             	mov    %r14,%rdi
    1a5d:	e8 ce e9 ff ff       	callq  430 <e1000_alloc_frag>
		if (!data) {
    1a62:	48 85 c0             	test   %rax,%rax
		void *data;

		if (buffer_info->rxbuf.data)
			goto skip;

		data = e1000_alloc_frag(adapter);
    1a65:	49 89 c2             	mov    %rax,%r10
		if (!data) {
    1a68:	0f 84 df 02 00 00    	je     1d4d <e1000_alloc_rx_buffers+0x38d>
	unsigned long end = begin + len;

	/* First rev 82545 and 82546 need to not allow any memory
	 * write location to cross 64k boundary due to errata 23
	 */
	if (hw->mac_type == e1000_82545 ||
    1a6e:	41 8b 86 d8 03 00 00 	mov    0x3d8(%r14),%eax
    1a75:	83 f8 06             	cmp    $0x6,%eax
    1a78:	0f 84 02 01 00 00    	je     1b80 <e1000_alloc_rx_buffers+0x1c0>
	    hw->mac_type == e1000_ce4100 ||
    1a7e:	83 e8 08             	sub    $0x8,%eax
    1a81:	4c 89 d6             	mov    %r10,%rsi
    1a84:	83 f8 01             	cmp    $0x1,%eax
    1a87:	0f 86 f3 00 00 00    	jbe    1b80 <e1000_alloc_rx_buffers+0x1c0>
static inline struct dma_map_ops *get_dma_ops(struct device *dev)
{
#ifndef CONFIG_X86_DEV_DMA_OPS
	return dma_ops;
#else
	if (unlikely(!dev) || !dev->archdata.dma_ops)
    1a8d:	48 83 7d d0 00       	cmpq   $0x0,-0x30(%rbp)
			}

			/* Use new allocation */
			skb_free_frag(olddata);
		}
		buffer_info->dma = dma_map_single(&pdev->dev,
    1a92:	41 8b 8e 08 02 00 00 	mov    0x208(%r14),%ecx
    1a99:	0f 84 9a 02 00 00    	je     1d39 <e1000_alloc_rx_buffers+0x379>
    1a9f:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
    1aa3:	48 8b 80 e8 02 00 00 	mov    0x2e8(%rax),%rax
    1aaa:	48 85 c0             	test   %rax,%rax
    1aad:	0f 84 86 02 00 00    	je     1d39 <e1000_alloc_rx_buffers+0x379>
	struct dma_map_ops *ops = get_dma_ops(dev);
	dma_addr_t addr;

	kmemcheck_mark_initialized(ptr, size);
	BUG_ON(!valid_dma_direction(dir));
	addr = ops->map_page(dev, virt_to_page(ptr),
    1ab3:	48 89 f2             	mov    %rsi,%rdx
static inline unsigned long __phys_addr_nodebug(unsigned long x)
{
	unsigned long y = x - __START_KERNEL_map;

	/* use the carry flag to determine if x was < __START_KERNEL_map */
	x = y + ((x > y) ? phys_base : (__START_KERNEL_map - PAGE_OFFSET));
    1ab6:	41 bb 00 00 00 80    	mov    $0x80000000,%r11d
    1abc:	48 bf 00 00 00 80 ff 	movabs $0x77ff80000000,%rdi
    1ac3:	77 00 00 
    1ac6:	81 e2 ff 0f 00 00    	and    $0xfff,%edx
    1acc:	4c 01 de             	add    %r11,%rsi
    1acf:	48 0f 42 3d 00 00 00 	cmovb  0x0(%rip),%rdi        # 1ad7 <e1000_alloc_rx_buffers+0x117>
    1ad6:	00 
    1ad7:	4c 89 55 c0          	mov    %r10,-0x40(%rbp)
    1adb:	45 31 c9             	xor    %r9d,%r9d
    1ade:	41 b8 02 00 00 00    	mov    $0x2,%r8d
    1ae4:	48 01 fe             	add    %rdi,%rsi
    1ae7:	48 bf 00 00 00 00 00 	movabs $0xffffea0000000000,%rdi
    1aee:	ea ff ff 
    1af1:	48 c1 ee 0c          	shr    $0xc,%rsi
    1af5:	48 c1 e6 06          	shl    $0x6,%rsi
    1af9:	48 01 fe             	add    %rdi,%rsi
    1afc:	48 8b 7d d0          	mov    -0x30(%rbp),%rdi
    1b00:	ff 50 20             	callq  *0x20(%rax)
    1b03:	48 83 7d d0 00       	cmpq   $0x0,-0x30(%rbp)
    1b08:	49 89 44 24 08       	mov    %rax,0x8(%r12)
    1b0d:	4c 8b 55 c0          	mov    -0x40(%rbp),%r10
    1b11:	0f 84 00 02 00 00    	je     1d17 <e1000_alloc_rx_buffers+0x357>
    1b17:	48 8b 4d c8          	mov    -0x38(%rbp),%rcx
    1b1b:	48 8b 91 e8 02 00 00 	mov    0x2e8(%rcx),%rdx
    1b22:	48 85 d2             	test   %rdx,%rdx
    1b25:	0f 84 ec 01 00 00    	je     1d17 <e1000_alloc_rx_buffers+0x357>

static inline int dma_mapping_error(struct device *dev, dma_addr_t dma_addr)
{
	debug_dma_mapping_error(dev, dma_addr);

	if (get_dma_ops(dev)->mapping_error)
    1b2b:	48 83 7a 60 00       	cmpq   $0x0,0x60(%rdx)
    1b30:	0f 84 f5 01 00 00    	je     1d2b <e1000_alloc_rx_buffers+0x36b>
    1b36:	48 8b 52 60          	mov    0x60(%rdx),%rdx
    1b3a:	4c 89 55 c0          	mov    %r10,-0x40(%rbp)
		return get_dma_ops(dev)->mapping_error(dev, dma_addr);
    1b3e:	48 89 c6             	mov    %rax,%rsi
    1b41:	48 8b 7d d0          	mov    -0x30(%rbp),%rdi
    1b45:	ff d2                	callq  *%rdx
    1b47:	4c 8b 55 c0          	mov    -0x40(%rbp),%r10
						  data,
						  adapter->rx_buffer_len,
						  DMA_FROM_DEVICE);
		if (dma_mapping_error(&pdev->dev, buffer_info->dma)) {
    1b4b:	85 c0                	test   %eax,%eax
    1b4d:	0f 85 07 02 00 00    	jne    1d5a <e1000_alloc_rx_buffers+0x39a>
	unsigned long end = begin + len;

	/* First rev 82545 and 82546 need to not allow any memory
	 * write location to cross 64k boundary due to errata 23
	 */
	if (hw->mac_type == e1000_82545 ||
    1b53:	41 8b 86 d8 03 00 00 	mov    0x3d8(%r14),%eax
		 */

		/* Fix for errata 23, can't cross 64kB boundary */
		if (!e1000_check_64k_bound(adapter,
					(void *)(unsigned long)buffer_info->dma,
					adapter->rx_buffer_len)) {
    1b5a:	45 8b 86 08 02 00 00 	mov    0x208(%r14),%r8d
		 * boundary crossing
		 */

		/* Fix for errata 23, can't cross 64kB boundary */
		if (!e1000_check_64k_bound(adapter,
					(void *)(unsigned long)buffer_info->dma,
    1b61:	49 8b 54 24 08       	mov    0x8(%r12),%rdx
	unsigned long end = begin + len;

	/* First rev 82545 and 82546 need to not allow any memory
	 * write location to cross 64k boundary due to errata 23
	 */
	if (hw->mac_type == e1000_82545 ||
    1b66:	83 f8 06             	cmp    $0x6,%eax
    1b69:	0f 84 86 00 00 00    	je     1bf5 <e1000_alloc_rx_buffers+0x235>
	    hw->mac_type == e1000_ce4100 ||
    1b6f:	83 e8 08             	sub    $0x8,%eax
    1b72:	83 f8 01             	cmp    $0x1,%eax
    1b75:	76 7e                	jbe    1bf5 <e1000_alloc_rx_buffers+0x235>
			buffer_info->dma = 0;

			adapter->alloc_rx_buff_failed++;
			break;
		}
		buffer_info->rxbuf.data = data;
    1b77:	4d 89 14 24          	mov    %r10,(%r12)
    1b7b:	e9 a4 fe ff ff       	jmpq   1a24 <e1000_alloc_rx_buffers+0x64>
	 * write location to cross 64k boundary due to errata 23
	 */
	if (hw->mac_type == e1000_82545 ||
	    hw->mac_type == e1000_ce4100 ||
	    hw->mac_type == e1000_82546) {
		return ((begin ^ (end - 1)) >> 16) != 0 ? false : true;
    1b80:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
    1b84:	4c 01 d0             	add    %r10,%rax
    1b87:	4c 31 d0             	xor    %r10,%rax
    1b8a:	48 c1 e8 10          	shr    $0x10,%rax
			adapter->alloc_rx_buff_failed++;
			break;
		}

		/* Fix for errata 23, can't cross 64kB boundary */
		if (!e1000_check_64k_bound(adapter, data, bufsz)) {
    1b8e:	48 85 c0             	test   %rax,%rax
    1b91:	0f 84 37 02 00 00    	je     1dce <e1000_alloc_rx_buffers+0x40e>
			void *olddata = data;
			e_err(rx_err, "skb align check failed: %u bytes at "
    1b97:	41 f6 86 a0 07 00 00 	testb  $0x40,0x7a0(%r14)
    1b9e:	40 
    1b9f:	0f 85 4a 01 00 00    	jne    1cef <e1000_alloc_rx_buffers+0x32f>
			      "%p\n", bufsz, data);
			/* Try again, without freeing the previous */
			data = e1000_alloc_frag(adapter);
    1ba5:	4c 89 f7             	mov    %r14,%rdi
    1ba8:	4c 89 55 c0          	mov    %r10,-0x40(%rbp)
    1bac:	e8 7f e8 ff ff       	callq  430 <e1000_alloc_frag>
			/* Failed allocation, critical failure */
			if (!data) {
    1bb1:	48 85 c0             	test   %rax,%rax
    1bb4:	4c 8b 55 c0          	mov    -0x40(%rbp),%r10
    1bb8:	0f 84 87 01 00 00    	je     1d45 <e1000_alloc_rx_buffers+0x385>
	unsigned long end = begin + len;

	/* First rev 82545 and 82546 need to not allow any memory
	 * write location to cross 64k boundary due to errata 23
	 */
	if (hw->mac_type == e1000_82545 ||
    1bbe:	41 8b 96 d8 03 00 00 	mov    0x3d8(%r14),%edx
    1bc5:	83 fa 06             	cmp    $0x6,%edx
    1bc8:	0f 84 e7 00 00 00    	je     1cb5 <e1000_alloc_rx_buffers+0x2f5>
	    hw->mac_type == e1000_ce4100 ||
    1bce:	83 ea 08             	sub    $0x8,%edx
    1bd1:	83 fa 01             	cmp    $0x1,%edx
    1bd4:	0f 86 db 00 00 00    	jbe    1cb5 <e1000_alloc_rx_buffers+0x2f5>
	return __netdev_alloc_skb_ip_align(dev, length, GFP_ATOMIC);
}

static inline void skb_free_frag(void *addr)
{
	__free_page_frag(addr);
    1bda:	4c 89 d7             	mov    %r10,%rdi
    1bdd:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
    1be1:	e8 00 00 00 00       	callq  1be6 <e1000_alloc_rx_buffers+0x226>
    1be6:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
    1bea:	49 89 c2             	mov    %rax,%r10
    1bed:	48 89 c6             	mov    %rax,%rsi
    1bf0:	e9 98 fe ff ff       	jmpq   1a8d <e1000_alloc_rx_buffers+0xcd>
		/* XXX if it was allocated cleanly it will never map to a
		 * boundary crossing
		 */

		/* Fix for errata 23, can't cross 64kB boundary */
		if (!e1000_check_64k_bound(adapter,
    1bf5:	44 89 c7             	mov    %r8d,%edi
	 * write location to cross 64k boundary due to errata 23
	 */
	if (hw->mac_type == e1000_82545 ||
	    hw->mac_type == e1000_ce4100 ||
	    hw->mac_type == e1000_82546) {
		return ((begin ^ (end - 1)) >> 16) != 0 ? false : true;
    1bf8:	48 8d 44 17 ff       	lea    -0x1(%rdi,%rdx,1),%rax
    1bfd:	48 31 d0             	xor    %rdx,%rax
    1c00:	48 c1 e8 10          	shr    $0x10,%rax
		/* XXX if it was allocated cleanly it will never map to a
		 * boundary crossing
		 */

		/* Fix for errata 23, can't cross 64kB boundary */
		if (!e1000_check_64k_bound(adapter,
    1c04:	48 85 c0             	test   %rax,%rax
    1c07:	0f 84 6a ff ff ff    	je     1b77 <e1000_alloc_rx_buffers+0x1b7>
					(void *)(unsigned long)buffer_info->dma,
					adapter->rx_buffer_len)) {
			e_err(rx_err, "dma align check failed: %u bytes at "
    1c0d:	41 f6 86 a0 07 00 00 	testb  $0x40,0x7a0(%r14)
    1c14:	40 
		 * boundary crossing
		 */

		/* Fix for errata 23, can't cross 64kB boundary */
		if (!e1000_check_64k_bound(adapter,
					(void *)(unsigned long)buffer_info->dma,
    1c15:	48 89 d6             	mov    %rdx,%rsi
					adapter->rx_buffer_len)) {
			e_err(rx_err, "dma align check failed: %u bytes at "
    1c18:	0f 85 5a 01 00 00    	jne    1d78 <e1000_alloc_rx_buffers+0x3b8>
    1c1e:	48 83 7d d0 00       	cmpq   $0x0,-0x30(%rbp)
    1c23:	0f 84 83 01 00 00    	je     1dac <e1000_alloc_rx_buffers+0x3ec>
    1c29:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
    1c2d:	48 8b 80 e8 02 00 00 	mov    0x2e8(%rax),%rax
    1c34:	48 85 c0             	test   %rax,%rax
    1c37:	0f 84 6f 01 00 00    	je     1dac <e1000_alloc_rx_buffers+0x3ec>
					  struct dma_attrs *attrs)
{
	struct dma_map_ops *ops = get_dma_ops(dev);

	BUG_ON(!valid_dma_direction(dir));
	if (ops->unmap_page)
    1c3d:	48 8b 40 28          	mov    0x28(%rax),%rax
    1c41:	48 85 c0             	test   %rax,%rax
    1c44:	74 19                	je     1c5f <e1000_alloc_rx_buffers+0x29f>
    1c46:	4c 89 55 c8          	mov    %r10,-0x38(%rbp)
		ops->unmap_page(dev, addr, size, dir, attrs);
    1c4a:	48 89 fa             	mov    %rdi,%rdx
    1c4d:	45 31 c0             	xor    %r8d,%r8d
    1c50:	b9 02 00 00 00       	mov    $0x2,%ecx
    1c55:	48 8b 7d d0          	mov    -0x30(%rbp),%rdi
    1c59:	ff d0                	callq  *%rax
    1c5b:	4c 8b 55 c8          	mov    -0x38(%rbp),%r10
    1c5f:	4c 89 d7             	mov    %r10,%rdi
    1c62:	e8 00 00 00 00       	callq  1c67 <e1000_alloc_rx_buffers+0x2a7>
			dma_unmap_single(&pdev->dev, buffer_info->dma,
					 adapter->rx_buffer_len,
					 DMA_FROM_DEVICE);

			skb_free_frag(data);
			buffer_info->rxbuf.data = NULL;
    1c67:	49 c7 04 24 00 00 00 	movq   $0x0,(%r12)
    1c6e:	00 
			buffer_info->dma = 0;
    1c6f:	49 c7 44 24 08 00 00 	movq   $0x0,0x8(%r12)
    1c76:	00 00 

			adapter->alloc_rx_buff_failed++;
    1c78:	41 83 86 90 03 00 00 	addl   $0x1,0x390(%r14)
    1c7f:	01 
		if (unlikely(++i == rx_ring->count))
			i = 0;
		buffer_info = &rx_ring->buffer_info[i];
	}

	if (likely(rx_ring->next_to_use != i)) {
    1c80:	41 3b 5d 18          	cmp    0x18(%r13),%ebx
    1c84:	74 20                	je     1ca6 <e1000_alloc_rx_buffers+0x2e6>
		rx_ring->next_to_use = i;
		if (unlikely(i-- == 0))
    1c86:	85 db                	test   %ebx,%ebx
			i = 0;
		buffer_info = &rx_ring->buffer_info[i];
	}

	if (likely(rx_ring->next_to_use != i)) {
		rx_ring->next_to_use = i;
    1c88:	41 89 5d 18          	mov    %ebx,0x18(%r13)
		if (unlikely(i-- == 0))
    1c8c:	8d 53 ff             	lea    -0x1(%rbx),%edx
    1c8f:	0f 84 2d 01 00 00    	je     1dc2 <e1000_alloc_rx_buffers+0x402>
		/* Force memory writes to complete before letting h/w
		 * know there are new descriptors to fetch.  (Only
		 * applicable for weak-ordered memory model archs,
		 * such as IA-64).
		 */
		wmb();
    1c95:	0f ae f8             	sfence 
		writel(i, hw->hw_addr + rx_ring->rdt);
    1c98:	41 0f b7 45 36       	movzwl 0x36(%r13),%eax
    1c9d:	49 03 86 c0 03 00 00 	add    0x3c0(%r14),%rax
    1ca4:	89 10                	mov    %edx,(%rax)
	}
}
    1ca6:	48 83 c4 28          	add    $0x28,%rsp
    1caa:	5b                   	pop    %rbx
    1cab:	41 5c                	pop    %r12
    1cad:	41 5d                	pop    %r13
    1caf:	41 5e                	pop    %r14
    1cb1:	41 5f                	pop    %r15
    1cb3:	5d                   	pop    %rbp
    1cb4:	c3                   	retq   
	 * write location to cross 64k boundary due to errata 23
	 */
	if (hw->mac_type == e1000_82545 ||
	    hw->mac_type == e1000_ce4100 ||
	    hw->mac_type == e1000_82546) {
		return ((begin ^ (end - 1)) >> 16) != 0 ? false : true;
    1cb5:	48 8b 4d b8          	mov    -0x48(%rbp),%rcx
    1cb9:	48 8d 14 08          	lea    (%rax,%rcx,1),%rdx
    1cbd:	48 31 c2             	xor    %rax,%rdx
    1cc0:	48 c1 ea 10          	shr    $0x10,%rdx
				skb_free_frag(olddata);
				adapter->alloc_rx_buff_failed++;
				break;
			}

			if (!e1000_check_64k_bound(adapter, data, bufsz)) {
    1cc4:	48 85 d2             	test   %rdx,%rdx
    1cc7:	0f 84 0d ff ff ff    	je     1bda <e1000_alloc_rx_buffers+0x21a>
    1ccd:	48 89 c7             	mov    %rax,%rdi
    1cd0:	4c 89 55 d0          	mov    %r10,-0x30(%rbp)
    1cd4:	e8 00 00 00 00       	callq  1cd9 <e1000_alloc_rx_buffers+0x319>
    1cd9:	4c 8b 55 d0          	mov    -0x30(%rbp),%r10
    1cdd:	4c 89 d7             	mov    %r10,%rdi
    1ce0:	e8 00 00 00 00       	callq  1ce5 <e1000_alloc_rx_buffers+0x325>
				/* give up */
				skb_free_frag(data);
				skb_free_frag(olddata);
				adapter->alloc_rx_buff_failed++;
    1ce5:	41 83 86 90 03 00 00 	addl   $0x1,0x390(%r14)
    1cec:	01 
				break;
    1ced:	eb 91                	jmp    1c80 <e1000_alloc_rx_buffers+0x2c0>
		}

		/* Fix for errata 23, can't cross 64kB boundary */
		if (!e1000_check_64k_bound(adapter, data, bufsz)) {
			void *olddata = data;
			e_err(rx_err, "skb align check failed: %u bytes at "
    1cef:	49 8b be b0 03 00 00 	mov    0x3b0(%r14),%rdi
    1cf6:	8b 55 b4             	mov    -0x4c(%rbp),%edx
    1cf9:	4c 89 d1             	mov    %r10,%rcx
    1cfc:	48 c7 c6 00 00 00 00 	mov    $0x0,%rsi
    1d03:	31 c0                	xor    %eax,%eax
    1d05:	4c 89 55 c0          	mov    %r10,-0x40(%rbp)
    1d09:	e8 00 00 00 00       	callq  1d0e <e1000_alloc_rx_buffers+0x34e>
    1d0e:	4c 8b 55 c0          	mov    -0x40(%rbp),%r10
    1d12:	e9 8e fe ff ff       	jmpq   1ba5 <e1000_alloc_rx_buffers+0x1e5>

static inline int dma_mapping_error(struct device *dev, dma_addr_t dma_addr)
{
	debug_dma_mapping_error(dev, dma_addr);

	if (get_dma_ops(dev)->mapping_error)
    1d17:	48 8b 15 00 00 00 00 	mov    0x0(%rip),%rdx        # 1d1e <e1000_alloc_rx_buffers+0x35e>
    1d1e:	48 8b 52 60          	mov    0x60(%rdx),%rdx
    1d22:	48 85 d2             	test   %rdx,%rdx
    1d25:	0f 85 0f fe ff ff    	jne    1b3a <e1000_alloc_rx_buffers+0x17a>
		return get_dma_ops(dev)->mapping_error(dev, dma_addr);

#ifdef DMA_ERROR_CODE
	return dma_addr == DMA_ERROR_CODE;
    1d2b:	48 85 c0             	test   %rax,%rax
    1d2e:	0f 94 c0             	sete   %al
    1d31:	0f b6 c0             	movzbl %al,%eax
    1d34:	e9 12 fe ff ff       	jmpq   1b4b <e1000_alloc_rx_buffers+0x18b>
		return dma_ops;
    1d39:	48 8b 05 00 00 00 00 	mov    0x0(%rip),%rax        # 1d40 <e1000_alloc_rx_buffers+0x380>
    1d40:	e9 6e fd ff ff       	jmpq   1ab3 <e1000_alloc_rx_buffers+0xf3>
    1d45:	4c 89 d7             	mov    %r10,%rdi
    1d48:	e8 00 00 00 00       	callq  1d4d <e1000_alloc_rx_buffers+0x38d>
			/* Try again, without freeing the previous */
			data = e1000_alloc_frag(adapter);
			/* Failed allocation, critical failure */
			if (!data) {
				skb_free_frag(olddata);
				adapter->alloc_rx_buff_failed++;
    1d4d:	41 83 86 90 03 00 00 	addl   $0x1,0x390(%r14)
    1d54:	01 
				break;
    1d55:	e9 26 ff ff ff       	jmpq   1c80 <e1000_alloc_rx_buffers+0x2c0>
    1d5a:	4c 89 d7             	mov    %r10,%rdi
    1d5d:	e8 00 00 00 00       	callq  1d62 <e1000_alloc_rx_buffers+0x3a2>
						  data,
						  adapter->rx_buffer_len,
						  DMA_FROM_DEVICE);
		if (dma_mapping_error(&pdev->dev, buffer_info->dma)) {
			skb_free_frag(data);
			buffer_info->dma = 0;
    1d62:	49 c7 44 24 08 00 00 	movq   $0x0,0x8(%r12)
    1d69:	00 00 
			adapter->alloc_rx_buff_failed++;
    1d6b:	41 83 86 90 03 00 00 	addl   $0x1,0x390(%r14)
    1d72:	01 
			break;
    1d73:	e9 08 ff ff ff       	jmpq   1c80 <e1000_alloc_rx_buffers+0x2c0>

		/* Fix for errata 23, can't cross 64kB boundary */
		if (!e1000_check_64k_bound(adapter,
					(void *)(unsigned long)buffer_info->dma,
					adapter->rx_buffer_len)) {
			e_err(rx_err, "dma align check failed: %u bytes at "
    1d78:	49 8b be b0 03 00 00 	mov    0x3b0(%r14),%rdi
    1d7f:	48 89 d1             	mov    %rdx,%rcx
    1d82:	48 c7 c6 00 00 00 00 	mov    $0x0,%rsi
    1d89:	44 89 c2             	mov    %r8d,%edx
    1d8c:	31 c0                	xor    %eax,%eax
    1d8e:	4c 89 55 c0          	mov    %r10,-0x40(%rbp)
    1d92:	e8 00 00 00 00       	callq  1d97 <e1000_alloc_rx_buffers+0x3d7>
    1d97:	41 8b be 08 02 00 00 	mov    0x208(%r14),%edi
    1d9e:	49 8b 74 24 08       	mov    0x8(%r12),%rsi
    1da3:	4c 8b 55 c0          	mov    -0x40(%rbp),%r10
    1da7:	e9 72 fe ff ff       	jmpq   1c1e <e1000_alloc_rx_buffers+0x25e>
    1dac:	48 8b 05 00 00 00 00 	mov    0x0(%rip),%rax        # 1db3 <e1000_alloc_rx_buffers+0x3f3>
    1db3:	e9 85 fe ff ff       	jmpq   1c3d <e1000_alloc_rx_buffers+0x27d>
    1db8:	45 31 e4             	xor    %r12d,%r12d
 skip:
		rx_desc = E1000_RX_DESC(*rx_ring, i);
		rx_desc->buffer_addr = cpu_to_le64(buffer_info->dma);

		if (unlikely(++i == rx_ring->count))
			i = 0;
    1dbb:	31 db                	xor    %ebx,%ebx
    1dbd:	e9 83 fc ff ff       	jmpq   1a45 <e1000_alloc_rx_buffers+0x85>
	}

	if (likely(rx_ring->next_to_use != i)) {
		rx_ring->next_to_use = i;
		if (unlikely(i-- == 0))
			i = (rx_ring->count - 1);
    1dc2:	41 8b 45 14          	mov    0x14(%r13),%eax
    1dc6:	8d 50 ff             	lea    -0x1(%rax),%edx
    1dc9:	e9 c7 fe ff ff       	jmpq   1c95 <e1000_alloc_rx_buffers+0x2d5>
    1dce:	4c 89 d6             	mov    %r10,%rsi
    1dd1:	e9 b7 fc ff ff       	jmpq   1a8d <e1000_alloc_rx_buffers+0xcd>
    1dd6:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    1ddd:	00 00 00 

0000000000001de0 <e1000_unmap_and_free_tx_resource.isra.51>:
	for (i = 0; i < adapter->num_tx_queues; i++)
		e1000_free_tx_resources(adapter, &adapter->tx_ring[i]);
}

static void
e1000_unmap_and_free_tx_resource(struct e1000_adapter *adapter,
    1de0:	e8 00 00 00 00       	callq  1de5 <e1000_unmap_and_free_tx_resource.isra.51+0x5>
    1de5:	55                   	push   %rbp
    1de6:	48 89 e5             	mov    %rsp,%rbp
    1de9:	53                   	push   %rbx
    1dea:	48 89 f3             	mov    %rsi,%rbx
				 struct e1000_tx_buffer *buffer_info)
{
	if (buffer_info->dma) {
    1ded:	48 8b 76 08          	mov    0x8(%rsi),%rsi
    1df1:	48 85 f6             	test   %rsi,%rsi
    1df4:	74 3a                	je     1e30 <e1000_unmap_and_free_tx_resource.isra.51+0x50>
		if (buffer_info->mapped_as_page)
			dma_unmap_page(&adapter->pdev->dev, buffer_info->dma,
    1df6:	48 8b 07             	mov    (%rdi),%rax
    1df9:	0f b7 53 18          	movzwl 0x18(%rbx),%edx
static inline struct dma_map_ops *get_dma_ops(struct device *dev)
{
#ifndef CONFIG_X86_DEV_DMA_OPS
	return dma_ops;
#else
	if (unlikely(!dev) || !dev->archdata.dma_ops)
    1dfd:	48 89 c7             	mov    %rax,%rdi
    1e00:	48 81 c7 98 00 00 00 	add    $0x98,%rdi
    1e07:	74 4b                	je     1e54 <e1000_unmap_and_free_tx_resource.isra.51+0x74>
    1e09:	48 8b 80 e8 02 00 00 	mov    0x2e8(%rax),%rax
    1e10:	48 85 c0             	test   %rax,%rax
    1e13:	74 3f                	je     1e54 <e1000_unmap_and_free_tx_resource.isra.51+0x74>
					  struct dma_attrs *attrs)
{
	struct dma_map_ops *ops = get_dma_ops(dev);

	BUG_ON(!valid_dma_direction(dir));
	if (ops->unmap_page)
    1e15:	48 8b 40 28          	mov    0x28(%rax),%rax
    1e19:	48 85 c0             	test   %rax,%rax
    1e1c:	74 0a                	je     1e28 <e1000_unmap_and_free_tx_resource.isra.51+0x48>
		ops->unmap_page(dev, addr, size, dir, attrs);
    1e1e:	45 31 c0             	xor    %r8d,%r8d
    1e21:	b9 01 00 00 00       	mov    $0x1,%ecx
    1e26:	ff d0                	callq  *%rax
				       buffer_info->length, DMA_TO_DEVICE);
		else
			dma_unmap_single(&adapter->pdev->dev, buffer_info->dma,
					 buffer_info->length,
					 DMA_TO_DEVICE);
		buffer_info->dma = 0;
    1e28:	48 c7 43 08 00 00 00 	movq   $0x0,0x8(%rbx)
    1e2f:	00 
	}
	if (buffer_info->skb) {
    1e30:	48 8b 3b             	mov    (%rbx),%rdi
    1e33:	48 85 ff             	test   %rdi,%rdi
    1e36:	74 11                	je     1e49 <e1000_unmap_and_free_tx_resource.isra.51+0x69>
	__dev_kfree_skb_irq(skb, SKB_REASON_CONSUMED);
}

static inline void dev_kfree_skb_any(struct sk_buff *skb)
{
	__dev_kfree_skb_any(skb, SKB_REASON_DROPPED);
    1e38:	be 01 00 00 00       	mov    $0x1,%esi
    1e3d:	e8 00 00 00 00       	callq  1e42 <e1000_unmap_and_free_tx_resource.isra.51+0x62>
		dev_kfree_skb_any(buffer_info->skb);
		buffer_info->skb = NULL;
    1e42:	48 c7 03 00 00 00 00 	movq   $0x0,(%rbx)
	}
	buffer_info->time_stamp = 0;
    1e49:	48 c7 43 10 00 00 00 	movq   $0x0,0x10(%rbx)
    1e50:	00 
	/* buffer_info must be completely set up in the transmit path */
}
    1e51:	5b                   	pop    %rbx
    1e52:	5d                   	pop    %rbp
    1e53:	c3                   	retq   
		return dma_ops;
    1e54:	48 8b 05 00 00 00 00 	mov    0x0(%rip),%rax        # 1e5b <e1000_unmap_and_free_tx_resource.isra.51+0x7b>
    1e5b:	eb b8                	jmp    1e15 <e1000_unmap_and_free_tx_resource.isra.51+0x35>
    1e5d:	0f 1f 00             	nopl   (%rax)

0000000000001e60 <e1000_clean>:
/**
 * e1000_clean - NAPI Rx polling callback
 * @adapter: board private structure
 **/
static int e1000_clean(struct napi_struct *napi, int budget)
{
    1e60:	e8 00 00 00 00       	callq  1e65 <e1000_clean+0x5>
    1e65:	55                   	push   %rbp
    1e66:	48 89 f8             	mov    %rdi,%rax
	static int i= 1;
	static int count = 0;	
	struct e1000_adapter *adapter = container_of(napi, struct e1000_adapter,
    1e69:	48 2d b0 02 00 00    	sub    $0x2b0,%rax
/**
 * e1000_clean - NAPI Rx polling callback
 * @adapter: board private structure
 **/
static int e1000_clean(struct napi_struct *napi, int budget)
{
    1e6f:	48 89 e5             	mov    %rsp,%rbp
    1e72:	41 57                	push   %r15
    1e74:	41 56                	push   %r14
    1e76:	41 55                	push   %r13
    1e78:	41 54                	push   %r12
    1e7a:	53                   	push   %rbx
    1e7b:	48 83 ec 68          	sub    $0x68,%rsp
	static int i= 1;
	static int count = 0;	
	struct e1000_adapter *adapter = container_of(napi, struct e1000_adapter,

						     napi);
	if(i == 1)
    1e7f:	83 3d 00 00 00 00 01 	cmpl   $0x1,0x0(%rip)        # 1e86 <e1000_clean+0x26>
/**
 * e1000_clean - NAPI Rx polling callback
 * @adapter: board private structure
 **/
static int e1000_clean(struct napi_struct *napi, int budget)
{
    1e86:	48 89 7d a8          	mov    %rdi,-0x58(%rbp)
    1e8a:	89 75 b0             	mov    %esi,-0x50(%rbp)
	static int i= 1;
	static int count = 0;	
	struct e1000_adapter *adapter = container_of(napi, struct e1000_adapter,
    1e8d:	48 89 45 98          	mov    %rax,-0x68(%rbp)

						     napi);
	if(i == 1)
    1e91:	0f 84 64 04 00 00    	je     22fb <e1000_clean+0x49b>
		WARN_ON(1);
	i = 2;
	printk("%s,%d\n",__func__,__LINE__);
    1e97:	ba 23 0f 00 00       	mov    $0xf23,%edx
    1e9c:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
    1ea3:	31 c0                	xor    %eax,%eax
    1ea5:	48 c7 c6 00 00 00 00 	mov    $0x0,%rsi
	struct e1000_adapter *adapter = container_of(napi, struct e1000_adapter,

						     napi);
	if(i == 1)
		WARN_ON(1);
	i = 2;
    1eac:	c7 05 00 00 00 00 02 	movl   $0x2,0x0(%rip)        # 1eb6 <e1000_clean+0x56>
    1eb3:	00 00 00 
	printk("%s,%d\n",__func__,__LINE__);
    1eb6:	e8 00 00 00 00       	callq  1ebb <e1000_clean+0x5b>
	
	int tx_clean_complete = 0, work_done = 0;

	tx_clean_complete = e1000_clean_tx_irq(adapter, &adapter->tx_ring[0]);
    1ebb:	48 8b 55 a8          	mov    -0x58(%rbp),%rdx
	if(i == 1)
		WARN_ON(1);
	i = 2;
	printk("%s,%d\n",__func__,__LINE__);
	
	int tx_clean_complete = 0, work_done = 0;
    1ebf:	c7 45 d4 00 00 00 00 	movl   $0x0,-0x2c(%rbp)

	tx_clean_complete = e1000_clean_tx_irq(adapter, &adapter->tx_ring[0]);
    1ec6:	4c 8b 72 90          	mov    -0x70(%rdx),%r14
 **/
static bool e1000_clean_tx_irq(struct e1000_adapter *adapter,
			       struct e1000_tx_ring *tx_ring)
{
	struct e1000_hw *hw = &adapter->hw;
	struct net_device *netdev = adapter->netdev;
    1eca:	48 8b 82 00 01 00 00 	mov    0x100(%rdx),%rax
	unsigned int i, eop;
	unsigned int count = 0;
	unsigned int total_tx_bytes=0, total_tx_packets=0;
	unsigned int bytes_compl = 0, pkts_compl = 0;

	i = tx_ring->next_to_clean;
    1ed1:	45 8b 7e 1c          	mov    0x1c(%r14),%r15d
 **/
static bool e1000_clean_tx_irq(struct e1000_adapter *adapter,
			       struct e1000_tx_ring *tx_ring)
{
	struct e1000_hw *hw = &adapter->hw;
	struct net_device *netdev = adapter->netdev;
    1ed5:	48 89 45 a0          	mov    %rax,-0x60(%rbp)
	unsigned int count = 0;
	unsigned int total_tx_bytes=0, total_tx_packets=0;
	unsigned int bytes_compl = 0, pkts_compl = 0;

	i = tx_ring->next_to_clean;
	eop = tx_ring->buffer_info[i].next_to_watch;
    1ed9:	4d 8b 56 20          	mov    0x20(%r14),%r10
    1edd:	44 89 f8             	mov    %r15d,%eax
    1ee0:	48 8d 0c 80          	lea    (%rax,%rax,4),%rcx
    1ee4:	49 8d 0c ca          	lea    (%r10,%rcx,8),%rcx
    1ee8:	44 0f b7 61 1a       	movzwl 0x1a(%rcx),%r12d
    1eed:	41 0f b7 fc          	movzwl %r12w,%edi
	eop_desc = E1000_TX_DESC(*tx_ring, eop);
    1ef1:	49 c1 e4 04          	shl    $0x4,%r12
    1ef5:	4d 03 26             	add    (%r14),%r12
	unsigned int count = 0;
	unsigned int total_tx_bytes=0, total_tx_packets=0;
	unsigned int bytes_compl = 0, pkts_compl = 0;

	i = tx_ring->next_to_clean;
	eop = tx_ring->buffer_info[i].next_to_watch;
    1ef8:	89 7d c8             	mov    %edi,-0x38(%rbp)
	eop_desc = E1000_TX_DESC(*tx_ring, eop);

	while ((eop_desc->upper.data & cpu_to_le32(E1000_TXD_STAT_DD)) &&
    1efb:	41 f6 44 24 0c 01    	testb  $0x1,0xc(%r12)
    1f01:	0f 84 0a 04 00 00    	je     2311 <e1000_clean+0x4b1>
    1f07:	45 8b 4e 14          	mov    0x14(%r14),%r9d
    1f0b:	45 85 c9             	test   %r9d,%r9d
    1f0e:	0f 84 fd 03 00 00    	je     2311 <e1000_clean+0x4b1>
    1f14:	48 81 c2 08 01 00 00 	add    $0x108,%rdx
	struct e1000_hw *hw = &adapter->hw;
	struct net_device *netdev = adapter->netdev;
	struct e1000_tx_desc *tx_desc, *eop_desc;
	struct e1000_tx_buffer *buffer_info;
	unsigned int i, eop;
	unsigned int count = 0;
    1f1b:	45 89 fd             	mov    %r15d,%r13d
	unsigned int total_tx_bytes=0, total_tx_packets=0;
    1f1e:	c7 45 b8 00 00 00 00 	movl   $0x0,-0x48(%rbp)
    1f25:	48 89 55 c0          	mov    %rdx,-0x40(%rbp)
    1f29:	c7 45 bc 00 00 00 00 	movl   $0x0,-0x44(%rbp)
	struct e1000_hw *hw = &adapter->hw;
	struct net_device *netdev = adapter->netdev;
	struct e1000_tx_desc *tx_desc, *eop_desc;
	struct e1000_tx_buffer *buffer_info;
	unsigned int i, eop;
	unsigned int count = 0;
    1f30:	31 db                	xor    %ebx,%ebx
	unsigned int total_tx_bytes=0, total_tx_packets=0;
	unsigned int bytes_compl = 0, pkts_compl = 0;
    1f32:	c7 45 b4 00 00 00 00 	movl   $0x0,-0x4c(%rbp)
	struct e1000_hw *hw = &adapter->hw;
	struct net_device *netdev = adapter->netdev;
	struct e1000_tx_desc *tx_desc, *eop_desc;
	struct e1000_tx_buffer *buffer_info;
	unsigned int i, eop;
	unsigned int count = 0;
    1f39:	4d 89 f7             	mov    %r14,%r15
	eop_desc = E1000_TX_DESC(*tx_ring, eop);

	while ((eop_desc->upper.data & cpu_to_le32(E1000_TXD_STAT_DD)) &&
	       (count < tx_ring->count)) {
		bool cleaned = false;
		dma_rmb();	/* read buffer_info after eop_desc */
    1f3c:	44 89 ea             	mov    %r13d,%edx
    1f3f:	4d 89 fd             	mov    %r15,%r13
    1f42:	41 89 d7             	mov    %edx,%r15d
    1f45:	eb 03                	jmp    1f4a <e1000_clean+0xea>
    1f47:	44 89 f8             	mov    %r15d,%eax
		for ( ; !cleaned; count++) {
			tx_desc = E1000_TX_DESC(*tx_ring, i);
    1f4a:	49 89 c6             	mov    %rax,%r14
			buffer_info = &tx_ring->buffer_info[i];
    1f4d:	48 8d 34 80          	lea    (%rax,%rax,4),%rsi
    1f51:	49 8b 45 20          	mov    0x20(%r13),%rax
	while ((eop_desc->upper.data & cpu_to_le32(E1000_TXD_STAT_DD)) &&
	       (count < tx_ring->count)) {
		bool cleaned = false;
		dma_rmb();	/* read buffer_info after eop_desc */
		for ( ; !cleaned; count++) {
			tx_desc = E1000_TX_DESC(*tx_ring, i);
    1f55:	49 c1 e6 04          	shl    $0x4,%r14
    1f59:	4d 03 75 00          	add    0x0(%r13),%r14
			buffer_info = &tx_ring->buffer_info[i];
			cleaned = (i == eop);
    1f5d:	44 3b 7d c8          	cmp    -0x38(%rbp),%r15d
	       (count < tx_ring->count)) {
		bool cleaned = false;
		dma_rmb();	/* read buffer_info after eop_desc */
		for ( ; !cleaned; count++) {
			tx_desc = E1000_TX_DESC(*tx_ring, i);
			buffer_info = &tx_ring->buffer_info[i];
    1f61:	48 8d 34 f0          	lea    (%rax,%rsi,8),%rsi
			cleaned = (i == eop);

			if (cleaned) {
    1f65:	41 0f 94 c4          	sete   %r12b
    1f69:	75 1e                	jne    1f89 <e1000_clean+0x129>
				total_tx_packets += buffer_info->segs;
    1f6b:	0f b7 46 1e          	movzwl 0x1e(%rsi),%eax
    1f6f:	01 45 b8             	add    %eax,-0x48(%rbp)
				total_tx_bytes += buffer_info->bytecount;
    1f72:	8b 46 20             	mov    0x20(%rsi),%eax
    1f75:	01 45 bc             	add    %eax,-0x44(%rbp)
				if (buffer_info->skb) {
    1f78:	48 8b 06             	mov    (%rsi),%rax
    1f7b:	48 85 c0             	test   %rax,%rax
    1f7e:	74 09                	je     1f89 <e1000_clean+0x129>
					bytes_compl += buffer_info->skb->len;
    1f80:	8b 80 80 00 00 00    	mov    0x80(%rax),%eax
    1f86:	01 45 b4             	add    %eax,-0x4c(%rbp)
					pkts_compl++;
				}

			}
			e1000_unmap_and_free_tx_resource(adapter, buffer_info);
    1f89:	48 8b 7d c0          	mov    -0x40(%rbp),%rdi
			tx_desc->upper.data = 0;

			if (unlikely(++i == tx_ring->count)) i = 0;
    1f8d:	41 83 c7 01          	add    $0x1,%r15d
					bytes_compl += buffer_info->skb->len;
					pkts_compl++;
				}

			}
			e1000_unmap_and_free_tx_resource(adapter, buffer_info);
    1f91:	e8 4a fe ff ff       	callq  1de0 <e1000_unmap_and_free_tx_resource.isra.51>
			tx_desc->upper.data = 0;
    1f96:	41 c7 46 0c 00 00 00 	movl   $0x0,0xc(%r14)
    1f9d:	00 

			if (unlikely(++i == tx_ring->count)) i = 0;
    1f9e:	41 8b 4d 14          	mov    0x14(%r13),%ecx
    1fa2:	41 39 cf             	cmp    %ecx,%r15d
    1fa5:	0f 84 90 03 00 00    	je     233b <e1000_clean+0x4db>
    1fab:	44 89 f8             	mov    %r15d,%eax
    1fae:	48 8d 04 80          	lea    (%rax,%rax,4),%rax
    1fb2:	48 c1 e0 03          	shl    $0x3,%rax

	while ((eop_desc->upper.data & cpu_to_le32(E1000_TXD_STAT_DD)) &&
	       (count < tx_ring->count)) {
		bool cleaned = false;
		dma_rmb();	/* read buffer_info after eop_desc */
		for ( ; !cleaned; count++) {
    1fb6:	83 c3 01             	add    $0x1,%ebx
    1fb9:	45 84 e4             	test   %r12b,%r12b
    1fbc:	74 89                	je     1f47 <e1000_clean+0xe7>
    1fbe:	44 89 fa             	mov    %r15d,%edx
    1fc1:	4d 89 ef             	mov    %r13,%r15
			tx_desc->upper.data = 0;

			if (unlikely(++i == tx_ring->count)) i = 0;
		}

		eop = tx_ring->buffer_info[i].next_to_watch;
    1fc4:	49 8b 77 20          	mov    0x20(%r15),%rsi
    1fc8:	41 89 d5             	mov    %edx,%r13d
    1fcb:	44 0f b7 64 06 1a    	movzwl 0x1a(%rsi,%rax,1),%r12d
    1fd1:	41 0f b7 c4          	movzwl %r12w,%eax
		eop_desc = E1000_TX_DESC(*tx_ring, eop);
    1fd5:	49 c1 e4 04          	shl    $0x4,%r12
    1fd9:	4d 03 27             	add    (%r15),%r12
			tx_desc->upper.data = 0;

			if (unlikely(++i == tx_ring->count)) i = 0;
		}

		eop = tx_ring->buffer_info[i].next_to_watch;
    1fdc:	89 45 c8             	mov    %eax,-0x38(%rbp)

	i = tx_ring->next_to_clean;
	eop = tx_ring->buffer_info[i].next_to_watch;
	eop_desc = E1000_TX_DESC(*tx_ring, eop);

	while ((eop_desc->upper.data & cpu_to_le32(E1000_TXD_STAT_DD)) &&
    1fdf:	41 f6 44 24 0c 01    	testb  $0x1,0xc(%r12)
    1fe5:	74 0b                	je     1ff2 <e1000_clean+0x192>
    1fe7:	39 cb                	cmp    %ecx,%ebx
    1fe9:	73 07                	jae    1ff2 <e1000_clean+0x192>
    1feb:	89 d0                	mov    %edx,%eax
    1fed:	e9 4a ff ff ff       	jmpq   1f3c <e1000_clean+0xdc>

static inline void netdev_tx_completed_queue(struct netdev_queue *dev_queue,
					     unsigned int pkts, unsigned int bytes)
{
#ifdef CONFIG_BQL
	if (unlikely(!bytes))
    1ff2:	44 8b 45 b4          	mov    -0x4c(%rbp),%r8d
 *
 * 	Report the number of bytes and packets transmitted by the network device
 * 	hardware queue over the physical medium, @bytes must exactly match the
 * 	@bytes amount passed to netdev_sent_queue()
 */
static inline void netdev_completed_queue(struct net_device *dev,
    1ff6:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
    1ffa:	4d 89 fe             	mov    %r15,%r14

		eop = tx_ring->buffer_info[i].next_to_watch;
		eop_desc = E1000_TX_DESC(*tx_ring, eop);
	}

	tx_ring->next_to_clean = i;
    1ffd:	45 89 6e 1c          	mov    %r13d,0x1c(%r14)

static inline void netdev_tx_completed_queue(struct netdev_queue *dev_queue,
					     unsigned int pkts, unsigned int bytes)
{
#ifdef CONFIG_BQL
	if (unlikely(!bytes))
    2001:	45 85 c0             	test   %r8d,%r8d
 *
 * 	Report the number of bytes and packets transmitted by the network device
 * 	hardware queue over the physical medium, @bytes must exactly match the
 * 	@bytes amount passed to netdev_sent_queue()
 */
static inline void netdev_completed_queue(struct net_device *dev,
    2004:	4c 8b a8 c0 03 00 00 	mov    0x3c0(%rax),%r13

static inline void netdev_tx_completed_queue(struct netdev_queue *dev_queue,
					     unsigned int pkts, unsigned int bytes)
{
#ifdef CONFIG_BQL
	if (unlikely(!bytes))
    200b:	74 34                	je     2041 <e1000_clean+0x1e1>
		return;

	dql_completed(&dev_queue->dql, bytes);
    200d:	8b 75 b4             	mov    -0x4c(%rbp),%esi
    2010:	49 8d bd c0 00 00 00 	lea    0xc0(%r13),%rdi
    2017:	e8 00 00 00 00       	callq  201c <e1000_clean+0x1bc>
	/*
	 * Without the memory barrier there is a small possiblity that
	 * netdev_tx_sent_queue will miss the update and cause the queue to
	 * be stopped forever
	 */
	smp_mb();
    201c:	0f ae f0             	mfence 
}

/* Returns how many objects can be queued, < 0 indicates over limit. */
static inline int dql_avail(const struct dql *dql)
{
	return ACCESS_ONCE(dql->adj_limit) - ACCESS_ONCE(dql->num_queued);
    201f:	41 8b 95 c4 00 00 00 	mov    0xc4(%r13),%edx
    2026:	41 8b 85 c0 00 00 00 	mov    0xc0(%r13),%eax

	if (dql_avail(&dev_queue->dql) < 0)
    202d:	39 c2                	cmp    %eax,%edx
    202f:	78 10                	js     2041 <e1000_clean+0x1e1>
 * This operation is atomic and cannot be reordered.
 * It also implies a memory barrier.
 */
static inline int test_and_clear_bit(long nr, volatile unsigned long *addr)
{
	GEN_BINARY_RMWcc(LOCK_PREFIX "btr", *addr, "Ir", nr, "%0", "c");
    2031:	f0 41 0f ba b5 98 00 	lock btrl $0x1,0x98(%r13)
    2038:	00 00 01 
    203b:	0f 82 e8 01 00 00    	jb     2229 <e1000_clean+0x3c9>
    2041:	8b 45 bc             	mov    -0x44(%rbp),%eax
    2044:	44 8b 7d b8          	mov    -0x48(%rbp),%r15d
    2048:	48 89 45 c0          	mov    %rax,-0x40(%rbp)

	netdev_completed_queue(netdev, pkts_compl, bytes_compl);

#define TX_WAKE_THRESHOLD 32
	if (unlikely(count && netif_carrier_ok(netdev) &&
    204c:	85 db                	test   %ebx,%ebx
    204e:	0f 85 84 03 00 00    	jne    23d8 <e1000_clean+0x578>
			netif_wake_queue(netdev);
			++adapter->restart_queue;
		}
	}

	if (adapter->detect_tx_hung) {
    2054:	48 8b 7d a8          	mov    -0x58(%rbp),%rdi
    2058:	80 7f e1 00          	cmpb   $0x0,-0x1f(%rdi)
    205c:	74 3b                	je     2099 <e1000_clean+0x239>
		/* Detect a transmit hang in hardware, this serializes the
		 * check with the clearing of time_stamp and movement of i
		 */
		adapter->detect_tx_hung = false;
		if (tx_ring->buffer_info[eop].time_stamp &&
    205e:	8b 45 c8             	mov    -0x38(%rbp),%eax

	if (adapter->detect_tx_hung) {
		/* Detect a transmit hang in hardware, this serializes the
		 * check with the clearing of time_stamp and movement of i
		 */
		adapter->detect_tx_hung = false;
    2061:	c6 47 e1 00          	movb   $0x0,-0x1f(%rdi)
		if (tx_ring->buffer_info[eop].time_stamp &&
    2065:	48 8d 14 80          	lea    (%rax,%rax,4),%rdx
    2069:	49 8b 46 20          	mov    0x20(%r14),%rax
    206d:	48 c1 e2 03          	shl    $0x3,%rdx
    2071:	48 8b 44 10 10       	mov    0x10(%rax,%rdx,1),%rax
    2076:	48 85 c0             	test   %rax,%rax
    2079:	74 1e                	je     2099 <e1000_clean+0x239>
		    time_after(jiffies, tx_ring->buffer_info[eop].time_stamp +
    207b:	48 8b 0d 00 00 00 00 	mov    0x0(%rip),%rcx        # 2082 <e1000_clean+0x222>
    2082:	48 29 c8             	sub    %rcx,%rax
    2085:	0f b6 4f d8          	movzbl -0x28(%rdi),%ecx
    2089:	48 69 c9 fa 00 00 00 	imul   $0xfa,%rcx,%rcx
    2090:	48 01 c8             	add    %rcx,%rax
    2093:	0f 88 01 02 00 00    	js     229a <e1000_clean+0x43a>
				eop_desc->upper.fields.status);
			e1000_dump(adapter);
			netif_stop_queue(netdev);
		}
	}
	adapter->total_tx_bytes += total_tx_bytes;
    2099:	4c 8b 5d a8          	mov    -0x58(%rbp),%r11
    209d:	8b 55 bc             	mov    -0x44(%rbp),%edx
	adapter->total_tx_packets += total_tx_packets;
	netdev->stats.tx_bytes += total_tx_bytes;
    20a0:	48 8b 7d c0          	mov    -0x40(%rbp),%rdi
				eop_desc->upper.fields.status);
			e1000_dump(adapter);
			netif_stop_queue(netdev);
		}
	}
	adapter->total_tx_bytes += total_tx_bytes;
    20a4:	41 01 93 70 ff ff ff 	add    %edx,-0x90(%r11)
	adapter->total_tx_packets += total_tx_packets;
    20ab:	8b 55 b8             	mov    -0x48(%rbp),%edx
    20ae:	41 01 93 74 ff ff ff 	add    %edx,-0x8c(%r11)
	netdev->stats.tx_bytes += total_tx_bytes;
    20b5:	48 8b 55 a0          	mov    -0x60(%rbp),%rdx
    20b9:	48 01 ba 40 01 00 00 	add    %rdi,0x140(%rdx)
	netdev->stats.tx_packets += total_tx_packets;
    20c0:	4c 01 ba 30 01 00 00 	add    %r15,0x130(%rdx)
	
	int tx_clean_complete = 0, work_done = 0;

	tx_clean_complete = e1000_clean_tx_irq(adapter, &adapter->tx_ring[0]);

	adapter->clean_rx(adapter, &adapter->rx_ring[0], &work_done, budget);
    20c7:	44 8b 7d b0          	mov    -0x50(%rbp),%r15d
    20cb:	48 8d 55 d4          	lea    -0x2c(%rbp),%rdx
	}
	adapter->total_tx_bytes += total_tx_bytes;
	adapter->total_tx_packets += total_tx_packets;
	netdev->stats.tx_bytes += total_tx_bytes;
	netdev->stats.tx_packets += total_tx_packets;
	return count < tx_ring->count;
    20cf:	45 8b 66 14          	mov    0x14(%r14),%r12d
	
	int tx_clean_complete = 0, work_done = 0;

	tx_clean_complete = e1000_clean_tx_irq(adapter, &adapter->tx_ring[0]);

	adapter->clean_rx(adapter, &adapter->rx_ring[0], &work_done, budget);
    20d3:	49 8b 73 f8          	mov    -0x8(%r11),%rsi
    20d7:	48 8b 7d 98          	mov    -0x68(%rbp),%rdi
    20db:	44 89 f9             	mov    %r15d,%ecx
    20de:	41 ff 53 e8          	callq  *-0x18(%r11)

	if (!tx_clean_complete)
    20e2:	44 39 e3             	cmp    %r12d,%ebx
    20e5:	44 89 f8             	mov    %r15d,%eax
    20e8:	0f 83 2c 01 00 00    	jae    221a <e1000_clean+0x3ba>
		work_done = budget;

	/* If budget not fully consumed, exit the polling mode */
	if (work_done < budget) {
    20ee:	8b 5d d4             	mov    -0x2c(%rbp),%ebx
    20f1:	39 5d b0             	cmp    %ebx,-0x50(%rbp)
    20f4:	0f 8e 52 03 00 00    	jle    244c <e1000_clean+0x5ec>
		if (likely(adapter->itr_setting & 3))
    20fa:	4c 8b 7d a8          	mov    -0x58(%rbp),%r15
    20fe:	45 8b 6f 84          	mov    -0x7c(%r15),%r13d
    2102:	41 f6 c5 03          	test   $0x3,%r13b
    2106:	0f 84 d2 00 00 00    	je     21de <e1000_clean+0x37e>
{
	struct e1000_hw *hw = &adapter->hw;
	u16 current_itr;
	u32 new_itr = adapter->itr;

	if (unlikely(hw->mac_type < e1000_82540))
    210c:	41 83 bf 28 01 00 00 	cmpl   $0x4,0x128(%r15)
    2113:	04 

static void e1000_set_itr(struct e1000_adapter *adapter)
{
	struct e1000_hw *hw = &adapter->hw;
	u16 current_itr;
	u32 new_itr = adapter->itr;
    2114:	45 8b 67 80          	mov    -0x80(%r15),%r12d

	if (unlikely(hw->mac_type < e1000_82540))
    2118:	0f 86 c0 00 00 00    	jbe    21de <e1000_clean+0x37e>
		return;

	/* for non-gigabit speeds, just fix the interrupt rate at 4000 */
	if (unlikely(adapter->link_speed != SPEED_1000)) {
    211e:	66 41 81 bf 68 ff ff 	cmpw   $0x3e8,-0x98(%r15)
    2125:	ff e8 03 
    2128:	75 72                	jne    219c <e1000_clean+0x33c>
		current_itr = 0;
		new_itr = 4000;
		goto set_itr_now;
	}

	adapter->tx_itr = e1000_update_itr(adapter, adapter->tx_itr,
    212a:	41 0f b7 77 88       	movzwl -0x78(%r15),%esi
    212f:	41 8b 8f 70 ff ff ff 	mov    -0x90(%r15),%ecx
    2136:	41 8b 97 74 ff ff ff 	mov    -0x8c(%r15),%edx
    213d:	48 8b 7d 98          	mov    -0x68(%rbp),%rdi
    2141:	e8 0a e2 ff ff       	callq  350 <e1000_update_itr>
					   adapter->total_tx_packets,
					   adapter->total_tx_bytes);
	/* conservative mode (itr 3) eliminates the lowest_latency setting */
	if (adapter->itr_setting == 3 && adapter->tx_itr == lowest_latency)
    2146:	41 83 fd 03          	cmp    $0x3,%r13d
		current_itr = 0;
		new_itr = 4000;
		goto set_itr_now;
	}

	adapter->tx_itr = e1000_update_itr(adapter, adapter->tx_itr,
    214a:	41 89 c6             	mov    %eax,%r14d
    214d:	66 45 89 77 88       	mov    %r14w,-0x78(%r15)
					   adapter->total_tx_packets,
					   adapter->total_tx_bytes);
	/* conservative mode (itr 3) eliminates the lowest_latency setting */
	if (adapter->itr_setting == 3 && adapter->tx_itr == lowest_latency)
    2152:	0f 84 e9 00 00 00    	je     2241 <e1000_clean+0x3e1>
		adapter->tx_itr = low_latency;

	adapter->rx_itr = e1000_update_itr(adapter, adapter->rx_itr,
    2158:	4c 8b 7d a8          	mov    -0x58(%rbp),%r15
    215c:	48 8b 7d 98          	mov    -0x68(%rbp),%rdi
    2160:	41 0f b7 77 8a       	movzwl -0x76(%r15),%esi
    2165:	41 8b 97 7c ff ff ff 	mov    -0x84(%r15),%edx
    216c:	41 8b 8f 78 ff ff ff 	mov    -0x88(%r15),%ecx
    2173:	e8 d8 e1 ff ff       	callq  350 <e1000_update_itr>
		current_itr = 0;
		new_itr = 4000;
		goto set_itr_now;
	}

	adapter->tx_itr = e1000_update_itr(adapter, adapter->tx_itr,
    2178:	44 89 f2             	mov    %r14d,%edx
					   adapter->total_tx_bytes);
	/* conservative mode (itr 3) eliminates the lowest_latency setting */
	if (adapter->itr_setting == 3 && adapter->tx_itr == lowest_latency)
		adapter->tx_itr = low_latency;

	adapter->rx_itr = e1000_update_itr(adapter, adapter->rx_itr,
    217b:	66 41 89 47 8a       	mov    %ax,-0x76(%r15)
					   adapter->total_rx_bytes);
	/* conservative mode (itr 3) eliminates the lowest_latency setting */
	if (adapter->itr_setting == 3 && adapter->rx_itr == lowest_latency)
		adapter->rx_itr = low_latency;

	current_itr = max(adapter->rx_itr, adapter->tx_itr);
    2180:	66 39 c2             	cmp    %ax,%dx
    2183:	0f 43 c2             	cmovae %edx,%eax

	switch (current_itr) {
    2186:	66 83 f8 01          	cmp    $0x1,%ax
    218a:	0f 84 61 01 00 00    	je     22f1 <e1000_clean+0x491>
    2190:	0f 82 51 01 00 00    	jb     22e7 <e1000_clean+0x487>
    2196:	66 83 f8 02          	cmp    $0x2,%ax
    219a:	75 42                	jne    21de <e1000_clean+0x37e>
		return;

	/* for non-gigabit speeds, just fix the interrupt rate at 4000 */
	if (unlikely(adapter->link_speed != SPEED_1000)) {
		current_itr = 0;
		new_itr = 4000;
    219c:	ba a0 0f 00 00       	mov    $0xfa0,%edx
	default:
		break;
	}

set_itr_now:
	if (new_itr != adapter->itr) {
    21a1:	41 39 d4             	cmp    %edx,%r12d
    21a4:	74 38                	je     21de <e1000_clean+0x37e>
		/* this attempts to bias the interrupt rate towards Bulk
		 * by adding intermediate steps when interrupt rate is
		 * increasing
		 */
		new_itr = new_itr > adapter->itr ?
			  min(adapter->itr + (new_itr >> 2), new_itr) :
    21a6:	73 0f                	jae    21b7 <e1000_clean+0x357>
    21a8:	89 d0                	mov    %edx,%eax
    21aa:	c1 e8 02             	shr    $0x2,%eax
    21ad:	41 01 c4             	add    %eax,%r12d
    21b0:	44 39 e2             	cmp    %r12d,%edx
    21b3:	41 0f 47 d4          	cmova  %r12d,%edx
			  new_itr;
		adapter->itr = new_itr;
    21b7:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
    21bb:	89 50 80             	mov    %edx,-0x80(%rax)
		ew32(ITR, 1000000000 / (new_itr * 256));
    21be:	c1 e2 08             	shl    $0x8,%edx
    21c1:	48 8b b0 10 01 00 00 	mov    0x110(%rax),%rsi
    21c8:	89 d1                	mov    %edx,%ecx
    21ca:	b8 00 ca 9a 3b       	mov    $0x3b9aca00,%eax
    21cf:	31 d2                	xor    %edx,%edx
    21d1:	f7 f1                	div    %ecx
    21d3:	89 86 c4 00 00 00    	mov    %eax,0xc4(%rsi)
    21d9:	8b 75 d4             	mov    -0x2c(%rbp),%esi
    21dc:	eb 02                	jmp    21e0 <e1000_clean+0x380>
{
	struct e1000_hw *hw = &adapter->hw;
	u16 current_itr;
	u32 new_itr = adapter->itr;

	if (unlikely(hw->mac_type < e1000_82540))
    21de:	89 de                	mov    %ebx,%esi

	/* If budget not fully consumed, exit the polling mode */
	if (work_done < budget) {
		if (likely(adapter->itr_setting & 3))
			e1000_set_itr(adapter);
		napi_complete_done(napi, work_done);
    21e0:	48 8b 5d a8          	mov    -0x58(%rbp),%rbx
    21e4:	48 89 df             	mov    %rbx,%rdi
    21e7:	e8 00 00 00 00       	callq  21ec <e1000_clean+0x38c>
}

static __always_inline int constant_test_bit(long nr, const volatile unsigned long *addr)
{
	return ((1UL << (nr & (BITS_PER_LONG-1))) &
		(addr[nr >> _BITOPS_LONG_SHIFT])) != 0;
    21ec:	48 8b 83 f8 04 00 00 	mov    0x4f8(%rbx),%rax
		if (!test_bit(__E1000_DOWN, &adapter->flags))
    21f3:	a8 04                	test   $0x4,%al
    21f5:	75 20                	jne    2217 <e1000_clean+0x3b7>
 **/
static void e1000_irq_enable(struct e1000_adapter *adapter)
{
	struct e1000_hw *hw = &adapter->hw;

	ew32(IMS, IMS_ENABLE_MASK);
    21f7:	48 8b 7d a8          	mov    -0x58(%rbp),%rdi
    21fb:	b8 9d 00 00 00       	mov    $0x9d,%eax
    2200:	48 8b 97 10 01 00 00 	mov    0x110(%rdi),%rdx
    2207:	89 82 d0 00 00 00    	mov    %eax,0xd0(%rdx)
	E1000_WRITE_FLUSH();
    220d:	48 8b 87 10 01 00 00 	mov    0x110(%rdi),%rax
{ asm volatile("mov" size " %0,%1": :reg (val), \
"m" (*(volatile type __force *)addr) barrier); }

build_mmio_read(readb, "b", unsigned char, "=q", :"memory")
build_mmio_read(readw, "w", unsigned short, "=r", :"memory")
build_mmio_read(readl, "l", unsigned int, "=r", :"memory")
    2214:	8b 40 08             	mov    0x8(%rax),%eax
    2217:	8b 45 d4             	mov    -0x2c(%rbp),%eax
		if (!test_bit(__E1000_DOWN, &adapter->flags))
			e1000_irq_enable(adapter);
	}

	return work_done;
}
    221a:	48 83 c4 68          	add    $0x68,%rsp
    221e:	5b                   	pop    %rbx
    221f:	41 5c                	pop    %r12
    2221:	41 5d                	pop    %r13
    2223:	41 5e                	pop    %r14
    2225:	41 5f                	pop    %r15
    2227:	5d                   	pop    %rbp
    2228:	c3                   	retq   
		return;

	if (test_and_clear_bit(__QUEUE_STATE_STACK_XOFF, &dev_queue->state))
		netif_schedule_queue(dev_queue);
    2229:	4c 89 ef             	mov    %r13,%rdi
    222c:	e8 00 00 00 00       	callq  2231 <e1000_clean+0x3d1>
    2231:	8b 45 bc             	mov    -0x44(%rbp),%eax
    2234:	44 8b 7d b8          	mov    -0x48(%rbp),%r15d
    2238:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
    223c:	e9 0b fe ff ff       	jmpq   204c <e1000_clean+0x1ec>

	adapter->tx_itr = e1000_update_itr(adapter, adapter->tx_itr,
					   adapter->total_tx_packets,
					   adapter->total_tx_bytes);
	/* conservative mode (itr 3) eliminates the lowest_latency setting */
	if (adapter->itr_setting == 3 && adapter->tx_itr == lowest_latency)
    2241:	66 45 85 f6          	test   %r14w,%r14w
    2245:	75 0a                	jne    2251 <e1000_clean+0x3f1>
		adapter->tx_itr = low_latency;
    2247:	b9 01 00 00 00       	mov    $0x1,%ecx
    224c:	66 41 89 4f 88       	mov    %cx,-0x78(%r15)

	adapter->rx_itr = e1000_update_itr(adapter, adapter->rx_itr,
    2251:	4c 8b 7d a8          	mov    -0x58(%rbp),%r15
    2255:	48 8b 7d 98          	mov    -0x68(%rbp),%rdi
    2259:	41 0f b7 77 8a       	movzwl -0x76(%r15),%esi
    225e:	41 8b 8f 78 ff ff ff 	mov    -0x88(%r15),%ecx
    2265:	41 8b 97 7c ff ff ff 	mov    -0x84(%r15),%edx
    226c:	e8 df e0 ff ff       	callq  350 <e1000_update_itr>
					   adapter->total_rx_packets,
					   adapter->total_rx_bytes);
	/* conservative mode (itr 3) eliminates the lowest_latency setting */
	if (adapter->itr_setting == 3 && adapter->rx_itr == lowest_latency)
    2271:	66 85 c0             	test   %ax,%ax
					   adapter->total_tx_bytes);
	/* conservative mode (itr 3) eliminates the lowest_latency setting */
	if (adapter->itr_setting == 3 && adapter->tx_itr == lowest_latency)
		adapter->tx_itr = low_latency;

	adapter->rx_itr = e1000_update_itr(adapter, adapter->rx_itr,
    2274:	66 41 89 47 8a       	mov    %ax,-0x76(%r15)
					   adapter->total_rx_packets,
					   adapter->total_rx_bytes);
	/* conservative mode (itr 3) eliminates the lowest_latency setting */
	if (adapter->itr_setting == 3 && adapter->rx_itr == lowest_latency)
    2279:	0f 85 b2 00 00 00    	jne    2331 <e1000_clean+0x4d1>
		adapter->rx_itr = low_latency;
    227f:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
    2283:	ba 01 00 00 00       	mov    $0x1,%edx
    2288:	66 89 50 8a          	mov    %dx,-0x76(%rax)
    228c:	0f b7 50 88          	movzwl -0x78(%rax),%edx
    2290:	b8 01 00 00 00       	mov    $0x1,%eax
    2295:	e9 e6 fe ff ff       	jmpq   2180 <e1000_clean+0x320>
		 */
		adapter->detect_tx_hung = false;
		if (tx_ring->buffer_info[eop].time_stamp &&
		    time_after(jiffies, tx_ring->buffer_info[eop].time_stamp +
			       (adapter->tx_timeout_factor * HZ)) &&
		    !(er32(STATUS) & E1000_STATUS_TXOFF)) {
    229a:	48 8b 87 10 01 00 00 	mov    0x110(%rdi),%rax
    22a1:	8b 40 08             	mov    0x8(%rax),%eax
		 * check with the clearing of time_stamp and movement of i
		 */
		adapter->detect_tx_hung = false;
		if (tx_ring->buffer_info[eop].time_stamp &&
		    time_after(jiffies, tx_ring->buffer_info[eop].time_stamp +
			       (adapter->tx_timeout_factor * HZ)) &&
    22a4:	a8 10                	test   $0x10,%al
    22a6:	0f 85 ed fd ff ff    	jne    2099 <e1000_clean+0x239>
		    !(er32(STATUS) & E1000_STATUS_TXOFF)) {

			/* detected Tx unit hang */
			e_err(drv, "Detected Tx Unit Hang\n"
    22ac:	8b 87 f0 04 00 00    	mov    0x4f0(%rdi),%eax
    22b2:	a8 01                	test   $0x1,%al
    22b4:	0f 85 8b 00 00 00    	jne    2345 <e1000_clean+0x4e5>
 * e1000_dump: Print registers, tx ring and rx ring
 */
static void e1000_dump(struct e1000_adapter *adapter)
{
	/* this code doesn't handle multiple rings */
	struct e1000_tx_ring *tx_ring = adapter->tx_ring;
    22ba:	48 8b 55 a8          	mov    -0x58(%rbp),%rdx
	struct e1000_rx_ring *rx_ring = adapter->rx_ring;
	int i;

	if (!netif_msg_hw(adapter))
    22be:	f6 c4 20             	test   $0x20,%ah
 * e1000_dump: Print registers, tx ring and rx ring
 */
static void e1000_dump(struct e1000_adapter *adapter)
{
	/* this code doesn't handle multiple rings */
	struct e1000_tx_ring *tx_ring = adapter->tx_ring;
    22c1:	4c 8b 5a 90          	mov    -0x70(%rdx),%r11
	struct e1000_rx_ring *rx_ring = adapter->rx_ring;
    22c5:	4c 8b 62 f8          	mov    -0x8(%rdx),%r12
	int i;

	if (!netif_msg_hw(adapter))
    22c9:	0f 85 84 01 00 00    	jne    2453 <e1000_clean+0x5f3>
static __always_inline void
set_bit(long nr, volatile unsigned long *addr)
{
	if (IS_IMMEDIATE(nr)) {
		asm volatile(LOCK_PREFIX "orb %1,%0"
			: CONST_MASK_ADDR(nr, addr)
    22cf:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
    22d3:	48 8b 80 c0 03 00 00 	mov    0x3c0(%rax),%rax
 */
static __always_inline void
set_bit(long nr, volatile unsigned long *addr)
{
	if (IS_IMMEDIATE(nr)) {
		asm volatile(LOCK_PREFIX "orb %1,%0"
    22da:	f0 80 88 98 00 00 00 	lock orb $0x1,0x98(%rax)
    22e1:	01 
    22e2:	e9 b2 fd ff ff       	jmpq   2099 <e1000_clean+0x239>
	current_itr = max(adapter->rx_itr, adapter->tx_itr);

	switch (current_itr) {
	/* counts and packets in update_itr are dependent on these numbers */
	case lowest_latency:
		new_itr = 70000;
    22e7:	ba 70 11 01 00       	mov    $0x11170,%edx
    22ec:	e9 b0 fe ff ff       	jmpq   21a1 <e1000_clean+0x341>
		break;
	case low_latency:
		new_itr = 20000; /* aka hwitr = ~200 */
    22f1:	ba 20 4e 00 00       	mov    $0x4e20,%edx
    22f6:	e9 a6 fe ff ff       	jmpq   21a1 <e1000_clean+0x341>
	static int count = 0;	
	struct e1000_adapter *adapter = container_of(napi, struct e1000_adapter,

						     napi);
	if(i == 1)
		WARN_ON(1);
    22fb:	be 21 0f 00 00       	mov    $0xf21,%esi
    2300:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
    2307:	e8 00 00 00 00       	callq  230c <e1000_clean+0x4ac>
    230c:	e9 86 fb ff ff       	jmpq   1e97 <e1000_clean+0x37>

	i = tx_ring->next_to_clean;
	eop = tx_ring->buffer_info[i].next_to_watch;
	eop_desc = E1000_TX_DESC(*tx_ring, eop);

	while ((eop_desc->upper.data & cpu_to_le32(E1000_TXD_STAT_DD)) &&
    2311:	45 31 ff             	xor    %r15d,%r15d
    2314:	48 c7 45 c0 00 00 00 	movq   $0x0,-0x40(%rbp)
    231b:	00 
    231c:	c7 45 bc 00 00 00 00 	movl   $0x0,-0x44(%rbp)
    2323:	c7 45 b8 00 00 00 00 	movl   $0x0,-0x48(%rbp)
    232a:	31 db                	xor    %ebx,%ebx
    232c:	e9 23 fd ff ff       	jmpq   2054 <e1000_clean+0x1f4>
    2331:	41 0f b7 57 88       	movzwl -0x78(%r15),%edx
    2336:	e9 45 fe ff ff       	jmpq   2180 <e1000_clean+0x320>

			}
			e1000_unmap_and_free_tx_resource(adapter, buffer_info);
			tx_desc->upper.data = 0;

			if (unlikely(++i == tx_ring->count)) i = 0;
    233b:	31 c0                	xor    %eax,%eax
    233d:	45 31 ff             	xor    %r15d,%r15d
    2340:	e9 71 fc ff ff       	jmpq   1fb6 <e1000_clean+0x156>
		    time_after(jiffies, tx_ring->buffer_info[eop].time_stamp +
			       (adapter->tx_timeout_factor * HZ)) &&
		    !(er32(STATUS) & E1000_STATUS_TXOFF)) {

			/* detected Tx unit hang */
			e_err(drv, "Detected Tx Unit Hang\n"
    2345:	49 8b 46 20          	mov    0x20(%r14),%rax
    2349:	4c 8b 6d a8          	mov    -0x58(%rbp),%r13
    234d:	45 0f b6 5c 24 0c    	movzbl 0xc(%r12),%r11d
    2353:	48 8b 35 00 00 00 00 	mov    0x0(%rip),%rsi        # 235a <e1000_clean+0x4fa>
    235a:	45 8b 66 1c          	mov    0x1c(%r14),%r12d
    235e:	45 8b 4e 18          	mov    0x18(%r14),%r9d
    2362:	48 8b 44 10 10       	mov    0x10(%rax,%rdx,1),%rax
    2367:	41 0f b7 56 2a       	movzwl 0x2a(%r14),%edx
    236c:	49 03 95 10 01 00 00 	add    0x110(%r13),%rdx
    2373:	44 8b 02             	mov    (%rdx),%r8d
    2376:	41 0f b7 56 28       	movzwl 0x28(%r14),%edx
    237b:	49 03 95 10 01 00 00 	add    0x110(%r13),%rdx
    2382:	8b 0a                	mov    (%rdx),%ecx
    2384:	4c 89 f2             	mov    %r14,%rdx
    2387:	49 2b 55 90          	sub    -0x70(%r13),%rdx
    238b:	48 bf ab aa aa aa aa 	movabs $0xaaaaaaaaaaaaaaab,%rdi
    2392:	aa aa aa 
    2395:	48 c1 fa 04          	sar    $0x4,%rdx
    2399:	48 0f af d7          	imul   %rdi,%rdx
    239d:	49 8b bd 00 01 00 00 	mov    0x100(%r13),%rdi
    23a4:	48 89 74 24 18       	mov    %rsi,0x18(%rsp)
    23a9:	8b 75 c8             	mov    -0x38(%rbp),%esi
    23ac:	48 89 44 24 08       	mov    %rax,0x8(%rsp)
    23b1:	31 c0                	xor    %eax,%eax
    23b3:	44 89 5c 24 20       	mov    %r11d,0x20(%rsp)
    23b8:	44 89 24 24          	mov    %r12d,(%rsp)
    23bc:	89 74 24 10          	mov    %esi,0x10(%rsp)
    23c0:	48 c7 c6 00 00 00 00 	mov    $0x0,%rsi
    23c7:	e8 00 00 00 00       	callq  23cc <e1000_clean+0x56c>
    23cc:	41 8b 85 f0 04 00 00 	mov    0x4f0(%r13),%eax
    23d3:	e9 e2 fe ff ff       	jmpq   22ba <e1000_clean+0x45a>
}

static __always_inline int constant_test_bit(long nr, const volatile unsigned long *addr)
{
	return ((1UL << (nr & (BITS_PER_LONG-1))) &
		(addr[nr >> _BITOPS_LONG_SHIFT])) != 0;
    23d8:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
    23dc:	48 8b 40 48          	mov    0x48(%rax),%rax
	tx_ring->next_to_clean = i;

	netdev_completed_queue(netdev, pkts_compl, bytes_compl);

#define TX_WAKE_THRESHOLD 32
	if (unlikely(count && netif_carrier_ok(netdev) &&
    23e0:	a8 04                	test   $0x4,%al
    23e2:	0f 85 6c fc ff ff    	jne    2054 <e1000_clean+0x1f4>
    23e8:	41 8b 46 1c          	mov    0x1c(%r14),%eax
    23ec:	41 8b 4e 18          	mov    0x18(%r14),%ecx
    23f0:	31 d2                	xor    %edx,%edx
    23f2:	39 c8                	cmp    %ecx,%eax
    23f4:	77 04                	ja     23fa <e1000_clean+0x59a>
    23f6:	41 8b 56 14          	mov    0x14(%r14),%edx
    23fa:	83 e8 01             	sub    $0x1,%eax
    23fd:	29 c8                	sub    %ecx,%eax
    23ff:	01 d0                	add    %edx,%eax
    2401:	83 f8 1f             	cmp    $0x1f,%eax
    2404:	0f 86 4a fc ff ff    	jbe    2054 <e1000_clean+0x1f4>
		     E1000_DESC_UNUSED(tx_ring) >= TX_WAKE_THRESHOLD)) {
		/* Make sure that anybody stopping the queue after this
		 * sees the new next_to_clean.
		 */
		smp_mb();
    240a:	0f ae f0             	mfence 
 *	netif_queue_stopped - test if transmit queue is flowblocked
 *	@dev: network device
 *
 *	Test if transmit queue on device is currently unable to send.
 */
static inline bool netif_queue_stopped(const struct net_device *dev)
    240d:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
    2411:	48 8b b8 c0 03 00 00 	mov    0x3c0(%rax),%rdi
    2418:	48 8b 87 98 00 00 00 	mov    0x98(%rdi),%rax

		if (netif_queue_stopped(netdev) &&
    241f:	a8 01                	test   $0x1,%al
    2421:	0f 84 2d fc ff ff    	je     2054 <e1000_clean+0x1f4>
    2427:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
    242b:	48 8b 80 f8 04 00 00 	mov    0x4f8(%rax),%rax
    2432:	a8 04                	test   $0x4,%al
    2434:	0f 85 1a fc ff ff    	jne    2054 <e1000_clean+0x1f4>
 *	Allow upper layers to call the device hard_start_xmit routine.
 *	Used for flow control when transmit resources are available.
 */
static inline void netif_wake_queue(struct net_device *dev)
{
	netif_tx_wake_queue(netdev_get_tx_queue(dev, 0));
    243a:	e8 00 00 00 00       	callq  243f <e1000_clean+0x5df>
		    !(test_bit(__E1000_DOWN, &adapter->flags))) {
			netif_wake_queue(netdev);
			++adapter->restart_queue;
    243f:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
    2443:	83 40 98 01          	addl   $0x1,-0x68(%rax)
    2447:	e9 08 fc ff ff       	jmpq   2054 <e1000_clean+0x1f4>
    244c:	89 d8                	mov    %ebx,%eax
    244e:	e9 c7 fd ff ff       	jmpq   221a <e1000_clean+0x3ba>

	if (!netif_msg_hw(adapter))
		return;

	/* Print Registers */
	e1000_regdump(adapter);
    2453:	48 8b 7d 98          	mov    -0x68(%rbp),%rdi
    2457:	4c 89 5d c8          	mov    %r11,-0x38(%rbp)
    245b:	e8 00 00 00 00       	callq  2460 <e1000_clean+0x600>

	/* transmit dump */
	pr_info("TX Desc ring0 dump\n");
    2460:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
    2467:	31 c0                	xor    %eax,%eax
    2469:	e8 00 00 00 00       	callq  246e <e1000_clean+0x60e>
	 *   +----------------------------------------------------------------+
	 * 8 | VLAN tag |  POPTS  | Rsvd | Status | Command | DTYP |  DTALEN  |
	 *   +----------------------------------------------------------------+
	 *   63       48 47     40 39  36 35    32 31     24 23  20 19        0
	 */
	pr_info("Tc[desc]     [Ce CoCsIpceCoS] [MssHlRSCm0Plen] [bi->dma       ] leng  ntw timestmp         bi->skb\n");
    246e:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
    2475:	31 c0                	xor    %eax,%eax
    2477:	e8 00 00 00 00       	callq  247c <e1000_clean+0x61c>
	pr_info("Td[desc]     [address 63:0  ] [VlaPoRSCm1Dlen] [bi->dma       ] leng  ntw timestmp         bi->skb\n");
    247c:	31 c0                	xor    %eax,%eax
    247e:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
    2485:	e8 00 00 00 00       	callq  248a <e1000_clean+0x62a>

	if (!netif_msg_tx_done(adapter))
    248a:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
    248e:	4c 8b 5d c8          	mov    -0x38(%rbp),%r11
    2492:	f6 80 f1 04 00 00 04 	testb  $0x4,0x4f1(%rax)
    2499:	0f 85 23 01 00 00    	jne    25c2 <e1000_clean+0x762>
			(u64)buffer_info->time_stamp, buffer_info->skb, type);
	}

rx_ring_summary:
	/* receive dump */
	pr_info("\nRX Desc ring dump\n");
    249f:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
    24a6:	31 c0                	xor    %eax,%eax
    24a8:	e8 00 00 00 00       	callq  24ad <e1000_clean+0x64d>
	 * +-----------------------------------------------------+
	 * | VLAN Tag | Errors | Status 0 | Packet csum | Length |
	 * +-----------------------------------------------------+
	 * 63       48 47    40 39      32 31         16 15      0
	 */
	pr_info("R[desc]      [address 63:0  ] [vl er S cks ln] [bi->dma       ] [bi->skb]\n");
    24ad:	31 c0                	xor    %eax,%eax
    24af:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
    24b6:	e8 00 00 00 00       	callq  24bb <e1000_clean+0x65b>

	if (!netif_msg_rx_status(adapter))
    24bb:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
    24bf:	f6 80 f1 04 00 00 08 	testb  $0x8,0x4f1(%rax)
    24c6:	0f 84 03 fe ff ff    	je     22cf <e1000_clean+0x46f>
		goto exit;

	for (i = 0; rx_ring->desc && (i < rx_ring->count); i++) {
    24cc:	49 8b 04 24          	mov    (%r12),%rax
    24d0:	48 85 c0             	test   %rax,%rax
    24d3:	74 0d                	je     24e2 <e1000_clean+0x682>
    24d5:	41 8b 74 24 14       	mov    0x14(%r12),%esi
    24da:	85 f6                	test   %esi,%esi
    24dc:	0f 85 bf 01 00 00    	jne    26a1 <e1000_clean+0x841>
			(u64)buffer_info->dma, buffer_info->rxbuf.data, type);
	} /* for */

	/* dump the descriptor caches */
	/* rx */
	pr_info("Rx descriptor cache in 64bit format\n");
    24e2:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
    24e9:	31 c0                	xor    %eax,%eax
    24eb:	41 bc 00 60 00 00    	mov    $0x6000,%r12d
    24f1:	e8 00 00 00 00       	callq  24f6 <e1000_clean+0x696>
    24f6:	4c 8b 6d a8          	mov    -0x58(%rbp),%r13
	for (i = 0x6000; i <= 0x63FF ; i += 0x10) {
		pr_info("R%04X: %08X|%08X %08X|%08X\n",
    24fa:	49 8b 85 10 01 00 00 	mov    0x110(%r13),%rax
    2501:	4a 8d 44 20 08       	lea    0x8(%rax,%r12,1),%rax
    2506:	44 8b 08             	mov    (%rax),%r9d
    2509:	49 8b 85 10 01 00 00 	mov    0x110(%r13),%rax
    2510:	4a 8d 44 20 0c       	lea    0xc(%rax,%r12,1),%rax
    2515:	44 8b 00             	mov    (%rax),%r8d
    2518:	4c 89 e0             	mov    %r12,%rax
    251b:	49 03 85 10 01 00 00 	add    0x110(%r13),%rax
    2522:	8b 08                	mov    (%rax),%ecx
    2524:	49 8b 85 10 01 00 00 	mov    0x110(%r13),%rax
    252b:	4a 8d 44 20 04       	lea    0x4(%rax,%r12,1),%rax
    2530:	8b 10                	mov    (%rax),%edx
    2532:	31 c0                	xor    %eax,%eax
    2534:	44 89 e6             	mov    %r12d,%esi
    2537:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
    253e:	49 83 c4 10          	add    $0x10,%r12
    2542:	e8 00 00 00 00       	callq  2547 <e1000_clean+0x6e7>
	} /* for */

	/* dump the descriptor caches */
	/* rx */
	pr_info("Rx descriptor cache in 64bit format\n");
	for (i = 0x6000; i <= 0x63FF ; i += 0x10) {
    2547:	49 81 fc 00 64 00 00 	cmp    $0x6400,%r12
    254e:	75 aa                	jne    24fa <e1000_clean+0x69a>
			readl(adapter->hw.hw_addr + i),
			readl(adapter->hw.hw_addr + i+12),
			readl(adapter->hw.hw_addr + i+8));
	}
	/* tx */
	pr_info("Tx descriptor cache in 64bit format\n");
    2550:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
    2557:	31 c0                	xor    %eax,%eax
    2559:	66 41 bc 00 70       	mov    $0x7000,%r12w
    255e:	e8 00 00 00 00       	callq  2563 <e1000_clean+0x703>
    2563:	4c 8b 6d a8          	mov    -0x58(%rbp),%r13
	for (i = 0x7000; i <= 0x73FF ; i += 0x10) {
		pr_info("T%04X: %08X|%08X %08X|%08X\n",
    2567:	49 8b 85 10 01 00 00 	mov    0x110(%r13),%rax
    256e:	4a 8d 44 20 08       	lea    0x8(%rax,%r12,1),%rax
    2573:	44 8b 08             	mov    (%rax),%r9d
    2576:	49 8b 85 10 01 00 00 	mov    0x110(%r13),%rax
    257d:	4a 8d 44 20 0c       	lea    0xc(%rax,%r12,1),%rax
    2582:	44 8b 00             	mov    (%rax),%r8d
    2585:	4c 89 e0             	mov    %r12,%rax
    2588:	49 03 85 10 01 00 00 	add    0x110(%r13),%rax
    258f:	8b 08                	mov    (%rax),%ecx
    2591:	49 8b 85 10 01 00 00 	mov    0x110(%r13),%rax
    2598:	4a 8d 44 20 04       	lea    0x4(%rax,%r12,1),%rax
    259d:	8b 10                	mov    (%rax),%edx
    259f:	31 c0                	xor    %eax,%eax
    25a1:	44 89 e6             	mov    %r12d,%esi
    25a4:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
    25ab:	49 83 c4 10          	add    $0x10,%r12
    25af:	e8 00 00 00 00       	callq  25b4 <e1000_clean+0x754>
			readl(adapter->hw.hw_addr + i+12),
			readl(adapter->hw.hw_addr + i+8));
	}
	/* tx */
	pr_info("Tx descriptor cache in 64bit format\n");
	for (i = 0x7000; i <= 0x73FF ; i += 0x10) {
    25b4:	49 81 fc 00 74 00 00 	cmp    $0x7400,%r12
    25bb:	75 aa                	jne    2567 <e1000_clean+0x707>
    25bd:	e9 0d fd ff ff       	jmpq   22cf <e1000_clean+0x46f>
	pr_info("Td[desc]     [address 63:0  ] [VlaPoRSCm1Dlen] [bi->dma       ] leng  ntw timestmp         bi->skb\n");

	if (!netif_msg_tx_done(adapter))
		goto rx_ring_summary;

	for (i = 0; tx_ring->desc && (i < tx_ring->count); i++) {
    25c2:	49 8b 13             	mov    (%r11),%rdx
    25c5:	48 85 d2             	test   %rdx,%rdx
    25c8:	0f 84 d1 fe ff ff    	je     249f <e1000_clean+0x63f>
    25ce:	41 8b 7b 14          	mov    0x14(%r11),%edi
    25d2:	85 ff                	test   %edi,%edi
    25d4:	0f 84 c5 fe ff ff    	je     249f <e1000_clean+0x63f>
    25da:	31 c0                	xor    %eax,%eax
    25dc:	45 31 d2             	xor    %r10d,%r10d
		struct my_u { __le64 a; __le64 b; };
		struct my_u *u = (struct my_u *)tx_desc;
		const char *type;

		if (i == tx_ring->next_to_use && i == tx_ring->next_to_clean)
			type = "NTC/U";
    25df:	4d 89 dd             	mov    %r11,%r13

	if (!netif_msg_tx_done(adapter))
		goto rx_ring_summary;

	for (i = 0; tx_ring->desc && (i < tx_ring->count); i++) {
		struct e1000_tx_desc *tx_desc = E1000_TX_DESC(*tx_ring, i);
    25e2:	49 63 ca             	movslq %r10d,%rcx
    25e5:	48 89 ce             	mov    %rcx,%rsi
		struct e1000_tx_buffer *buffer_info = &tx_ring->buffer_info[i];
    25e8:	48 8d 0c 89          	lea    (%rcx,%rcx,4),%rcx

	if (!netif_msg_tx_done(adapter))
		goto rx_ring_summary;

	for (i = 0; tx_ring->desc && (i < tx_ring->count); i++) {
		struct e1000_tx_desc *tx_desc = E1000_TX_DESC(*tx_ring, i);
    25ec:	48 c1 e6 04          	shl    $0x4,%rsi
    25f0:	48 01 d6             	add    %rdx,%rsi
		struct e1000_tx_buffer *buffer_info = &tx_ring->buffer_info[i];
		struct my_u { __le64 a; __le64 b; };
		struct my_u *u = (struct my_u *)tx_desc;
		const char *type;

		if (i == tx_ring->next_to_use && i == tx_ring->next_to_clean)
    25f3:	41 39 45 18          	cmp    %eax,0x18(%r13)
	if (!netif_msg_tx_done(adapter))
		goto rx_ring_summary;

	for (i = 0; tx_ring->desc && (i < tx_ring->count); i++) {
		struct e1000_tx_desc *tx_desc = E1000_TX_DESC(*tx_ring, i);
		struct e1000_tx_buffer *buffer_info = &tx_ring->buffer_info[i];
    25f7:	49 8b 55 20          	mov    0x20(%r13),%rdx
    25fb:	48 8d 0c ca          	lea    (%rdx,%rcx,8),%rcx
		struct my_u { __le64 a; __le64 b; };
		struct my_u *u = (struct my_u *)tx_desc;
		const char *type;

		if (i == tx_ring->next_to_use && i == tx_ring->next_to_clean)
    25ff:	0f 84 21 01 00 00    	je     2726 <e1000_clean+0x8c6>
			type = "NTC/U";
		else if (i == tx_ring->next_to_use)
			type = "NTU";
		else if (i == tx_ring->next_to_clean)
			type = "NTC";
    2605:	41 3b 45 1c          	cmp    0x1c(%r13),%eax
    2609:	48 c7 c2 00 00 00 00 	mov    $0x0,%rdx
    2610:	48 c7 c0 00 00 00 00 	mov    $0x0,%rax
    2617:	48 0f 45 c2          	cmovne %rdx,%rax
		else
			type = "";

		pr_info("T%c[0x%03X]    %016llX %016llX %016llX %04X  %3X %016llX %p %s\n",
    261b:	44 0f b7 49 18       	movzwl 0x18(%rcx),%r9d
    2620:	4c 8b 46 08          	mov    0x8(%rsi),%r8
    2624:	48 8b 79 10          	mov    0x10(%rcx),%rdi
    2628:	0f b7 51 1a          	movzwl 0x1a(%rcx),%edx
    262c:	4c 8b 19             	mov    (%rcx),%r11
    262f:	44 89 4d c8          	mov    %r9d,-0x38(%rbp)
    2633:	4c 8b 49 08          	mov    0x8(%rcx),%r9
    2637:	48 8b 0e             	mov    (%rsi),%rcx
    263a:	4c 89 c6             	mov    %r8,%rsi
    263d:	48 89 44 24 20       	mov    %rax,0x20(%rsp)
    2642:	81 e6 00 00 10 00    	and    $0x100000,%esi
    2648:	8b 45 c8             	mov    -0x38(%rbp),%eax
    264b:	48 89 7c 24 10       	mov    %rdi,0x10(%rsp)
    2650:	48 83 fe 01          	cmp    $0x1,%rsi
    2654:	89 54 24 08          	mov    %edx,0x8(%rsp)
    2658:	4c 89 5c 24 18       	mov    %r11,0x18(%rsp)
    265d:	19 f6                	sbb    %esi,%esi
    265f:	44 89 d2             	mov    %r10d,%edx
    2662:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
    2669:	83 c6 64             	add    $0x64,%esi
    266c:	89 04 24             	mov    %eax,(%rsp)
    266f:	31 c0                	xor    %eax,%eax
    2671:	44 89 55 c8          	mov    %r10d,-0x38(%rbp)
    2675:	e8 00 00 00 00       	callq  267a <e1000_clean+0x81a>
	pr_info("Td[desc]     [address 63:0  ] [VlaPoRSCm1Dlen] [bi->dma       ] leng  ntw timestmp         bi->skb\n");

	if (!netif_msg_tx_done(adapter))
		goto rx_ring_summary;

	for (i = 0; tx_ring->desc && (i < tx_ring->count); i++) {
    267a:	44 8b 55 c8          	mov    -0x38(%rbp),%r10d
    267e:	49 8b 55 00          	mov    0x0(%r13),%rdx
    2682:	41 83 c2 01          	add    $0x1,%r10d
    2686:	48 85 d2             	test   %rdx,%rdx
    2689:	0f 84 10 fe ff ff    	je     249f <e1000_clean+0x63f>
    268f:	45 3b 55 14          	cmp    0x14(%r13),%r10d
    2693:	44 89 d0             	mov    %r10d,%eax
    2696:	0f 83 03 fe ff ff    	jae    249f <e1000_clean+0x63f>
    269c:	e9 41 ff ff ff       	jmpq   25e2 <e1000_clean+0x782>
	pr_info("R[desc]      [address 63:0  ] [vl er S cks ln] [bi->dma       ] [bi->skb]\n");

	if (!netif_msg_rx_status(adapter))
		goto exit;

	for (i = 0; rx_ring->desc && (i < rx_ring->count); i++) {
    26a1:	31 c9                	xor    %ecx,%ecx
    26a3:	45 31 d2             	xor    %r10d,%r10d
		const char *type;

		if (i == rx_ring->next_to_use)
			type = "NTU";
		else if (i == rx_ring->next_to_clean)
			type = "NTC";
    26a6:	49 c7 c5 00 00 00 00 	mov    $0x0,%r13

	if (!netif_msg_rx_status(adapter))
		goto exit;

	for (i = 0; rx_ring->desc && (i < rx_ring->count); i++) {
		struct e1000_rx_desc *rx_desc = E1000_RX_DESC(*rx_ring, i);
    26ad:	49 63 d2             	movslq %r10d,%rdx
		struct my_u { __le64 a; __le64 b; };
		struct my_u *u = (struct my_u *)rx_desc;
		const char *type;

		if (i == rx_ring->next_to_use)
			type = "NTU";
    26b0:	48 c7 c6 00 00 00 00 	mov    $0x0,%rsi

	if (!netif_msg_rx_status(adapter))
		goto exit;

	for (i = 0; rx_ring->desc && (i < rx_ring->count); i++) {
		struct e1000_rx_desc *rx_desc = E1000_RX_DESC(*rx_ring, i);
    26b7:	48 c1 e2 04          	shl    $0x4,%rdx
    26bb:	48 01 d0             	add    %rdx,%rax
		struct e1000_rx_buffer *buffer_info = &rx_ring->buffer_info[i];
    26be:	49 03 54 24 20       	add    0x20(%r12),%rdx
		struct my_u { __le64 a; __le64 b; };
		struct my_u *u = (struct my_u *)rx_desc;
		const char *type;

		if (i == rx_ring->next_to_use)
    26c3:	41 39 4c 24 18       	cmp    %ecx,0x18(%r12)
    26c8:	74 10                	je     26da <e1000_clean+0x87a>
			type = "NTU";
		else if (i == rx_ring->next_to_clean)
			type = "NTC";
    26ca:	41 3b 4c 24 1c       	cmp    0x1c(%r12),%ecx
    26cf:	48 c7 c6 00 00 00 00 	mov    $0x0,%rsi
    26d6:	49 0f 45 f5          	cmovne %r13,%rsi
		else
			type = "";

		pr_info("R[0x%03X]     %016llX %016llX %016llX %p %s\n",
    26da:	4c 8b 42 08          	mov    0x8(%rdx),%r8
    26de:	48 8b 48 08          	mov    0x8(%rax),%rcx
    26e2:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
    26e9:	48 89 34 24          	mov    %rsi,(%rsp)
    26ed:	4c 8b 0a             	mov    (%rdx),%r9
    26f0:	44 89 d6             	mov    %r10d,%esi
    26f3:	48 8b 10             	mov    (%rax),%rdx
    26f6:	31 c0                	xor    %eax,%eax
    26f8:	44 89 55 c8          	mov    %r10d,-0x38(%rbp)
    26fc:	e8 00 00 00 00       	callq  2701 <e1000_clean+0x8a1>
	pr_info("R[desc]      [address 63:0  ] [vl er S cks ln] [bi->dma       ] [bi->skb]\n");

	if (!netif_msg_rx_status(adapter))
		goto exit;

	for (i = 0; rx_ring->desc && (i < rx_ring->count); i++) {
    2701:	44 8b 55 c8          	mov    -0x38(%rbp),%r10d
    2705:	49 8b 04 24          	mov    (%r12),%rax
    2709:	41 83 c2 01          	add    $0x1,%r10d
    270d:	48 85 c0             	test   %rax,%rax
    2710:	0f 84 cc fd ff ff    	je     24e2 <e1000_clean+0x682>
    2716:	45 3b 54 24 14       	cmp    0x14(%r12),%r10d
    271b:	44 89 d1             	mov    %r10d,%ecx
    271e:	0f 83 be fd ff ff    	jae    24e2 <e1000_clean+0x682>
    2724:	eb 87                	jmp    26ad <e1000_clean+0x84d>
		struct my_u { __le64 a; __le64 b; };
		struct my_u *u = (struct my_u *)tx_desc;
		const char *type;

		if (i == tx_ring->next_to_use && i == tx_ring->next_to_clean)
			type = "NTC/U";
    2726:	41 3b 45 1c          	cmp    0x1c(%r13),%eax
    272a:	48 c7 c2 00 00 00 00 	mov    $0x0,%rdx
    2731:	48 c7 c0 00 00 00 00 	mov    $0x0,%rax
    2738:	48 0f 45 c2          	cmovne %rdx,%rax
    273c:	e9 da fe ff ff       	jmpq   261b <e1000_clean+0x7bb>
    2741:	66 66 66 66 66 66 2e 	data32 data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
    2748:	0f 1f 84 00 00 00 00 
    274f:	00 

0000000000002750 <e1000_clean_tx_ring>:
 * @adapter: board private structure
 * @tx_ring: ring to be cleaned
 **/
static void e1000_clean_tx_ring(struct e1000_adapter *adapter,
				struct e1000_tx_ring *tx_ring)
{
    2750:	e8 00 00 00 00       	callq  2755 <e1000_clean_tx_ring+0x5>
    2755:	55                   	push   %rbp
    2756:	48 89 e5             	mov    %rsp,%rbp
    2759:	41 56                	push   %r14
    275b:	49 89 fe             	mov    %rdi,%r14
    275e:	41 55                	push   %r13
    2760:	4c 8d af b8 03 00 00 	lea    0x3b8(%rdi),%r13
    2767:	41 54                	push   %r12
    2769:	49 89 f4             	mov    %rsi,%r12
    276c:	53                   	push   %rbx
	unsigned long size;
	unsigned int i;

	/* Free all the Tx ring sk_buffs */

	for (i = 0; i < tx_ring->count; i++) {
    276d:	8b 46 14             	mov    0x14(%rsi),%eax
    2770:	31 db                	xor    %ebx,%ebx
    2772:	85 c0                	test   %eax,%eax
    2774:	74 21                	je     2797 <e1000_clean_tx_ring+0x47>
		buffer_info = &tx_ring->buffer_info[i];
    2776:	89 d8                	mov    %ebx,%eax
		e1000_unmap_and_free_tx_resource(adapter, buffer_info);
    2778:	4c 89 ef             	mov    %r13,%rdi
	unsigned long size;
	unsigned int i;

	/* Free all the Tx ring sk_buffs */

	for (i = 0; i < tx_ring->count; i++) {
    277b:	83 c3 01             	add    $0x1,%ebx
		buffer_info = &tx_ring->buffer_info[i];
    277e:	48 8d 14 80          	lea    (%rax,%rax,4),%rdx
    2782:	49 8b 44 24 20       	mov    0x20(%r12),%rax
    2787:	48 8d 34 d0          	lea    (%rax,%rdx,8),%rsi
		e1000_unmap_and_free_tx_resource(adapter, buffer_info);
    278b:	e8 50 f6 ff ff       	callq  1de0 <e1000_unmap_and_free_tx_resource.isra.51>
	unsigned long size;
	unsigned int i;

	/* Free all the Tx ring sk_buffs */

	for (i = 0; i < tx_ring->count; i++) {
    2790:	41 39 5c 24 14       	cmp    %ebx,0x14(%r12)
    2795:	77 df                	ja     2776 <e1000_clean_tx_ring+0x26>
 * 	@dev_queue: network device
 *
 * 	Reset the bytes and packet count of a network device and clear the
 * 	software flow control OFF bit for this network device
 */
static inline void netdev_reset_queue(struct net_device *dev_queue)
    2797:	49 8b 86 b0 03 00 00 	mov    0x3b0(%r14),%rax
    279e:	48 8b b8 c0 03 00 00 	mov    0x3c0(%rax),%rdi
 */
static __always_inline void
clear_bit(long nr, volatile unsigned long *addr)
{
	if (IS_IMMEDIATE(nr)) {
		asm volatile(LOCK_PREFIX "andb %1,%0"
    27a5:	f0 80 a7 98 00 00 00 	lock andb $0xfd,0x98(%rdi)
    27ac:	fd 

static inline void netdev_tx_reset_queue(struct netdev_queue *q)
{
#ifdef CONFIG_BQL
	clear_bit(__QUEUE_STATE_STACK_XOFF, &q->state);
	dql_reset(&q->dql);
    27ad:	48 81 c7 c0 00 00 00 	add    $0xc0,%rdi
    27b4:	e8 00 00 00 00       	callq  27b9 <e1000_clean_tx_ring+0x69>
		buffer_info = &tx_ring->buffer_info[i];
		e1000_unmap_and_free_tx_resource(adapter, buffer_info);
	}

	netdev_reset_queue(adapter->netdev);
	size = sizeof(struct e1000_tx_buffer) * tx_ring->count;
    27b9:	41 8b 44 24 14       	mov    0x14(%r12),%eax
	memset(tx_ring->buffer_info, 0, size);
    27be:	49 8b 7c 24 20       	mov    0x20(%r12),%rdi
    27c3:	31 f6                	xor    %esi,%esi
		buffer_info = &tx_ring->buffer_info[i];
		e1000_unmap_and_free_tx_resource(adapter, buffer_info);
	}

	netdev_reset_queue(adapter->netdev);
	size = sizeof(struct e1000_tx_buffer) * tx_ring->count;
    27c5:	48 8d 14 80          	lea    (%rax,%rax,4),%rdx
    27c9:	48 c1 e2 03          	shl    $0x3,%rdx
	memset(tx_ring->buffer_info, 0, size);
    27cd:	e8 00 00 00 00       	callq  27d2 <e1000_clean_tx_ring+0x82>

	/* Zero out the descriptor ring */

	memset(tx_ring->desc, 0, tx_ring->size);
    27d2:	41 8b 54 24 10       	mov    0x10(%r12),%edx
    27d7:	49 8b 3c 24          	mov    (%r12),%rdi
    27db:	31 f6                	xor    %esi,%esi
    27dd:	e8 00 00 00 00       	callq  27e2 <e1000_clean_tx_ring+0x92>

	tx_ring->next_to_use = 0;
	tx_ring->next_to_clean = 0;
	tx_ring->last_tx_tso = false;

	writel(0, hw->hw_addr + tx_ring->tdh);
    27e2:	41 0f b7 44 24 28    	movzwl 0x28(%r12),%eax

	/* Zero out the descriptor ring */

	memset(tx_ring->desc, 0, tx_ring->size);

	tx_ring->next_to_use = 0;
    27e8:	41 c7 44 24 18 00 00 	movl   $0x0,0x18(%r12)
    27ef:	00 00 
build_mmio_read(__readw, "w", unsigned short, "=r", )
build_mmio_read(__readl, "l", unsigned int, "=r", )

build_mmio_write(writeb, "b", unsigned char, "q", :"memory")
build_mmio_write(writew, "w", unsigned short, "r", :"memory")
build_mmio_write(writel, "l", unsigned int, "r", :"memory")
    27f1:	31 d2                	xor    %edx,%edx
	tx_ring->next_to_clean = 0;
    27f3:	41 c7 44 24 1c 00 00 	movl   $0x0,0x1c(%r12)
    27fa:	00 00 
	tx_ring->last_tx_tso = false;
    27fc:	41 c6 44 24 2c 00    	movb   $0x0,0x2c(%r12)

	writel(0, hw->hw_addr + tx_ring->tdh);
    2802:	49 03 86 c0 03 00 00 	add    0x3c0(%r14),%rax
    2809:	89 10                	mov    %edx,(%rax)
	writel(0, hw->hw_addr + tx_ring->tdt);
    280b:	41 0f b7 44 24 2a    	movzwl 0x2a(%r12),%eax
    2811:	49 03 86 c0 03 00 00 	add    0x3c0(%r14),%rax
    2818:	89 10                	mov    %edx,(%rax)
}
    281a:	5b                   	pop    %rbx
    281b:	41 5c                	pop    %r12
    281d:	41 5d                	pop    %r13
    281f:	41 5e                	pop    %r14
    2821:	5d                   	pop    %rbp
    2822:	c3                   	retq   
    2823:	66 66 66 66 2e 0f 1f 	data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
    282a:	84 00 00 00 00 00 

0000000000002830 <e1000_alloc_jumbo_rx_buffers>:
 * @cleaned_count: number of buffers to allocate this pass
 **/
static void
e1000_alloc_jumbo_rx_buffers(struct e1000_adapter *adapter,
			     struct e1000_rx_ring *rx_ring, int cleaned_count)
{
    2830:	e8 00 00 00 00       	callq  2835 <e1000_alloc_jumbo_rx_buffers+0x5>
    2835:	55                   	push   %rbp
    2836:	48 89 e5             	mov    %rsp,%rbp
    2839:	41 57                	push   %r15
    283b:	49 89 f7             	mov    %rsi,%r15
    283e:	41 56                	push   %r14
    2840:	41 55                	push   %r13
    2842:	41 89 d5             	mov    %edx,%r13d
    2845:	41 54                	push   %r12
    2847:	53                   	push   %rbx
    2848:	48 83 ec 10          	sub    $0x10,%rsp
	struct pci_dev *pdev = adapter->pdev;
	struct e1000_rx_desc *rx_desc;
	struct e1000_rx_buffer *buffer_info;
	unsigned int i;

	i = rx_ring->next_to_use;
    284c:	8b 5e 18             	mov    0x18(%rsi),%ebx
 **/
static void
e1000_alloc_jumbo_rx_buffers(struct e1000_adapter *adapter,
			     struct e1000_rx_ring *rx_ring, int cleaned_count)
{
	struct pci_dev *pdev = adapter->pdev;
    284f:	48 8b 87 b8 03 00 00 	mov    0x3b8(%rdi),%rax
 * @cleaned_count: number of buffers to allocate this pass
 **/
static void
e1000_alloc_jumbo_rx_buffers(struct e1000_adapter *adapter,
			     struct e1000_rx_ring *rx_ring, int cleaned_count)
{
    2856:	48 89 7d c8          	mov    %rdi,-0x38(%rbp)
	struct e1000_rx_desc *rx_desc;
	struct e1000_rx_buffer *buffer_info;
	unsigned int i;

	i = rx_ring->next_to_use;
	buffer_info = &rx_ring->buffer_info[i];
    285a:	41 89 de             	mov    %ebx,%r14d
 **/
static void
e1000_alloc_jumbo_rx_buffers(struct e1000_adapter *adapter,
			     struct e1000_rx_ring *rx_ring, int cleaned_count)
{
	struct pci_dev *pdev = adapter->pdev;
    285d:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
				break;
			}
		}

		if (!buffer_info->dma) {
			buffer_info->dma = dma_map_page(&pdev->dev,
    2861:	4c 8d a0 98 00 00 00 	lea    0x98(%rax),%r12
	struct e1000_rx_desc *rx_desc;
	struct e1000_rx_buffer *buffer_info;
	unsigned int i;

	i = rx_ring->next_to_use;
	buffer_info = &rx_ring->buffer_info[i];
    2868:	49 c1 e6 04          	shl    $0x4,%r14
    286c:	4c 03 76 20          	add    0x20(%rsi),%r14

	while (cleaned_count--) {
    2870:	85 d2                	test   %edx,%edx
    2872:	75 36                	jne    28aa <e1000_alloc_jumbo_rx_buffers+0x7a>
    2874:	e9 8d 01 00 00       	jmpq   2a06 <e1000_alloc_jumbo_rx_buffers+0x1d6>
				adapter->alloc_rx_buff_failed++;
				break;
			}
		}

		rx_desc = E1000_RX_DESC(*rx_ring, i);
    2879:	89 d8                	mov    %ebx,%eax
		rx_desc->buffer_addr = cpu_to_le64(buffer_info->dma);

		if (unlikely(++i == rx_ring->count))
    287b:	83 c3 01             	add    $0x1,%ebx
				break;
			}
		}

		rx_desc = E1000_RX_DESC(*rx_ring, i);
		rx_desc->buffer_addr = cpu_to_le64(buffer_info->dma);
    287e:	48 c1 e0 04          	shl    $0x4,%rax
    2882:	49 03 07             	add    (%r15),%rax
    2885:	48 89 10             	mov    %rdx,(%rax)

		if (unlikely(++i == rx_ring->count))
    2888:	41 3b 5f 14          	cmp    0x14(%r15),%ebx
    288c:	0f 84 83 01 00 00    	je     2a15 <e1000_alloc_jumbo_rx_buffers+0x1e5>
    2892:	41 89 db             	mov    %ebx,%r11d
    2895:	49 c1 e3 04          	shl    $0x4,%r11
			i = 0;
		buffer_info = &rx_ring->buffer_info[i];
    2899:	4d 03 5f 20          	add    0x20(%r15),%r11
	unsigned int i;

	i = rx_ring->next_to_use;
	buffer_info = &rx_ring->buffer_info[i];

	while (cleaned_count--) {
    289d:	41 83 ed 01          	sub    $0x1,%r13d
		rx_desc = E1000_RX_DESC(*rx_ring, i);
		rx_desc->buffer_addr = cpu_to_le64(buffer_info->dma);

		if (unlikely(++i == rx_ring->count))
			i = 0;
		buffer_info = &rx_ring->buffer_info[i];
    28a1:	4d 89 de             	mov    %r11,%r14
	unsigned int i;

	i = rx_ring->next_to_use;
	buffer_info = &rx_ring->buffer_info[i];

	while (cleaned_count--) {
    28a4:	0f 84 36 01 00 00    	je     29e0 <e1000_alloc_jumbo_rx_buffers+0x1b0>
		/* allocate a new page if necessary */
		if (!buffer_info->rxbuf.page) {
    28aa:	49 83 3e 00          	cmpq   $0x0,(%r14)
    28ae:	74 7c                	je     292c <e1000_alloc_jumbo_rx_buffers+0xfc>
    28b0:	49 8b 56 08          	mov    0x8(%r14),%rdx
				adapter->alloc_rx_buff_failed++;
				break;
			}
		}

		if (!buffer_info->dma) {
    28b4:	48 85 d2             	test   %rdx,%rdx
    28b7:	75 c0                	jne    2879 <e1000_alloc_jumbo_rx_buffers+0x49>
			buffer_info->dma = dma_map_page(&pdev->dev,
    28b9:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
static inline struct dma_map_ops *get_dma_ops(struct device *dev)
{
#ifndef CONFIG_X86_DEV_DMA_OPS
	return dma_ops;
#else
	if (unlikely(!dev) || !dev->archdata.dma_ops)
    28bd:	4d 85 e4             	test   %r12,%r12
    28c0:	49 8b 36             	mov    (%r14),%rsi
    28c3:	8b 88 08 02 00 00    	mov    0x208(%rax),%ecx
    28c9:	0f 84 af 00 00 00    	je     297e <e1000_alloc_jumbo_rx_buffers+0x14e>
    28cf:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
    28d3:	48 8b 80 e8 02 00 00 	mov    0x2e8(%rax),%rax
    28da:	48 85 c0             	test   %rax,%rax
    28dd:	74 6a                	je     2949 <e1000_alloc_jumbo_rx_buffers+0x119>
	struct dma_map_ops *ops = get_dma_ops(dev);
	dma_addr_t addr;

	kmemcheck_mark_initialized(page_address(page) + offset, size);
	BUG_ON(!valid_dma_direction(dir));
	addr = ops->map_page(dev, page, offset, size, dir, NULL);
    28df:	31 d2                	xor    %edx,%edx
    28e1:	45 31 c9             	xor    %r9d,%r9d
    28e4:	4c 89 e7             	mov    %r12,%rdi
    28e7:	41 b8 02 00 00 00    	mov    $0x2,%r8d
    28ed:	ff 50 20             	callq  *0x20(%rax)
    28f0:	48 8b 7d d0          	mov    -0x30(%rbp),%rdi
    28f4:	49 89 46 08          	mov    %rax,0x8(%r14)
    28f8:	48 8b 97 e8 02 00 00 	mov    0x2e8(%rdi),%rdx
    28ff:	48 85 d2             	test   %rdx,%rdx
    2902:	74 71                	je     2975 <e1000_alloc_jumbo_rx_buffers+0x145>

static inline int dma_mapping_error(struct device *dev, dma_addr_t dma_addr)
{
	debug_dma_mapping_error(dev, dma_addr);

	if (get_dma_ops(dev)->mapping_error)
    2904:	48 83 7a 60 00       	cmpq   $0x0,0x60(%rdx)
    2909:	0f 84 9e 00 00 00    	je     29ad <e1000_alloc_jumbo_rx_buffers+0x17d>
    290f:	48 8b 52 60          	mov    0x60(%rdx),%rdx
		return get_dma_ops(dev)->mapping_error(dev, dma_addr);
    2913:	48 89 c6             	mov    %rax,%rsi
    2916:	4c 89 e7             	mov    %r12,%rdi
    2919:	ff d2                	callq  *%rdx
							buffer_info->rxbuf.page, 0,
							adapter->rx_buffer_len,
							DMA_FROM_DEVICE);
			if (dma_mapping_error(&pdev->dev, buffer_info->dma)) {
    291b:	85 c0                	test   %eax,%eax
    291d:	0f 85 9b 00 00 00    	jne    29be <e1000_alloc_jumbo_rx_buffers+0x18e>
    2923:	49 8b 56 08          	mov    0x8(%r14),%rdx
    2927:	e9 4d ff ff ff       	jmpq   2879 <e1000_alloc_jumbo_rx_buffers+0x49>
extern struct page *alloc_pages_current(gfp_t gfp_mask, unsigned order);

static inline struct page *
alloc_pages(gfp_t gfp_mask, unsigned int order)
{
	return alloc_pages_current(gfp_mask, order);
    292c:	31 f6                	xor    %esi,%esi
    292e:	bf 20 00 08 02       	mov    $0x2080020,%edi
    2933:	e8 00 00 00 00       	callq  2938 <e1000_alloc_jumbo_rx_buffers+0x108>

	while (cleaned_count--) {
		/* allocate a new page if necessary */
		if (!buffer_info->rxbuf.page) {
			buffer_info->rxbuf.page = alloc_page(GFP_ATOMIC);
			if (unlikely(!buffer_info->rxbuf.page)) {
    2938:	48 85 c0             	test   %rax,%rax
	buffer_info = &rx_ring->buffer_info[i];

	while (cleaned_count--) {
		/* allocate a new page if necessary */
		if (!buffer_info->rxbuf.page) {
			buffer_info->rxbuf.page = alloc_page(GFP_ATOMIC);
    293b:	49 89 06             	mov    %rax,(%r14)
			if (unlikely(!buffer_info->rxbuf.page)) {
    293e:	0f 85 6c ff ff ff    	jne    28b0 <e1000_alloc_jumbo_rx_buffers+0x80>
    2944:	e9 8c 00 00 00       	jmpq   29d5 <e1000_alloc_jumbo_rx_buffers+0x1a5>
	struct dma_map_ops *ops = get_dma_ops(dev);
	dma_addr_t addr;

	kmemcheck_mark_initialized(page_address(page) + offset, size);
	BUG_ON(!valid_dma_direction(dir));
	addr = ops->map_page(dev, page, offset, size, dir, NULL);
    2949:	48 8b 05 00 00 00 00 	mov    0x0(%rip),%rax        # 2950 <e1000_alloc_jumbo_rx_buffers+0x120>
    2950:	31 d2                	xor    %edx,%edx
    2952:	45 31 c9             	xor    %r9d,%r9d
    2955:	4c 89 e7             	mov    %r12,%rdi
    2958:	41 b8 02 00 00 00    	mov    $0x2,%r8d
    295e:	ff 50 20             	callq  *0x20(%rax)
    2961:	48 8b 7d d0          	mov    -0x30(%rbp),%rdi
				break;
			}
		}

		if (!buffer_info->dma) {
			buffer_info->dma = dma_map_page(&pdev->dev,
    2965:	49 89 46 08          	mov    %rax,0x8(%r14)
    2969:	48 8b 97 e8 02 00 00 	mov    0x2e8(%rdi),%rdx
    2970:	48 85 d2             	test   %rdx,%rdx
    2973:	75 8f                	jne    2904 <e1000_alloc_jumbo_rx_buffers+0xd4>

static inline int dma_mapping_error(struct device *dev, dma_addr_t dma_addr)
{
	debug_dma_mapping_error(dev, dma_addr);

	if (get_dma_ops(dev)->mapping_error)
    2975:	48 8b 15 00 00 00 00 	mov    0x0(%rip),%rdx        # 297c <e1000_alloc_jumbo_rx_buffers+0x14c>
    297c:	eb 86                	jmp    2904 <e1000_alloc_jumbo_rx_buffers+0xd4>
	struct dma_map_ops *ops = get_dma_ops(dev);
	dma_addr_t addr;

	kmemcheck_mark_initialized(page_address(page) + offset, size);
	BUG_ON(!valid_dma_direction(dir));
	addr = ops->map_page(dev, page, offset, size, dir, NULL);
    297e:	48 8b 05 00 00 00 00 	mov    0x0(%rip),%rax        # 2985 <e1000_alloc_jumbo_rx_buffers+0x155>
    2985:	31 d2                	xor    %edx,%edx
    2987:	45 31 c9             	xor    %r9d,%r9d
    298a:	31 ff                	xor    %edi,%edi
    298c:	41 b8 02 00 00 00    	mov    $0x2,%r8d
    2992:	ff 50 20             	callq  *0x20(%rax)

static inline int dma_mapping_error(struct device *dev, dma_addr_t dma_addr)
{
	debug_dma_mapping_error(dev, dma_addr);

	if (get_dma_ops(dev)->mapping_error)
    2995:	48 8b 15 00 00 00 00 	mov    0x0(%rip),%rdx        # 299c <e1000_alloc_jumbo_rx_buffers+0x16c>
    299c:	49 89 46 08          	mov    %rax,0x8(%r14)
    29a0:	48 8b 52 60          	mov    0x60(%rdx),%rdx
    29a4:	48 85 d2             	test   %rdx,%rdx
    29a7:	0f 85 66 ff ff ff    	jne    2913 <e1000_alloc_jumbo_rx_buffers+0xe3>
		return get_dma_ops(dev)->mapping_error(dev, dma_addr);

#ifdef DMA_ERROR_CODE
	return dma_addr == DMA_ERROR_CODE;
    29ad:	48 85 c0             	test   %rax,%rax
    29b0:	0f 94 c0             	sete   %al
    29b3:	0f b6 c0             	movzbl %al,%eax
							buffer_info->rxbuf.page, 0,
							adapter->rx_buffer_len,
							DMA_FROM_DEVICE);
			if (dma_mapping_error(&pdev->dev, buffer_info->dma)) {
    29b6:	85 c0                	test   %eax,%eax
    29b8:	0f 84 65 ff ff ff    	je     2923 <e1000_alloc_jumbo_rx_buffers+0xf3>
				put_page(buffer_info->rxbuf.page);
    29be:	49 8b 3e             	mov    (%r14),%rdi
    29c1:	e8 00 00 00 00       	callq  29c6 <e1000_alloc_jumbo_rx_buffers+0x196>
				buffer_info->rxbuf.page = NULL;
    29c6:	49 c7 06 00 00 00 00 	movq   $0x0,(%r14)
				buffer_info->dma = 0;
    29cd:	49 c7 46 08 00 00 00 	movq   $0x0,0x8(%r14)
    29d4:	00 
				adapter->alloc_rx_buff_failed++;
    29d5:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
    29d9:	83 80 90 03 00 00 01 	addl   $0x1,0x390(%rax)
		if (unlikely(++i == rx_ring->count))
			i = 0;
		buffer_info = &rx_ring->buffer_info[i];
	}

	if (likely(rx_ring->next_to_use != i)) {
    29e0:	41 3b 5f 18          	cmp    0x18(%r15),%ebx
    29e4:	74 20                	je     2a06 <e1000_alloc_jumbo_rx_buffers+0x1d6>
		rx_ring->next_to_use = i;
		if (unlikely(i-- == 0))
    29e6:	85 db                	test   %ebx,%ebx
			i = 0;
		buffer_info = &rx_ring->buffer_info[i];
	}

	if (likely(rx_ring->next_to_use != i)) {
		rx_ring->next_to_use = i;
    29e8:	41 89 5f 18          	mov    %ebx,0x18(%r15)
		if (unlikely(i-- == 0))
    29ec:	8d 53 ff             	lea    -0x1(%rbx),%edx
    29ef:	74 2e                	je     2a1f <e1000_alloc_jumbo_rx_buffers+0x1ef>
		/* Force memory writes to complete before letting h/w
		 * know there are new descriptors to fetch.  (Only
		 * applicable for weak-ordered memory model archs,
		 * such as IA-64).
		 */
		wmb();
    29f1:	0f ae f8             	sfence 
		writel(i, adapter->hw.hw_addr + rx_ring->rdt);
    29f4:	48 8b 4d c8          	mov    -0x38(%rbp),%rcx
    29f8:	41 0f b7 47 36       	movzwl 0x36(%r15),%eax
    29fd:	48 03 81 c0 03 00 00 	add    0x3c0(%rcx),%rax
    2a04:	89 10                	mov    %edx,(%rax)
	}
}
    2a06:	48 83 c4 10          	add    $0x10,%rsp
    2a0a:	5b                   	pop    %rbx
    2a0b:	41 5c                	pop    %r12
    2a0d:	41 5d                	pop    %r13
    2a0f:	41 5e                	pop    %r14
    2a11:	41 5f                	pop    %r15
    2a13:	5d                   	pop    %rbp
    2a14:	c3                   	retq   
    2a15:	45 31 db             	xor    %r11d,%r11d

		rx_desc = E1000_RX_DESC(*rx_ring, i);
		rx_desc->buffer_addr = cpu_to_le64(buffer_info->dma);

		if (unlikely(++i == rx_ring->count))
			i = 0;
    2a18:	31 db                	xor    %ebx,%ebx
    2a1a:	e9 7a fe ff ff       	jmpq   2899 <e1000_alloc_jumbo_rx_buffers+0x69>
	}

	if (likely(rx_ring->next_to_use != i)) {
		rx_ring->next_to_use = i;
		if (unlikely(i-- == 0))
			i = (rx_ring->count - 1);
    2a1f:	41 8b 47 14          	mov    0x14(%r15),%eax
    2a23:	8d 50 ff             	lea    -0x1(%rax),%edx
    2a26:	eb c9                	jmp    29f1 <e1000_alloc_jumbo_rx_buffers+0x1c1>
    2a28:	0f 1f 84 00 00 00 00 	nopl   0x0(%rax,%rax,1)
    2a2f:	00 

0000000000002a30 <e1000_clean_rx_ring>:
 * @adapter: board private structure
 * @rx_ring: ring to free buffers from
 **/
static void e1000_clean_rx_ring(struct e1000_adapter *adapter,
				struct e1000_rx_ring *rx_ring)
{
    2a30:	e8 00 00 00 00       	callq  2a35 <e1000_clean_rx_ring+0x5>
    2a35:	55                   	push   %rbp
    2a36:	48 89 e5             	mov    %rsp,%rbp
    2a39:	41 57                	push   %r15
    2a3b:	49 89 ff             	mov    %rdi,%r15
    2a3e:	41 56                	push   %r14
    2a40:	41 55                	push   %r13
    2a42:	49 89 f5             	mov    %rsi,%r13
    2a45:	41 54                	push   %r12
	struct pci_dev *pdev = adapter->pdev;
	unsigned long size;
	unsigned int i;

	/* Free all the Rx netfrags */
	for (i = 0; i < rx_ring->count; i++) {
    2a47:	45 31 e4             	xor    %r12d,%r12d
 * @adapter: board private structure
 * @rx_ring: ring to free buffers from
 **/
static void e1000_clean_rx_ring(struct e1000_adapter *adapter,
				struct e1000_rx_ring *rx_ring)
{
    2a4a:	53                   	push   %rbx
    2a4b:	48 83 ec 08          	sub    $0x8,%rsp
	struct e1000_hw *hw = &adapter->hw;
	struct e1000_rx_buffer *buffer_info;
	struct pci_dev *pdev = adapter->pdev;
    2a4f:	4c 8b b7 b8 03 00 00 	mov    0x3b8(%rdi),%r14
	/* Free all the Rx netfrags */
	for (i = 0; i < rx_ring->count; i++) {
		buffer_info = &rx_ring->buffer_info[i];
		if (adapter->clean_rx == e1000_clean_rx_irq) {
			if (buffer_info->dma)
				dma_unmap_single(&pdev->dev, buffer_info->dma,
    2a56:	49 8d 86 98 00 00 00 	lea    0x98(%r14),%rax
    2a5d:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
	struct pci_dev *pdev = adapter->pdev;
	unsigned long size;
	unsigned int i;

	/* Free all the Rx netfrags */
	for (i = 0; i < rx_ring->count; i++) {
    2a61:	8b 46 14             	mov    0x14(%rsi),%eax
    2a64:	85 c0                	test   %eax,%eax
    2a66:	75 1c                	jne    2a84 <e1000_clean_rx_ring+0x54>
    2a68:	eb 7a                	jmp    2ae4 <e1000_clean_rx_ring+0xb4>
						 DMA_FROM_DEVICE);
			if (buffer_info->rxbuf.data) {
				skb_free_frag(buffer_info->rxbuf.data);
				buffer_info->rxbuf.data = NULL;
			}
		} else if (adapter->clean_rx == e1000_clean_jumbo_rx_irq) {
    2a6a:	48 3d 00 00 00 00    	cmp    $0x0,%rax
    2a70:	74 4f                	je     2ac1 <e1000_clean_rx_ring+0x91>
				put_page(buffer_info->rxbuf.page);
				buffer_info->rxbuf.page = NULL;
			}
		}

		buffer_info->dma = 0;
    2a72:	48 c7 43 08 00 00 00 	movq   $0x0,0x8(%rbx)
    2a79:	00 
	struct pci_dev *pdev = adapter->pdev;
	unsigned long size;
	unsigned int i;

	/* Free all the Rx netfrags */
	for (i = 0; i < rx_ring->count; i++) {
    2a7a:	41 83 c4 01          	add    $0x1,%r12d
    2a7e:	45 39 65 14          	cmp    %r12d,0x14(%r13)
    2a82:	76 60                	jbe    2ae4 <e1000_clean_rx_ring+0xb4>
		buffer_info = &rx_ring->buffer_info[i];
		if (adapter->clean_rx == e1000_clean_rx_irq) {
    2a84:	49 8b 87 98 02 00 00 	mov    0x298(%r15),%rax
	unsigned long size;
	unsigned int i;

	/* Free all the Rx netfrags */
	for (i = 0; i < rx_ring->count; i++) {
		buffer_info = &rx_ring->buffer_info[i];
    2a8b:	44 89 e3             	mov    %r12d,%ebx
    2a8e:	48 c1 e3 04          	shl    $0x4,%rbx
    2a92:	49 03 5d 20          	add    0x20(%r13),%rbx
		if (adapter->clean_rx == e1000_clean_rx_irq) {
    2a96:	48 3d 00 00 00 00    	cmp    $0x0,%rax
    2a9c:	75 cc                	jne    2a6a <e1000_clean_rx_ring+0x3a>
			if (buffer_info->dma)
    2a9e:	48 8b 73 08          	mov    0x8(%rbx),%rsi
    2aa2:	48 85 f6             	test   %rsi,%rsi
    2aa5:	0f 85 b7 00 00 00    	jne    2b62 <e1000_clean_rx_ring+0x132>
				dma_unmap_single(&pdev->dev, buffer_info->dma,
						 adapter->rx_buffer_len,
						 DMA_FROM_DEVICE);
			if (buffer_info->rxbuf.data) {
    2aab:	48 8b 3b             	mov    (%rbx),%rdi
    2aae:	48 85 ff             	test   %rdi,%rdi
    2ab1:	74 bf                	je     2a72 <e1000_clean_rx_ring+0x42>
    2ab3:	e8 00 00 00 00       	callq  2ab8 <e1000_clean_rx_ring+0x88>
				skb_free_frag(buffer_info->rxbuf.data);
				buffer_info->rxbuf.data = NULL;
    2ab8:	48 c7 03 00 00 00 00 	movq   $0x0,(%rbx)
    2abf:	eb b1                	jmp    2a72 <e1000_clean_rx_ring+0x42>
			}
		} else if (adapter->clean_rx == e1000_clean_jumbo_rx_irq) {
			if (buffer_info->dma)
    2ac1:	48 8b 73 08          	mov    0x8(%rbx),%rsi
    2ac5:	48 85 f6             	test   %rsi,%rsi
    2ac8:	0f 85 ce 00 00 00    	jne    2b9c <e1000_clean_rx_ring+0x16c>
				dma_unmap_page(&pdev->dev, buffer_info->dma,
					       adapter->rx_buffer_len,
					       DMA_FROM_DEVICE);
			if (buffer_info->rxbuf.page) {
    2ace:	48 8b 3b             	mov    (%rbx),%rdi
    2ad1:	48 85 ff             	test   %rdi,%rdi
    2ad4:	74 9c                	je     2a72 <e1000_clean_rx_ring+0x42>
				put_page(buffer_info->rxbuf.page);
    2ad6:	e8 00 00 00 00       	callq  2adb <e1000_clean_rx_ring+0xab>
				buffer_info->rxbuf.page = NULL;
    2adb:	48 c7 03 00 00 00 00 	movq   $0x0,(%rbx)
    2ae2:	eb 8e                	jmp    2a72 <e1000_clean_rx_ring+0x42>
struct packet_offload *gro_find_receive_by_type(__be16 type);
struct packet_offload *gro_find_complete_by_type(__be16 type);

static inline void napi_free_frags(struct napi_struct *napi)
{
	kfree_skb(napi->skb);
    2ae4:	49 8b bf f0 02 00 00 	mov    0x2f0(%r15),%rdi
    2aeb:	e8 00 00 00 00       	callq  2af0 <e1000_clean_rx_ring+0xc0>
	napi->skb = NULL;
    2af0:	49 c7 87 f0 02 00 00 	movq   $0x0,0x2f0(%r15)
    2af7:	00 00 00 00 

	/* there also may be some cached data from a chained receive */
	napi_free_frags(&adapter->napi);
	rx_ring->rx_skb_top = NULL;

	size = sizeof(struct e1000_rx_buffer) * rx_ring->count;
    2afb:	41 8b 55 14          	mov    0x14(%r13),%edx
	memset(rx_ring->buffer_info, 0, size);
    2aff:	31 f6                	xor    %esi,%esi
    2b01:	49 8b 7d 20          	mov    0x20(%r13),%rdi
		buffer_info->dma = 0;
	}

	/* there also may be some cached data from a chained receive */
	napi_free_frags(&adapter->napi);
	rx_ring->rx_skb_top = NULL;
    2b05:	49 c7 45 28 00 00 00 	movq   $0x0,0x28(%r13)
    2b0c:	00 

	size = sizeof(struct e1000_rx_buffer) * rx_ring->count;
    2b0d:	48 c1 e2 04          	shl    $0x4,%rdx
	memset(rx_ring->buffer_info, 0, size);
    2b11:	e8 00 00 00 00       	callq  2b16 <e1000_clean_rx_ring+0xe6>

	/* Zero out the descriptor ring */
	memset(rx_ring->desc, 0, rx_ring->size);
    2b16:	41 8b 55 10          	mov    0x10(%r13),%edx
    2b1a:	49 8b 7d 00          	mov    0x0(%r13),%rdi
    2b1e:	31 f6                	xor    %esi,%esi
    2b20:	e8 00 00 00 00       	callq  2b25 <e1000_clean_rx_ring+0xf5>

	rx_ring->next_to_clean = 0;
	rx_ring->next_to_use = 0;

	writel(0, hw->hw_addr + rx_ring->rdh);
    2b25:	41 0f b7 45 34       	movzwl 0x34(%r13),%eax
	memset(rx_ring->buffer_info, 0, size);

	/* Zero out the descriptor ring */
	memset(rx_ring->desc, 0, rx_ring->size);

	rx_ring->next_to_clean = 0;
    2b2a:	41 c7 45 1c 00 00 00 	movl   $0x0,0x1c(%r13)
    2b31:	00 
    2b32:	31 d2                	xor    %edx,%edx
	rx_ring->next_to_use = 0;
    2b34:	41 c7 45 18 00 00 00 	movl   $0x0,0x18(%r13)
    2b3b:	00 

	writel(0, hw->hw_addr + rx_ring->rdh);
    2b3c:	49 03 87 c0 03 00 00 	add    0x3c0(%r15),%rax
    2b43:	89 10                	mov    %edx,(%rax)
	writel(0, hw->hw_addr + rx_ring->rdt);
    2b45:	41 0f b7 45 36       	movzwl 0x36(%r13),%eax
    2b4a:	49 03 87 c0 03 00 00 	add    0x3c0(%r15),%rax
    2b51:	89 10                	mov    %edx,(%rax)
}
    2b53:	48 83 c4 08          	add    $0x8,%rsp
    2b57:	5b                   	pop    %rbx
    2b58:	41 5c                	pop    %r12
    2b5a:	41 5d                	pop    %r13
    2b5c:	41 5e                	pop    %r14
    2b5e:	41 5f                	pop    %r15
    2b60:	5d                   	pop    %rbp
    2b61:	c3                   	retq   
    2b62:	48 83 7d d0 00       	cmpq   $0x0,-0x30(%rbp)
	/* Free all the Rx netfrags */
	for (i = 0; i < rx_ring->count; i++) {
		buffer_info = &rx_ring->buffer_info[i];
		if (adapter->clean_rx == e1000_clean_rx_irq) {
			if (buffer_info->dma)
				dma_unmap_single(&pdev->dev, buffer_info->dma,
    2b67:	41 8b 97 08 02 00 00 	mov    0x208(%r15),%edx
    2b6e:	74 66                	je     2bd6 <e1000_clean_rx_ring+0x1a6>
    2b70:	49 8b 86 e8 02 00 00 	mov    0x2e8(%r14),%rax
    2b77:	48 85 c0             	test   %rax,%rax
    2b7a:	74 5a                	je     2bd6 <e1000_clean_rx_ring+0x1a6>
					  struct dma_attrs *attrs)
{
	struct dma_map_ops *ops = get_dma_ops(dev);

	BUG_ON(!valid_dma_direction(dir));
	if (ops->unmap_page)
    2b7c:	48 8b 40 28          	mov    0x28(%rax),%rax
    2b80:	48 85 c0             	test   %rax,%rax
    2b83:	0f 84 22 ff ff ff    	je     2aab <e1000_clean_rx_ring+0x7b>
		ops->unmap_page(dev, addr, size, dir, attrs);
    2b89:	45 31 c0             	xor    %r8d,%r8d
    2b8c:	b9 02 00 00 00       	mov    $0x2,%ecx
    2b91:	48 8b 7d d0          	mov    -0x30(%rbp),%rdi
    2b95:	ff d0                	callq  *%rax
    2b97:	e9 0f ff ff ff       	jmpq   2aab <e1000_clean_rx_ring+0x7b>
    2b9c:	48 83 7d d0 00       	cmpq   $0x0,-0x30(%rbp)
				skb_free_frag(buffer_info->rxbuf.data);
				buffer_info->rxbuf.data = NULL;
			}
		} else if (adapter->clean_rx == e1000_clean_jumbo_rx_irq) {
			if (buffer_info->dma)
				dma_unmap_page(&pdev->dev, buffer_info->dma,
    2ba1:	41 8b 97 08 02 00 00 	mov    0x208(%r15),%edx
    2ba8:	74 35                	je     2bdf <e1000_clean_rx_ring+0x1af>
    2baa:	49 8b 86 e8 02 00 00 	mov    0x2e8(%r14),%rax
    2bb1:	48 85 c0             	test   %rax,%rax
    2bb4:	74 29                	je     2bdf <e1000_clean_rx_ring+0x1af>
				  size_t size, enum dma_data_direction dir)
{
	struct dma_map_ops *ops = get_dma_ops(dev);

	BUG_ON(!valid_dma_direction(dir));
	if (ops->unmap_page)
    2bb6:	48 8b 40 28          	mov    0x28(%rax),%rax
    2bba:	48 85 c0             	test   %rax,%rax
    2bbd:	0f 84 0b ff ff ff    	je     2ace <e1000_clean_rx_ring+0x9e>
		ops->unmap_page(dev, addr, size, dir, NULL);
    2bc3:	45 31 c0             	xor    %r8d,%r8d
    2bc6:	b9 02 00 00 00       	mov    $0x2,%ecx
    2bcb:	48 8b 7d d0          	mov    -0x30(%rbp),%rdi
    2bcf:	ff d0                	callq  *%rax
    2bd1:	e9 f8 fe ff ff       	jmpq   2ace <e1000_clean_rx_ring+0x9e>
		return dma_ops;
    2bd6:	48 8b 05 00 00 00 00 	mov    0x0(%rip),%rax        # 2bdd <e1000_clean_rx_ring+0x1ad>
    2bdd:	eb 9d                	jmp    2b7c <e1000_clean_rx_ring+0x14c>
    2bdf:	48 8b 05 00 00 00 00 	mov    0x0(%rip),%rax        # 2be6 <e1000_clean_rx_ring+0x1b6>
    2be6:	eb ce                	jmp    2bb6 <e1000_clean_rx_ring+0x186>
    2be8:	0f 1f 84 00 00 00 00 	nopl   0x0(%rax,%rax,1)
    2bef:	00 

0000000000002bf0 <e1000_clean_all_rx_rings>:
/**
 * e1000_clean_all_rx_rings - Free Rx Buffers for all queues
 * @adapter: board private structure
 **/
static void e1000_clean_all_rx_rings(struct e1000_adapter *adapter)
{
    2bf0:	e8 00 00 00 00       	callq  2bf5 <e1000_clean_all_rx_rings+0x5>
    2bf5:	55                   	push   %rbp
    2bf6:	48 89 e5             	mov    %rsp,%rbp
    2bf9:	41 54                	push   %r12
    2bfb:	49 89 fc             	mov    %rdi,%r12
    2bfe:	53                   	push   %rbx
	int i;

	for (i = 0; i < adapter->num_rx_queues; i++)
    2bff:	8b 87 7c 03 00 00    	mov    0x37c(%rdi),%eax
    2c05:	31 db                	xor    %ebx,%ebx
    2c07:	85 c0                	test   %eax,%eax
    2c09:	7e 2f                	jle    2c3a <e1000_clean_all_rx_rings+0x4a>
		e1000_clean_rx_ring(adapter, &adapter->rx_ring[i]);
    2c0b:	48 63 f3             	movslq %ebx,%rsi
    2c0e:	4c 89 e7             	mov    %r12,%rdi
 **/
static void e1000_clean_all_rx_rings(struct e1000_adapter *adapter)
{
	int i;

	for (i = 0; i < adapter->num_rx_queues; i++)
    2c11:	83 c3 01             	add    $0x1,%ebx
		e1000_clean_rx_ring(adapter, &adapter->rx_ring[i]);
    2c14:	48 8d 04 f5 00 00 00 	lea    0x0(,%rsi,8),%rax
    2c1b:	00 
    2c1c:	48 c1 e6 06          	shl    $0x6,%rsi
    2c20:	48 29 c6             	sub    %rax,%rsi
    2c23:	49 03 b4 24 a8 02 00 	add    0x2a8(%r12),%rsi
    2c2a:	00 
    2c2b:	e8 00 fe ff ff       	callq  2a30 <e1000_clean_rx_ring>
 **/
static void e1000_clean_all_rx_rings(struct e1000_adapter *adapter)
{
	int i;

	for (i = 0; i < adapter->num_rx_queues; i++)
    2c30:	41 39 9c 24 7c 03 00 	cmp    %ebx,0x37c(%r12)
    2c37:	00 
    2c38:	7f d1                	jg     2c0b <e1000_clean_all_rx_rings+0x1b>
		e1000_clean_rx_ring(adapter, &adapter->rx_ring[i]);
}
    2c3a:	5b                   	pop    %rbx
    2c3b:	41 5c                	pop    %r12
    2c3d:	5d                   	pop    %rbp
    2c3e:	c3                   	retq   
    2c3f:	90                   	nop

0000000000002c40 <e1000_enter_82542_rst>:

/* The 82542 2.0 (revision 2) needs to have the receive unit in reset
 * and memory write and invalidate disabled for certain operations
 */
static void e1000_enter_82542_rst(struct e1000_adapter *adapter)
{
    2c40:	e8 00 00 00 00       	callq  2c45 <e1000_enter_82542_rst+0x5>
    2c45:	55                   	push   %rbp
    2c46:	48 89 e5             	mov    %rsp,%rbp
    2c49:	41 54                	push   %r12
    2c4b:	53                   	push   %rbx

void e1000_pci_clear_mwi(struct e1000_hw *hw)
{
	struct e1000_adapter *adapter = hw->back;

	pci_clear_mwi(adapter->pdev);
    2c4c:	48 8b 87 e8 03 00 00 	mov    0x3e8(%rdi),%rax

/* The 82542 2.0 (revision 2) needs to have the receive unit in reset
 * and memory write and invalidate disabled for certain operations
 */
static void e1000_enter_82542_rst(struct e1000_adapter *adapter)
{
    2c53:	48 89 fb             	mov    %rdi,%rbx
	struct e1000_hw *hw = &adapter->hw;
	struct net_device *netdev = adapter->netdev;
    2c56:	4c 8b a7 b0 03 00 00 	mov    0x3b0(%rdi),%r12

void e1000_pci_clear_mwi(struct e1000_hw *hw)
{
	struct e1000_adapter *adapter = hw->back;

	pci_clear_mwi(adapter->pdev);
    2c5d:	48 8b b8 b8 03 00 00 	mov    0x3b8(%rax),%rdi
    2c64:	e8 00 00 00 00       	callq  2c69 <e1000_enter_82542_rst+0x29>
	struct net_device *netdev = adapter->netdev;
	u32 rctl;

	e1000_pci_clear_mwi(hw);

	rctl = er32(RCTL);
    2c69:	48 8b 83 c0 03 00 00 	mov    0x3c0(%rbx),%rax
{ asm volatile("mov" size " %0,%1": :reg (val), \
"m" (*(volatile type __force *)addr) barrier); }

build_mmio_read(readb, "b", unsigned char, "=q", :"memory")
build_mmio_read(readw, "w", unsigned short, "=r", :"memory")
build_mmio_read(readl, "l", unsigned int, "=r", :"memory")
    2c70:	8b 80 00 01 00 00    	mov    0x100(%rax),%eax
	rctl |= E1000_RCTL_RST;
    2c76:	83 c8 01             	or     $0x1,%eax
	ew32(RCTL, rctl);
    2c79:	48 8b 93 c0 03 00 00 	mov    0x3c0(%rbx),%rdx
build_mmio_read(__readw, "w", unsigned short, "=r", )
build_mmio_read(__readl, "l", unsigned int, "=r", )

build_mmio_write(writeb, "b", unsigned char, "q", :"memory")
build_mmio_write(writew, "w", unsigned short, "r", :"memory")
build_mmio_write(writel, "l", unsigned int, "r", :"memory")
    2c80:	89 82 00 01 00 00    	mov    %eax,0x100(%rdx)
	E1000_WRITE_FLUSH();
    2c86:	48 8b 83 c0 03 00 00 	mov    0x3c0(%rbx),%rax
{ asm volatile("mov" size " %0,%1": :reg (val), \
"m" (*(volatile type __force *)addr) barrier); }

build_mmio_read(readb, "b", unsigned char, "=q", :"memory")
build_mmio_read(readw, "w", unsigned short, "=r", :"memory")
build_mmio_read(readl, "l", unsigned int, "=r", :"memory")
    2c8d:	8b 40 08             	mov    0x8(%rax),%eax
	mdelay(5);
    2c90:	bf b8 ae 47 01       	mov    $0x147aeb8,%edi
    2c95:	e8 00 00 00 00       	callq  2c9a <e1000_enter_82542_rst+0x5a>
}

static __always_inline int constant_test_bit(long nr, const volatile unsigned long *addr)
{
	return ((1UL << (nr & (BITS_PER_LONG-1))) &
		(addr[nr >> _BITOPS_LONG_SHIFT])) != 0;
    2c9a:	49 8b 44 24 48       	mov    0x48(%r12),%rax

	if (netif_running(netdev))
    2c9f:	a8 01                	test   $0x1,%al
    2ca1:	74 08                	je     2cab <e1000_enter_82542_rst+0x6b>
		e1000_clean_all_rx_rings(adapter);
    2ca3:	48 89 df             	mov    %rbx,%rdi
    2ca6:	e8 45 ff ff ff       	callq  2bf0 <e1000_clean_all_rx_rings>
}
    2cab:	5b                   	pop    %rbx
    2cac:	41 5c                	pop    %r12
    2cae:	5d                   	pop    %rbp
    2caf:	c3                   	retq   

0000000000002cb0 <e1000_xmit_frame>:
}

#define TXD_USE_COUNT(S, X) (((S) >> (X)) + 1 )
static netdev_tx_t e1000_xmit_frame(struct sk_buff *skb,
				    struct net_device *netdev)
{
    2cb0:	e8 00 00 00 00       	callq  2cb5 <e1000_xmit_frame+0x5>
    2cb5:	55                   	push   %rbp
    2cb6:	48 89 e5             	mov    %rsp,%rbp
    2cb9:	41 57                	push   %r15
    2cbb:	41 56                	push   %r14
    2cbd:	49 89 fe             	mov    %rdi,%r14
    2cc0:	41 55                	push   %r13
    2cc2:	41 54                	push   %r12
    2cc4:	53                   	push   %rbx
    2cc5:	48 83 ec 58          	sub    $0x58,%rsp
		return 0;
	return __e1000_maybe_stop_tx(netdev, size);
}

#define TXD_USE_COUNT(S, X) (((S) >> (X)) + 1 )
static netdev_tx_t e1000_xmit_frame(struct sk_buff *skb,
    2cc9:	8b 97 80 00 00 00    	mov    0x80(%rdi),%edx
 * Returns the EtherType of the packet, regardless of whether it is
 * vlan encapsulated (normal or hardware accelerated) or not.
 */
static inline __be16 vlan_get_protocol(struct sk_buff *skb)
{
	return __vlan_get_protocol(skb, skb->protocol, NULL);
    2ccf:	44 0f b7 a7 c0 00 00 	movzwl 0xc0(%rdi),%r12d
    2cd6:	00 
    2cd7:	8b 87 84 00 00 00    	mov    0x84(%rdi),%eax
				    struct net_device *netdev)
{
    2cdd:	48 89 75 c8          	mov    %rsi,-0x38(%rbp)
 * vlan encapsulated (normal or hardware accelerated) or not.
 */
static inline __be16 __vlan_get_protocol(struct sk_buff *skb, __be16 type,
					 int *depth)
{
	unsigned int vlan_depth = skb->mac_len;
    2ce1:	0f b7 9f 88 00 00 00 	movzwl 0x88(%rdi),%ebx
	return skb->data_len;
}

static inline unsigned int skb_headlen(const struct sk_buff *skb)
{
	return skb->len - skb->data_len;
    2ce8:	41 89 d2             	mov    %edx,%r10d
    2ceb:	41 29 c2             	sub    %eax,%r10d

	/* if type is 802.1Q/AD then the header should already be
	 * present at mac_len - VLAN_HLEN (if mac_len > 0), or at
	 * ETH_HLEN otherwise
	 */
	if (type == htons(ETH_P_8021Q) || type == htons(ETH_P_8021AD)) {
    2cee:	66 41 81 fc 88 a8    	cmp    $0xa888,%r12w
    2cf4:	0f 84 a0 03 00 00    	je     309a <e1000_xmit_frame+0x3ea>
    2cfa:	66 41 81 fc 81 00    	cmp    $0x81,%r12w
    2d00:	0f 84 94 03 00 00    	je     309a <e1000_xmit_frame+0x3ea>
	/* This goes back to the question of how to logically map a Tx queue
	 * to a flow.  Right now, performance is impacted slightly negatively
	 * if using multiple Tx queues.  If the stack breaks away from a
	 * single qdisc implementation, we can look at this again.
	 */
	tx_ring = adapter->tx_ring;
    2d06:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
 */
static inline int skb_put_padto(struct sk_buff *skb, unsigned int len)
{
	unsigned int size = skb->len;

	if (unlikely(size < len)) {
    2d0a:	83 fa 3b             	cmp    $0x3b,%edx
    2d0d:	4c 8b b8 80 0a 00 00 	mov    0xa80(%rax),%r15
    2d14:	0f 86 84 0f 00 00    	jbe    3c9e <e1000_xmit_frame+0xfee>
    2d1a:	41 8b 96 84 00 00 00 	mov    0x84(%r14),%edx
}

#ifdef NET_SKBUFF_DATA_USES_OFFSET
static inline unsigned char *skb_end_pointer(const struct sk_buff *skb)
{
	return skb->head + skb->end;
    2d21:	41 8b be cc 00 00 00 	mov    0xcc(%r14),%edi
		return 0;
	return __e1000_maybe_stop_tx(netdev, size);
}

#define TXD_USE_COUNT(S, X) (((S) >> (X)) + 1 )
static netdev_tx_t e1000_xmit_frame(struct sk_buff *skb,
    2d28:	49 8b 86 d0 00 00 00 	mov    0xd0(%r14),%rax
    2d2f:	48 01 c7             	add    %rax,%rdi
	 * To WA this issue, pad all small packets manually.
	 */
	if (eth_skb_pad(skb))
		return NETDEV_TX_OK;

	mss = skb_shinfo(skb)->gso_size;
    2d32:	0f b7 4f 02          	movzwl 0x2(%rdi),%ecx
	 * initiating the DMA for each buffer.  The calc is:
	 * 4 = ceil(buffer len/mss).  To make sure we don't
	 * overrun the FIFO, adjust the max buffer len if mss
	 * drops.
	 */
	if (mss) {
    2d36:	85 c9                	test   %ecx,%ecx
	 * To WA this issue, pad all small packets manually.
	 */
	if (eth_skb_pad(skb))
		return NETDEV_TX_OK;

	mss = skb_shinfo(skb)->gso_size;
    2d38:	89 4d a8             	mov    %ecx,-0x58(%rbp)
	 * initiating the DMA for each buffer.  The calc is:
	 * 4 = ceil(buffer len/mss).  To make sure we don't
	 * overrun the FIFO, adjust the max buffer len if mss
	 * drops.
	 */
	if (mss) {
    2d3b:	0f 84 b3 08 00 00    	je     35f4 <e1000_xmit_frame+0x944>
		u8 hdr_len;
		max_per_txd = min(mss << 2, max_per_txd);
    2d41:	8b 4d a8             	mov    -0x58(%rbp),%ecx
	return skb->transport_header != (typeof(skb->transport_header))~0U;
}

static inline unsigned char *skb_transport_header(const struct sk_buff *skb)
{
	return skb->head + skb->transport_header;
    2d44:	45 0f b7 86 c2 00 00 	movzwl 0xc2(%r14),%r8d
    2d4b:	00 
	 * top 32 bits will be cleared.
	 *
	 * We cannot do this on 32 bits because at the very least some
	 * 486 CPUs did not behave this way.
	 */
	asm("bsrl %1,%0"
    2d4c:	bb ff ff ff ff       	mov    $0xffffffff,%ebx
	return skb->csum_start - skb_headroom(skb);
}

static inline int skb_transport_offset(const struct sk_buff *skb)
{
	return skb_transport_header(skb) - skb->data;
    2d51:	4d 8b 8e d8 00 00 00 	mov    0xd8(%r14),%r9
    2d58:	c1 e1 02             	shl    $0x2,%ecx
    2d5b:	81 f9 00 10 00 00    	cmp    $0x1000,%ecx
    2d61:	89 ce                	mov    %ecx,%esi
    2d63:	b9 00 10 00 00       	mov    $0x1000,%ecx
    2d68:	0f 46 ce             	cmovbe %esi,%ecx
	return skb->transport_header != (typeof(skb->transport_header))~0U;
}

static inline unsigned char *skb_transport_header(const struct sk_buff *skb)
{
	return skb->head + skb->transport_header;
    2d6b:	49 01 c0             	add    %rax,%r8
	return (struct tcphdr *)skb_transport_header(skb);
}

static inline unsigned int tcp_hdrlen(const struct sk_buff *skb)
{
	return tcp_hdr(skb)->doff * 4;
    2d6e:	41 0f b6 70 0c       	movzbl 0xc(%r8),%esi
    2d73:	89 4d ac             	mov    %ecx,-0x54(%rbp)
    2d76:	0f bd d9             	bsr    %ecx,%ebx
    2d79:	40 c0 ee 04          	shr    $0x4,%sil
		max_txd_pwr = fls(max_per_txd) - 1;

		hdr_len = skb_transport_offset(skb) + tcp_hdrlen(skb);
		if (skb->data_len && hdr_len == len) {
    2d7d:	85 d2                	test   %edx,%edx
    2d7f:	0f 85 e1 09 00 00    	jne    3766 <e1000_xmit_frame+0xab6>
		if (vlan_depth) {
			if (WARN_ON(vlan_depth < VLAN_HLEN))
				return 0;
    2d85:	89 d9                	mov    %ebx,%ecx
	unsigned int max_txd_pwr = E1000_MAX_TXD_PWR;
	unsigned int tx_flags = 0;
	unsigned int len = skb_headlen(skb);
	unsigned int nr_frags;
	unsigned int mss;
	int count = 0;
    2d87:	b8 02 00 00 00       	mov    $0x2,%eax
		}
	}

	/* reserve a descriptor for the offload context */
	if ((mss) || (skb->ip_summed == CHECKSUM_PARTIAL))
		count++;
    2d8c:	be 01 00 00 00       	mov    $0x1,%esi
	count++;

	/* Controller Erratum workaround */
	if (!skb->data_len && tx_ring->last_tx_tso && !skb_is_gso(skb))
    2d91:	85 d2                	test   %edx,%edx
    2d93:	75 0b                	jne    2da0 <e1000_xmit_frame+0xf0>
    2d95:	41 80 7f 2c 00       	cmpb   $0x0,0x2c(%r15)
    2d9a:	0f 85 3c 0a 00 00    	jne    37dc <e1000_xmit_frame+0xb2c>
		count++;

	count += TXD_USE_COUNT(len, max_txd_pwr);

	if (adapter->pcix_82544)
    2da0:	48 8b 5d c8          	mov    -0x38(%rbp),%rbx

	/* Controller Erratum workaround */
	if (!skb->data_len && tx_ring->last_tx_tso && !skb_is_gso(skb))
		count++;

	count += TXD_USE_COUNT(len, max_txd_pwr);
    2da4:	44 89 d2             	mov    %r10d,%edx
    2da7:	d3 ea                	shr    %cl,%edx
    2da9:	8d 44 10 01          	lea    0x1(%rax,%rdx,1),%eax

	if (adapter->pcix_82544)
    2dad:	44 0f b6 83 d0 0a 00 	movzbl 0xad0(%rbx),%r8d
    2db4:	00 
		count++;
    2db5:	8d 70 01             	lea    0x1(%rax),%esi
    2db8:	45 84 c0             	test   %r8b,%r8b
    2dbb:	0f 44 f0             	cmove  %eax,%esi

	/* work-around for errata 10 and it applies to all controllers
	 * in PCI-X mode, so add one more descriptor to the count
	 */
	if (unlikely((hw->bus_type == e1000_bus_type_pcix) &&
    2dbe:	83 bb 4c 0c 00 00 02 	cmpl   $0x2,0xc4c(%rbx)
    2dc5:	0f 84 1b 0f 00 00    	je     3ce6 <e1000_xmit_frame+0x1036>
			(len > 2015)))
		count++;

	nr_frags = skb_shinfo(skb)->nr_frags;
    2dcb:	0f b6 07             	movzbl (%rdi),%eax
	for (f = 0; f < nr_frags; f++)
    2dce:	85 c0                	test   %eax,%eax
	 */
	if (unlikely((hw->bus_type == e1000_bus_type_pcix) &&
			(len > 2015)))
		count++;

	nr_frags = skb_shinfo(skb)->nr_frags;
    2dd0:	89 45 94             	mov    %eax,-0x6c(%rbp)
	for (f = 0; f < nr_frags; f++)
    2dd3:	74 21                	je     2df6 <e1000_xmit_frame+0x146>
    2dd5:	44 8d 48 ff          	lea    -0x1(%rax),%r9d
    2dd9:	31 c0                	xor    %eax,%eax
    2ddb:	49 83 c1 01          	add    $0x1,%r9
    2ddf:	49 c1 e1 04          	shl    $0x4,%r9
		count += TXD_USE_COUNT(skb_frag_size(&skb_shinfo(skb)->frags[f]),
    2de3:	8b 54 07 3c          	mov    0x3c(%rdi,%rax,1),%edx
    2de7:	48 83 c0 10          	add    $0x10,%rax
    2deb:	d3 ea                	shr    %cl,%edx
	if (unlikely((hw->bus_type == e1000_bus_type_pcix) &&
			(len > 2015)))
		count++;

	nr_frags = skb_shinfo(skb)->nr_frags;
	for (f = 0; f < nr_frags; f++)
    2ded:	4c 39 c8             	cmp    %r9,%rax
		count += TXD_USE_COUNT(skb_frag_size(&skb_shinfo(skb)->frags[f]),
    2df0:	8d 74 16 01          	lea    0x1(%rsi,%rdx,1),%esi
	if (unlikely((hw->bus_type == e1000_bus_type_pcix) &&
			(len > 2015)))
		count++;

	nr_frags = skb_shinfo(skb)->nr_frags;
	for (f = 0; f < nr_frags; f++)
    2df4:	75 ed                	jne    2de3 <e1000_xmit_frame+0x133>
		count += TXD_USE_COUNT(skb_frag_size(&skb_shinfo(skb)->frags[f]),
				       max_txd_pwr);
	if (adapter->pcix_82544)
		count += nr_frags;
    2df6:	8b 45 94             	mov    -0x6c(%rbp),%eax
static netdev_tx_t e1000_xmit_frame(struct sk_buff *skb,
				    struct net_device *netdev)
{
	struct e1000_adapter *adapter = netdev_priv(netdev);
	struct e1000_hw *hw = &adapter->hw;
	struct e1000_tx_ring *tx_ring;
    2df9:	41 8b 4f 18          	mov    0x18(%r15),%ecx
    2dfd:	41 8b 57 1c          	mov    0x1c(%r15),%edx
	nr_frags = skb_shinfo(skb)->nr_frags;
	for (f = 0; f < nr_frags; f++)
		count += TXD_USE_COUNT(skb_frag_size(&skb_shinfo(skb)->frags[f]),
				       max_txd_pwr);
	if (adapter->pcix_82544)
		count += nr_frags;
    2e01:	01 f0                	add    %esi,%eax
    2e03:	45 84 c0             	test   %r8b,%r8b
    2e06:	0f 45 f0             	cmovne %eax,%esi
}

static int e1000_maybe_stop_tx(struct net_device *netdev,
			       struct e1000_tx_ring *tx_ring, int size)
{
	if (likely(E1000_DESC_UNUSED(tx_ring) >= size))
    2e09:	31 c0                	xor    %eax,%eax
		count += nr_frags;

	/* need: count + 2 desc gap to keep tail from touching
	 * head, otherwise try next time
	 */
	if (unlikely(e1000_maybe_stop_tx(netdev, tx_ring, count + 2)))
    2e0b:	83 c6 02             	add    $0x2,%esi
}

static int e1000_maybe_stop_tx(struct net_device *netdev,
			       struct e1000_tx_ring *tx_ring, int size)
{
	if (likely(E1000_DESC_UNUSED(tx_ring) >= size))
    2e0e:	39 d1                	cmp    %edx,%ecx
    2e10:	41 0f 43 47 14       	cmovae 0x14(%r15),%eax
    2e15:	83 ea 01             	sub    $0x1,%edx
    2e18:	29 ca                	sub    %ecx,%edx
    2e1a:	01 d0                	add    %edx,%eax
    2e1c:	39 f0                	cmp    %esi,%eax
    2e1e:	0f 82 d3 0e 00 00    	jb     3cf7 <e1000_xmit_frame+0x1047>
	 * head, otherwise try next time
	 */
	if (unlikely(e1000_maybe_stop_tx(netdev, tx_ring, count + 2)))
		return NETDEV_TX_BUSY;

	if (unlikely((hw->mac_type == e1000_82547) &&
    2e24:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
    2e28:	83 b8 18 0c 00 00 0d 	cmpl   $0xd,0xc18(%rax)
    2e2f:	0f 84 2b 0c 00 00    	je     3a60 <e1000_xmit_frame+0xdb0>
		if (!test_bit(__E1000_DOWN, &adapter->flags))
			schedule_delayed_work(&adapter->fifo_stall_task, 1);
		return NETDEV_TX_BUSY;
	}

	if (skb_vlan_tag_present(skb)) {
    2e35:	41 0f b7 86 aa 00 00 	movzwl 0xaa(%r14),%eax
    2e3c:	00 
	struct e1000_adapter *adapter = netdev_priv(netdev);
	struct e1000_hw *hw = &adapter->hw;
	struct e1000_tx_ring *tx_ring;
	unsigned int first, max_per_txd = E1000_MAX_DATA_PER_TXD;
	unsigned int max_txd_pwr = E1000_MAX_TXD_PWR;
	unsigned int tx_flags = 0;
    2e3d:	c7 45 98 00 00 00 00 	movl   $0x0,-0x68(%rbp)
		if (!test_bit(__E1000_DOWN, &adapter->flags))
			schedule_delayed_work(&adapter->fifo_stall_task, 1);
		return NETDEV_TX_BUSY;
	}

	if (skb_vlan_tag_present(skb)) {
    2e44:	f6 c4 10             	test   $0x10,%ah
    2e47:	74 10                	je     2e59 <e1000_xmit_frame+0x1a9>
		tx_flags |= E1000_TX_FLAGS_VLAN;
		tx_flags |= (skb_vlan_tag_get(skb) <<
    2e49:	25 ff ef 00 00       	and    $0xefff,%eax
    2e4e:	89 45 98             	mov    %eax,-0x68(%rbp)
    2e51:	c1 65 98 10          	shll   $0x10,-0x68(%rbp)
    2e55:	83 4d 98 02          	orl    $0x2,-0x68(%rbp)
			     E1000_TX_FLAGS_VLAN_SHIFT);
	}

	first = tx_ring->next_to_use;
    2e59:	41 8b 47 18          	mov    0x18(%r15),%eax
	SKB_GSO_CB(skb)->csum_start -= plen;

	return csum_fold(partial);
}

static inline bool skb_is_gso(const struct sk_buff *skb)
    2e5d:	49 8b be d0 00 00 00 	mov    0xd0(%r14),%rdi
    2e64:	89 45 90             	mov    %eax,-0x70(%rbp)
}

#ifdef NET_SKBUFF_DATA_USES_OFFSET
static inline unsigned char *skb_end_pointer(const struct sk_buff *skb)
{
	return skb->head + skb->end;
    2e67:	41 8b 86 cc 00 00 00 	mov    0xcc(%r14),%eax
    2e6e:	48 01 f8             	add    %rdi,%rax
	return csum_fold(partial);
}

static inline bool skb_is_gso(const struct sk_buff *skb)
{
	return skb_shinfo(skb)->gso_size;
    2e71:	44 0f b7 68 02       	movzwl 0x2(%rax),%r13d
	unsigned int i;
	u32 cmd_length = 0;
	u16 ipcse = 0, tucse, mss;
	u8 ipcss, ipcso, tucss, tucso, hdr_len;

	if (skb_is_gso(skb)) {
    2e76:	66 45 85 ed          	test   %r13w,%r13w
    2e7a:	0f 85 9f 07 00 00    	jne    361f <e1000_xmit_frame+0x96f>
	struct e1000_tx_buffer *buffer_info;
	unsigned int i;
	u8 css;
	u32 cmd_len = E1000_TXD_CMD_DEXT;

	if (skb->ip_summed != CHECKSUM_PARTIAL)
    2e80:	41 0f b6 86 91 00 00 	movzbl 0x91(%r14),%eax
    2e87:	00 
    2e88:	8b 5d 90             	mov    -0x70(%rbp),%ebx
    2e8b:	83 e0 06             	and    $0x6,%eax
    2e8e:	3c 06                	cmp    $0x6,%al
    2e90:	0f 84 b9 0c 00 00    	je     3b4f <e1000_xmit_frame+0xe9f>
		tx_flags |= E1000_TX_FLAGS_TSO;
	} else if (likely(e1000_tx_csum(adapter, tx_ring, skb, protocol)))
		tx_flags |= E1000_TX_FLAGS_CSUM;

	if (protocol == htons(ETH_P_IP))
		tx_flags |= E1000_TX_FLAGS_IPV4;
    2e96:	8b 4d 98             	mov    -0x68(%rbp),%ecx
    2e99:	89 c8                	mov    %ecx,%eax
    2e9b:	83 c8 08             	or     $0x8,%eax
    2e9e:	66 41 83 fc 08       	cmp    $0x8,%r12w
    2ea3:	0f 45 c1             	cmovne %ecx,%eax

	if (unlikely(skb->no_fcs))
    2ea6:	41 f6 86 92 00 00 00 	testb  $0x1,0x92(%r14)
    2ead:	01 
		tx_flags |= E1000_TX_FLAGS_TSO;
	} else if (likely(e1000_tx_csum(adapter, tx_ring, skb, protocol)))
		tx_flags |= E1000_TX_FLAGS_CSUM;

	if (protocol == htons(ETH_P_IP))
		tx_flags |= E1000_TX_FLAGS_IPV4;
    2eae:	89 45 98             	mov    %eax,-0x68(%rbp)

	if (unlikely(skb->no_fcs))
    2eb1:	0f 85 46 0d 00 00    	jne    3bfd <e1000_xmit_frame+0xf4d>
			struct sk_buff *skb, unsigned int first,
			unsigned int max_per_txd, unsigned int nr_frags,
			unsigned int mss)
{
	struct e1000_hw *hw = &adapter->hw;
	struct pci_dev *pdev = adapter->pdev;
    2eb7:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
#define E1000_MAX_TXD_PWR	12
#define E1000_MAX_DATA_PER_TXD	(1<<E1000_MAX_TXD_PWR)

static int e1000_tx_map(struct e1000_adapter *adapter,
			struct e1000_tx_ring *tx_ring,
			struct sk_buff *skb, unsigned int first,
    2ebb:	41 8b 8e 84 00 00 00 	mov    0x84(%r14),%ecx
			unsigned int max_per_txd, unsigned int nr_frags,
			unsigned int mss)
{
	struct e1000_hw *hw = &adapter->hw;
	struct pci_dev *pdev = adapter->pdev;
    2ec2:	48 8b 80 f8 0b 00 00 	mov    0xbf8(%rax),%rax
    2ec9:	48 89 c6             	mov    %rax,%rsi
    2ecc:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
	unsigned int offset = 0, size, count = 0, i;
	unsigned int f, bytecount, segs;

	i = tx_ring->next_to_use;

	while (len) {
    2ed0:	41 8b 86 80 00 00 00 	mov    0x80(%r14),%eax
    2ed7:	29 c8                	sub    %ecx,%eax
    2ed9:	89 c7                	mov    %eax,%edi
    2edb:	0f 84 49 0a 00 00    	je     392a <e1000_xmit_frame+0xc7a>
    2ee1:	44 8b 45 94          	mov    -0x6c(%rbp),%r8d
    2ee5:	44 8b 4d a8          	mov    -0x58(%rbp),%r9d
		offset += size;
		count++;
		if (len) {
			i++;
			if (unlikely(i == tx_ring->count))
				i = 0;
    2ee9:	4c 89 75 c0          	mov    %r14,-0x40(%rbp)
{
	struct e1000_hw *hw = &adapter->hw;
	struct pci_dev *pdev = adapter->pdev;
	struct e1000_tx_buffer *buffer_info;
	unsigned int len = skb_headlen(skb);
	unsigned int offset = 0, size, count = 0, i;
    2eed:	c7 45 a0 00 00 00 00 	movl   $0x0,-0x60(%rbp)
		offset += size;
		count++;
		if (len) {
			i++;
			if (unlikely(i == tx_ring->count))
				i = 0;
    2ef4:	4d 89 fe             	mov    %r15,%r14
{
	struct e1000_hw *hw = &adapter->hw;
	struct pci_dev *pdev = adapter->pdev;
	struct e1000_tx_buffer *buffer_info;
	unsigned int len = skb_headlen(skb);
	unsigned int offset = 0, size, count = 0, i;
    2ef7:	c7 45 bc 00 00 00 00 	movl   $0x0,-0x44(%rbp)
		offset += size;
		count++;
		if (len) {
			i++;
			if (unlikely(i == tx_ring->count))
				i = 0;
    2efe:	41 89 df             	mov    %ebx,%r15d
    2f01:	89 fb                	mov    %edi,%ebx
    2f03:	45 85 c0             	test   %r8d,%r8d
    2f06:	0f 94 45 9c          	sete   -0x64(%rbp)
    2f0a:	45 85 c9             	test   %r9d,%r9d
    2f0d:	0f 95 c0             	setne  %al
    2f10:	20 45 9c             	and    %al,-0x64(%rbp)
    2f13:	48 89 f0             	mov    %rsi,%rax
    2f16:	48 05 98 00 00 00    	add    $0x98,%rax
    2f1c:	48 89 45 b0          	mov    %rax,-0x50(%rbp)
    2f20:	0f 94 45 b8          	sete   -0x48(%rbp)

	i = tx_ring->next_to_use;

	while (len) {
		buffer_info = &tx_ring->buffer_info[i];
		size = min(len, max_per_txd);
    2f24:	44 8b 6d ac          	mov    -0x54(%rbp),%r13d
	unsigned int f, bytecount, segs;

	i = tx_ring->next_to_use;

	while (len) {
		buffer_info = &tx_ring->buffer_info[i];
    2f28:	44 89 f8             	mov    %r15d,%eax
    2f2b:	48 8d 14 80          	lea    (%rax,%rax,4),%rdx
    2f2f:	49 8b 46 20          	mov    0x20(%r14),%rax
		size = min(len, max_per_txd);
    2f33:	44 39 eb             	cmp    %r13d,%ebx
    2f36:	44 0f 46 eb          	cmovbe %ebx,%r13d
		/* Workaround for Controller erratum --
		 * descriptor for non-tso packet in a linear SKB that follows a
		 * tso gets written back prematurely before the data is fully
		 * DMA'd to the controller
		 */
		if (!skb->data_len && tx_ring->last_tx_tso &&
    2f3a:	85 c9                	test   %ecx,%ecx
	unsigned int f, bytecount, segs;

	i = tx_ring->next_to_use;

	while (len) {
		buffer_info = &tx_ring->buffer_info[i];
    2f3c:	4c 8d 24 d0          	lea    (%rax,%rdx,8),%r12
		/* Workaround for Controller erratum --
		 * descriptor for non-tso packet in a linear SKB that follows a
		 * tso gets written back prematurely before the data is fully
		 * DMA'd to the controller
		 */
		if (!skb->data_len && tx_ring->last_tx_tso &&
    2f40:	75 29                	jne    2f6b <e1000_xmit_frame+0x2bb>
    2f42:	41 80 7e 2c 00       	cmpb   $0x0,0x2c(%r14)
    2f47:	74 22                	je     2f6b <e1000_xmit_frame+0x2bb>
}

#ifdef NET_SKBUFF_DATA_USES_OFFSET
static inline unsigned char *skb_end_pointer(const struct sk_buff *skb)
{
	return skb->head + skb->end;
    2f49:	48 8b 4d c0          	mov    -0x40(%rbp),%rcx
    2f4d:	8b 81 cc 00 00 00    	mov    0xcc(%rcx),%eax
	return csum_fold(partial);
}

static inline bool skb_is_gso(const struct sk_buff *skb)
{
	return skb_shinfo(skb)->gso_size;
    2f53:	48 8b 91 d0 00 00 00 	mov    0xd0(%rcx),%rdx
    2f5a:	66 83 7c 02 02 00    	cmpw   $0x0,0x2(%rdx,%rax,1)
    2f60:	75 09                	jne    2f6b <e1000_xmit_frame+0x2bb>
		    !skb_is_gso(skb)) {
			tx_ring->last_tx_tso = false;
    2f62:	41 c6 46 2c 00       	movb   $0x0,0x2c(%r14)
			size -= 4;
    2f67:	41 83 ed 04          	sub    $0x4,%r13d
		}

		/* Workaround for premature desc write-backs
		 * in TSO mode.  Append 4-byte sentinel desc
		 */
		if (unlikely(mss && !nr_frags && size == len && size > 8))
    2f6b:	80 7d 9c 00          	cmpb   $0x0,-0x64(%rbp)
    2f6f:	0f 85 1c 0a 00 00    	jne    3991 <e1000_xmit_frame+0xce1>
		/* work-around for errata 10 and it applies
		 * to all controllers in PCI-X mode
		 * The fix is to make sure that the first descriptor of a
		 * packet is smaller than 2048 - 16 - 16 (or 2016) bytes
		 */
		if (unlikely((hw->bus_type == e1000_bus_type_pcix) &&
    2f75:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
    2f79:	83 b8 4c 0c 00 00 02 	cmpl   $0x2,0xc4c(%rax)
    2f80:	0f 84 27 0a 00 00    	je     39ad <e1000_xmit_frame+0xcfd>
    2f86:	44 89 e9             	mov    %r13d,%ecx
		        size = 2015;

		/* Workaround for potential 82544 hang in PCI-X.  Avoid
		 * terminating buffers within evenly-aligned dwords.
		 */
		if (unlikely(adapter->pcix_82544 &&
    2f89:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
    2f8d:	8b 75 a0             	mov    -0x60(%rbp),%esi
    2f90:	80 b8 d0 0a 00 00 00 	cmpb   $0x0,0xad0(%rax)
    2f97:	0f 85 38 0a 00 00    	jne    39d5 <e1000_xmit_frame+0xd25>
		   size > 4))
			size -= 4;

		buffer_info->length = size;
		/* set time_stamp *before* dma to help avoid a possible race */
		buffer_info->time_stamp = jiffies;
    2f9d:	48 8b 05 00 00 00 00 	mov    0x0(%rip),%rax        # 2fa4 <e1000_xmit_frame+0x2f4>
		if (unlikely(adapter->pcix_82544 &&
		   !((unsigned long)(skb->data + offset + size - 1) & 4) &&
		   size > 4))
			size -= 4;

		buffer_info->length = size;
    2fa4:	66 45 89 6c 24 18    	mov    %r13w,0x18(%r12)
		/* set time_stamp *before* dma to help avoid a possible race */
		buffer_info->time_stamp = jiffies;
		buffer_info->mapped_as_page = false;
    2faa:	41 c6 44 24 1c 00    	movb   $0x0,0x1c(%r12)
		   size > 4))
			size -= 4;

		buffer_info->length = size;
		/* set time_stamp *before* dma to help avoid a possible race */
		buffer_info->time_stamp = jiffies;
    2fb0:	49 89 44 24 10       	mov    %rax,0x10(%r12)
		buffer_info->mapped_as_page = false;
		buffer_info->dma = dma_map_single(&pdev->dev,
    2fb5:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
    2fb9:	48 03 b0 d8 00 00 00 	add    0xd8(%rax),%rsi
static inline struct dma_map_ops *get_dma_ops(struct device *dev)
{
#ifndef CONFIG_X86_DEV_DMA_OPS
	return dma_ops;
#else
	if (unlikely(!dev) || !dev->archdata.dma_ops)
    2fc0:	80 7d b8 00          	cmpb   $0x0,-0x48(%rbp)
    2fc4:	0f 85 af 04 00 00    	jne    3479 <e1000_xmit_frame+0x7c9>
    2fca:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
    2fce:	48 8b 80 e8 02 00 00 	mov    0x2e8(%rax),%rax
    2fd5:	48 85 c0             	test   %rax,%rax
    2fd8:	0f 84 9b 04 00 00    	je     3479 <e1000_xmit_frame+0x7c9>
	struct dma_map_ops *ops = get_dma_ops(dev);
	dma_addr_t addr;

	kmemcheck_mark_initialized(ptr, size);
	BUG_ON(!valid_dma_direction(dir));
	addr = ops->map_page(dev, virt_to_page(ptr),
    2fde:	48 89 f2             	mov    %rsi,%rdx
    2fe1:	bf 00 00 00 80       	mov    $0x80000000,%edi
    2fe6:	41 b8 01 00 00 00    	mov    $0x1,%r8d
    2fec:	81 e2 ff 0f 00 00    	and    $0xfff,%edx
    2ff2:	48 01 fe             	add    %rdi,%rsi
    2ff5:	48 bf 00 00 00 80 ff 	movabs $0x77ff80000000,%rdi
    2ffc:	77 00 00 
    2fff:	48 0f 42 3d 00 00 00 	cmovb  0x0(%rip),%rdi        # 3007 <e1000_xmit_frame+0x357>
    3006:	00 
    3007:	45 31 c9             	xor    %r9d,%r9d
    300a:	48 01 fe             	add    %rdi,%rsi
    300d:	48 bf 00 00 00 00 00 	movabs $0xffffea0000000000,%rdi
    3014:	ea ff ff 
    3017:	48 c1 ee 0c          	shr    $0xc,%rsi
    301b:	48 c1 e6 06          	shl    $0x6,%rsi
    301f:	48 01 fe             	add    %rdi,%rsi
    3022:	48 8b 7d b0          	mov    -0x50(%rbp),%rdi
    3026:	ff 50 20             	callq  *0x20(%rax)
    3029:	80 7d b8 00          	cmpb   $0x0,-0x48(%rbp)
    302d:	49 89 44 24 08       	mov    %rax,0x8(%r12)
    3032:	0f 85 4d 04 00 00    	jne    3485 <e1000_xmit_frame+0x7d5>
    3038:	48 8b 4d d0          	mov    -0x30(%rbp),%rcx
    303c:	48 8b 91 e8 02 00 00 	mov    0x2e8(%rcx),%rdx
    3043:	48 85 d2             	test   %rdx,%rdx
    3046:	0f 84 39 04 00 00    	je     3485 <e1000_xmit_frame+0x7d5>

static inline int dma_mapping_error(struct device *dev, dma_addr_t dma_addr)
{
	debug_dma_mapping_error(dev, dma_addr);

	if (get_dma_ops(dev)->mapping_error)
    304c:	48 83 7a 60 00       	cmpq   $0x0,0x60(%rdx)
    3051:	0f 84 42 04 00 00    	je     3499 <e1000_xmit_frame+0x7e9>
    3057:	48 8b 52 60          	mov    0x60(%rdx),%rdx
		return get_dma_ops(dev)->mapping_error(dev, dma_addr);
    305b:	48 89 c6             	mov    %rax,%rsi
    305e:	48 8b 7d b0          	mov    -0x50(%rbp),%rdi
    3062:	ff d2                	callq  *%rdx
						  skb->data + offset,
						  size, DMA_TO_DEVICE);
		if (dma_mapping_error(&pdev->dev, buffer_info->dma))
    3064:	85 c0                	test   %eax,%eax
    3066:	0f 85 3e 04 00 00    	jne    34aa <e1000_xmit_frame+0x7fa>
			goto dma_error;
		buffer_info->next_to_watch = i;

		len -= size;
		offset += size;
		count++;
    306c:	83 45 bc 01          	addl   $0x1,-0x44(%rbp)
		if (len) {
    3070:	44 29 eb             	sub    %r13d,%ebx
		buffer_info->dma = dma_map_single(&pdev->dev,
						  skb->data + offset,
						  size, DMA_TO_DEVICE);
		if (dma_mapping_error(&pdev->dev, buffer_info->dma))
			goto dma_error;
		buffer_info->next_to_watch = i;
    3073:	66 45 89 7c 24 1a    	mov    %r15w,0x1a(%r12)

		len -= size;
		offset += size;
		count++;
		if (len) {
    3079:	74 7b                	je     30f6 <e1000_xmit_frame+0x446>
			i++;
    307b:	41 83 c7 01          	add    $0x1,%r15d
			if (unlikely(i == tx_ring->count))
				i = 0;
    307f:	45 3b 7e 14          	cmp    0x14(%r14),%r15d
    3083:	44 0f 44 f8          	cmove  %eax,%r15d
    3087:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
		if (dma_mapping_error(&pdev->dev, buffer_info->dma))
			goto dma_error;
		buffer_info->next_to_watch = i;

		len -= size;
		offset += size;
    308b:	44 01 6d a0          	add    %r13d,-0x60(%rbp)
    308f:	8b 88 84 00 00 00    	mov    0x84(%rax),%ecx
    3095:	e9 8a fe ff ff       	jmpq   2f24 <e1000_xmit_frame+0x274>
	/* if type is 802.1Q/AD then the header should already be
	 * present at mac_len - VLAN_HLEN (if mac_len > 0), or at
	 * ETH_HLEN otherwise
	 */
	if (type == htons(ETH_P_8021Q) || type == htons(ETH_P_8021AD)) {
		if (vlan_depth) {
    309a:	85 db                	test   %ebx,%ebx
    309c:	75 4a                	jne    30e8 <e1000_xmit_frame+0x438>
			if (WARN_ON(vlan_depth < VLAN_HLEN))
				return 0;
			vlan_depth -= VLAN_HLEN;
		} else {
			vlan_depth = ETH_HLEN;
    309e:	bb 0e 00 00 00       	mov    $0xe,%ebx
    30a3:	45 89 d7             	mov    %r10d,%r15d
    30a6:	eb 0a                	jmp    30b2 <e1000_xmit_frame+0x402>
    30a8:	41 8b 86 84 00 00 00 	mov    0x84(%r14),%eax
		}
		do {
			struct vlan_hdr *vh;

			if (unlikely(!pskb_may_pull(skb,
    30af:	44 89 eb             	mov    %r13d,%ebx
    30b2:	44 8d 6b 04          	lea    0x4(%rbx),%r13d
	return skb->data_len;
}

static inline unsigned int skb_headlen(const struct sk_buff *skb)
{
	return skb->len - skb->data_len;
    30b6:	89 d7                	mov    %edx,%edi
    30b8:	29 c7                	sub    %eax,%edi
	return unlikely(len > skb->len) ? NULL : __pskb_pull(skb, len);
}

static inline int pskb_may_pull(struct sk_buff *skb, unsigned int len)
{
	if (likely(len <= skb_headlen(skb)))
    30ba:	41 39 fd             	cmp    %edi,%r13d
    30bd:	0f 87 92 08 00 00    	ja     3955 <e1000_xmit_frame+0xca5>
						    vlan_depth + VLAN_HLEN)))
				return 0;

			vh = (struct vlan_hdr *)(skb->data + vlan_depth);
			type = vh->h_vlan_encapsulated_proto;
    30c3:	49 8b 86 d8 00 00 00 	mov    0xd8(%r14),%rax
    30ca:	44 0f b7 64 18 02    	movzwl 0x2(%rax,%rbx,1),%r12d
			vlan_depth += VLAN_HLEN;
		} while (type == htons(ETH_P_8021Q) ||
			 type == htons(ETH_P_8021AD));
    30d0:	66 41 81 fc 88 a8    	cmp    $0xa888,%r12w
    30d6:	74 d0                	je     30a8 <e1000_xmit_frame+0x3f8>
    30d8:	66 41 81 fc 81 00    	cmp    $0x81,%r12w
    30de:	74 c8                	je     30a8 <e1000_xmit_frame+0x3f8>
    30e0:	45 89 fa             	mov    %r15d,%r10d
    30e3:	e9 1e fc ff ff       	jmpq   2d06 <e1000_xmit_frame+0x56>
	 * present at mac_len - VLAN_HLEN (if mac_len > 0), or at
	 * ETH_HLEN otherwise
	 */
	if (type == htons(ETH_P_8021Q) || type == htons(ETH_P_8021AD)) {
		if (vlan_depth) {
			if (WARN_ON(vlan_depth < VLAN_HLEN))
    30e8:	83 fb 03             	cmp    $0x3,%ebx
    30eb:	0f 86 85 0b 00 00    	jbe    3c76 <e1000_xmit_frame+0xfc6>
				return 0;
			vlan_depth -= VLAN_HLEN;
    30f1:	83 eb 04             	sub    $0x4,%ebx
    30f4:	eb ad                	jmp    30a3 <e1000_xmit_frame+0x3f3>
    30f6:	44 89 fb             	mov    %r15d,%ebx
    30f9:	4d 89 f7             	mov    %r14,%r15
    30fc:	4c 8b 75 c0          	mov    -0x40(%rbp),%r14
			if (unlikely(i == tx_ring->count))
				i = 0;
		}
	}

	for (f = 0; f < nr_frags; f++) {
    3100:	8b 75 94             	mov    -0x6c(%rbp),%esi
    3103:	85 f6                	test   %esi,%esi
    3105:	0f 84 2b 08 00 00    	je     3936 <e1000_xmit_frame+0xc86>
			buffer_info = &tx_ring->buffer_info[i];
			size = min(len, max_per_txd);
			/* Workaround for premature desc write-backs
			 * in TSO mode.  Append 4-byte sentinel desc
			 */
			if (unlikely(mss && f == (nr_frags-1) &&
    310b:	8b 75 94             	mov    -0x6c(%rbp),%esi
    310e:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
    3112:	49 8b 8e d0 00 00 00 	mov    0xd0(%r14),%rcx
    3119:	41 8b 96 cc 00 00 00 	mov    0xcc(%r14),%edx
    3120:	4c 89 7d c0          	mov    %r15,-0x40(%rbp)
    3124:	4c 89 75 88          	mov    %r14,-0x78(%rbp)
    3128:	41 89 de             	mov    %ebx,%r14d
    312b:	8d 7e ff             	lea    -0x1(%rsi),%edi
    312e:	48 05 98 00 00 00    	add    $0x98,%rax
			if (unlikely(i == tx_ring->count))
				i = 0;
		}
	}

	for (f = 0; f < nr_frags; f++) {
    3134:	c7 45 9c 00 00 00 00 	movl   $0x0,-0x64(%rbp)
			buffer_info = &tx_ring->buffer_info[i];
			size = min(len, max_per_txd);
			/* Workaround for premature desc write-backs
			 * in TSO mode.  Append 4-byte sentinel desc
			 */
			if (unlikely(mss && f == (nr_frags-1) &&
    313b:	49 89 c7             	mov    %rax,%r15
    313e:	89 7d 84             	mov    %edi,-0x7c(%rbp)
	}

	for (f = 0; f < nr_frags; f++) {
		const struct skb_frag_struct *frag;

		frag = &skb_shinfo(skb)->frags[f];
    3141:	8b 5d 9c             	mov    -0x64(%rbp),%ebx
}

#ifdef NET_SKBUFF_DATA_USES_OFFSET
static inline unsigned char *skb_end_pointer(const struct sk_buff *skb)
{
	return skb->head + skb->end;
    3144:	48 8d 04 11          	lea    (%rcx,%rdx,1),%rax
    3148:	48 83 c3 03          	add    $0x3,%rbx
    314c:	48 c1 e3 04          	shl    $0x4,%rbx
    3150:	48 8d 34 18          	lea    (%rax,%rbx,1),%rsi
				i = 0;
		}
	}

	for (f = 0; f < nr_frags; f++) {
		const struct skb_frag_struct *frag;
    3154:	44 8b 6e 0c          	mov    0xc(%rsi),%r13d

		frag = &skb_shinfo(skb)->frags[f];
    3158:	48 89 75 a0          	mov    %rsi,-0x60(%rbp)
		len = skb_frag_size(frag);
		offset = 0;

		while (len) {
    315c:	45 85 ed             	test   %r13d,%r13d
    315f:	0f 84 0f 01 00 00    	je     3274 <e1000_xmit_frame+0x5c4>
    3165:	4c 89 7d b0          	mov    %r15,-0x50(%rbp)
	for (f = 0; f < nr_frags; f++) {
		const struct skb_frag_struct *frag;

		frag = &skb_shinfo(skb)->frags[f];
		len = skb_frag_size(frag);
		offset = 0;
    3169:	c7 45 b8 00 00 00 00 	movl   $0x0,-0x48(%rbp)

		while (len) {
			unsigned long bufend;
			i++;
			if (unlikely(i == tx_ring->count))
    3170:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
		len = skb_frag_size(frag);
		offset = 0;

		while (len) {
			unsigned long bufend;
			i++;
    3174:	41 83 c6 01          	add    $0x1,%r14d
			if (unlikely(i == tx_ring->count))
    3178:	44 3b 70 14          	cmp    0x14(%rax),%r14d
    317c:	0f 84 04 08 00 00    	je     3986 <e1000_xmit_frame+0xcd6>
    3182:	44 89 f0             	mov    %r14d,%eax
    3185:	4c 8d 24 80          	lea    (%rax,%rax,4),%r12
    3189:	49 c1 e4 03          	shl    $0x3,%r12
				i = 0;

			buffer_info = &tx_ring->buffer_info[i];
			size = min(len, max_per_txd);
    318d:	8b 5d ac             	mov    -0x54(%rbp),%ebx
			unsigned long bufend;
			i++;
			if (unlikely(i == tx_ring->count))
				i = 0;

			buffer_info = &tx_ring->buffer_info[i];
    3190:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
			size = min(len, max_per_txd);
			/* Workaround for premature desc write-backs
			 * in TSO mode.  Append 4-byte sentinel desc
			 */
			if (unlikely(mss && f == (nr_frags-1) &&
    3194:	8b 4d a8             	mov    -0x58(%rbp),%ecx
			unsigned long bufend;
			i++;
			if (unlikely(i == tx_ring->count))
				i = 0;

			buffer_info = &tx_ring->buffer_info[i];
    3197:	4c 03 60 20          	add    0x20(%rax),%r12
			size = min(len, max_per_txd);
    319b:	41 39 dd             	cmp    %ebx,%r13d
    319e:	41 0f 46 dd          	cmovbe %r13d,%ebx
			/* Workaround for premature desc write-backs
			 * in TSO mode.  Append 4-byte sentinel desc
			 */
			if (unlikely(mss && f == (nr_frags-1) &&
    31a2:	85 c9                	test   %ecx,%ecx
    31a4:	0f 85 59 08 00 00    	jne    3a03 <e1000_xmit_frame+0xd53>
			 * dwords.
			 */
			bufend = (unsigned long)
				page_to_phys(skb_frag_page(frag));
			bufend += offset + size - 1;
			if (unlikely(adapter->pcix_82544 &&
    31aa:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
    31ae:	80 b8 d0 0a 00 00 00 	cmpb   $0x0,0xad0(%rax)
    31b5:	0f 85 6e 08 00 00    	jne    3a29 <e1000_xmit_frame+0xd79>
				     !(bufend & 4) &&
				     size > 4))
				size -= 4;

			buffer_info->length = size;
			buffer_info->time_stamp = jiffies;
    31bb:	48 8b 05 00 00 00 00 	mov    0x0(%rip),%rax        # 31c2 <e1000_xmit_frame+0x512>
static inline dma_addr_t skb_frag_dma_map(struct device *dev,
					  const skb_frag_t *frag,
					  size_t offset, size_t size,
					  enum dma_data_direction dir)
{
	return dma_map_page(dev, skb_frag_page(frag),
    31c2:	48 8b 7d a0          	mov    -0x60(%rbp),%rdi
			buffer_info->mapped_as_page = true;
			buffer_info->dma = skb_frag_dma_map(&pdev->dev, frag,
    31c6:	89 d9                	mov    %ebx,%ecx
			if (unlikely(adapter->pcix_82544 &&
				     !(bufend & 4) &&
				     size > 4))
				size -= 4;

			buffer_info->length = size;
    31c8:	66 41 89 5c 24 18    	mov    %bx,0x18(%r12)
			buffer_info->time_stamp = jiffies;
			buffer_info->mapped_as_page = true;
    31ce:	41 c6 44 24 1c 01    	movb   $0x1,0x1c(%r12)
			buffer_info->dma = skb_frag_dma_map(&pdev->dev, frag,
    31d4:	8b 55 b8             	mov    -0x48(%rbp),%edx
				     !(bufend & 4) &&
				     size > 4))
				size -= 4;

			buffer_info->length = size;
			buffer_info->time_stamp = jiffies;
    31d7:	49 89 44 24 10       	mov    %rax,0x10(%r12)
    31dc:	8b 47 08             	mov    0x8(%rdi),%eax
 * @dir: the direction of the mapping (%PCI_DMA_*)
 *
 * Maps the page associated with @frag to @device.
 */
static inline dma_addr_t skb_frag_dma_map(struct device *dev,
					  const skb_frag_t *frag,
    31df:	48 8b 37             	mov    (%rdi),%rsi
					  size_t offset, size_t size,
					  enum dma_data_direction dir)
{
	return dma_map_page(dev, skb_frag_page(frag),
    31e2:	48 01 c2             	add    %rax,%rdx
    31e5:	4d 85 ff             	test   %r15,%r15
    31e8:	0f 84 b7 03 00 00    	je     35a5 <e1000_xmit_frame+0x8f5>
    31ee:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
    31f2:	48 8b 80 e8 02 00 00 	mov    0x2e8(%rax),%rax
    31f9:	48 85 c0             	test   %rax,%rax
    31fc:	0f 84 68 03 00 00    	je     356a <e1000_xmit_frame+0x8ba>
	struct dma_map_ops *ops = get_dma_ops(dev);
	dma_addr_t addr;

	kmemcheck_mark_initialized(page_address(page) + offset, size);
	BUG_ON(!valid_dma_direction(dir));
	addr = ops->map_page(dev, page, offset, size, dir, NULL);
    3202:	45 31 c9             	xor    %r9d,%r9d
    3205:	41 b8 01 00 00 00    	mov    $0x1,%r8d
    320b:	4c 89 ff             	mov    %r15,%rdi
    320e:	ff 50 20             	callq  *0x20(%rax)
    3211:	48 8b 4d d0          	mov    -0x30(%rbp),%rcx
			buffer_info->mapped_as_page = true;
			buffer_info->dma = skb_frag_dma_map(&pdev->dev, frag,
    3215:	49 89 44 24 08       	mov    %rax,0x8(%r12)
    321a:	48 8b 91 e8 02 00 00 	mov    0x2e8(%rcx),%rdx
    3221:	48 85 d2             	test   %rdx,%rdx
    3224:	0f 84 6f 03 00 00    	je     3599 <e1000_xmit_frame+0x8e9>

static inline int dma_mapping_error(struct device *dev, dma_addr_t dma_addr)
{
	debug_dma_mapping_error(dev, dma_addr);

	if (get_dma_ops(dev)->mapping_error)
    322a:	48 83 7a 60 00       	cmpq   $0x0,0x60(%rdx)
    322f:	0f 84 9e 03 00 00    	je     35d3 <e1000_xmit_frame+0x923>
    3235:	48 8b 52 60          	mov    0x60(%rdx),%rdx
		return get_dma_ops(dev)->mapping_error(dev, dma_addr);
    3239:	48 89 c6             	mov    %rax,%rsi
    323c:	4c 89 ff             	mov    %r15,%rdi
    323f:	ff d2                	callq  *%rdx
						offset, size, DMA_TO_DEVICE);
			if (dma_mapping_error(&pdev->dev, buffer_info->dma))
    3241:	85 c0                	test   %eax,%eax
    3243:	0f 85 9b 03 00 00    	jne    35e4 <e1000_xmit_frame+0x934>
				goto dma_error;
			buffer_info->next_to_watch = i;

			len -= size;
			offset += size;
    3249:	01 5d b8             	add    %ebx,-0x48(%rbp)
			count++;
    324c:	83 45 bc 01          	addl   $0x1,-0x44(%rbp)

		frag = &skb_shinfo(skb)->frags[f];
		len = skb_frag_size(frag);
		offset = 0;

		while (len) {
    3250:	41 29 dd             	sub    %ebx,%r13d
			buffer_info->mapped_as_page = true;
			buffer_info->dma = skb_frag_dma_map(&pdev->dev, frag,
						offset, size, DMA_TO_DEVICE);
			if (dma_mapping_error(&pdev->dev, buffer_info->dma))
				goto dma_error;
			buffer_info->next_to_watch = i;
    3253:	66 45 89 74 24 1a    	mov    %r14w,0x1a(%r12)

		frag = &skb_shinfo(skb)->frags[f];
		len = skb_frag_size(frag);
		offset = 0;

		while (len) {
    3259:	0f 85 11 ff ff ff    	jne    3170 <e1000_xmit_frame+0x4c0>
    325f:	48 8b 45 88          	mov    -0x78(%rbp),%rax
    3263:	8b 90 cc 00 00 00    	mov    0xcc(%rax),%edx
    3269:	48 8b 88 d0 00 00 00 	mov    0xd0(%rax),%rcx
    3270:	48 8d 04 11          	lea    (%rcx,%rdx,1),%rax
			if (unlikely(i == tx_ring->count))
				i = 0;
		}
	}

	for (f = 0; f < nr_frags; f++) {
    3274:	83 45 9c 01          	addl   $0x1,-0x64(%rbp)
    3278:	8b 7d 9c             	mov    -0x64(%rbp),%edi
    327b:	39 7d 94             	cmp    %edi,-0x6c(%rbp)
    327e:	0f 87 bd fe ff ff    	ja     3141 <e1000_xmit_frame+0x491>
    3284:	44 89 f3             	mov    %r14d,%ebx
    3287:	4c 8b 7d c0          	mov    -0x40(%rbp),%r15
    328b:	4c 8b 75 88          	mov    -0x78(%rbp),%r14
			offset += size;
			count++;
		}
	}

	segs = skb_shinfo(skb)->gso_segs ?: 1;
    328f:	0f b7 50 04          	movzwl 0x4(%rax),%edx
    3293:	66 85 d2             	test   %dx,%dx
    3296:	0f 84 ad 06 00 00    	je     3949 <e1000_xmit_frame+0xc99>
    329c:	0f b7 f2             	movzwl %dx,%esi
    329f:	83 ee 01             	sub    $0x1,%esi
#define E1000_MAX_TXD_PWR	12
#define E1000_MAX_DATA_PER_TXD	(1<<E1000_MAX_TXD_PWR)

static int e1000_tx_map(struct e1000_adapter *adapter,
			struct e1000_tx_ring *tx_ring,
			struct sk_buff *skb, unsigned int first,
    32a2:	41 8b 86 80 00 00 00 	mov    0x80(%r14),%eax
	return skb->data_len;
}

static inline unsigned int skb_headlen(const struct sk_buff *skb)
{
	return skb->len - skb->data_len;
    32a9:	89 c1                	mov    %eax,%ecx
    32ab:	41 2b 8e 84 00 00 00 	sub    0x84(%r14),%ecx
		}
	}

	segs = skb_shinfo(skb)->gso_segs ?: 1;
	/* multiply data chunks by size of headers */
	bytecount = ((segs - 1) * skb_headlen(skb)) + skb->len;
    32b2:	0f af ce             	imul   %esi,%ecx

	tx_ring->buffer_info[i].skb = skb;
    32b5:	49 8b 77 20          	mov    0x20(%r15),%rsi
		}
	}

	segs = skb_shinfo(skb)->gso_segs ?: 1;
	/* multiply data chunks by size of headers */
	bytecount = ((segs - 1) * skb_headlen(skb)) + skb->len;
    32b9:	01 c1                	add    %eax,%ecx

	tx_ring->buffer_info[i].skb = skb;
    32bb:	89 d8                	mov    %ebx,%eax
    32bd:	48 8d 04 80          	lea    (%rax,%rax,4),%rax
    32c1:	48 c1 e0 03          	shl    $0x3,%rax
    32c5:	4c 89 34 06          	mov    %r14,(%rsi,%rax,1)
	tx_ring->buffer_info[i].segs = segs;
    32c9:	49 8b 77 20          	mov    0x20(%r15),%rsi
    32cd:	66 89 54 06 1e       	mov    %dx,0x1e(%rsi,%rax,1)
	tx_ring->buffer_info[i].bytecount = bytecount;
    32d2:	49 8b 57 20          	mov    0x20(%r15),%rdx
    32d6:	89 4c 02 20          	mov    %ecx,0x20(%rdx,%rax,1)
	tx_ring->buffer_info[first].next_to_watch = i;
    32da:	8b 45 90             	mov    -0x70(%rbp),%eax
		tx_flags |= E1000_TX_FLAGS_NO_FCS;

	count = e1000_tx_map(adapter, tx_ring, skb, first, max_per_txd,
			     nr_frags, mss);

	if (count) {
    32dd:	8b 55 bc             	mov    -0x44(%rbp),%edx
	bytecount = ((segs - 1) * skb_headlen(skb)) + skb->len;

	tx_ring->buffer_info[i].skb = skb;
	tx_ring->buffer_info[i].segs = segs;
	tx_ring->buffer_info[i].bytecount = bytecount;
	tx_ring->buffer_info[first].next_to_watch = i;
    32e0:	4c 8d 24 80          	lea    (%rax,%rax,4),%r12
    32e4:	49 8b 47 20          	mov    0x20(%r15),%rax
    32e8:	49 c1 e4 03          	shl    $0x3,%r12
		tx_flags |= E1000_TX_FLAGS_NO_FCS;

	count = e1000_tx_map(adapter, tx_ring, skb, first, max_per_txd,
			     nr_frags, mss);

	if (count) {
    32ec:	85 d2                	test   %edx,%edx
	bytecount = ((segs - 1) * skb_headlen(skb)) + skb->len;

	tx_ring->buffer_info[i].skb = skb;
	tx_ring->buffer_info[i].segs = segs;
	tx_ring->buffer_info[i].bytecount = bytecount;
	tx_ring->buffer_info[first].next_to_watch = i;
    32ee:	66 42 89 5c 20 1a    	mov    %bx,0x1a(%rax,%r12,1)
		tx_flags |= E1000_TX_FLAGS_NO_FCS;

	count = e1000_tx_map(adapter, tx_ring, skb, first, max_per_txd,
			     nr_frags, mss);

	if (count) {
    32f4:	0f 84 3e 02 00 00    	je     3538 <e1000_xmit_frame+0x888>
		netdev_sent_queue(netdev, skb->len);
    32fa:	41 8b 96 80 00 00 00 	mov    0x80(%r14),%edx
 *
 * 	Report the number of bytes queued for sending/completion to the network
 * 	device hardware queue. @bytes should be a good approximation and should
 * 	exactly match netdev_completed_queue() @bytes
 */
static inline void netdev_sent_queue(struct net_device *dev, unsigned int bytes)
    3301:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
 * Record number of objects queued. Assumes that caller has already checked
 * availability in the queue with dql_avail.
 */
static inline void dql_queued(struct dql *dql, unsigned int count)
{
	BUG_ON(count > DQL_MAX_OBJECT);
    3305:	81 fa ff ff ff 0f    	cmp    $0xfffffff,%edx
    330b:	48 8b 80 c0 03 00 00 	mov    0x3c0(%rax),%rax
    3312:	0f 87 35 08 00 00    	ja     3b4d <e1000_xmit_frame+0xe9d>

	dql->last_obj_cnt = count;
    3318:	89 90 c8 00 00 00    	mov    %edx,0xc8(%rax)
	 * in Shared state, but directly does a Request For Ownership
	 * It is only a hint, we use barrier() only.
	 */
	barrier();

	dql->num_queued += count;
    331e:	01 90 c0 00 00 00    	add    %edx,0xc0(%rax)
}

/* Returns how many objects can be queued, < 0 indicates over limit. */
static inline int dql_avail(const struct dql *dql)
{
	return ACCESS_ONCE(dql->adj_limit) - ACCESS_ONCE(dql->num_queued);
    3324:	8b 88 c4 00 00 00    	mov    0xc4(%rax),%ecx
    332a:	8b 90 c0 00 00 00    	mov    0xc0(%rax),%edx
					unsigned int bytes)
{
#ifdef CONFIG_BQL
	dql_queued(&dev_queue->dql, bytes);

	if (likely(dql_avail(&dev_queue->dql) >= 0))
    3330:	39 d1                	cmp    %edx,%ecx
    3332:	0f 88 e9 07 00 00    	js     3b21 <e1000_xmit_frame+0xe71>
}

#ifdef NET_SKBUFF_DATA_USES_OFFSET
static inline unsigned char *skb_end_pointer(const struct sk_buff *skb)
{
	return skb->head + skb->end;
    3338:	41 8b 86 cc 00 00 00 	mov    0xcc(%r14),%eax
void skb_tstamp_tx(struct sk_buff *orig_skb,
		   struct skb_shared_hwtstamps *hwtstamps);

static inline void sw_tx_timestamp(struct sk_buff *skb)
{
	if (skb_shinfo(skb)->tx_flags & SKBTX_SW_TSTAMP &&
    333f:	49 8b 96 d0 00 00 00 	mov    0xd0(%r14),%rdx
    3346:	0f b6 44 02 01       	movzbl 0x1(%rdx,%rax,1),%eax
    334b:	a8 02                	test   $0x2,%al
    334d:	74 0e                	je     335d <e1000_xmit_frame+0x6ad>
    334f:	a8 04                	test   $0x4,%al
    3351:	75 0a                	jne    335d <e1000_xmit_frame+0x6ad>
	    !(skb_shinfo(skb)->tx_flags & SKBTX_IN_PROGRESS))
		skb_tstamp_tx(skb, NULL);
    3353:	31 f6                	xor    %esi,%esi
    3355:	4c 89 f7             	mov    %r14,%rdi
    3358:	e8 00 00 00 00       	callq  335d <e1000_xmit_frame+0x6ad>
	struct e1000_tx_desc *tx_desc = NULL;
	struct e1000_tx_buffer *buffer_info;
	u32 txd_upper = 0, txd_lower = E1000_TXD_CMD_IFCS;
	unsigned int i;

	if (likely(tx_flags & E1000_TX_FLAGS_TSO)) {
    335d:	8b 45 98             	mov    -0x68(%rbp),%eax
    3360:	a8 04                	test   $0x4,%al
    3362:	0f 84 db 09 00 00    	je     3d43 <e1000_xmit_frame+0x1093>
		txd_lower |= E1000_TXD_CMD_DEXT | E1000_TXD_DTYP_D |
			     E1000_TXD_CMD_TSE;
		txd_upper |= E1000_TXD_POPTS_TXSM << 8;

		if (likely(tx_flags & E1000_TX_FLAGS_IPV4))
    3368:	83 e0 08             	and    $0x8,%eax
	struct e1000_tx_buffer *buffer_info;
	u32 txd_upper = 0, txd_lower = E1000_TXD_CMD_IFCS;
	unsigned int i;

	if (likely(tx_flags & E1000_TX_FLAGS_TSO)) {
		txd_lower |= E1000_TXD_CMD_DEXT | E1000_TXD_DTYP_D |
    336b:	41 b9 00 00 10 26    	mov    $0x26100000,%r9d
    3371:	83 f8 01             	cmp    $0x1,%eax
    3374:	45 19 c0             	sbb    %r8d,%r8d
    3377:	41 80 e0 00          	and    $0x0,%r8b
    337b:	41 81 c0 00 03 00 00 	add    $0x300,%r8d

		if (likely(tx_flags & E1000_TX_FLAGS_IPV4))
			txd_upper |= E1000_TXD_POPTS_IXSM << 8;
	}

	if (likely(tx_flags & E1000_TX_FLAGS_CSUM)) {
    3382:	f6 45 98 01          	testb  $0x1,-0x68(%rbp)
    3386:	74 0e                	je     3396 <e1000_xmit_frame+0x6e6>
		txd_lower |= E1000_TXD_CMD_DEXT | E1000_TXD_DTYP_D;
    3388:	41 81 c9 00 00 10 20 	or     $0x20100000,%r9d
		txd_upper |= E1000_TXD_POPTS_TXSM << 8;
    338f:	41 81 c8 00 02 00 00 	or     $0x200,%r8d
	}

	if (unlikely(tx_flags & E1000_TX_FLAGS_VLAN)) {
    3396:	f6 45 98 02          	testb  $0x2,-0x68(%rbp)
    339a:	0f 85 8e 09 00 00    	jne    3d2e <e1000_xmit_frame+0x107e>
		txd_lower |= E1000_TXD_CMD_VLE;
		txd_upper |= (tx_flags & E1000_TX_FLAGS_VLAN_MASK);
	}

	if (unlikely(tx_flags & E1000_TX_FLAGS_NO_FCS))
    33a0:	44 8b 5d 98          	mov    -0x68(%rbp),%r11d
    33a4:	41 c1 eb 04          	shr    $0x4,%r11d
    33a8:	41 83 e3 01          	and    $0x1,%r11d
    33ac:	0f 85 f6 06 00 00    	jne    3aa8 <e1000_xmit_frame+0xdf8>
		txd_lower &= ~(E1000_TXD_CMD_IFCS);

	i = tx_ring->next_to_use;

	while (count--) {
    33b2:	8b 75 bc             	mov    -0x44(%rbp),%esi
	}

	if (unlikely(tx_flags & E1000_TX_FLAGS_NO_FCS))
		txd_lower &= ~(E1000_TXD_CMD_IFCS);

	i = tx_ring->next_to_use;
    33b5:	41 8b 47 18          	mov    0x18(%r15),%eax
		tx_desc = E1000_TX_DESC(*tx_ring, i);
		tx_desc->buffer_addr = cpu_to_le64(buffer_info->dma);
		tx_desc->lower.data =
			cpu_to_le32(txd_lower | buffer_info->length);
		tx_desc->upper.data = cpu_to_le32(txd_upper);
		if (unlikely(++i == tx_ring->count)) i = 0;
    33b9:	31 db                	xor    %ebx,%ebx
	if (unlikely(tx_flags & E1000_TX_FLAGS_NO_FCS))
		txd_lower &= ~(E1000_TXD_CMD_IFCS);

	i = tx_ring->next_to_use;

	while (count--) {
    33bb:	83 ee 01             	sub    $0x1,%esi
		buffer_info = &tx_ring->buffer_info[i];
    33be:	49 8b 4f 20          	mov    0x20(%r15),%rcx
    33c2:	89 c2                	mov    %eax,%edx
		tx_desc = E1000_TX_DESC(*tx_ring, i);
		tx_desc->buffer_addr = cpu_to_le64(buffer_info->dma);
		tx_desc->lower.data =
			cpu_to_le32(txd_lower | buffer_info->length);
		tx_desc->upper.data = cpu_to_le32(txd_upper);
		if (unlikely(++i == tx_ring->count)) i = 0;
    33c4:	83 c0 01             	add    $0x1,%eax
		txd_lower &= ~(E1000_TXD_CMD_IFCS);

	i = tx_ring->next_to_use;

	while (count--) {
		buffer_info = &tx_ring->buffer_info[i];
    33c7:	48 8d 3c 92          	lea    (%rdx,%rdx,4),%rdi
		tx_desc = E1000_TX_DESC(*tx_ring, i);
    33cb:	48 c1 e2 04          	shl    $0x4,%rdx
    33cf:	49 03 17             	add    (%r15),%rdx
		txd_lower &= ~(E1000_TXD_CMD_IFCS);

	i = tx_ring->next_to_use;

	while (count--) {
		buffer_info = &tx_ring->buffer_info[i];
    33d2:	48 8d 0c f9          	lea    (%rcx,%rdi,8),%rcx
		tx_desc = E1000_TX_DESC(*tx_ring, i);
		tx_desc->buffer_addr = cpu_to_le64(buffer_info->dma);
    33d6:	48 8b 79 08          	mov    0x8(%rcx),%rdi
    33da:	48 89 3a             	mov    %rdi,(%rdx)
		tx_desc->lower.data =
			cpu_to_le32(txd_lower | buffer_info->length);
    33dd:	0f b7 49 18          	movzwl 0x18(%rcx),%ecx
		tx_desc->upper.data = cpu_to_le32(txd_upper);
    33e1:	44 89 42 0c          	mov    %r8d,0xc(%rdx)
	while (count--) {
		buffer_info = &tx_ring->buffer_info[i];
		tx_desc = E1000_TX_DESC(*tx_ring, i);
		tx_desc->buffer_addr = cpu_to_le64(buffer_info->dma);
		tx_desc->lower.data =
			cpu_to_le32(txd_lower | buffer_info->length);
    33e5:	44 09 c9             	or     %r9d,%ecx

	while (count--) {
		buffer_info = &tx_ring->buffer_info[i];
		tx_desc = E1000_TX_DESC(*tx_ring, i);
		tx_desc->buffer_addr = cpu_to_le64(buffer_info->dma);
		tx_desc->lower.data =
    33e8:	89 4a 08             	mov    %ecx,0x8(%rdx)
			cpu_to_le32(txd_lower | buffer_info->length);
		tx_desc->upper.data = cpu_to_le32(txd_upper);
		if (unlikely(++i == tx_ring->count)) i = 0;
    33eb:	41 3b 47 14          	cmp    0x14(%r15),%eax
    33ef:	0f 44 c3             	cmove  %ebx,%eax
	if (unlikely(tx_flags & E1000_TX_FLAGS_NO_FCS))
		txd_lower &= ~(E1000_TXD_CMD_IFCS);

	i = tx_ring->next_to_use;

	while (count--) {
    33f2:	83 ee 01             	sub    $0x1,%esi
    33f5:	83 fe ff             	cmp    $0xffffffff,%esi
    33f8:	75 c4                	jne    33be <e1000_xmit_frame+0x70e>
			cpu_to_le32(txd_lower | buffer_info->length);
		tx_desc->upper.data = cpu_to_le32(txd_upper);
		if (unlikely(++i == tx_ring->count)) i = 0;
	}

	tx_desc->lower.data |= cpu_to_le32(adapter->txd_cmd);
    33fa:	48 8b 7d c8          	mov    -0x38(%rbp),%rdi
    33fe:	0b 8f 8c 0a 00 00    	or     0xa8c(%rdi),%ecx

	/* txd_cmd re-enables FCS, so we'll re-disable it here as desired. */
	if (unlikely(tx_flags & E1000_TX_FLAGS_NO_FCS))
    3404:	4d 85 db             	test   %r11,%r11
			cpu_to_le32(txd_lower | buffer_info->length);
		tx_desc->upper.data = cpu_to_le32(txd_upper);
		if (unlikely(++i == tx_ring->count)) i = 0;
	}

	tx_desc->lower.data |= cpu_to_le32(adapter->txd_cmd);
    3407:	89 4a 08             	mov    %ecx,0x8(%rdx)

	/* txd_cmd re-enables FCS, so we'll re-disable it here as desired. */
	if (unlikely(tx_flags & E1000_TX_FLAGS_NO_FCS))
    340a:	0f 85 10 09 00 00    	jne    3d20 <e1000_xmit_frame+0x1070>
	/* Force memory writes to complete before letting h/w
	 * know there are new descriptors to fetch.  (Only
	 * applicable for weak-ordered memory model archs,
	 * such as IA-64).
	 */
	wmb();
    3410:	0f ae f8             	sfence 
static netdev_tx_t e1000_xmit_frame(struct sk_buff *skb,
				    struct net_device *netdev)
{
	struct e1000_adapter *adapter = netdev_priv(netdev);
	struct e1000_hw *hw = &adapter->hw;
	struct e1000_tx_ring *tx_ring;
    3413:	41 8b 4f 1c          	mov    0x1c(%r15),%ecx
}

static int e1000_maybe_stop_tx(struct net_device *netdev,
			       struct e1000_tx_ring *tx_ring, int size)
{
	if (likely(E1000_DESC_UNUSED(tx_ring) >= size))
    3417:	31 d2                	xor    %edx,%edx
	 * applicable for weak-ordered memory model archs,
	 * such as IA-64).
	 */
	wmb();

	tx_ring->next_to_use = i;
    3419:	41 89 47 18          	mov    %eax,0x18(%r15)
}

static int e1000_maybe_stop_tx(struct net_device *netdev,
			       struct e1000_tx_ring *tx_ring, int size)
{
	if (likely(E1000_DESC_UNUSED(tx_ring) >= size))
    341d:	39 c1                	cmp    %eax,%ecx
    341f:	41 0f 46 57 14       	cmovbe 0x14(%r15),%edx
    3424:	83 e9 01             	sub    $0x1,%ecx
    3427:	29 c1                	sub    %eax,%ecx
    3429:	01 ca                	add    %ecx,%edx
    342b:	83 fa 12             	cmp    $0x12,%edx
    342e:	0f 86 d9 08 00 00    	jbe    3d0d <e1000_xmit_frame+0x105d>

		e1000_tx_queue(adapter, tx_ring, tx_flags, count);
		/* Make sure there is space in the ring for the next send. */
		e1000_maybe_stop_tx(netdev, tx_ring, MAX_SKB_FRAGS + 2);

		if (!skb->xmit_more ||
    3434:	41 f6 86 8e 00 00 00 	testb  $0x40,0x8e(%r14)
    343b:	40 
    343c:	74 14                	je     3452 <e1000_xmit_frame+0x7a2>
		    netif_xmit_stopped(netdev_get_tx_queue(netdev, 0))) {
    343e:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
    3442:	48 8b 80 c0 03 00 00 	mov    0x3c0(%rax),%rax

		e1000_tx_queue(adapter, tx_ring, tx_flags, count);
		/* Make sure there is space in the ring for the next send. */
		e1000_maybe_stop_tx(netdev, tx_ring, MAX_SKB_FRAGS + 2);

		if (!skb->xmit_more ||
    3449:	f6 80 98 00 00 00 03 	testb  $0x3,0x98(%rax)
    3450:	74 16                	je     3468 <e1000_xmit_frame+0x7b8>
		    netif_xmit_stopped(netdev_get_tx_queue(netdev, 0))) {
			writel(tx_ring->next_to_use, hw->hw_addr + tx_ring->tdt);
    3452:	48 8b 4d c8          	mov    -0x38(%rbp),%rcx
    3456:	41 0f b7 47 2a       	movzwl 0x2a(%r15),%eax
    345b:	41 8b 57 18          	mov    0x18(%r15),%edx
    345f:	48 03 81 00 0c 00 00 	add    0xc00(%rcx),%rax
build_mmio_read(__readw, "w", unsigned short, "=r", )
build_mmio_read(__readl, "l", unsigned int, "=r", )

build_mmio_write(writeb, "b", unsigned char, "q", :"memory")
build_mmio_write(writew, "w", unsigned short, "r", :"memory")
build_mmio_write(writel, "l", unsigned int, "r", :"memory")
    3466:	89 10                	mov    %edx,(%rax)
		tx_ring->buffer_info[first].time_stamp = 0;
		tx_ring->next_to_use = first;
	}

	return NETDEV_TX_OK;
}
    3468:	48 83 c4 58          	add    $0x58,%rsp
		dev_kfree_skb_any(skb);
		tx_ring->buffer_info[first].time_stamp = 0;
		tx_ring->next_to_use = first;
	}

	return NETDEV_TX_OK;
    346c:	31 c0                	xor    %eax,%eax
}
    346e:	5b                   	pop    %rbx
    346f:	41 5c                	pop    %r12
    3471:	41 5d                	pop    %r13
    3473:	41 5e                	pop    %r14
    3475:	41 5f                	pop    %r15
    3477:	5d                   	pop    %rbp
    3478:	c3                   	retq   
		return dma_ops;
    3479:	48 8b 05 00 00 00 00 	mov    0x0(%rip),%rax        # 3480 <e1000_xmit_frame+0x7d0>
    3480:	e9 59 fb ff ff       	jmpq   2fde <e1000_xmit_frame+0x32e>

static inline int dma_mapping_error(struct device *dev, dma_addr_t dma_addr)
{
	debug_dma_mapping_error(dev, dma_addr);

	if (get_dma_ops(dev)->mapping_error)
    3485:	48 8b 15 00 00 00 00 	mov    0x0(%rip),%rdx        # 348c <e1000_xmit_frame+0x7dc>
    348c:	48 8b 52 60          	mov    0x60(%rdx),%rdx
    3490:	48 85 d2             	test   %rdx,%rdx
    3493:	0f 85 c2 fb ff ff    	jne    305b <e1000_xmit_frame+0x3ab>
		return get_dma_ops(dev)->mapping_error(dev, dma_addr);

#ifdef DMA_ERROR_CODE
	return dma_addr == DMA_ERROR_CODE;
    3499:	48 85 c0             	test   %rax,%rax
    349c:	0f 94 c0             	sete   %al
    349f:	0f b6 c0             	movzbl %al,%eax
		buffer_info->time_stamp = jiffies;
		buffer_info->mapped_as_page = false;
		buffer_info->dma = dma_map_single(&pdev->dev,
						  skb->data + offset,
						  size, DMA_TO_DEVICE);
		if (dma_mapping_error(&pdev->dev, buffer_info->dma))
    34a2:	85 c0                	test   %eax,%eax
    34a4:	0f 84 c2 fb ff ff    	je     306c <e1000_xmit_frame+0x3bc>
    34aa:	44 89 fb             	mov    %r15d,%ebx
    34ad:	4d 89 f7             	mov    %r14,%r15
    34b0:	4c 8b 75 c0          	mov    -0x40(%rbp),%r14
	tx_ring->buffer_info[first].next_to_watch = i;

	return count;

dma_error:
	dev_err(&pdev->dev, "TX DMA map failed\n");
    34b4:	48 8b 7d b0          	mov    -0x50(%rbp),%rdi
    34b8:	31 c0                	xor    %eax,%eax
    34ba:	48 c7 c6 00 00 00 00 	mov    $0x0,%rsi
    34c1:	e8 00 00 00 00       	callq  34c6 <e1000_xmit_frame+0x816>
	buffer_info->dma = 0;
	if (count)
    34c6:	8b 45 bc             	mov    -0x44(%rbp),%eax

	return count;

dma_error:
	dev_err(&pdev->dev, "TX DMA map failed\n");
	buffer_info->dma = 0;
    34c9:	49 c7 44 24 08 00 00 	movq   $0x0,0x8(%r12)
    34d0:	00 00 
	if (count)
    34d2:	85 c0                	test   %eax,%eax
    34d4:	74 57                	je     352d <e1000_xmit_frame+0x87d>
		count--;

	while (count--) {
    34d6:	8b 45 bc             	mov    -0x44(%rbp),%eax
    34d9:	83 f8 01             	cmp    $0x1,%eax
    34dc:	44 8d 60 fe          	lea    -0x2(%rax),%r12d
    34e0:	74 4b                	je     352d <e1000_xmit_frame+0x87d>
    34e2:	4c 8b 6d c8          	mov    -0x38(%rbp),%r13
    34e6:	49 8d 44 24 01       	lea    0x1(%r12),%rax
    34eb:	4c 89 75 d0          	mov    %r14,-0x30(%rbp)
    34ef:	45 31 e4             	xor    %r12d,%r12d
    34f2:	49 81 c5 f8 0b 00 00 	add    $0xbf8,%r13
    34f9:	4d 89 ee             	mov    %r13,%r14
    34fc:	49 89 c5             	mov    %rax,%r13
		if (i==0)
    34ff:	85 db                	test   %ebx,%ebx
    3501:	75 04                	jne    3507 <e1000_xmit_frame+0x857>
			i += tx_ring->count;
    3503:	41 8b 5f 14          	mov    0x14(%r15),%ebx
		i--;
    3507:	83 eb 01             	sub    $0x1,%ebx
		buffer_info = &tx_ring->buffer_info[i];
		e1000_unmap_and_free_tx_resource(adapter, buffer_info);
    350a:	4c 89 f7             	mov    %r14,%rdi
    350d:	49 83 c4 01          	add    $0x1,%r12

	while (count--) {
		if (i==0)
			i += tx_ring->count;
		i--;
		buffer_info = &tx_ring->buffer_info[i];
    3511:	89 d8                	mov    %ebx,%eax
    3513:	48 8d 14 80          	lea    (%rax,%rax,4),%rdx
    3517:	49 8b 47 20          	mov    0x20(%r15),%rax
    351b:	48 8d 34 d0          	lea    (%rax,%rdx,8),%rsi
		e1000_unmap_and_free_tx_resource(adapter, buffer_info);
    351f:	e8 bc e8 ff ff       	callq  1de0 <e1000_unmap_and_free_tx_resource.isra.51>
	dev_err(&pdev->dev, "TX DMA map failed\n");
	buffer_info->dma = 0;
	if (count)
		count--;

	while (count--) {
    3524:	4d 39 ec             	cmp    %r13,%r12
    3527:	75 d6                	jne    34ff <e1000_xmit_frame+0x84f>
    3529:	4c 8b 75 d0          	mov    -0x30(%rbp),%r14
    352d:	8b 45 90             	mov    -0x70(%rbp),%eax
    3530:	4c 8d 24 80          	lea    (%rax,%rax,4),%r12
    3534:	49 c1 e4 03          	shl    $0x3,%r12
	__dev_kfree_skb_irq(skb, SKB_REASON_CONSUMED);
}

static inline void dev_kfree_skb_any(struct sk_buff *skb)
{
	__dev_kfree_skb_any(skb, SKB_REASON_DROPPED);
    3538:	be 01 00 00 00       	mov    $0x1,%esi
    353d:	4c 89 f7             	mov    %r14,%rdi
    3540:	e8 00 00 00 00       	callq  3545 <e1000_xmit_frame+0x895>
			 */
			mmiowb();
		}
	} else {
		dev_kfree_skb_any(skb);
		tx_ring->buffer_info[first].time_stamp = 0;
    3545:	49 8b 47 20          	mov    0x20(%r15),%rax
    3549:	4a c7 44 20 10 00 00 	movq   $0x0,0x10(%rax,%r12,1)
    3550:	00 00 
		tx_ring->next_to_use = first;
    3552:	8b 45 90             	mov    -0x70(%rbp),%eax
    3555:	41 89 47 18          	mov    %eax,0x18(%r15)
	}

	return NETDEV_TX_OK;
    3559:	31 c0                	xor    %eax,%eax
}
    355b:	48 83 c4 58          	add    $0x58,%rsp
    355f:	5b                   	pop    %rbx
    3560:	41 5c                	pop    %r12
    3562:	41 5d                	pop    %r13
    3564:	41 5e                	pop    %r14
    3566:	41 5f                	pop    %r15
    3568:	5d                   	pop    %rbp
    3569:	c3                   	retq   
	struct dma_map_ops *ops = get_dma_ops(dev);
	dma_addr_t addr;

	kmemcheck_mark_initialized(page_address(page) + offset, size);
	BUG_ON(!valid_dma_direction(dir));
	addr = ops->map_page(dev, page, offset, size, dir, NULL);
    356a:	48 8b 05 00 00 00 00 	mov    0x0(%rip),%rax        # 3571 <e1000_xmit_frame+0x8c1>
    3571:	45 31 c9             	xor    %r9d,%r9d
    3574:	41 b8 01 00 00 00    	mov    $0x1,%r8d
    357a:	4c 89 ff             	mov    %r15,%rdi
    357d:	ff 50 20             	callq  *0x20(%rax)
static inline struct dma_map_ops *get_dma_ops(struct device *dev)
{
#ifndef CONFIG_X86_DEV_DMA_OPS
	return dma_ops;
#else
	if (unlikely(!dev) || !dev->archdata.dma_ops)
    3580:	48 8b 4d d0          	mov    -0x30(%rbp),%rcx
				size -= 4;

			buffer_info->length = size;
			buffer_info->time_stamp = jiffies;
			buffer_info->mapped_as_page = true;
			buffer_info->dma = skb_frag_dma_map(&pdev->dev, frag,
    3584:	49 89 44 24 08       	mov    %rax,0x8(%r12)
    3589:	48 8b 91 e8 02 00 00 	mov    0x2e8(%rcx),%rdx
    3590:	48 85 d2             	test   %rdx,%rdx
    3593:	0f 85 91 fc ff ff    	jne    322a <e1000_xmit_frame+0x57a>

static inline int dma_mapping_error(struct device *dev, dma_addr_t dma_addr)
{
	debug_dma_mapping_error(dev, dma_addr);

	if (get_dma_ops(dev)->mapping_error)
    3599:	48 8b 15 00 00 00 00 	mov    0x0(%rip),%rdx        # 35a0 <e1000_xmit_frame+0x8f0>
    35a0:	e9 85 fc ff ff       	jmpq   322a <e1000_xmit_frame+0x57a>
	struct dma_map_ops *ops = get_dma_ops(dev);
	dma_addr_t addr;

	kmemcheck_mark_initialized(page_address(page) + offset, size);
	BUG_ON(!valid_dma_direction(dir));
	addr = ops->map_page(dev, page, offset, size, dir, NULL);
    35a5:	48 8b 05 00 00 00 00 	mov    0x0(%rip),%rax        # 35ac <e1000_xmit_frame+0x8fc>
    35ac:	45 31 c9             	xor    %r9d,%r9d
    35af:	31 ff                	xor    %edi,%edi
    35b1:	41 b8 01 00 00 00    	mov    $0x1,%r8d
    35b7:	ff 50 20             	callq  *0x20(%rax)

static inline int dma_mapping_error(struct device *dev, dma_addr_t dma_addr)
{
	debug_dma_mapping_error(dev, dma_addr);

	if (get_dma_ops(dev)->mapping_error)
    35ba:	48 8b 15 00 00 00 00 	mov    0x0(%rip),%rdx        # 35c1 <e1000_xmit_frame+0x911>
    35c1:	49 89 44 24 08       	mov    %rax,0x8(%r12)
    35c6:	48 8b 52 60          	mov    0x60(%rdx),%rdx
    35ca:	48 85 d2             	test   %rdx,%rdx
    35cd:	0f 85 66 fc ff ff    	jne    3239 <e1000_xmit_frame+0x589>
		return get_dma_ops(dev)->mapping_error(dev, dma_addr);

#ifdef DMA_ERROR_CODE
	return dma_addr == DMA_ERROR_CODE;
    35d3:	48 85 c0             	test   %rax,%rax
    35d6:	0f 94 c0             	sete   %al
    35d9:	0f b6 c0             	movzbl %al,%eax
						offset, size, DMA_TO_DEVICE);
			if (dma_mapping_error(&pdev->dev, buffer_info->dma))
    35dc:	85 c0                	test   %eax,%eax
    35de:	0f 84 65 fc ff ff    	je     3249 <e1000_xmit_frame+0x599>
    35e4:	44 89 f3             	mov    %r14d,%ebx
    35e7:	4c 8b 7d c0          	mov    -0x40(%rbp),%r15
    35eb:	4c 8b 75 88          	mov    -0x78(%rbp),%r14
    35ef:	e9 c0 fe ff ff       	jmpq   34b4 <e1000_xmit_frame+0x804>
			}
		}
	}

	/* reserve a descriptor for the offload context */
	if ((mss) || (skb->ip_summed == CHECKSUM_PARTIAL))
    35f4:	41 0f b6 86 91 00 00 	movzbl 0x91(%r14),%eax
    35fb:	00 
    35fc:	b9 0c 00 00 00       	mov    $0xc,%ecx
    3601:	83 e0 06             	and    $0x6,%eax
    3604:	3c 06                	cmp    $0x6,%al
    3606:	0f 84 e0 01 00 00    	je     37ec <e1000_xmit_frame+0xb3c>
    360c:	b8 01 00 00 00       	mov    $0x1,%eax
				    struct net_device *netdev)
{
	struct e1000_adapter *adapter = netdev_priv(netdev);
	struct e1000_hw *hw = &adapter->hw;
	struct e1000_tx_ring *tx_ring;
	unsigned int first, max_per_txd = E1000_MAX_DATA_PER_TXD;
    3611:	c7 45 ac 00 10 00 00 	movl   $0x1000,-0x54(%rbp)
	unsigned int max_txd_pwr = E1000_MAX_TXD_PWR;
	unsigned int tx_flags = 0;
	unsigned int len = skb_headlen(skb);
	unsigned int nr_frags;
	unsigned int mss;
	int count = 0;
    3618:	31 f6                	xor    %esi,%esi
    361a:	e9 72 f7 ff ff       	jmpq   2d91 <e1000_xmit_frame+0xe1>
 */
static inline int skb_header_cloned(const struct sk_buff *skb)
{
	int dataref;

	if (!skb->cloned)
    361f:	41 f6 86 8e 00 00 00 	testb  $0x1,0x8e(%r14)
    3626:	01 
    3627:	74 3f                	je     3668 <e1000_xmit_frame+0x9b8>
})

static __always_inline
void __read_once_size(const volatile void *p, void *res, int size)
{
	__READ_ONCE_SIZE;
    3629:	8b 48 20             	mov    0x20(%rax),%ecx
		return 0;

	dataref = atomic_read(&skb_shinfo(skb)->dataref);
	dataref = (dataref & SKB_DATAREF_MASK) - (dataref >> SKB_DATAREF_SHIFT);
    362c:	0f b7 d1             	movzwl %cx,%edx
    362f:	c1 f9 10             	sar    $0x10,%ecx
    3632:	29 ca                	sub    %ecx,%edx
	int delta = 0;

	if (headroom > skb_headroom(skb))
		delta = headroom - skb_headroom(skb);

	if (delta || cloned)
    3634:	83 fa 01             	cmp    $0x1,%edx
    3637:	74 2f                	je     3668 <e1000_xmit_frame+0x9b8>
		return pskb_expand_head(skb, ALIGN(delta, NET_SKB_PAD), 0,
    3639:	31 d2                	xor    %edx,%edx
    363b:	31 f6                	xor    %esi,%esi
    363d:	b9 20 00 08 02       	mov    $0x2080020,%ecx
    3642:	4c 89 f7             	mov    %r14,%rdi
    3645:	e8 00 00 00 00       	callq  364a <e1000_xmit_frame+0x99a>

	if (skb_is_gso(skb)) {
		int err;

		err = skb_cow_head(skb, 0);
		if (err < 0)
    364a:	85 c0                	test   %eax,%eax
    364c:	0f 88 49 02 00 00    	js     389b <e1000_xmit_frame+0xbeb>
    3652:	41 8b 86 cc 00 00 00 	mov    0xcc(%r14),%eax
    3659:	49 8b be d0 00 00 00 	mov    0xd0(%r14),%rdi
    3660:	48 01 f8             	add    %rdi,%rax
    3663:	44 0f b7 68 02       	movzwl 0x2(%rax),%r13d
	return skb->transport_header != (typeof(skb->transport_header))~0U;
}

static inline unsigned char *skb_transport_header(const struct sk_buff *skb)
{
	return skb->head + skb->transport_header;
    3668:	41 0f b7 8e c2 00 00 	movzwl 0xc2(%r14),%ecx
    366f:	00 
	return skb->csum_start - skb_headroom(skb);
}

static inline int skb_transport_offset(const struct sk_buff *skb)
{
	return skb_transport_header(skb) - skb->data;
    3670:	49 8b 96 d8 00 00 00 	mov    0xd8(%r14),%rdx
	return skb->transport_header != (typeof(skb->transport_header))~0U;
}

static inline unsigned char *skb_transport_header(const struct sk_buff *skb)
{
	return skb->head + skb->transport_header;
    3677:	48 01 f9             	add    %rdi,%rcx
    367a:	0f b6 71 0c          	movzbl 0xc(%rcx),%esi
	return skb->csum_start - skb_headroom(skb);
}

static inline int skb_transport_offset(const struct sk_buff *skb)
{
	return skb_transport_header(skb) - skb->data;
    367e:	49 89 c8             	mov    %rcx,%r8
    3681:	49 29 d0             	sub    %rdx,%r8
    3684:	40 c0 ee 04          	shr    $0x4,%sil
			return err;

		hdr_len = skb_transport_offset(skb) + tcp_hdrlen(skb);
		mss = skb_shinfo(skb)->gso_size;
		if (protocol == htons(ETH_P_IP)) {
    3688:	66 41 83 fc 08       	cmp    $0x8,%r12w

		err = skb_cow_head(skb, 0);
		if (err < 0)
			return err;

		hdr_len = skb_transport_offset(skb) + tcp_hdrlen(skb);
    368d:	45 8d 14 b0          	lea    (%r8,%rsi,4),%r10d
		mss = skb_shinfo(skb)->gso_size;
		if (protocol == htons(ETH_P_IP)) {
    3691:	0f 84 61 01 00 00    	je     37f8 <e1000_xmit_frame+0xb48>
								 iph->daddr, 0,
								 IPPROTO_TCP,
								 0);
			cmd_length = E1000_TXD_CMD_IP;
			ipcse = skb_transport_offset(skb) - 1;
		} else if (skb_is_gso_v6(skb)) {
    3697:	f6 40 06 10          	testb  $0x10,0x6(%rax)
    369b:	0f 85 0e 02 00 00    	jne    38af <e1000_xmit_frame+0xbff>
    36a1:	44 88 45 d0          	mov    %r8b,-0x30(%rbp)
{
	struct e1000_context_desc *context_desc;
	struct e1000_tx_buffer *buffer_info;
	unsigned int i;
	u32 cmd_length = 0;
	u16 ipcse = 0, tucse, mss;
    36a5:	45 31 db             	xor    %r11d,%r11d
		     __be16 protocol)
{
	struct e1000_context_desc *context_desc;
	struct e1000_tx_buffer *buffer_info;
	unsigned int i;
	u32 cmd_length = 0;
    36a8:	31 f6                	xor    %esi,%esi
	skb->transport_header += offset;
}

static inline unsigned char *skb_network_header(const struct sk_buff *skb)
{
	return skb->head + skb->network_header;
    36aa:	41 0f b7 86 c4 00 00 	movzwl 0xc4(%r14),%eax
    36b1:	00 
		tucss = skb_transport_offset(skb);
		tucso = (void *)&(tcp_hdr(skb)->check) - (void *)skb->data;
		tucse = 0;

		cmd_length |= (E1000_TXD_CMD_DEXT | E1000_TXD_CMD_TSE |
			       E1000_TXD_CMD_TCP | (skb->len - (hdr_len)));
    36b2:	45 8b 8e 80 00 00 00 	mov    0x80(%r14),%r9d
			ipcse = 0;
		}
		ipcss = skb_network_offset(skb);
		ipcso = (void *)&(ip_hdr(skb)->check) - (void *)skb->data;
		tucss = skb_transport_offset(skb);
		tucso = (void *)&(tcp_hdr(skb)->check) - (void *)skb->data;
    36b9:	48 83 c1 10          	add    $0x10,%rcx
		tucse = 0;

		cmd_length |= (E1000_TXD_CMD_DEXT | E1000_TXD_CMD_TSE |
			       E1000_TXD_CMD_TCP | (skb->len - (hdr_len)));

		i = tx_ring->next_to_use;
    36bd:	41 8b 5f 18          	mov    0x18(%r15),%ebx
			ipcse = 0;
		}
		ipcss = skb_network_offset(skb);
		ipcso = (void *)&(ip_hdr(skb)->check) - (void *)skb->data;
		tucss = skb_transport_offset(skb);
		tucso = (void *)&(tcp_hdr(skb)->check) - (void *)skb->data;
    36c1:	48 29 d1             	sub    %rdx,%rcx
    36c4:	48 01 c7             	add    %rax,%rdi
		tucse = 0;

		cmd_length |= (E1000_TXD_CMD_DEXT | E1000_TXD_CMD_TSE |
    36c7:	41 0f b6 c2          	movzbl %r10b,%eax
			       E1000_TXD_CMD_TCP | (skb->len - (hdr_len)));
    36cb:	41 29 c1             	sub    %eax,%r9d
		ipcso = (void *)&(ip_hdr(skb)->check) - (void *)skb->data;
		tucss = skb_transport_offset(skb);
		tucso = (void *)&(tcp_hdr(skb)->check) - (void *)skb->data;
		tucse = 0;

		cmd_length |= (E1000_TXD_CMD_DEXT | E1000_TXD_CMD_TSE |
    36ce:	41 81 c9 00 00 00 25 	or     $0x25000000,%r9d
    36d5:	41 09 f1             	or     %esi,%r9d
			       E1000_TXD_CMD_TCP | (skb->len - (hdr_len)));

		i = tx_ring->next_to_use;
		context_desc = E1000_CONTEXT_DESC(*tx_ring, i);
    36d8:	89 de                	mov    %ebx,%esi
		buffer_info = &tx_ring->buffer_info[i];
    36da:	4c 8d 04 b6          	lea    (%rsi,%rsi,4),%r8

		cmd_length |= (E1000_TXD_CMD_DEXT | E1000_TXD_CMD_TSE |
			       E1000_TXD_CMD_TCP | (skb->len - (hdr_len)));

		i = tx_ring->next_to_use;
		context_desc = E1000_CONTEXT_DESC(*tx_ring, i);
    36de:	48 89 f0             	mov    %rsi,%rax
		buffer_info = &tx_ring->buffer_info[i];
    36e1:	49 8b 77 20          	mov    0x20(%r15),%rsi

		cmd_length |= (E1000_TXD_CMD_DEXT | E1000_TXD_CMD_TSE |
			       E1000_TXD_CMD_TCP | (skb->len - (hdr_len)));

		i = tx_ring->next_to_use;
		context_desc = E1000_CONTEXT_DESC(*tx_ring, i);
    36e5:	48 c1 e0 04          	shl    $0x4,%rax
    36e9:	49 03 07             	add    (%r15),%rax
		buffer_info = &tx_ring->buffer_info[i];
    36ec:	4a 8d 34 c6          	lea    (%rsi,%r8,8),%rsi
	return skb->inner_transport_header - skb->inner_network_header;
}

static inline int skb_network_offset(const struct sk_buff *skb)
{
	return skb_network_header(skb) - skb->data;
    36f0:	49 89 f8             	mov    %rdi,%r8
						 &ipv6_hdr(skb)->daddr,
						 0, IPPROTO_TCP, 0);
			ipcse = 0;
		}
		ipcss = skb_network_offset(skb);
		ipcso = (void *)&(ip_hdr(skb)->check) - (void *)skb->data;
    36f3:	48 83 c7 0a          	add    $0xa,%rdi
    36f7:	48 29 d7             	sub    %rdx,%rdi
    36fa:	49 29 d0             	sub    %rdx,%r8
    36fd:	40 88 78 01          	mov    %dil,0x1(%rax)
		buffer_info = &tx_ring->buffer_info[i];

		context_desc->lower_setup.ip_fields.ipcss  = ipcss;
		context_desc->lower_setup.ip_fields.ipcso  = ipcso;
		context_desc->lower_setup.ip_fields.ipcse  = cpu_to_le16(ipcse);
		context_desc->upper_setup.tcp_fields.tucss = tucss;
    3701:	0f b6 7d d0          	movzbl -0x30(%rbp),%edi
		context_desc = E1000_CONTEXT_DESC(*tx_ring, i);
		buffer_info = &tx_ring->buffer_info[i];

		context_desc->lower_setup.ip_fields.ipcss  = ipcss;
		context_desc->lower_setup.ip_fields.ipcso  = ipcso;
		context_desc->lower_setup.ip_fields.ipcse  = cpu_to_le16(ipcse);
    3705:	66 44 89 58 02       	mov    %r11w,0x2(%rax)
		context_desc->upper_setup.tcp_fields.tucss = tucss;
		context_desc->upper_setup.tcp_fields.tucso = tucso;
		context_desc->upper_setup.tcp_fields.tucse = cpu_to_le16(tucse);
    370a:	45 31 db             	xor    %r11d,%r11d
				~csum_ipv6_magic(&ipv6_hdr(skb)->saddr,
						 &ipv6_hdr(skb)->daddr,
						 0, IPPROTO_TCP, 0);
			ipcse = 0;
		}
		ipcss = skb_network_offset(skb);
    370d:	44 88 00             	mov    %r8b,(%rax)
		ipcso = (void *)&(ip_hdr(skb)->check) - (void *)skb->data;
		tucss = skb_transport_offset(skb);
		tucso = (void *)&(tcp_hdr(skb)->check) - (void *)skb->data;
    3710:	88 48 05             	mov    %cl,0x5(%rax)
		context_desc->lower_setup.ip_fields.ipcss  = ipcss;
		context_desc->lower_setup.ip_fields.ipcso  = ipcso;
		context_desc->lower_setup.ip_fields.ipcse  = cpu_to_le16(ipcse);
		context_desc->upper_setup.tcp_fields.tucss = tucss;
		context_desc->upper_setup.tcp_fields.tucso = tucso;
		context_desc->upper_setup.tcp_fields.tucse = cpu_to_le16(tucse);
    3713:	66 44 89 58 06       	mov    %r11w,0x6(%rax)
		context_desc->tcp_seg_setup.fields.mss     = cpu_to_le16(mss);
    3718:	66 44 89 68 0e       	mov    %r13w,0xe(%rax)
		context_desc->tcp_seg_setup.fields.hdr_len = hdr_len;
    371d:	44 88 50 0d          	mov    %r10b,0xd(%rax)
		buffer_info = &tx_ring->buffer_info[i];

		context_desc->lower_setup.ip_fields.ipcss  = ipcss;
		context_desc->lower_setup.ip_fields.ipcso  = ipcso;
		context_desc->lower_setup.ip_fields.ipcse  = cpu_to_le16(ipcse);
		context_desc->upper_setup.tcp_fields.tucss = tucss;
    3721:	40 88 78 04          	mov    %dil,0x4(%rax)
		context_desc->upper_setup.tcp_fields.tucso = tucso;
		context_desc->upper_setup.tcp_fields.tucse = cpu_to_le16(tucse);
		context_desc->tcp_seg_setup.fields.mss     = cpu_to_le16(mss);
		context_desc->tcp_seg_setup.fields.hdr_len = hdr_len;
		context_desc->cmd_and_length = cpu_to_le32(cmd_length);
    3725:	44 89 48 08          	mov    %r9d,0x8(%rax)

		buffer_info->time_stamp = jiffies;
    3729:	48 8b 05 00 00 00 00 	mov    0x0(%rip),%rax        # 3730 <e1000_xmit_frame+0xa80>
		buffer_info->next_to_watch = i;
    3730:	66 89 5e 1a          	mov    %bx,0x1a(%rsi)

		if (++i == tx_ring->count) i = 0;
    3734:	83 c3 01             	add    $0x1,%ebx
		context_desc->upper_setup.tcp_fields.tucse = cpu_to_le16(tucse);
		context_desc->tcp_seg_setup.fields.mss     = cpu_to_le16(mss);
		context_desc->tcp_seg_setup.fields.hdr_len = hdr_len;
		context_desc->cmd_and_length = cpu_to_le32(cmd_length);

		buffer_info->time_stamp = jiffies;
    3737:	48 89 46 10          	mov    %rax,0x10(%rsi)
		buffer_info->next_to_watch = i;

		if (++i == tx_ring->count) i = 0;
    373b:	41 3b 5f 14          	cmp    0x14(%r15),%ebx
    373f:	b8 00 00 00 00       	mov    $0x0,%eax
    3744:	0f 44 d8             	cmove  %eax,%ebx
		dev_kfree_skb_any(skb);
		return NETDEV_TX_OK;
	}

	if (likely(tso)) {
		if (likely(hw->mac_type != e1000_82544))
    3747:	48 8b 45 c8          	mov    -0x38(%rbp),%rax

		buffer_info->time_stamp = jiffies;
		buffer_info->next_to_watch = i;

		if (++i == tx_ring->count) i = 0;
		tx_ring->next_to_use = i;
    374b:	41 89 5f 18          	mov    %ebx,0x18(%r15)
		dev_kfree_skb_any(skb);
		return NETDEV_TX_OK;
	}

	if (likely(tso)) {
		if (likely(hw->mac_type != e1000_82544))
    374f:	83 b8 18 0c 00 00 04 	cmpl   $0x4,0xc18(%rax)
    3756:	74 05                	je     375d <e1000_xmit_frame+0xaad>
			tx_ring->last_tx_tso = true;
    3758:	41 c6 47 2c 01       	movb   $0x1,0x2c(%r15)
		tx_flags |= E1000_TX_FLAGS_TSO;
    375d:	83 4d 98 04          	orl    $0x4,-0x68(%rbp)
    3761:	e9 30 f7 ff ff       	jmpq   2e96 <e1000_xmit_frame+0x1e6>
	return skb->csum_start - skb_headroom(skb);
}

static inline int skb_transport_offset(const struct sk_buff *skb)
{
	return skb_transport_header(skb) - skb->data;
    3766:	4d 29 c8             	sub    %r9,%r8
	if (mss) {
		u8 hdr_len;
		max_per_txd = min(mss << 2, max_per_txd);
		max_txd_pwr = fls(max_per_txd) - 1;

		hdr_len = skb_transport_offset(skb) + tcp_hdrlen(skb);
    3769:	41 8d 34 b0          	lea    (%r8,%rsi,4),%esi
		if (skb->data_len && hdr_len == len) {
    376d:	40 0f b6 f6          	movzbl %sil,%esi
    3771:	44 39 d6             	cmp    %r10d,%esi
    3774:	0f 85 0b f6 ff ff    	jne    2d85 <e1000_xmit_frame+0xd5>
			switch (hw->mac_type) {
    377a:	48 8b 4d c8          	mov    -0x38(%rbp),%rcx
    377e:	8b b1 18 0c 00 00    	mov    0xc18(%rcx),%esi
    3784:	83 fe 04             	cmp    $0x4,%esi
    3787:	0f 85 f8 f5 ff ff    	jne    2d85 <e1000_xmit_frame+0xd5>
#define SKB_LINEAR_ASSERT(skb)  BUG_ON(skb_is_nonlinear(skb))

#ifdef NET_SKBUFF_DATA_USES_OFFSET
static inline unsigned char *skb_tail_pointer(const struct sk_buff *skb)
{
	return skb->head + skb->tail;
    378d:	45 8b 86 c8 00 00 00 	mov    0xc8(%r14),%r8d
				 * this hardware's requirements
				 * NOTE: this is a TSO only workaround
				 * if end byte alignment not correct move us
				 * into the next dword
				 */
				if ((unsigned long)(skb_tail_pointer(skb) - 1)
    3794:	4a 8d 44 00 ff       	lea    -0x1(%rax,%r8,1),%rax
    3799:	a8 04                	test   $0x4,%al
    379b:	0f 85 e4 f5 ff ff    	jne    2d85 <e1000_xmit_frame+0xd5>
				    & 4)
					break;
				/* fall through */
				pull_size = min((unsigned int)4, skb->data_len);
    37a1:	83 fa 04             	cmp    $0x4,%edx
				if (!__pskb_pull_tail(skb, pull_size)) {
    37a4:	4c 89 f7             	mov    %r14,%rdi
				 */
				if ((unsigned long)(skb_tail_pointer(skb) - 1)
				    & 4)
					break;
				/* fall through */
				pull_size = min((unsigned int)4, skb->data_len);
    37a7:	0f 46 f2             	cmovbe %edx,%esi
				if (!__pskb_pull_tail(skb, pull_size)) {
    37aa:	e8 00 00 00 00       	callq  37af <e1000_xmit_frame+0xaff>
    37af:	48 85 c0             	test   %rax,%rax
    37b2:	0f 84 c1 00 00 00    	je     3879 <e1000_xmit_frame+0xbc9>
		return 0;
	return __e1000_maybe_stop_tx(netdev, size);
}

#define TXD_USE_COUNT(S, X) (((S) >> (X)) + 1 )
static netdev_tx_t e1000_xmit_frame(struct sk_buff *skb,
    37b8:	41 8b 96 84 00 00 00 	mov    0x84(%r14),%edx
	return skb->data_len;
}

static inline unsigned int skb_headlen(const struct sk_buff *skb)
{
	return skb->len - skb->data_len;
    37bf:	45 8b 96 80 00 00 00 	mov    0x80(%r14),%r10d
    37c6:	41 8b be cc 00 00 00 	mov    0xcc(%r14),%edi
    37cd:	49 03 be d0 00 00 00 	add    0xd0(%r14),%rdi
    37d4:	41 29 d2             	sub    %edx,%r10d
					      "failed.\n");
					dev_kfree_skb_any(skb);
					return NETDEV_TX_OK;
				}
				len = skb_headlen(skb);
				break;
    37d7:	e9 a9 f5 ff ff       	jmpq   2d85 <e1000_xmit_frame+0xd5>
		count++;
	count++;

	/* Controller Erratum workaround */
	if (!skb->data_len && tx_ring->last_tx_tso && !skb_is_gso(skb))
		count++;
    37dc:	83 c6 02             	add    $0x2,%esi
    37df:	66 83 7f 02 00       	cmpw   $0x0,0x2(%rdi)
    37e4:	0f 44 c6             	cmove  %esi,%eax
    37e7:	e9 b4 f5 ff ff       	jmpq   2da0 <e1000_xmit_frame+0xf0>
				    struct net_device *netdev)
{
	struct e1000_adapter *adapter = netdev_priv(netdev);
	struct e1000_hw *hw = &adapter->hw;
	struct e1000_tx_ring *tx_ring;
	unsigned int first, max_per_txd = E1000_MAX_DATA_PER_TXD;
    37ec:	c7 45 ac 00 10 00 00 	movl   $0x1000,-0x54(%rbp)
    37f3:	e9 8f f5 ff ff       	jmpq   2d87 <e1000_xmit_frame+0xd7>
	skb->transport_header += offset;
}

static inline unsigned char *skb_network_header(const struct sk_buff *skb)
{
	return skb->head + skb->network_header;
    37f8:	41 0f b7 86 c4 00 00 	movzwl 0xc4(%r14),%eax
    37ff:	00 
			iph->check = 0;
			tcp_hdr(skb)->check = ~csum_tcpudp_magic(iph->saddr,
								 iph->daddr, 0,
								 IPPROTO_TCP,
								 0);
			cmd_length = E1000_TXD_CMD_IP;
    3800:	be 00 00 00 02       	mov    $0x2000000,%esi
    3805:	48 01 c7             	add    %rax,%rdi

		hdr_len = skb_transport_offset(skb) + tcp_hdrlen(skb);
		mss = skb_shinfo(skb)->gso_size;
		if (protocol == htons(ETH_P_IP)) {
			struct iphdr *iph = ip_hdr(skb);
			iph->tot_len = 0;
    3808:	31 c0                	xor    %eax,%eax
    380a:	66 89 47 02          	mov    %ax,0x2(%rdi)
			iph->check = 0;
    380e:	31 c0                	xor    %eax,%eax
    3810:	66 89 47 0a          	mov    %ax,0xa(%rdi)
 */
static inline __wsum
csum_tcpudp_nofold(__be32 saddr, __be32 daddr, unsigned short len,
		   unsigned short proto, __wsum sum)
{
	asm("  addl %1, %0\n"
    3814:	31 c0                	xor    %eax,%eax
			tcp_hdr(skb)->check = ~csum_tcpudp_magic(iph->saddr,
    3816:	49 8b 8e d0 00 00 00 	mov    0xd0(%r14),%rcx
    381d:	03 47 10             	add    0x10(%rdi),%eax
    3820:	13 47 0c             	adc    0xc(%rdi),%eax
    3823:	15 00 06 00 00       	adc    $0x600,%eax
    3828:	83 d0 00             	adc    $0x0,%eax
static inline __sum16 csum_fold(__wsum sum)
{
	asm("  addl %1,%0\n"
	    "  adcl $0xffff,%0"
	    : "=r" (sum)
	    : "r" ((__force u32)sum << 16),
    382b:	89 c2                	mov    %eax,%edx
	      "0" ((__force u32)sum & 0xffff0000));
    382d:	66 31 c0             	xor    %ax,%ax
static inline __sum16 csum_fold(__wsum sum)
{
	asm("  addl %1,%0\n"
	    "  adcl $0xffff,%0"
	    : "=r" (sum)
	    : "r" ((__force u32)sum << 16),
    3830:	c1 e2 10             	shl    $0x10,%edx
 * the last step before putting a checksum into a packet.
 * Make sure not to mix with 64bit checksums.
 */
static inline __sum16 csum_fold(__wsum sum)
{
	asm("  addl %1,%0\n"
    3833:	01 d0                	add    %edx,%eax
    3835:	15 ff ff 00 00       	adc    $0xffff,%eax
	return skb->transport_header != (typeof(skb->transport_header))~0U;
}

static inline unsigned char *skb_transport_header(const struct sk_buff *skb)
{
	return skb->head + skb->transport_header;
    383a:	41 0f b7 96 c2 00 00 	movzwl 0xc2(%r14),%edx
    3841:	00 
	    "  adcl $0xffff,%0"
	    : "=r" (sum)
	    : "r" ((__force u32)sum << 16),
	      "0" ((__force u32)sum & 0xffff0000));
	return (__force __sum16)(~(__force u32)sum >> 16);
    3842:	f7 d0                	not    %eax
    3844:	c1 e8 10             	shr    $0x10,%eax
    3847:	f7 d0                	not    %eax
    3849:	66 89 44 11 10       	mov    %ax,0x10(%rcx,%rdx,1)
    384e:	41 0f b7 8e c2 00 00 	movzwl 0xc2(%r14),%ecx
    3855:	00 
static inline int skb_checksum_start_offset(const struct sk_buff *skb)
{
	return skb->csum_start - skb_headroom(skb);
}

static inline int skb_transport_offset(const struct sk_buff *skb)
    3856:	49 8b be d0 00 00 00 	mov    0xd0(%r14),%rdi
{
	return skb_transport_header(skb) - skb->data;
    385d:	49 8b 96 d8 00 00 00 	mov    0xd8(%r14),%rdx
	return skb->transport_header != (typeof(skb->transport_header))~0U;
}

static inline unsigned char *skb_transport_header(const struct sk_buff *skb)
{
	return skb->head + skb->transport_header;
    3864:	48 01 f9             	add    %rdi,%rcx
	return skb->csum_start - skb_headroom(skb);
}

static inline int skb_transport_offset(const struct sk_buff *skb)
{
	return skb_transport_header(skb) - skb->data;
    3867:	48 89 c8             	mov    %rcx,%rax
    386a:	48 29 d0             	sub    %rdx,%rax
								 iph->daddr, 0,
								 IPPROTO_TCP,
								 0);
			cmd_length = E1000_TXD_CMD_IP;
			ipcse = skb_transport_offset(skb) - 1;
    386d:	44 8d 58 ff          	lea    -0x1(%rax),%r11d
    3871:	88 45 d0             	mov    %al,-0x30(%rbp)
    3874:	e9 31 fe ff ff       	jmpq   36aa <e1000_xmit_frame+0x9fa>
				    & 4)
					break;
				/* fall through */
				pull_size = min((unsigned int)4, skb->data_len);
				if (!__pskb_pull_tail(skb, pull_size)) {
					e_err(drv, "__pskb_pull_tail "
    3879:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
    387d:	f6 80 e0 0f 00 00 01 	testb  $0x1,0xfe0(%rax)
    3884:	74 15                	je     389b <e1000_xmit_frame+0xbeb>
    3886:	48 8b b8 f0 0b 00 00 	mov    0xbf0(%rax),%rdi
    388d:	48 c7 c6 00 00 00 00 	mov    $0x0,%rsi
    3894:	31 c0                	xor    %eax,%eax
    3896:	e8 00 00 00 00       	callq  389b <e1000_xmit_frame+0xbeb>
    389b:	be 01 00 00 00       	mov    $0x1,%esi
    38a0:	4c 89 f7             	mov    %r14,%rdi
    38a3:	e8 00 00 00 00       	callq  38a8 <e1000_xmit_frame+0xbf8>
					      "failed.\n");
					dev_kfree_skb_any(skb);
					return NETDEV_TX_OK;
    38a8:	31 c0                	xor    %eax,%eax
    38aa:	e9 ac fc ff ff       	jmpq   355b <e1000_xmit_frame+0x8ab>
	skb->transport_header += offset;
}

static inline unsigned char *skb_network_header(const struct sk_buff *skb)
{
	return skb->head + skb->network_header;
    38af:	41 0f b7 86 c4 00 00 	movzwl 0xc4(%r14),%eax
    38b6:	00 
								 IPPROTO_TCP,
								 0);
			cmd_length = E1000_TXD_CMD_IP;
			ipcse = skb_transport_offset(skb) - 1;
		} else if (skb_is_gso_v6(skb)) {
			ipv6_hdr(skb)->payload_len = 0;
    38b7:	31 db                	xor    %ebx,%ebx
			tcp_hdr(skb)->check =
				~csum_ipv6_magic(&ipv6_hdr(skb)->saddr,
    38b9:	b9 06 00 00 00       	mov    $0x6,%ecx
    38be:	45 31 c0             	xor    %r8d,%r8d
    38c1:	44 89 55 c0          	mov    %r10d,-0x40(%rbp)
								 IPPROTO_TCP,
								 0);
			cmd_length = E1000_TXD_CMD_IP;
			ipcse = skb_transport_offset(skb) - 1;
		} else if (skb_is_gso_v6(skb)) {
			ipv6_hdr(skb)->payload_len = 0;
    38c5:	66 89 5c 07 04       	mov    %bx,0x4(%rdi,%rax,1)
    38ca:	41 0f b7 96 c4 00 00 	movzwl 0xc4(%r14),%edx
    38d1:	00 
	return skb->transport_header != (typeof(skb->transport_header))~0U;
}

static inline unsigned char *skb_transport_header(const struct sk_buff *skb)
{
	return skb->head + skb->transport_header;
    38d2:	41 0f b7 9e c2 00 00 	movzwl 0xc2(%r14),%ebx
    38d9:	00 
#include <net/sock.h>
#include <net/inet_connection_sock.h>
#include <net/inet_timewait_sock.h>
#include <uapi/linux/tcp.h>

static inline struct tcphdr *tcp_hdr(const struct sk_buff *skb)
    38da:	49 8b 86 d0 00 00 00 	mov    0xd0(%r14),%rax
    38e1:	48 01 c3             	add    %rax,%rbx
	skb->transport_header += offset;
}

static inline unsigned char *skb_network_header(const struct sk_buff *skb)
{
	return skb->head + skb->network_header;
    38e4:	48 01 d0             	add    %rdx,%rax
			tcp_hdr(skb)->check =
				~csum_ipv6_magic(&ipv6_hdr(skb)->saddr,
    38e7:	31 d2                	xor    %edx,%edx
						 &ipv6_hdr(skb)->daddr,
    38e9:	48 8d 70 18          	lea    0x18(%rax),%rsi
			cmd_length = E1000_TXD_CMD_IP;
			ipcse = skb_transport_offset(skb) - 1;
		} else if (skb_is_gso_v6(skb)) {
			ipv6_hdr(skb)->payload_len = 0;
			tcp_hdr(skb)->check =
				~csum_ipv6_magic(&ipv6_hdr(skb)->saddr,
    38ed:	48 8d 78 08          	lea    0x8(%rax),%rdi
    38f1:	e8 00 00 00 00       	callq  38f6 <e1000_xmit_frame+0xc46>
								 0);
			cmd_length = E1000_TXD_CMD_IP;
			ipcse = skb_transport_offset(skb) - 1;
		} else if (skb_is_gso_v6(skb)) {
			ipv6_hdr(skb)->payload_len = 0;
			tcp_hdr(skb)->check =
    38f6:	f7 d0                	not    %eax
				~csum_ipv6_magic(&ipv6_hdr(skb)->saddr,
						 &ipv6_hdr(skb)->daddr,
						 0, IPPROTO_TCP, 0);
			ipcse = 0;
    38f8:	45 31 db             	xor    %r11d,%r11d
		     __be16 protocol)
{
	struct e1000_context_desc *context_desc;
	struct e1000_tx_buffer *buffer_info;
	unsigned int i;
	u32 cmd_length = 0;
    38fb:	31 f6                	xor    %esi,%esi
								 0);
			cmd_length = E1000_TXD_CMD_IP;
			ipcse = skb_transport_offset(skb) - 1;
		} else if (skb_is_gso_v6(skb)) {
			ipv6_hdr(skb)->payload_len = 0;
			tcp_hdr(skb)->check =
    38fd:	66 89 43 10          	mov    %ax,0x10(%rbx)
    3901:	41 0f b7 8e c2 00 00 	movzwl 0xc2(%r14),%ecx
    3908:	00 
    3909:	49 8b be d0 00 00 00 	mov    0xd0(%r14),%rdi
    3910:	49 8b 96 d8 00 00 00 	mov    0xd8(%r14),%rdx
    3917:	44 8b 55 c0          	mov    -0x40(%rbp),%r10d
    391b:	48 01 f9             	add    %rdi,%rcx
    391e:	89 c8                	mov    %ecx,%eax
    3920:	29 d0                	sub    %edx,%eax
    3922:	88 45 d0             	mov    %al,-0x30(%rbp)
    3925:	e9 80 fd ff ff       	jmpq   36aa <e1000_xmit_frame+0x9fa>
{
	struct e1000_hw *hw = &adapter->hw;
	struct pci_dev *pdev = adapter->pdev;
	struct e1000_tx_buffer *buffer_info;
	unsigned int len = skb_headlen(skb);
	unsigned int offset = 0, size, count = 0, i;
    392a:	c7 45 bc 00 00 00 00 	movl   $0x0,-0x44(%rbp)
    3931:	e9 ca f7 ff ff       	jmpq   3100 <e1000_xmit_frame+0x450>
    3936:	41 8b 86 cc 00 00 00 	mov    0xcc(%r14),%eax
    393d:	49 03 86 d0 00 00 00 	add    0xd0(%r14),%rax
    3944:	e9 46 f9 ff ff       	jmpq   328f <e1000_xmit_frame+0x5df>
			offset += size;
			count++;
		}
	}

	segs = skb_shinfo(skb)->gso_segs ?: 1;
    3949:	ba 01 00 00 00       	mov    $0x1,%edx
    394e:	31 f6                	xor    %esi,%esi
    3950:	e9 4d f9 ff ff       	jmpq   32a2 <e1000_xmit_frame+0x5f2>

static inline int pskb_may_pull(struct sk_buff *skb, unsigned int len)
{
	if (likely(len <= skb_headlen(skb)))
		return 1;
	if (unlikely(len > skb->len))
    3955:	41 39 d5             	cmp    %edx,%r13d
    3958:	0f 87 f7 00 00 00    	ja     3a55 <e1000_xmit_frame+0xda5>
		return 0;
	return __pskb_pull_tail(skb, len - skb_headlen(skb)) != NULL;
    395e:	44 89 ee             	mov    %r13d,%esi
    3961:	29 fe                	sub    %edi,%esi
    3963:	4c 89 f7             	mov    %r14,%rdi
    3966:	e8 00 00 00 00       	callq  396b <e1000_xmit_frame+0xcbb>
			vlan_depth = ETH_HLEN;
		}
		do {
			struct vlan_hdr *vh;

			if (unlikely(!pskb_may_pull(skb,
    396b:	48 85 c0             	test   %rax,%rax
    396e:	0f 85 d5 00 00 00    	jne    3a49 <e1000_xmit_frame+0xd99>
    3974:	45 89 fa             	mov    %r15d,%r10d
    3977:	41 8b 96 80 00 00 00 	mov    0x80(%r14),%edx
						    vlan_depth + VLAN_HLEN)))
				return 0;
    397e:	45 31 e4             	xor    %r12d,%r12d
    3981:	e9 80 f3 ff ff       	jmpq   2d06 <e1000_xmit_frame+0x56>
		offset = 0;

		while (len) {
			unsigned long bufend;
			i++;
			if (unlikely(i == tx_ring->count))
    3986:	45 31 e4             	xor    %r12d,%r12d
				i = 0;
    3989:	45 31 f6             	xor    %r14d,%r14d
    398c:	e9 fc f7 ff ff       	jmpq   318d <e1000_xmit_frame+0x4dd>
		}

		/* Workaround for premature desc write-backs
		 * in TSO mode.  Append 4-byte sentinel desc
		 */
		if (unlikely(mss && !nr_frags && size == len && size > 8))
    3991:	44 39 eb             	cmp    %r13d,%ebx
    3994:	0f 85 db f5 ff ff    	jne    2f75 <e1000_xmit_frame+0x2c5>
    399a:	41 83 fd 08          	cmp    $0x8,%r13d
    399e:	0f 86 d1 f5 ff ff    	jbe    2f75 <e1000_xmit_frame+0x2c5>
			size -= 4;
    39a4:	41 83 ed 04          	sub    $0x4,%r13d
    39a8:	e9 c8 f5 ff ff       	jmpq   2f75 <e1000_xmit_frame+0x2c5>
		/* work-around for errata 10 and it applies
		 * to all controllers in PCI-X mode
		 * The fix is to make sure that the first descriptor of a
		 * packet is smaller than 2048 - 16 - 16 (or 2016) bytes
		 */
		if (unlikely((hw->bus_type == e1000_bus_type_pcix) &&
    39ad:	41 81 fd df 07 00 00 	cmp    $0x7df,%r13d
    39b4:	0f 86 cc f5 ff ff    	jbe    2f86 <e1000_xmit_frame+0x2d6>
    39ba:	8b 7d bc             	mov    -0x44(%rbp),%edi
    39bd:	85 ff                	test   %edi,%edi
    39bf:	0f 85 c1 f5 ff ff    	jne    2f86 <e1000_xmit_frame+0x2d6>
    39c5:	b9 df 07 00 00       	mov    $0x7df,%ecx
		                (size > 2015) && count == 0))
		        size = 2015;
    39ca:	41 bd df 07 00 00    	mov    $0x7df,%r13d
    39d0:	e9 b4 f5 ff ff       	jmpq   2f89 <e1000_xmit_frame+0x2d9>

		/* Workaround for potential 82544 hang in PCI-X.  Avoid
		 * terminating buffers within evenly-aligned dwords.
		 */
		if (unlikely(adapter->pcix_82544 &&
    39d5:	48 8b 7d c0          	mov    -0x40(%rbp),%rdi
    39d9:	48 8d 44 31 ff       	lea    -0x1(%rcx,%rsi,1),%rax
    39de:	48 03 87 d8 00 00 00 	add    0xd8(%rdi),%rax
    39e5:	a8 04                	test   $0x4,%al
    39e7:	0f 85 b0 f5 ff ff    	jne    2f9d <e1000_xmit_frame+0x2ed>
    39ed:	41 83 fd 04          	cmp    $0x4,%r13d
    39f1:	0f 86 a6 f5 ff ff    	jbe    2f9d <e1000_xmit_frame+0x2ed>
		   !((unsigned long)(skb->data + offset + size - 1) & 4) &&
		   size > 4))
			size -= 4;
    39f7:	41 83 ed 04          	sub    $0x4,%r13d
    39fb:	44 89 e9             	mov    %r13d,%ecx
    39fe:	e9 9a f5 ff ff       	jmpq   2f9d <e1000_xmit_frame+0x2ed>
			buffer_info = &tx_ring->buffer_info[i];
			size = min(len, max_per_txd);
			/* Workaround for premature desc write-backs
			 * in TSO mode.  Append 4-byte sentinel desc
			 */
			if (unlikely(mss && f == (nr_frags-1) &&
    3a03:	8b 45 84             	mov    -0x7c(%rbp),%eax
    3a06:	39 45 9c             	cmp    %eax,-0x64(%rbp)
    3a09:	0f 85 9b f7 ff ff    	jne    31aa <e1000_xmit_frame+0x4fa>
    3a0f:	41 39 dd             	cmp    %ebx,%r13d
    3a12:	0f 85 92 f7 ff ff    	jne    31aa <e1000_xmit_frame+0x4fa>
    3a18:	83 fb 08             	cmp    $0x8,%ebx
    3a1b:	0f 86 89 f7 ff ff    	jbe    31aa <e1000_xmit_frame+0x4fa>
			    size == len && size > 8))
				size -= 4;
    3a21:	83 eb 04             	sub    $0x4,%ebx
    3a24:	e9 81 f7 ff ff       	jmpq   31aa <e1000_xmit_frame+0x4fa>
			 * Avoid terminating buffers within evenly-aligned
			 * dwords.
			 */
			bufend = (unsigned long)
				page_to_phys(skb_frag_page(frag));
			bufend += offset + size - 1;
    3a29:	8b 45 b8             	mov    -0x48(%rbp),%eax
    3a2c:	8d 44 18 ff          	lea    -0x1(%rax,%rbx,1),%eax
			if (unlikely(adapter->pcix_82544 &&
    3a30:	a8 04                	test   $0x4,%al
    3a32:	0f 85 83 f7 ff ff    	jne    31bb <e1000_xmit_frame+0x50b>
    3a38:	83 fb 04             	cmp    $0x4,%ebx
    3a3b:	0f 86 7a f7 ff ff    	jbe    31bb <e1000_xmit_frame+0x50b>
				     !(bufend & 4) &&
				     size > 4))
				size -= 4;
    3a41:	83 eb 04             	sub    $0x4,%ebx
    3a44:	e9 72 f7 ff ff       	jmpq   31bb <e1000_xmit_frame+0x50b>
    3a49:	41 8b 96 80 00 00 00 	mov    0x80(%r14),%edx
    3a50:	e9 6e f6 ff ff       	jmpq   30c3 <e1000_xmit_frame+0x413>
    3a55:	45 89 fa             	mov    %r15d,%r10d
    3a58:	45 31 e4             	xor    %r12d,%r12d
    3a5b:	e9 a6 f2 ff ff       	jmpq   2d06 <e1000_xmit_frame+0x56>
				       struct sk_buff *skb)
{
	u32 fifo_space = adapter->tx_fifo_size - adapter->tx_fifo_head;
	u32 skb_fifo_len = skb->len + E1000_FIFO_HDR;

	skb_fifo_len = ALIGN(skb_fifo_len, E1000_FIFO_HDR);
    3a60:	41 8b 86 80 00 00 00 	mov    0x80(%r14),%eax
#define E1000_82547_PAD_LEN		0x3E0

static int e1000_82547_fifo_workaround(struct e1000_adapter *adapter,
				       struct sk_buff *skb)
{
	u32 fifo_space = adapter->tx_fifo_size - adapter->tx_fifo_head;
    3a67:	48 8b 4d c8          	mov    -0x38(%rbp),%rcx
	u32 skb_fifo_len = skb->len + E1000_FIFO_HDR;

	skb_fifo_len = ALIGN(skb_fifo_len, E1000_FIFO_HDR);
    3a6b:	83 c0 1f             	add    $0x1f,%eax
#define E1000_82547_PAD_LEN		0x3E0

static int e1000_82547_fifo_workaround(struct e1000_adapter *adapter,
				       struct sk_buff *skb)
{
	u32 fifo_space = adapter->tx_fifo_size - adapter->tx_fifo_head;
    3a6e:	8b 91 c4 0a 00 00    	mov    0xac4(%rcx),%edx
    3a74:	8b b1 bc 0a 00 00    	mov    0xabc(%rcx),%esi
	u32 skb_fifo_len = skb->len + E1000_FIFO_HDR;

	skb_fifo_len = ALIGN(skb_fifo_len, E1000_FIFO_HDR);
    3a7a:	83 e0 f0             	and    $0xfffffff0,%eax

	if (adapter->link_duplex != HALF_DUPLEX)
    3a7d:	66 83 b9 5a 0a 00 00 	cmpw   $0x1,0xa5a(%rcx)
    3a84:	01 
    3a85:	74 2d                	je     3ab4 <e1000_xmit_frame+0xe04>
		atomic_set(&adapter->tx_fifo_stall, 1);
		return 1;
	}

no_fifo_stall_required:
	adapter->tx_fifo_head += skb_fifo_len;
    3a87:	48 8b 4d c8          	mov    -0x38(%rbp),%rcx
    3a8b:	01 f0                	add    %esi,%eax
	if (adapter->tx_fifo_head >= adapter->tx_fifo_size)
    3a8d:	39 c2                	cmp    %eax,%edx
		atomic_set(&adapter->tx_fifo_stall, 1);
		return 1;
	}

no_fifo_stall_required:
	adapter->tx_fifo_head += skb_fifo_len;
    3a8f:	89 81 bc 0a 00 00    	mov    %eax,0xabc(%rcx)
	if (adapter->tx_fifo_head >= adapter->tx_fifo_size)
    3a95:	0f 87 9a f3 ff ff    	ja     2e35 <e1000_xmit_frame+0x185>
		adapter->tx_fifo_head -= adapter->tx_fifo_size;
    3a9b:	29 d0                	sub    %edx,%eax
    3a9d:	89 81 bc 0a 00 00    	mov    %eax,0xabc(%rcx)
    3aa3:	e9 8d f3 ff ff       	jmpq   2e35 <e1000_xmit_frame+0x185>
		txd_lower |= E1000_TXD_CMD_VLE;
		txd_upper |= (tx_flags & E1000_TX_FLAGS_VLAN_MASK);
	}

	if (unlikely(tx_flags & E1000_TX_FLAGS_NO_FCS))
		txd_lower &= ~(E1000_TXD_CMD_IFCS);
    3aa8:	41 81 e1 ff ff ff fd 	and    $0xfdffffff,%r9d
    3aaf:	e9 fe f8 ff ff       	jmpq   33b2 <e1000_xmit_frame+0x702>
    3ab4:	8b 89 cc 0a 00 00    	mov    0xacc(%rcx),%ecx
	skb_fifo_len = ALIGN(skb_fifo_len, E1000_FIFO_HDR);

	if (adapter->link_duplex != HALF_DUPLEX)
		goto no_fifo_stall_required;

	if (atomic_read(&adapter->tx_fifo_stall))
    3aba:	85 c9                	test   %ecx,%ecx
    3abc:	75 1a                	jne    3ad8 <e1000_xmit_frame+0xe28>
#define E1000_82547_PAD_LEN		0x3E0

static int e1000_82547_fifo_workaround(struct e1000_adapter *adapter,
				       struct sk_buff *skb)
{
	u32 fifo_space = adapter->tx_fifo_size - adapter->tx_fifo_head;
    3abe:	8d 8a e0 03 00 00    	lea    0x3e0(%rdx),%ecx
		goto no_fifo_stall_required;

	if (atomic_read(&adapter->tx_fifo_stall))
		return 1;

	if (skb_fifo_len >= (E1000_82547_PAD_LEN + fifo_space)) {
    3ac4:	29 f1                	sub    %esi,%ecx
    3ac6:	39 c8                	cmp    %ecx,%eax
    3ac8:	72 bd                	jb     3a87 <e1000_xmit_frame+0xdd7>
static __always_inline void __write_once_size(volatile void *p, void *res, int size)
{
	switch (size) {
	case 1: *(volatile __u8 *)p = *(__u8 *)res; break;
	case 2: *(volatile __u16 *)p = *(__u16 *)res; break;
	case 4: *(volatile __u32 *)p = *(__u32 *)res; break;
    3aca:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
    3ace:	c7 80 cc 0a 00 00 01 	movl   $0x1,0xacc(%rax)
    3ad5:	00 00 00 
static __always_inline void
set_bit(long nr, volatile unsigned long *addr)
{
	if (IS_IMMEDIATE(nr)) {
		asm volatile(LOCK_PREFIX "orb %1,%0"
			: CONST_MASK_ADDR(nr, addr)
    3ad8:	48 8b 4d c8          	mov    -0x38(%rbp),%rcx
    3adc:	48 8b 81 c0 03 00 00 	mov    0x3c0(%rcx),%rax
 */
static __always_inline void
set_bit(long nr, volatile unsigned long *addr)
{
	if (IS_IMMEDIATE(nr)) {
		asm volatile(LOCK_PREFIX "orb %1,%0"
    3ae3:	f0 80 88 98 00 00 00 	lock orb $0x1,0x98(%rax)
    3aea:	01 
}

static __always_inline int constant_test_bit(long nr, const volatile unsigned long *addr)
{
	return ((1UL << (nr & (BITS_PER_LONG-1))) &
		(addr[nr >> _BITOPS_LONG_SHIFT])) != 0;
    3aeb:	48 8b 81 e8 0f 00 00 	mov    0xfe8(%rcx),%rax
		return NETDEV_TX_BUSY;

	if (unlikely((hw->mac_type == e1000_82547) &&
		     (e1000_82547_fifo_workaround(adapter, skb)))) {
		netif_stop_queue(netdev);
		if (!test_bit(__E1000_DOWN, &adapter->flags))
    3af2:	a8 04                	test   $0x4,%al
    3af4:	75 21                	jne    3b17 <e1000_xmit_frame+0xe67>
			schedule_delayed_work(&adapter->fifo_stall_task, 1);
    3af6:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
 */
static inline bool queue_delayed_work(struct workqueue_struct *wq,
				      struct delayed_work *dwork,
				      unsigned long delay)
{
	return queue_delayed_work_on(WORK_CPU_UNBOUND, wq, dwork, delay);
    3afa:	48 8b 35 00 00 00 00 	mov    0x0(%rip),%rsi        # 3b01 <e1000_xmit_frame+0xe51>
    3b01:	b9 01 00 00 00       	mov    $0x1,%ecx
    3b06:	bf 00 01 00 00       	mov    $0x100,%edi
    3b0b:	48 81 c2 a0 10 00 00 	add    $0x10a0,%rdx
    3b12:	e8 00 00 00 00       	callq  3b17 <e1000_xmit_frame+0xe67>
		return NETDEV_TX_BUSY;
    3b17:	b8 10 00 00 00       	mov    $0x10,%eax
    3b1c:	e9 3a fa ff ff       	jmpq   355b <e1000_xmit_frame+0x8ab>
 */
static __always_inline void
set_bit(long nr, volatile unsigned long *addr)
{
	if (IS_IMMEDIATE(nr)) {
		asm volatile(LOCK_PREFIX "orb %1,%0"
    3b21:	f0 80 88 98 00 00 00 	lock orb $0x2,0x98(%rax)
    3b28:	02 
	/*
	 * The XOFF flag must be set before checking the dql_avail below,
	 * because in netdev_tx_completed_queue we update the dql_completed
	 * before checking the XOFF flag.
	 */
	smp_mb();
    3b29:	0f ae f0             	mfence 
    3b2c:	8b 88 c4 00 00 00    	mov    0xc4(%rax),%ecx
    3b32:	8b 90 c0 00 00 00    	mov    0xc0(%rax),%edx

	/* check again in case another CPU has just made room avail */
	if (unlikely(dql_avail(&dev_queue->dql) >= 0))
    3b38:	39 d1                	cmp    %edx,%ecx
    3b3a:	0f 88 f8 f7 ff ff    	js     3338 <e1000_xmit_frame+0x688>
 */
static __always_inline void
clear_bit(long nr, volatile unsigned long *addr)
{
	if (IS_IMMEDIATE(nr)) {
		asm volatile(LOCK_PREFIX "andb %1,%0"
    3b40:	f0 80 a0 98 00 00 00 	lock andb $0xfd,0x98(%rax)
    3b47:	fd 
    3b48:	e9 eb f7 ff ff       	jmpq   3338 <e1000_xmit_frame+0x688>
 * Record number of objects queued. Assumes that caller has already checked
 * availability in the queue with dql_avail.
 */
static inline void dql_queued(struct dql *dql, unsigned int count)
{
	BUG_ON(count > DQL_MAX_OBJECT);
    3b4d:	0f 0b                	ud2    
	u32 cmd_len = E1000_TXD_CMD_DEXT;

	if (skb->ip_summed != CHECKSUM_PARTIAL)
		return false;

	switch (protocol) {
    3b4f:	66 41 83 fc 08       	cmp    $0x8,%r12w
    3b54:	0f 84 ca 00 00 00    	je     3c24 <e1000_xmit_frame+0xf74>
    3b5a:	66 41 81 fc 86 dd    	cmp    $0xdd86,%r12w
    3b60:	0f 85 a0 00 00 00    	jne    3c06 <e1000_xmit_frame+0xf56>
	skb->transport_header += offset;
}

static inline unsigned char *skb_network_header(const struct sk_buff *skb)
{
	return skb->head + skb->network_header;
    3b66:	41 0f b7 96 c4 00 00 	movzwl 0xc4(%r14),%edx
    3b6d:	00 
		if (ip_hdr(skb)->protocol == IPPROTO_TCP)
			cmd_len |= E1000_TXD_CMD_TCP;
		break;
	case cpu_to_be16(ETH_P_IPV6):
		/* XXX not handling all IPV6 headers */
		if (ipv6_hdr(skb)->nexthdr == IPPROTO_TCP)
    3b6e:	8b 4d 90             	mov    -0x70(%rbp),%ecx
    3b71:	b8 00 00 00 20       	mov    $0x20000000,%eax
    3b76:	80 7c 17 06 06       	cmpb   $0x6,0x6(%rdi,%rdx,1)
    3b7b:	ba 00 00 00 21       	mov    $0x21000000,%edx
    3b80:	0f 44 c2             	cmove  %edx,%eax
	}
}

static inline int skb_checksum_start_offset(const struct sk_buff *skb)
{
	return skb->csum_start - skb_headroom(skb);
    3b83:	41 0f b7 96 98 00 00 	movzwl 0x98(%r14),%edx
    3b8a:	00 
	}

	css = skb_checksum_start_offset(skb);

	i = tx_ring->next_to_use;
	buffer_info = &tx_ring->buffer_info[i];
    3b8b:	49 8b 77 20          	mov    0x20(%r15),%rsi

	context_desc->lower_setup.ip_config = 0;
	context_desc->upper_setup.tcp_fields.tucss = css;
	context_desc->upper_setup.tcp_fields.tucso =
		css + skb->csum_offset;
	context_desc->upper_setup.tcp_fields.tucse = 0;
    3b8f:	45 31 d2             	xor    %r10d,%r10d
 *
 *	Return the number of bytes of free space at the head of an &sk_buff.
 */
static inline unsigned int skb_headroom(const struct sk_buff *skb)
{
	return skb->data - skb->head;
    3b92:	41 2b 96 d8 00 00 00 	sub    0xd8(%r14),%edx
	}
}

static inline int skb_checksum_start_offset(const struct sk_buff *skb)
{
	return skb->csum_start - skb_headroom(skb);
    3b99:	01 d7                	add    %edx,%edi
	}

	css = skb_checksum_start_offset(skb);

	i = tx_ring->next_to_use;
	buffer_info = &tx_ring->buffer_info[i];
    3b9b:	89 ca                	mov    %ecx,%edx
    3b9d:	4c 8d 04 92          	lea    (%rdx,%rdx,4),%r8
	context_desc = E1000_CONTEXT_DESC(*tx_ring, i);
    3ba1:	48 c1 e2 04          	shl    $0x4,%rdx
    3ba5:	49 03 17             	add    (%r15),%rdx
	}

	css = skb_checksum_start_offset(skb);

	i = tx_ring->next_to_use;
	buffer_info = &tx_ring->buffer_info[i];
    3ba8:	4a 8d 34 c6          	lea    (%rsi,%r8,8),%rsi
	context_desc = E1000_CONTEXT_DESC(*tx_ring, i);

	context_desc->lower_setup.ip_config = 0;
    3bac:	c7 02 00 00 00 00    	movl   $0x0,(%rdx)
	context_desc->upper_setup.tcp_fields.tucss = css;
    3bb2:	40 88 7a 04          	mov    %dil,0x4(%rdx)
	context_desc->upper_setup.tcp_fields.tucso =
    3bb6:	41 02 be 9a 00 00 00 	add    0x9a(%r14),%dil
		css + skb->csum_offset;
	context_desc->upper_setup.tcp_fields.tucse = 0;
    3bbd:	66 44 89 52 06       	mov    %r10w,0x6(%rdx)
	context_desc->tcp_seg_setup.data = 0;
	context_desc->cmd_and_length = cpu_to_le32(cmd_len);
    3bc2:	89 42 08             	mov    %eax,0x8(%rdx)
	context_desc->lower_setup.ip_config = 0;
	context_desc->upper_setup.tcp_fields.tucss = css;
	context_desc->upper_setup.tcp_fields.tucso =
		css + skb->csum_offset;
	context_desc->upper_setup.tcp_fields.tucse = 0;
	context_desc->tcp_seg_setup.data = 0;
    3bc5:	c7 42 0c 00 00 00 00 	movl   $0x0,0xc(%rdx)
	buffer_info = &tx_ring->buffer_info[i];
	context_desc = E1000_CONTEXT_DESC(*tx_ring, i);

	context_desc->lower_setup.ip_config = 0;
	context_desc->upper_setup.tcp_fields.tucss = css;
	context_desc->upper_setup.tcp_fields.tucso =
    3bcc:	40 88 7a 05          	mov    %dil,0x5(%rdx)
		css + skb->csum_offset;
	context_desc->upper_setup.tcp_fields.tucse = 0;
	context_desc->tcp_seg_setup.data = 0;
	context_desc->cmd_and_length = cpu_to_le32(cmd_len);

	buffer_info->time_stamp = jiffies;
    3bd0:	48 8b 05 00 00 00 00 	mov    0x0(%rip),%rax        # 3bd7 <e1000_xmit_frame+0xf27>
	buffer_info->next_to_watch = i;
    3bd7:	66 89 4e 1a          	mov    %cx,0x1a(%rsi)

	if (unlikely(++i == tx_ring->count)) i = 0;
    3bdb:	83 c1 01             	add    $0x1,%ecx
		css + skb->csum_offset;
	context_desc->upper_setup.tcp_fields.tucse = 0;
	context_desc->tcp_seg_setup.data = 0;
	context_desc->cmd_and_length = cpu_to_le32(cmd_len);

	buffer_info->time_stamp = jiffies;
    3bde:	48 89 46 10          	mov    %rax,0x10(%rsi)
	buffer_info->next_to_watch = i;

	if (unlikely(++i == tx_ring->count)) i = 0;
    3be2:	41 3b 4f 14          	cmp    0x14(%r15),%ecx
    3be6:	b8 00 00 00 00       	mov    $0x0,%eax
    3beb:	0f 44 c8             	cmove  %eax,%ecx
	if (likely(tso)) {
		if (likely(hw->mac_type != e1000_82544))
			tx_ring->last_tx_tso = true;
		tx_flags |= E1000_TX_FLAGS_TSO;
	} else if (likely(e1000_tx_csum(adapter, tx_ring, skb, protocol)))
		tx_flags |= E1000_TX_FLAGS_CSUM;
    3bee:	83 4d 98 01          	orl    $0x1,-0x68(%rbp)

	buffer_info->time_stamp = jiffies;
	buffer_info->next_to_watch = i;

	if (unlikely(++i == tx_ring->count)) i = 0;
	tx_ring->next_to_use = i;
    3bf2:	41 89 4f 18          	mov    %ecx,0x18(%r15)
	if (likely(tso)) {
		if (likely(hw->mac_type != e1000_82544))
			tx_ring->last_tx_tso = true;
		tx_flags |= E1000_TX_FLAGS_TSO;
	} else if (likely(e1000_tx_csum(adapter, tx_ring, skb, protocol)))
		tx_flags |= E1000_TX_FLAGS_CSUM;
    3bf6:	89 cb                	mov    %ecx,%ebx
    3bf8:	e9 99 f2 ff ff       	jmpq   2e96 <e1000_xmit_frame+0x1e6>

	if (protocol == htons(ETH_P_IP))
		tx_flags |= E1000_TX_FLAGS_IPV4;

	if (unlikely(skb->no_fcs))
		tx_flags |= E1000_TX_FLAGS_NO_FCS;
    3bfd:	83 4d 98 10          	orl    $0x10,-0x68(%rbp)
    3c01:	e9 b1 f2 ff ff       	jmpq   2eb7 <e1000_xmit_frame+0x207>
		/* XXX not handling all IPV6 headers */
		if (ipv6_hdr(skb)->nexthdr == IPPROTO_TCP)
			cmd_len |= E1000_TXD_CMD_TCP;
		break;
	default:
		if (unlikely(net_ratelimit()))
    3c06:	e8 00 00 00 00       	callq  3c0b <e1000_xmit_frame+0xf5b>
    3c0b:	85 c0                	test   %eax,%eax
    3c0d:	75 37                	jne    3c46 <e1000_xmit_frame+0xf96>
    3c0f:	49 8b be d0 00 00 00 	mov    0xd0(%r14),%rdi
    3c16:	41 8b 4f 18          	mov    0x18(%r15),%ecx
{
	struct e1000_context_desc *context_desc;
	struct e1000_tx_buffer *buffer_info;
	unsigned int i;
	u8 css;
	u32 cmd_len = E1000_TXD_CMD_DEXT;
    3c1a:	b8 00 00 00 20       	mov    $0x20000000,%eax
    3c1f:	e9 5f ff ff ff       	jmpq   3b83 <e1000_xmit_frame+0xed3>
	skb->transport_header += offset;
}

static inline unsigned char *skb_network_header(const struct sk_buff *skb)
{
	return skb->head + skb->network_header;
    3c24:	41 0f b7 96 c4 00 00 	movzwl 0xc4(%r14),%edx
    3c2b:	00 
	if (skb->ip_summed != CHECKSUM_PARTIAL)
		return false;

	switch (protocol) {
	case cpu_to_be16(ETH_P_IP):
		if (ip_hdr(skb)->protocol == IPPROTO_TCP)
    3c2c:	b8 00 00 00 20       	mov    $0x20000000,%eax
    3c31:	8b 4d 90             	mov    -0x70(%rbp),%ecx
    3c34:	80 7c 17 09 06       	cmpb   $0x6,0x9(%rdi,%rdx,1)
    3c39:	ba 00 00 00 21       	mov    $0x21000000,%edx
    3c3e:	0f 44 c2             	cmove  %edx,%eax
    3c41:	e9 3d ff ff ff       	jmpq   3b83 <e1000_xmit_frame+0xed3>
		if (ipv6_hdr(skb)->nexthdr == IPPROTO_TCP)
			cmd_len |= E1000_TXD_CMD_TCP;
		break;
	default:
		if (unlikely(net_ratelimit()))
			e_warn(drv, "checksum_partial proto=%x!\n",
    3c46:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
    3c4a:	f6 80 e0 0f 00 00 01 	testb  $0x1,0xfe0(%rax)
    3c51:	74 bc                	je     3c0f <e1000_xmit_frame+0xf5f>
    3c53:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
    3c57:	41 0f b7 96 c0 00 00 	movzwl 0xc0(%r14),%edx
    3c5e:	00 
    3c5f:	48 c7 c6 00 00 00 00 	mov    $0x0,%rsi
    3c66:	48 8b b8 f0 0b 00 00 	mov    0xbf0(%rax),%rdi
    3c6d:	31 c0                	xor    %eax,%eax
    3c6f:	e8 00 00 00 00       	callq  3c74 <e1000_xmit_frame+0xfc4>
    3c74:	eb 99                	jmp    3c0f <e1000_xmit_frame+0xf5f>
	 * present at mac_len - VLAN_HLEN (if mac_len > 0), or at
	 * ETH_HLEN otherwise
	 */
	if (type == htons(ETH_P_8021Q) || type == htons(ETH_P_8021AD)) {
		if (vlan_depth) {
			if (WARN_ON(vlan_depth < VLAN_HLEN))
    3c76:	be ec 01 00 00       	mov    $0x1ec,%esi
    3c7b:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
    3c82:	44 89 55 d0          	mov    %r10d,-0x30(%rbp)
				return 0;
    3c86:	45 31 e4             	xor    %r12d,%r12d
	 * present at mac_len - VLAN_HLEN (if mac_len > 0), or at
	 * ETH_HLEN otherwise
	 */
	if (type == htons(ETH_P_8021Q) || type == htons(ETH_P_8021AD)) {
		if (vlan_depth) {
			if (WARN_ON(vlan_depth < VLAN_HLEN))
    3c89:	e8 00 00 00 00       	callq  3c8e <e1000_xmit_frame+0xfde>
    3c8e:	41 8b 96 80 00 00 00 	mov    0x80(%r14),%edx
    3c95:	44 8b 55 d0          	mov    -0x30(%rbp),%r10d
    3c99:	e9 68 f0 ff ff       	jmpq   2d06 <e1000_xmit_frame+0x56>
static inline int skb_put_padto(struct sk_buff *skb, unsigned int len)
{
	unsigned int size = skb->len;

	if (unlikely(size < len)) {
		len -= size;
    3c9e:	bb 3c 00 00 00       	mov    $0x3c,%ebx
		if (skb_pad(skb, len))
    3ca3:	4c 89 f7             	mov    %r14,%rdi
    3ca6:	44 89 55 d0          	mov    %r10d,-0x30(%rbp)
static inline int skb_put_padto(struct sk_buff *skb, unsigned int len)
{
	unsigned int size = skb->len;

	if (unlikely(size < len)) {
		len -= size;
    3caa:	29 d3                	sub    %edx,%ebx
		if (skb_pad(skb, len))
    3cac:	89 de                	mov    %ebx,%esi
    3cae:	e8 00 00 00 00       	callq  3cb3 <e1000_xmit_frame+0x1003>
    3cb3:	85 c0                	test   %eax,%eax
    3cb5:	44 8b 55 d0          	mov    -0x30(%rbp),%r10d
    3cb9:	0f 85 a9 f7 ff ff    	jne    3468 <e1000_xmit_frame+0x7b8>
/*
 *	Add data to an sk_buff
 */
unsigned char *pskb_put(struct sk_buff *skb, struct sk_buff *tail, int len);
unsigned char *skb_put(struct sk_buff *skb, unsigned int len);
static inline unsigned char *__skb_put(struct sk_buff *skb, unsigned int len)
    3cbf:	41 8b 96 84 00 00 00 	mov    0x84(%r14),%edx
    3cc6:	41 8b 86 c8 00 00 00 	mov    0xc8(%r14),%eax
{
	unsigned char *tmp = skb_tail_pointer(skb);
	SKB_LINEAR_ASSERT(skb);
    3ccd:	85 d2                	test   %edx,%edx
    3ccf:	75 24                	jne    3cf5 <e1000_xmit_frame+0x1045>
	skb->tail += len;
    3cd1:	01 d8                	add    %ebx,%eax
	skb->len  += len;
    3cd3:	41 01 9e 80 00 00 00 	add    %ebx,0x80(%r14)
unsigned char *skb_put(struct sk_buff *skb, unsigned int len);
static inline unsigned char *__skb_put(struct sk_buff *skb, unsigned int len)
{
	unsigned char *tmp = skb_tail_pointer(skb);
	SKB_LINEAR_ASSERT(skb);
	skb->tail += len;
    3cda:	41 89 86 c8 00 00 00 	mov    %eax,0xc8(%r14)
    3ce1:	e9 3b f0 ff ff       	jmpq   2d21 <e1000_xmit_frame+0x71>
	/* work-around for errata 10 and it applies to all controllers
	 * in PCI-X mode, so add one more descriptor to the count
	 */
	if (unlikely((hw->bus_type == e1000_bus_type_pcix) &&
			(len > 2015)))
		count++;
    3ce6:	41 81 fa e0 07 00 00 	cmp    $0x7e0,%r10d
    3ced:	83 de ff             	sbb    $0xffffffff,%esi
    3cf0:	e9 d6 f0 ff ff       	jmpq   2dcb <e1000_xmit_frame+0x11b>
unsigned char *pskb_put(struct sk_buff *skb, struct sk_buff *tail, int len);
unsigned char *skb_put(struct sk_buff *skb, unsigned int len);
static inline unsigned char *__skb_put(struct sk_buff *skb, unsigned int len)
{
	unsigned char *tmp = skb_tail_pointer(skb);
	SKB_LINEAR_ASSERT(skb);
    3cf5:	0f 0b                	ud2    
static int e1000_maybe_stop_tx(struct net_device *netdev,
			       struct e1000_tx_ring *tx_ring, int size)
{
	if (likely(E1000_DESC_UNUSED(tx_ring) >= size))
		return 0;
	return __e1000_maybe_stop_tx(netdev, size);
    3cf7:	48 8b 7d c8          	mov    -0x38(%rbp),%rdi
    3cfb:	e8 00 00 00 00       	callq  3d00 <e1000_xmit_frame+0x1050>
		count += nr_frags;

	/* need: count + 2 desc gap to keep tail from touching
	 * head, otherwise try next time
	 */
	if (unlikely(e1000_maybe_stop_tx(netdev, tx_ring, count + 2)))
    3d00:	85 c0                	test   %eax,%eax
    3d02:	0f 85 0f fe ff ff    	jne    3b17 <e1000_xmit_frame+0xe67>
    3d08:	e9 17 f1 ff ff       	jmpq   2e24 <e1000_xmit_frame+0x174>
static int e1000_maybe_stop_tx(struct net_device *netdev,
			       struct e1000_tx_ring *tx_ring, int size)
{
	if (likely(E1000_DESC_UNUSED(tx_ring) >= size))
		return 0;
	return __e1000_maybe_stop_tx(netdev, size);
    3d0d:	48 8b 7d c8          	mov    -0x38(%rbp),%rdi
    3d11:	be 13 00 00 00       	mov    $0x13,%esi
    3d16:	e8 00 00 00 00       	callq  3d1b <e1000_xmit_frame+0x106b>
    3d1b:	e9 14 f7 ff ff       	jmpq   3434 <e1000_xmit_frame+0x784>

	tx_desc->lower.data |= cpu_to_le32(adapter->txd_cmd);

	/* txd_cmd re-enables FCS, so we'll re-disable it here as desired. */
	if (unlikely(tx_flags & E1000_TX_FLAGS_NO_FCS))
		tx_desc->lower.data &= ~(cpu_to_le32(E1000_TXD_CMD_IFCS));
    3d20:	81 e1 ff ff ff fd    	and    $0xfdffffff,%ecx
    3d26:	89 4a 08             	mov    %ecx,0x8(%rdx)
    3d29:	e9 e2 f6 ff ff       	jmpq   3410 <e1000_xmit_frame+0x760>
		txd_upper |= E1000_TXD_POPTS_TXSM << 8;
	}

	if (unlikely(tx_flags & E1000_TX_FLAGS_VLAN)) {
		txd_lower |= E1000_TXD_CMD_VLE;
		txd_upper |= (tx_flags & E1000_TX_FLAGS_VLAN_MASK);
    3d2e:	8b 45 98             	mov    -0x68(%rbp),%eax
		txd_lower |= E1000_TXD_CMD_DEXT | E1000_TXD_DTYP_D;
		txd_upper |= E1000_TXD_POPTS_TXSM << 8;
	}

	if (unlikely(tx_flags & E1000_TX_FLAGS_VLAN)) {
		txd_lower |= E1000_TXD_CMD_VLE;
    3d31:	41 81 c9 00 00 00 40 	or     $0x40000000,%r9d
		txd_upper |= (tx_flags & E1000_TX_FLAGS_VLAN_MASK);
    3d38:	66 31 c0             	xor    %ax,%ax
    3d3b:	41 09 c0             	or     %eax,%r8d
    3d3e:	e9 5d f6 ff ff       	jmpq   33a0 <e1000_xmit_frame+0x6f0>
			   struct e1000_tx_ring *tx_ring, int tx_flags,
			   int count)
{
	struct e1000_tx_desc *tx_desc = NULL;
	struct e1000_tx_buffer *buffer_info;
	u32 txd_upper = 0, txd_lower = E1000_TXD_CMD_IFCS;
    3d43:	41 b9 00 00 00 02    	mov    $0x2000000,%r9d
    3d49:	45 31 c0             	xor    %r8d,%r8d
    3d4c:	e9 31 f6 ff ff       	jmpq   3382 <e1000_xmit_frame+0x6d2>
    3d51:	66 66 66 66 66 66 2e 	data32 data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
    3d58:	0f 1f 84 00 00 00 00 
    3d5f:	00 

0000000000003d60 <e1000_clean_rx_irq>:
 * @work_to_do: max amount of work allowed for this call to do
 */
static bool e1000_clean_rx_irq(struct e1000_adapter *adapter,
			       struct e1000_rx_ring *rx_ring,
			       int *work_done, int work_to_do)
{
    3d60:	e8 00 00 00 00       	callq  3d65 <e1000_clean_rx_irq+0x5>
    3d65:	55                   	push   %rbp
    3d66:	48 89 e5             	mov    %rsp,%rbp
    3d69:	41 57                	push   %r15
    3d6b:	41 56                	push   %r14
    3d6d:	41 55                	push   %r13
    3d6f:	49 89 fd             	mov    %rdi,%r13
    3d72:	41 54                	push   %r12
    3d74:	53                   	push   %rbx
    3d75:	48 89 f3             	mov    %rsi,%rbx
    3d78:	48 83 ec 60          	sub    $0x60,%rsp
	static int i = 1;
	struct net_device *netdev = adapter->netdev;
    3d7c:	48 8b 87 b0 03 00 00 	mov    0x3b0(%rdi),%rax
 * @work_to_do: max amount of work allowed for this call to do
 */
static bool e1000_clean_rx_irq(struct e1000_adapter *adapter,
			       struct e1000_rx_ring *rx_ring,
			       int *work_done, int work_to_do)
{
    3d83:	48 89 75 c0          	mov    %rsi,-0x40(%rbp)
    3d87:	48 89 55 98          	mov    %rdx,-0x68(%rbp)
    3d8b:	89 4d 94             	mov    %ecx,-0x6c(%rbp)
	struct e1000_rx_desc *rx_desc, *next_rxd;
	struct e1000_rx_buffer *buffer_info, *next_buffer;
	u32 length;
	int cleaned_count = 0;
	bool cleaned = false;
	unsigned int total_rx_bytes=0, total_rx_packets=0;
    3d8e:	c7 45 90 00 00 00 00 	movl   $0x0,-0x70(%rbp)
    3d95:	c7 45 a0 00 00 00 00 	movl   $0x0,-0x60(%rbp)
static bool e1000_clean_rx_irq(struct e1000_adapter *adapter,
			       struct e1000_rx_ring *rx_ring,
			       int *work_done, int work_to_do)
{
	static int i = 1;
	struct net_device *netdev = adapter->netdev;
    3d9c:	48 89 45 88          	mov    %rax,-0x78(%rbp)
	struct pci_dev *pdev = adapter->pdev;
    3da0:	48 8b 87 b8 03 00 00 	mov    0x3b8(%rdi),%rax
	struct e1000_rx_desc *rx_desc, *next_rxd;
	struct e1000_rx_buffer *buffer_info, *next_buffer;
	u32 length;
	int cleaned_count = 0;
	bool cleaned = false;
    3da7:	c6 45 a4 00          	movb   $0x0,-0x5c(%rbp)
	struct net_device *netdev = adapter->netdev;
	struct pci_dev *pdev = adapter->pdev;
	struct e1000_rx_desc *rx_desc, *next_rxd;
	struct e1000_rx_buffer *buffer_info, *next_buffer;
	u32 length;
	int cleaned_count = 0;
    3dab:	c7 45 c8 00 00 00 00 	movl   $0x0,-0x38(%rbp)
			       struct e1000_rx_ring *rx_ring,
			       int *work_done, int work_to_do)
{
	static int i = 1;
	struct net_device *netdev = adapter->netdev;
	struct pci_dev *pdev = adapter->pdev;
    3db2:	48 89 c6             	mov    %rax,%rsi
    3db5:	48 89 85 78 ff ff ff 	mov    %rax,-0x88(%rbp)
	u32 length;
	int cleaned_count = 0;
	bool cleaned = false;
	unsigned int total_rx_bytes=0, total_rx_packets=0;

	i = rx_ring->next_to_clean;
    3dbc:	48 63 43 1c          	movslq 0x1c(%rbx),%rax
    3dc0:	89 05 00 00 00 00    	mov    %eax,0x0(%rip)        # 3dc6 <e1000_clean_rx_irq+0x66>
	rx_desc = E1000_RX_DESC(*rx_ring, i);
    3dc6:	48 c1 e0 04          	shl    $0x4,%rax
    3dca:	49 89 c6             	mov    %rax,%r14
	buffer_info = &rx_ring->buffer_info[i];
    3dcd:	48 03 43 20          	add    0x20(%rbx),%rax
	int cleaned_count = 0;
	bool cleaned = false;
	unsigned int total_rx_bytes=0, total_rx_packets=0;

	i = rx_ring->next_to_clean;
	rx_desc = E1000_RX_DESC(*rx_ring, i);
    3dd1:	4c 03 33             	add    (%rbx),%r14
	buffer_info = &rx_ring->buffer_info[i];
    3dd4:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
				adapter->alloc_rx_buff_failed++;
				break;
			}

			skb_reserve(skb, E1000_HEADROOM);
			dma_unmap_single(&pdev->dev, buffer_info->dma,
    3dd8:	48 89 f0             	mov    %rsi,%rax
    3ddb:	48 05 98 00 00 00    	add    $0x98,%rax
    3de1:	48 89 45 80          	mov    %rax,-0x80(%rbp)
}

static struct sk_buff *e1000_alloc_rx_skb(struct e1000_adapter *adapter,
					  unsigned int bufsz)
{
	struct sk_buff *skb = napi_alloc_skb(&adapter->napi, bufsz);
    3de5:	48 8d 87 b0 02 00 00 	lea    0x2b0(%rdi),%rax
    3dec:	48 89 45 a8          	mov    %rax,-0x58(%rbp)

	i = rx_ring->next_to_clean;
	rx_desc = E1000_RX_DESC(*rx_ring, i);
	buffer_info = &rx_ring->buffer_info[i];

	while (rx_desc->status & E1000_RXD_STAT_DD) {
    3df0:	eb 45                	jmp    3e37 <e1000_clean_rx_irq+0xd7>
		if (unlikely(!(status & E1000_RXD_STAT_EOP)))
			adapter->discarding = true;

		if (adapter->discarding) {
			/* All receives must fit into a single buffer */
			netdev_dbg(netdev, "Receive packet consumed multiple buffers\n");
    3df2:	f6 05 00 00 00 00 04 	testb  $0x4,0x0(%rip)        # 3df9 <e1000_clean_rx_irq+0x99>
    3df9:	0f 85 eb 03 00 00    	jne    41ea <e1000_clean_rx_irq+0x48a>
			dev_kfree_skb(skb);
    3dff:	48 89 df             	mov    %rbx,%rdi
    3e02:	89 4d d0             	mov    %ecx,-0x30(%rbp)
    3e05:	e8 00 00 00 00       	callq  3e0a <e1000_clean_rx_irq+0xaa>
			if (status & E1000_RXD_STAT_EOP)
    3e0a:	8b 4d d0             	mov    -0x30(%rbp),%ecx
    3e0d:	84 c9                	test   %cl,%cl
    3e0f:	74 08                	je     3e19 <e1000_clean_rx_irq+0xb9>
				adapter->discarding = false;
    3e11:	41 c6 85 bc 07 00 00 	movb   $0x0,0x7bc(%r13)
    3e18:	00 

next_desc:
		rx_desc->status = 0;

		/* return some buffers to hardware, one at a time is too slow */
		if (unlikely(cleaned_count >= E1000_RX_BUFFER_WRITE)) {
    3e19:	83 7d c8 0f          	cmpl   $0xf,-0x38(%rbp)
				  le16_to_cpu(rx_desc->csum), skb);

		e1000_receive_skb(adapter, status, rx_desc->special, skb);

next_desc:
		rx_desc->status = 0;
    3e1d:	41 c6 46 0c 00       	movb   $0x0,0xc(%r14)

		/* return some buffers to hardware, one at a time is too slow */
		if (unlikely(cleaned_count >= E1000_RX_BUFFER_WRITE)) {
    3e22:	0f 8f 65 03 00 00    	jg     418d <e1000_clean_rx_irq+0x42d>
			adapter->alloc_rx_buf(adapter, rx_ring, cleaned_count);
			cleaned_count = 0;
    3e28:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
    3e2c:	c6 45 a4 01          	movb   $0x1,-0x5c(%rbp)
    3e30:	4d 89 fe             	mov    %r15,%r14
    3e33:	48 89 45 d0          	mov    %rax,-0x30(%rbp)

	i = rx_ring->next_to_clean;
	rx_desc = E1000_RX_DESC(*rx_ring, i);
	buffer_info = &rx_ring->buffer_info[i];

	while (rx_desc->status & E1000_RXD_STAT_DD) {
    3e37:	41 f6 46 0c 01       	testb  $0x1,0xc(%r14)
    3e3c:	0f 84 d1 02 00 00    	je     4113 <e1000_clean_rx_irq+0x3b3>
		struct sk_buff *skb;
		u8 *data;
		u8 status;

		if (*work_done >= work_to_do)
    3e42:	48 8b 4d 98          	mov    -0x68(%rbp),%rcx
    3e46:	8b 01                	mov    (%rcx),%eax
    3e48:	3b 45 94             	cmp    -0x6c(%rbp),%eax
    3e4b:	0f 8d c2 02 00 00    	jge    4113 <e1000_clean_rx_irq+0x3b3>
			break;
		(*work_done)++;
    3e51:	83 c0 01             	add    $0x1,%eax
    3e54:	89 01                	mov    %eax,(%rcx)
		dma_rmb(); /* read descriptor and rx_buffer_info after status DD */

		status = rx_desc->status;
    3e56:	41 0f b6 46 0c       	movzbl 0xc(%r14),%eax
		length = le16_to_cpu(rx_desc->length);
    3e5b:	45 0f b7 7e 08       	movzwl 0x8(%r14),%r15d
		if (*work_done >= work_to_do)
			break;
		(*work_done)++;
		dma_rmb(); /* read descriptor and rx_buffer_info after status DD */

		status = rx_desc->status;
    3e60:	88 45 cf             	mov    %al,-0x31(%rbp)
		length = le16_to_cpu(rx_desc->length);

		data = buffer_info->rxbuf.data;
    3e63:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
			break;
		(*work_done)++;
		dma_rmb(); /* read descriptor and rx_buffer_info after status DD */

		status = rx_desc->status;
		length = le16_to_cpu(rx_desc->length);
    3e67:	45 0f b7 e7          	movzwl %r15w,%r12d
{
	u32 i;
	static int once = 1;
	struct sk_buff *skb;

	if (length > copybreak)
    3e6b:	44 3b 25 00 00 00 00 	cmp    0x0(%rip),%r12d        # 3e72 <e1000_clean_rx_irq+0x112>
		dma_rmb(); /* read descriptor and rx_buffer_info after status DD */

		status = rx_desc->status;
		length = le16_to_cpu(rx_desc->length);

		data = buffer_info->rxbuf.data;
    3e72:	48 8b 00             	mov    (%rax),%rax
    3e75:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
		prefetch(data);
    3e79:	0f 18 08             	prefetcht0 (%rax)
{
	u32 i;
	static int once = 1;
	struct sk_buff *skb;

	if (length > copybreak)
    3e7c:	0f 87 c2 01 00 00    	ja     4044 <e1000_clean_rx_irq+0x2e4>
		if((i % 8) == 0)
			printk("\n");
	}
	printk("\npack222222222,length=%d\n",length);
	*/
	if(once == 1)	
    3e82:	83 3d 00 00 00 00 01 	cmpl   $0x1,0x0(%rip)        # 3e89 <e1000_clean_rx_irq+0x129>
    3e89:	0f 84 5c 02 00 00    	je     40eb <e1000_clean_rx_irq+0x38b>
struct sk_buff *__napi_alloc_skb(struct napi_struct *napi,
				 unsigned int length, gfp_t gfp_mask);
static inline struct sk_buff *napi_alloc_skb(struct napi_struct *napi,
					     unsigned int length)
{
	return __napi_alloc_skb(napi, length, GFP_ATOMIC);
    3e8f:	48 8b 7d a8          	mov    -0x58(%rbp),%rdi
    3e93:	ba 20 00 08 02       	mov    $0x2080020,%edx
    3e98:	44 89 e6             	mov    %r12d,%esi
		WARN_ON(1);
	once = 2;
    3e9b:	c7 05 00 00 00 00 02 	movl   $0x2,0x0(%rip)        # 3ea5 <e1000_clean_rx_irq+0x145>
    3ea2:	00 00 00 
    3ea5:	e8 00 00 00 00       	callq  3eaa <e1000_clean_rx_irq+0x14a>
static struct sk_buff *e1000_alloc_rx_skb(struct e1000_adapter *adapter,
					  unsigned int bufsz)
{
	struct sk_buff *skb = napi_alloc_skb(&adapter->napi, bufsz);

	if (unlikely(!skb))
    3eaa:	48 85 c0             	test   %rax,%rax
    3ead:	48 89 c3             	mov    %rax,%rbx
    3eb0:	0f 84 86 01 00 00    	je     403c <e1000_clean_rx_irq+0x2dc>
	once = 2;
	skb = e1000_alloc_rx_skb(adapter, length);
	if (!skb)
		return NULL;

	dma_sync_single_for_cpu(&adapter->pdev->dev, buffer_info->dma,
    3eb6:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
    3eba:	48 8b 70 08          	mov    0x8(%rax),%rsi
    3ebe:	49 8b 85 b8 03 00 00 	mov    0x3b8(%r13),%rax
    3ec5:	48 89 c7             	mov    %rax,%rdi
    3ec8:	48 81 c7 98 00 00 00 	add    $0x98,%rdi
    3ecf:	0f 84 0a 02 00 00    	je     40df <e1000_clean_rx_irq+0x37f>
    3ed5:	48 8b 80 e8 02 00 00 	mov    0x2e8(%rax),%rax
    3edc:	48 85 c0             	test   %rax,%rax
    3edf:	0f 84 fa 01 00 00    	je     40df <e1000_clean_rx_irq+0x37f>
					   enum dma_data_direction dir)
{
	struct dma_map_ops *ops = get_dma_ops(dev);

	BUG_ON(!valid_dma_direction(dir));
	if (ops->sync_single_for_cpu)
    3ee5:	48 8b 40 40          	mov    0x40(%rax),%rax
    3ee9:	48 85 c0             	test   %rax,%rax
    3eec:	74 0a                	je     3ef8 <e1000_clean_rx_irq+0x198>
		ops->sync_single_for_cpu(dev, addr, size, dir);
    3eee:	b9 02 00 00 00       	mov    $0x2,%ecx
    3ef3:	4c 89 fa             	mov    %r15,%rdx
    3ef6:	ff d0                	callq  *%rax
				length, DMA_FROM_DEVICE);

	memcpy(skb_put(skb, length), data, length);
    3ef8:	44 89 e6             	mov    %r12d,%esi
    3efb:	48 89 df             	mov    %rbx,%rdi
    3efe:	e8 00 00 00 00       	callq  3f03 <e1000_clean_rx_irq+0x1a3>
    3f03:	48 8b 75 b8          	mov    -0x48(%rbp),%rsi
    3f07:	4c 89 fa             	mov    %r15,%rdx
    3f0a:	48 89 c7             	mov    %rax,%rdi
    3f0d:	e8 00 00 00 00       	callq  3f12 <e1000_clean_rx_irq+0x1b2>
					 DMA_FROM_DEVICE);
			buffer_info->dma = 0;
			buffer_info->rxbuf.data = NULL;
		}

		if (++i == rx_ring->count) i = 0;
    3f12:	8b 05 00 00 00 00    	mov    0x0(%rip),%eax        # 3f18 <e1000_clean_rx_irq+0x1b8>
    3f18:	48 8b 55 c0          	mov    -0x40(%rbp),%rdx
    3f1c:	83 c0 01             	add    $0x1,%eax
    3f1f:	3b 42 14             	cmp    0x14(%rdx),%eax
    3f22:	89 05 00 00 00 00    	mov    %eax,0x0(%rip)        # 3f28 <e1000_clean_rx_irq+0x1c8>
    3f28:	0f 84 fd 00 00 00    	je     402b <e1000_clean_rx_irq+0x2cb>
    3f2e:	48 98                	cltq   
    3f30:	48 c1 e0 04          	shl    $0x4,%rax
		next_rxd = E1000_RX_DESC(*rx_ring, i);
    3f34:	48 8b 55 c0          	mov    -0x40(%rbp),%rdx
    3f38:	49 89 c7             	mov    %rax,%r15
		 * packet, if thats the case we need to toss it.  In fact, we
		 * to toss every packet with the EOP bit clear and the next
		 * frame that _does_ have the EOP bit set, as it is by
		 * definition only a frame fragment
		 */
		if (unlikely(!(status & E1000_RXD_STAT_EOP)))
    3f3b:	0f b6 4d cf          	movzbl -0x31(%rbp),%ecx
			buffer_info->dma = 0;
			buffer_info->rxbuf.data = NULL;
		}

		if (++i == rx_ring->count) i = 0;
		next_rxd = E1000_RX_DESC(*rx_ring, i);
    3f3f:	4c 03 3a             	add    (%rdx),%r15
		prefetch(next_rxd);

		next_buffer = &rx_ring->buffer_info[i];
    3f42:	48 03 42 20          	add    0x20(%rdx),%rax
			buffer_info->rxbuf.data = NULL;
		}

		if (++i == rx_ring->count) i = 0;
		next_rxd = E1000_RX_DESC(*rx_ring, i);
		prefetch(next_rxd);
    3f46:	41 0f 18 0f          	prefetcht0 (%r15)

		next_buffer = &rx_ring->buffer_info[i];

		cleaned = true;
		cleaned_count++;
    3f4a:	83 45 c8 01          	addl   $0x1,-0x38(%rbp)
		 * packet, if thats the case we need to toss it.  In fact, we
		 * to toss every packet with the EOP bit clear and the next
		 * frame that _does_ have the EOP bit set, as it is by
		 * definition only a frame fragment
		 */
		if (unlikely(!(status & E1000_RXD_STAT_EOP)))
    3f4e:	83 e1 02             	and    $0x2,%ecx

		if (++i == rx_ring->count) i = 0;
		next_rxd = E1000_RX_DESC(*rx_ring, i);
		prefetch(next_rxd);

		next_buffer = &rx_ring->buffer_info[i];
    3f51:	48 89 45 b0          	mov    %rax,-0x50(%rbp)
		 * packet, if thats the case we need to toss it.  In fact, we
		 * to toss every packet with the EOP bit clear and the next
		 * frame that _does_ have the EOP bit set, as it is by
		 * definition only a frame fragment
		 */
		if (unlikely(!(status & E1000_RXD_STAT_EOP)))
    3f55:	0f 84 4f 02 00 00    	je     41aa <e1000_clean_rx_irq+0x44a>
			adapter->discarding = true;

		if (adapter->discarding) {
    3f5b:	41 80 bd bc 07 00 00 	cmpb   $0x0,0x7bc(%r13)
    3f62:	00 
    3f63:	0f 85 89 fe ff ff    	jne    3df2 <e1000_clean_rx_irq+0x92>
			if (status & E1000_RXD_STAT_EOP)
				adapter->discarding = false;
			goto next_desc;
		}

		if (unlikely(rx_desc->errors & E1000_RXD_ERR_FRAME_ERR_MASK)) {
    3f69:	41 0f b6 46 0d       	movzbl 0xd(%r14),%eax
    3f6e:	a8 97                	test   $0x97,%al
    3f70:	0f 85 41 02 00 00    	jne    41b7 <e1000_clean_rx_irq+0x457>
    3f76:	48 8b 45 88          	mov    -0x78(%rbp),%rax
    3f7a:	0f b6 7d cf          	movzbl -0x31(%rbp),%edi
    3f7e:	48 8b 80 f0 00 00 00 	mov    0xf0(%rax),%rax
    3f85:	89 7d a4             	mov    %edi,-0x5c(%rbp)
				goto next_desc;
			}
		}

process_skb:
		total_rx_bytes += (length - 4); /* don't count FCS */
    3f88:	8b 75 a0             	mov    -0x60(%rbp),%esi
		total_rx_packets++;

		if (likely(!(netdev->features & NETIF_F_RXFCS)))
    3f8b:	48 bf 00 00 00 00 20 	movabs $0x2000000000,%rdi
    3f92:	00 00 00 
			}
		}

process_skb:
		total_rx_bytes += (length - 4); /* don't count FCS */
		total_rx_packets++;
    3f95:	83 45 90 01          	addl   $0x1,-0x70(%rbp)

		if (likely(!(netdev->features & NETIF_F_RXFCS)))
    3f99:	48 85 f8             	test   %rdi,%rax
				goto next_desc;
			}
		}

process_skb:
		total_rx_bytes += (length - 4); /* don't count FCS */
    3f9c:	41 8d 4c 34 fc       	lea    -0x4(%r12,%rsi,1),%ecx
    3fa1:	89 4d a0             	mov    %ecx,-0x60(%rbp)
		total_rx_packets++;

		if (likely(!(netdev->features & NETIF_F_RXFCS)))
    3fa4:	75 04                	jne    3faa <e1000_clean_rx_irq+0x24a>
			/* adjust length to remove Ethernet CRC, this must be
			 * done after the TBI_ACCEPT workaround above
			 */
			length -= 4;
    3fa6:	41 83 ec 04          	sub    $0x4,%r12d

		if (buffer_info->rxbuf.data == NULL)
    3faa:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
			skb_put(skb, length);
    3fae:	44 89 e6             	mov    %r12d,%esi
    3fb1:	48 89 df             	mov    %rbx,%rdi
			/* adjust length to remove Ethernet CRC, this must be
			 * done after the TBI_ACCEPT workaround above
			 */
			length -= 4;

		if (buffer_info->rxbuf.data == NULL)
    3fb4:	48 83 38 00          	cmpq   $0x0,(%rax)
    3fb8:	0f 84 43 01 00 00    	je     4101 <e1000_clean_rx_irq+0x3a1>
			skb_put(skb, length);
		else /* copybreak skb */
			skb_trim(skb, length);
    3fbe:	e8 00 00 00 00       	callq  3fc3 <e1000_clean_rx_irq+0x263>

		/* Receive Checksum Offload */
		e1000_rx_checksum(adapter,
				  (u32)(status) |
				  ((u32)(rx_desc->errors) << 24),
    3fc3:	41 0f b6 76 0d       	movzbl 0xd(%r14),%esi
			skb_put(skb, length);
		else /* copybreak skb */
			skb_trim(skb, length);

		/* Receive Checksum Offload */
		e1000_rx_checksum(adapter,
    3fc8:	48 89 da             	mov    %rbx,%rdx
    3fcb:	4c 89 ef             	mov    %r13,%rdi
				  (u32)(status) |
				  ((u32)(rx_desc->errors) << 24),
    3fce:	c1 e6 18             	shl    $0x18,%esi
			skb_put(skb, length);
		else /* copybreak skb */
			skb_trim(skb, length);

		/* Receive Checksum Offload */
		e1000_rx_checksum(adapter,
    3fd1:	0b 75 a4             	or     -0x5c(%rbp),%esi
    3fd4:	e8 07 cf ff ff       	callq  ee0 <e1000_rx_checksum.isra.38>
 * @skb: pointer to sk_buff to be indicated to stack
 */
static void e1000_receive_skb(struct e1000_adapter *adapter, u8 status,
			      __le16 vlan, struct sk_buff *skb)
{
	skb->protocol = eth_type_trans(skb, adapter->netdev);
    3fd9:	49 8b b5 b0 03 00 00 	mov    0x3b0(%r13),%rsi
    3fe0:	48 89 df             	mov    %rbx,%rdi
		e1000_rx_checksum(adapter,
				  (u32)(status) |
				  ((u32)(rx_desc->errors) << 24),
				  le16_to_cpu(rx_desc->csum), skb);

		e1000_receive_skb(adapter, status, rx_desc->special, skb);
    3fe3:	45 0f b7 66 0e       	movzwl 0xe(%r14),%r12d
 * @skb: pointer to sk_buff to be indicated to stack
 */
static void e1000_receive_skb(struct e1000_adapter *adapter, u8 status,
			      __le16 vlan, struct sk_buff *skb)
{
	skb->protocol = eth_type_trans(skb, adapter->netdev);
    3fe8:	e8 00 00 00 00       	callq  3fed <e1000_clean_rx_irq+0x28d>

	if (status & E1000_RXD_STAT_VP) {
    3fed:	f6 45 cf 08          	testb  $0x8,-0x31(%rbp)
 * @skb: pointer to sk_buff to be indicated to stack
 */
static void e1000_receive_skb(struct e1000_adapter *adapter, u8 status,
			      __le16 vlan, struct sk_buff *skb)
{
	skb->protocol = eth_type_trans(skb, adapter->netdev);
    3ff1:	66 89 83 c0 00 00 00 	mov    %ax,0xc0(%rbx)

	if (status & E1000_RXD_STAT_VP) {
    3ff8:	74 20                	je     401a <e1000_clean_rx_irq+0x2ba>
		u16 vid = le16_to_cpu(vlan) & E1000_RXD_SPC_VLAN_MASK;
    3ffa:	66 41 81 e4 ff 0f    	and    $0xfff,%r12w
 * Puts the VLAN TCI in @skb->vlan_tci and lets the device do the rest
 */
static inline void __vlan_hwaccel_put_tag(struct sk_buff *skb,
					  __be16 vlan_proto, u16 vlan_tci)
{
	skb->vlan_proto = vlan_proto;
    4000:	b8 81 00 00 00       	mov    $0x81,%eax
	skb->vlan_tci = VLAN_TAG_PRESENT | vlan_tci;
    4005:	66 41 81 cc 00 10    	or     $0x1000,%r12w
 * Puts the VLAN TCI in @skb->vlan_tci and lets the device do the rest
 */
static inline void __vlan_hwaccel_put_tag(struct sk_buff *skb,
					  __be16 vlan_proto, u16 vlan_tci)
{
	skb->vlan_proto = vlan_proto;
    400b:	66 89 83 a8 00 00 00 	mov    %ax,0xa8(%rbx)
	skb->vlan_tci = VLAN_TAG_PRESENT | vlan_tci;
    4012:	66 44 89 a3 aa 00 00 	mov    %r12w,0xaa(%rbx)
    4019:	00 

		__vlan_hwaccel_put_tag(skb, htons(ETH_P_8021Q), vid);
	}
	napi_gro_receive(&adapter->napi, skb);
    401a:	48 8b 7d a8          	mov    -0x58(%rbp),%rdi
    401e:	48 89 de             	mov    %rbx,%rsi
    4021:	e8 00 00 00 00       	callq  4026 <e1000_clean_rx_irq+0x2c6>
    4026:	e9 ee fd ff ff       	jmpq   3e19 <e1000_clean_rx_irq+0xb9>
					 DMA_FROM_DEVICE);
			buffer_info->dma = 0;
			buffer_info->rxbuf.data = NULL;
		}

		if (++i == rx_ring->count) i = 0;
    402b:	c7 05 00 00 00 00 00 	movl   $0x0,0x0(%rip)        # 4035 <e1000_clean_rx_irq+0x2d5>
    4032:	00 00 00 
    4035:	31 c0                	xor    %eax,%eax
    4037:	e9 f8 fe ff ff       	jmpq   3f34 <e1000_clean_rx_irq+0x1d4>
					  unsigned int bufsz)
{
	struct sk_buff *skb = napi_alloc_skb(&adapter->napi, bufsz);

	if (unlikely(!skb))
		adapter->alloc_rx_buff_failed++;
    403c:	41 83 85 90 03 00 00 	addl   $0x1,0x390(%r13)
    4043:	01 
}

#define E1000_HEADROOM (NET_SKB_PAD + NET_IP_ALIGN)
static unsigned int e1000_frag_len(const struct e1000_adapter *a)
{
	return SKB_DATA_ALIGN(a->rx_buffer_len + E1000_HEADROOM) +
    4044:	41 8b 85 08 02 00 00 	mov    0x208(%r13),%eax
    404b:	8d 70 7f             	lea    0x7f(%rax),%esi
		prefetch(data);
		skb = e1000_copybreak(adapter, buffer_info, length, data);
		if (!skb) {
			unsigned int frag_len = e1000_frag_len(adapter);

			skb = build_skb(data - E1000_HEADROOM, frag_len);
    404e:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
}

#define E1000_HEADROOM (NET_SKB_PAD + NET_IP_ALIGN)
static unsigned int e1000_frag_len(const struct e1000_adapter *a)
{
	return SKB_DATA_ALIGN(a->rx_buffer_len + E1000_HEADROOM) +
    4052:	83 e6 c0             	and    $0xffffffc0,%esi
		prefetch(data);
		skb = e1000_copybreak(adapter, buffer_info, length, data);
		if (!skb) {
			unsigned int frag_len = e1000_frag_len(adapter);

			skb = build_skb(data - E1000_HEADROOM, frag_len);
    4055:	48 8d 78 c0          	lea    -0x40(%rax),%rdi
}

#define E1000_HEADROOM (NET_SKB_PAD + NET_IP_ALIGN)
static unsigned int e1000_frag_len(const struct e1000_adapter *a)
{
	return SKB_DATA_ALIGN(a->rx_buffer_len + E1000_HEADROOM) +
    4059:	81 c6 40 01 00 00    	add    $0x140,%esi
		prefetch(data);
		skb = e1000_copybreak(adapter, buffer_info, length, data);
		if (!skb) {
			unsigned int frag_len = e1000_frag_len(adapter);

			skb = build_skb(data - E1000_HEADROOM, frag_len);
    405f:	e8 00 00 00 00       	callq  4064 <e1000_clean_rx_irq+0x304>
			if (!skb) {
    4064:	48 85 c0             	test   %rax,%rax
		prefetch(data);
		skb = e1000_copybreak(adapter, buffer_info, length, data);
		if (!skb) {
			unsigned int frag_len = e1000_frag_len(adapter);

			skb = build_skb(data - E1000_HEADROOM, frag_len);
    4067:	48 89 c3             	mov    %rax,%rbx
			if (!skb) {
    406a:	0f 84 9b 00 00 00    	je     410b <e1000_clean_rx_irq+0x3ab>
 *	Increase the headroom of an empty &sk_buff by reducing the tail
 *	room. This is only allowed for an empty buffer.
 */
static inline void skb_reserve(struct sk_buff *skb, int len)
{
	skb->data += len;
    4070:	48 83 83 d8 00 00 00 	addq   $0x40,0xd8(%rbx)
    4077:	40 
	skb->tail += len;
    4078:	83 83 c8 00 00 00 40 	addl   $0x40,0xc8(%rbx)
    407f:	48 83 7d 80 00       	cmpq   $0x0,-0x80(%rbp)
				adapter->alloc_rx_buff_failed++;
				break;
			}

			skb_reserve(skb, E1000_HEADROOM);
			dma_unmap_single(&pdev->dev, buffer_info->dma,
    4084:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
    4088:	41 8b 95 08 02 00 00 	mov    0x208(%r13),%edx
    408f:	48 8b 70 08          	mov    0x8(%rax),%rsi
    4093:	0f 84 e8 00 00 00    	je     4181 <e1000_clean_rx_irq+0x421>
    4099:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
    40a0:	48 8b 80 e8 02 00 00 	mov    0x2e8(%rax),%rax
    40a7:	48 85 c0             	test   %rax,%rax
    40aa:	0f 84 d1 00 00 00    	je     4181 <e1000_clean_rx_irq+0x421>
					  struct dma_attrs *attrs)
{
	struct dma_map_ops *ops = get_dma_ops(dev);

	BUG_ON(!valid_dma_direction(dir));
	if (ops->unmap_page)
    40b0:	48 8b 40 28          	mov    0x28(%rax),%rax
    40b4:	48 85 c0             	test   %rax,%rax
    40b7:	74 0e                	je     40c7 <e1000_clean_rx_irq+0x367>
		ops->unmap_page(dev, addr, size, dir, attrs);
    40b9:	45 31 c0             	xor    %r8d,%r8d
    40bc:	b9 02 00 00 00       	mov    $0x2,%ecx
    40c1:	48 8b 7d 80          	mov    -0x80(%rbp),%rdi
    40c5:	ff d0                	callq  *%rax
					 adapter->rx_buffer_len,
					 DMA_FROM_DEVICE);
			buffer_info->dma = 0;
    40c7:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
    40cb:	48 c7 40 08 00 00 00 	movq   $0x0,0x8(%rax)
    40d2:	00 
			buffer_info->rxbuf.data = NULL;
    40d3:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
    40da:	e9 33 fe ff ff       	jmpq   3f12 <e1000_clean_rx_irq+0x1b2>
		return dma_ops;
    40df:	48 8b 05 00 00 00 00 	mov    0x0(%rip),%rax        # 40e6 <e1000_clean_rx_irq+0x386>
    40e6:	e9 fa fd ff ff       	jmpq   3ee5 <e1000_clean_rx_irq+0x185>
			printk("\n");
	}
	printk("\npack222222222,length=%d\n",length);
	*/
	if(once == 1)	
		WARN_ON(1);
    40eb:	be 3a 11 00 00       	mov    $0x113a,%esi
    40f0:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
    40f7:	e8 00 00 00 00       	callq  40fc <e1000_clean_rx_irq+0x39c>
    40fc:	e9 8e fd ff ff       	jmpq   3e8f <e1000_clean_rx_irq+0x12f>
			 * done after the TBI_ACCEPT workaround above
			 */
			length -= 4;

		if (buffer_info->rxbuf.data == NULL)
			skb_put(skb, length);
    4101:	e8 00 00 00 00       	callq  4106 <e1000_clean_rx_irq+0x3a6>
    4106:	e9 b8 fe ff ff       	jmpq   3fc3 <e1000_clean_rx_irq+0x263>
		if (!skb) {
			unsigned int frag_len = e1000_frag_len(adapter);

			skb = build_skb(data - E1000_HEADROOM, frag_len);
			if (!skb) {
				adapter->alloc_rx_buff_failed++;
    410b:	41 83 85 90 03 00 00 	addl   $0x1,0x390(%r13)
    4112:	01 

		/* use prefetched values */
		rx_desc = next_rxd;
		buffer_info = next_buffer;
	}
	rx_ring->next_to_clean = i;
    4113:	48 8b 5d c0          	mov    -0x40(%rbp),%rbx
    4117:	8b 05 00 00 00 00    	mov    0x0(%rip),%eax        # 411d <e1000_clean_rx_irq+0x3bd>

	cleaned_count = E1000_DESC_UNUSED(rx_ring);
    411d:	31 c9                	xor    %ecx,%ecx
    411f:	8b 53 18             	mov    0x18(%rbx),%edx

		/* use prefetched values */
		rx_desc = next_rxd;
		buffer_info = next_buffer;
	}
	rx_ring->next_to_clean = i;
    4122:	89 43 1c             	mov    %eax,0x1c(%rbx)

	cleaned_count = E1000_DESC_UNUSED(rx_ring);
    4125:	39 d0                	cmp    %edx,%eax
    4127:	76 53                	jbe    417c <e1000_clean_rx_irq+0x41c>
    4129:	29 d0                	sub    %edx,%eax
    412b:	8d 54 01 ff          	lea    -0x1(%rcx,%rax,1),%edx
	if (cleaned_count)
    412f:	85 d2                	test   %edx,%edx
    4131:	74 0e                	je     4141 <e1000_clean_rx_irq+0x3e1>
		adapter->alloc_rx_buf(adapter, rx_ring, cleaned_count);
    4133:	48 8b 75 c0          	mov    -0x40(%rbp),%rsi
    4137:	4c 89 ef             	mov    %r13,%rdi
    413a:	41 ff 95 a0 02 00 00 	callq  *0x2a0(%r13)

	adapter->total_rx_packets += total_rx_packets;
    4141:	8b 5d 90             	mov    -0x70(%rbp),%ebx
	adapter->total_rx_bytes += total_rx_bytes;
	netdev->stats.rx_bytes += total_rx_bytes;
    4144:	48 8b 75 88          	mov    -0x78(%rbp),%rsi
	cleaned_count = E1000_DESC_UNUSED(rx_ring);
	if (cleaned_count)
		adapter->alloc_rx_buf(adapter, rx_ring, cleaned_count);

	adapter->total_rx_packets += total_rx_packets;
	adapter->total_rx_bytes += total_rx_bytes;
    4148:	8b 45 a0             	mov    -0x60(%rbp),%eax

	cleaned_count = E1000_DESC_UNUSED(rx_ring);
	if (cleaned_count)
		adapter->alloc_rx_buf(adapter, rx_ring, cleaned_count);

	adapter->total_rx_packets += total_rx_packets;
    414b:	41 01 9d 2c 02 00 00 	add    %ebx,0x22c(%r13)
	adapter->total_rx_bytes += total_rx_bytes;
    4152:	41 01 85 28 02 00 00 	add    %eax,0x228(%r13)
	netdev->stats.rx_bytes += total_rx_bytes;
    4159:	48 01 86 38 01 00 00 	add    %rax,0x138(%rsi)
	netdev->stats.rx_packets += total_rx_packets;
    4160:	89 d8                	mov    %ebx,%eax
    4162:	48 01 86 28 01 00 00 	add    %rax,0x128(%rsi)
	return cleaned;
}
    4169:	0f b6 45 a4          	movzbl -0x5c(%rbp),%eax
    416d:	48 83 c4 60          	add    $0x60,%rsp
    4171:	5b                   	pop    %rbx
    4172:	41 5c                	pop    %r12
    4174:	41 5d                	pop    %r13
    4176:	41 5e                	pop    %r14
    4178:	41 5f                	pop    %r15
    417a:	5d                   	pop    %rbp
    417b:	c3                   	retq   
		rx_desc = next_rxd;
		buffer_info = next_buffer;
	}
	rx_ring->next_to_clean = i;

	cleaned_count = E1000_DESC_UNUSED(rx_ring);
    417c:	8b 4b 14             	mov    0x14(%rbx),%ecx
    417f:	eb a8                	jmp    4129 <e1000_clean_rx_irq+0x3c9>
    4181:	48 8b 05 00 00 00 00 	mov    0x0(%rip),%rax        # 4188 <e1000_clean_rx_irq+0x428>
    4188:	e9 23 ff ff ff       	jmpq   40b0 <e1000_clean_rx_irq+0x350>
next_desc:
		rx_desc->status = 0;

		/* return some buffers to hardware, one at a time is too slow */
		if (unlikely(cleaned_count >= E1000_RX_BUFFER_WRITE)) {
			adapter->alloc_rx_buf(adapter, rx_ring, cleaned_count);
    418d:	8b 55 c8             	mov    -0x38(%rbp),%edx
    4190:	48 8b 75 c0          	mov    -0x40(%rbp),%rsi
    4194:	4c 89 ef             	mov    %r13,%rdi
    4197:	41 ff 95 a0 02 00 00 	callq  *0x2a0(%r13)
			cleaned_count = 0;
    419e:	c7 45 c8 00 00 00 00 	movl   $0x0,-0x38(%rbp)
    41a5:	e9 7e fc ff ff       	jmpq   3e28 <e1000_clean_rx_irq+0xc8>
		 * to toss every packet with the EOP bit clear and the next
		 * frame that _does_ have the EOP bit set, as it is by
		 * definition only a frame fragment
		 */
		if (unlikely(!(status & E1000_RXD_STAT_EOP)))
			adapter->discarding = true;
    41aa:	41 c6 85 bc 07 00 00 	movb   $0x1,0x7bc(%r13)
    41b1:	01 
    41b2:	e9 3b fc ff ff       	jmpq   3df2 <e1000_clean_rx_irq+0x92>
				adapter->discarding = false;
			goto next_desc;
		}

		if (unlikely(rx_desc->errors & E1000_RXD_ERR_FRAME_ERR_MASK)) {
			if (e1000_tbi_should_accept(adapter, status,
    41b7:	0f b6 d0             	movzbl %al,%edx
    41ba:	0f b6 45 cf          	movzbl -0x31(%rbp),%eax
    41be:	4c 8b 45 b8          	mov    -0x48(%rbp),%r8
    41c2:	44 89 e1             	mov    %r12d,%ecx
    41c5:	4c 89 ef             	mov    %r13,%rdi
    41c8:	89 c6                	mov    %eax,%esi
    41ca:	89 45 a4             	mov    %eax,-0x5c(%rbp)
    41cd:	e8 5e cd ff ff       	callq  f30 <e1000_tbi_should_accept>
    41d2:	84 c0                	test   %al,%al
    41d4:	74 38                	je     420e <e1000_clean_rx_irq+0x4ae>
    41d6:	48 8b 45 88          	mov    -0x78(%rbp),%rax
						    rx_desc->errors,
						    length, data)) {
				length--;
    41da:	41 83 ec 01          	sub    $0x1,%r12d
    41de:	48 8b 80 f0 00 00 00 	mov    0xf0(%rax),%rax
    41e5:	e9 9e fd ff ff       	jmpq   3f88 <e1000_clean_rx_irq+0x228>
		if (unlikely(!(status & E1000_RXD_STAT_EOP)))
			adapter->discarding = true;

		if (adapter->discarding) {
			/* All receives must fit into a single buffer */
			netdev_dbg(netdev, "Receive packet consumed multiple buffers\n");
    41ea:	48 8b 75 88          	mov    -0x78(%rbp),%rsi
    41ee:	48 c7 c2 00 00 00 00 	mov    $0x0,%rdx
    41f5:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
    41fc:	31 c0                	xor    %eax,%eax
    41fe:	89 4d d0             	mov    %ecx,-0x30(%rbp)
    4201:	e8 00 00 00 00       	callq  4206 <e1000_clean_rx_irq+0x4a6>
    4206:	8b 4d d0             	mov    -0x30(%rbp),%ecx
    4209:	e9 f1 fb ff ff       	jmpq   3dff <e1000_clean_rx_irq+0x9f>
		if (unlikely(rx_desc->errors & E1000_RXD_ERR_FRAME_ERR_MASK)) {
			if (e1000_tbi_should_accept(adapter, status,
						    rx_desc->errors,
						    length, data)) {
				length--;
			} else if (netdev->features & NETIF_F_RXALL) {
    420e:	48 8b 45 88          	mov    -0x78(%rbp),%rax
    4212:	48 b9 00 00 00 00 40 	movabs $0x4000000000,%rcx
    4219:	00 00 00 
    421c:	48 8b 80 f0 00 00 00 	mov    0xf0(%rax),%rax
    4223:	48 85 c8             	test   %rcx,%rax
    4226:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
    422a:	0f 85 58 fd ff ff    	jne    3f88 <e1000_clean_rx_irq+0x228>
				goto process_skb;
			} else {
				dev_kfree_skb(skb);
    4230:	48 89 df             	mov    %rbx,%rdi
    4233:	e8 00 00 00 00       	callq  4238 <e1000_clean_rx_irq+0x4d8>
				goto next_desc;
    4238:	e9 dc fb ff ff       	jmpq   3e19 <e1000_clean_rx_irq+0xb9>
    423d:	0f 1f 00             	nopl   (%rax)

0000000000004240 <e1000_free_rx_resources>:
 *
 * Free all receive software resources
 **/
static void e1000_free_rx_resources(struct e1000_adapter *adapter,
				    struct e1000_rx_ring *rx_ring)
{
    4240:	e8 00 00 00 00       	callq  4245 <e1000_free_rx_resources+0x5>
    4245:	55                   	push   %rbp
    4246:	48 89 e5             	mov    %rsp,%rbp
    4249:	41 56                	push   %r14
    424b:	41 55                	push   %r13
    424d:	41 54                	push   %r12
    424f:	53                   	push   %rbx
    4250:	48 89 f3             	mov    %rsi,%rbx
    4253:	48 83 ec 10          	sub    $0x10,%rsp
	struct pci_dev *pdev = adapter->pdev;
    4257:	4c 8b a7 b8 03 00 00 	mov    0x3b8(%rdi),%r12

	e1000_clean_rx_ring(adapter, rx_ring);
    425e:	e8 cd e7 ff ff       	callq  2a30 <e1000_clean_rx_ring>

	vfree(rx_ring->buffer_info);
    4263:	48 8b 7b 20          	mov    0x20(%rbx),%rdi
static inline struct dma_map_ops *get_dma_ops(struct device *dev)
{
#ifndef CONFIG_X86_DEV_DMA_OPS
	return dma_ops;
#else
	if (unlikely(!dev) || !dev->archdata.dma_ops)
    4267:	4d 89 e5             	mov    %r12,%r13
    426a:	e8 00 00 00 00       	callq  426f <e1000_free_rx_resources+0x2f>
    426f:	49 81 c5 98 00 00 00 	add    $0x98,%r13
	rx_ring->buffer_info = NULL;
    4276:	48 c7 43 20 00 00 00 	movq   $0x0,0x20(%rbx)
    427d:	00 

	dma_free_coherent(&pdev->dev, rx_ring->size, rx_ring->desc,
    427e:	48 8b 4b 08          	mov    0x8(%rbx),%rcx
    4282:	48 8b 13             	mov    (%rbx),%rdx
    4285:	44 8b 73 10          	mov    0x10(%rbx),%r14d
    4289:	74 42                	je     42cd <e1000_free_rx_resources+0x8d>
    428b:	4d 8b a4 24 e8 02 00 	mov    0x2e8(%r12),%r12
    4292:	00 
    4293:	4d 85 e4             	test   %r12,%r12
    4296:	74 35                	je     42cd <e1000_free_rx_resources+0x8d>
#define __PV_IS_CALLEE_SAVE(func)			\
	((struct paravirt_callee_save) { func })

static inline notrace unsigned long arch_local_save_flags(void)
{
	return PVOP_CALLEE0(unsigned long, pv_irq_ops.save_fl);
    4298:	ff 14 25 00 00 00 00 	callq  *0x0
				     struct dma_attrs *attrs)
{
	struct dma_map_ops *ops = get_dma_ops(dev);

	BUG_ON(!ops);
	WARN_ON(irqs_disabled());
    429f:	f6 c4 02             	test   $0x2,%ah
    42a2:	74 37                	je     42db <e1000_free_rx_resources+0x9b>

	if (dma_release_from_coherent(dev, get_order(size), cpu_addr))
		return;

	if (!ops->free)
    42a4:	49 8b 44 24 08       	mov    0x8(%r12),%rax
    42a9:	48 85 c0             	test   %rax,%rax
    42ac:	74 0b                	je     42b9 <e1000_free_rx_resources+0x79>
		return;

	debug_dma_free_coherent(dev, size, cpu_addr, dma_handle);
	ops->free(dev, size, cpu_addr, dma_handle, attrs);
    42ae:	45 31 c0             	xor    %r8d,%r8d
    42b1:	4c 89 f6             	mov    %r14,%rsi
    42b4:	4c 89 ef             	mov    %r13,%rdi
    42b7:	ff d0                	callq  *%rax
			  rx_ring->dma);

	rx_ring->desc = NULL;
    42b9:	48 c7 03 00 00 00 00 	movq   $0x0,(%rbx)
}
    42c0:	48 83 c4 10          	add    $0x10,%rsp
    42c4:	5b                   	pop    %rbx
    42c5:	41 5c                	pop    %r12
    42c7:	41 5d                	pop    %r13
    42c9:	41 5e                	pop    %r14
    42cb:	5d                   	pop    %rbp
    42cc:	c3                   	retq   
		return dma_ops;
    42cd:	4c 8b 25 00 00 00 00 	mov    0x0(%rip),%r12        # 42d4 <e1000_free_rx_resources+0x94>
				     void *cpu_addr, dma_addr_t dma_handle,
				     struct dma_attrs *attrs)
{
	struct dma_map_ops *ops = get_dma_ops(dev);

	BUG_ON(!ops);
    42d4:	4d 85 e4             	test   %r12,%r12
    42d7:	75 bf                	jne    4298 <e1000_free_rx_resources+0x58>
    42d9:	0f 0b                	ud2    
	WARN_ON(irqs_disabled());
    42db:	be 12 01 00 00       	mov    $0x112,%esi
    42e0:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
    42e7:	48 89 55 d0          	mov    %rdx,-0x30(%rbp)
    42eb:	48 89 4d d8          	mov    %rcx,-0x28(%rbp)
    42ef:	e8 00 00 00 00       	callq  42f4 <e1000_free_rx_resources+0xb4>
    42f4:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
    42f8:	48 8b 4d d8          	mov    -0x28(%rbp),%rcx
    42fc:	eb a6                	jmp    42a4 <e1000_free_rx_resources+0x64>
    42fe:	66 90                	xchg   %ax,%ax

0000000000004300 <e1000_free_tx_resources>:
 *
 * Free all transmit software resources
 **/
static void e1000_free_tx_resources(struct e1000_adapter *adapter,
				    struct e1000_tx_ring *tx_ring)
{
    4300:	e8 00 00 00 00       	callq  4305 <e1000_free_tx_resources+0x5>
    4305:	55                   	push   %rbp
    4306:	48 89 e5             	mov    %rsp,%rbp
    4309:	41 56                	push   %r14
    430b:	41 55                	push   %r13
    430d:	41 54                	push   %r12
    430f:	53                   	push   %rbx
    4310:	48 89 f3             	mov    %rsi,%rbx
    4313:	48 83 ec 10          	sub    $0x10,%rsp
	struct pci_dev *pdev = adapter->pdev;
    4317:	4c 8b a7 b8 03 00 00 	mov    0x3b8(%rdi),%r12

	e1000_clean_tx_ring(adapter, tx_ring);
    431e:	e8 2d e4 ff ff       	callq  2750 <e1000_clean_tx_ring>

	vfree(tx_ring->buffer_info);
    4323:	48 8b 7b 20          	mov    0x20(%rbx),%rdi
static inline struct dma_map_ops *get_dma_ops(struct device *dev)
{
#ifndef CONFIG_X86_DEV_DMA_OPS
	return dma_ops;
#else
	if (unlikely(!dev) || !dev->archdata.dma_ops)
    4327:	4d 89 e5             	mov    %r12,%r13
    432a:	e8 00 00 00 00       	callq  432f <e1000_free_tx_resources+0x2f>
    432f:	49 81 c5 98 00 00 00 	add    $0x98,%r13
	tx_ring->buffer_info = NULL;
    4336:	48 c7 43 20 00 00 00 	movq   $0x0,0x20(%rbx)
    433d:	00 

	dma_free_coherent(&pdev->dev, tx_ring->size, tx_ring->desc,
    433e:	48 8b 4b 08          	mov    0x8(%rbx),%rcx
    4342:	48 8b 13             	mov    (%rbx),%rdx
    4345:	44 8b 73 10          	mov    0x10(%rbx),%r14d
    4349:	74 42                	je     438d <e1000_free_tx_resources+0x8d>
    434b:	4d 8b a4 24 e8 02 00 	mov    0x2e8(%r12),%r12
    4352:	00 
    4353:	4d 85 e4             	test   %r12,%r12
    4356:	74 35                	je     438d <e1000_free_tx_resources+0x8d>
    4358:	ff 14 25 00 00 00 00 	callq  *0x0
    435f:	f6 c4 02             	test   $0x2,%ah
    4362:	74 37                	je     439b <e1000_free_tx_resources+0x9b>

	if (dma_release_from_coherent(dev, get_order(size), cpu_addr))
		return;

	if (!ops->free)
    4364:	49 8b 44 24 08       	mov    0x8(%r12),%rax
    4369:	48 85 c0             	test   %rax,%rax
    436c:	74 0b                	je     4379 <e1000_free_tx_resources+0x79>
		return;

	debug_dma_free_coherent(dev, size, cpu_addr, dma_handle);
	ops->free(dev, size, cpu_addr, dma_handle, attrs);
    436e:	45 31 c0             	xor    %r8d,%r8d
    4371:	4c 89 f6             	mov    %r14,%rsi
    4374:	4c 89 ef             	mov    %r13,%rdi
    4377:	ff d0                	callq  *%rax
			  tx_ring->dma);

	tx_ring->desc = NULL;
    4379:	48 c7 03 00 00 00 00 	movq   $0x0,(%rbx)
}
    4380:	48 83 c4 10          	add    $0x10,%rsp
    4384:	5b                   	pop    %rbx
    4385:	41 5c                	pop    %r12
    4387:	41 5d                	pop    %r13
    4389:	41 5e                	pop    %r14
    438b:	5d                   	pop    %rbp
    438c:	c3                   	retq   
		return dma_ops;
    438d:	4c 8b 25 00 00 00 00 	mov    0x0(%rip),%r12        # 4394 <e1000_free_tx_resources+0x94>
				     void *cpu_addr, dma_addr_t dma_handle,
				     struct dma_attrs *attrs)
{
	struct dma_map_ops *ops = get_dma_ops(dev);

	BUG_ON(!ops);
    4394:	4d 85 e4             	test   %r12,%r12
    4397:	75 bf                	jne    4358 <e1000_free_tx_resources+0x58>
    4399:	0f 0b                	ud2    
	WARN_ON(irqs_disabled());
    439b:	be 12 01 00 00       	mov    $0x112,%esi
    43a0:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
    43a7:	48 89 55 d0          	mov    %rdx,-0x30(%rbp)
    43ab:	48 89 4d d8          	mov    %rcx,-0x28(%rbp)
    43af:	e8 00 00 00 00       	callq  43b4 <e1000_free_tx_resources+0xb4>
    43b4:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
    43b8:	48 8b 4d d8          	mov    -0x28(%rbp),%rcx
    43bc:	eb a6                	jmp    4364 <e1000_free_tx_resources+0x64>
    43be:	66 90                	xchg   %ax,%ax

00000000000043c0 <e1000_get_hw_dev>:
 * e1000_get_hw_dev - return device
 * used by hardware layer to print debugging information
 *
 **/
struct net_device *e1000_get_hw_dev(struct e1000_hw *hw)
{
    43c0:	e8 00 00 00 00       	callq  43c5 <e1000_get_hw_dev+0x5>
    43c5:	55                   	push   %rbp
	struct e1000_adapter *adapter = hw->back;
	return adapter->netdev;
    43c6:	48 8b 47 28          	mov    0x28(%rdi),%rax
 * e1000_get_hw_dev - return device
 * used by hardware layer to print debugging information
 *
 **/
struct net_device *e1000_get_hw_dev(struct e1000_hw *hw)
{
    43ca:	48 89 e5             	mov    %rsp,%rbp
	struct e1000_adapter *adapter = hw->back;
	return adapter->netdev;
    43cd:	48 8b 80 b0 03 00 00 	mov    0x3b0(%rax),%rax
}
    43d4:	5d                   	pop    %rbp
    43d5:	c3                   	retq   
    43d6:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    43dd:	00 00 00 

00000000000043e0 <e1000_power_up_phy>:
 * The phy may be powered down to save power and turn off link when the
 * driver is unloaded and wake on lan is not enabled (among others)
 * *** this routine MUST be followed by a call to e1000_reset ***
 **/
void e1000_power_up_phy(struct e1000_adapter *adapter)
{
    43e0:	e8 00 00 00 00       	callq  43e5 <e1000_power_up_phy+0x5>
    43e5:	55                   	push   %rbp
	struct e1000_hw *hw = &adapter->hw;
	u16 mii_reg = 0;
    43e6:	31 c0                	xor    %eax,%eax
 * The phy may be powered down to save power and turn off link when the
 * driver is unloaded and wake on lan is not enabled (among others)
 * *** this routine MUST be followed by a call to e1000_reset ***
 **/
void e1000_power_up_phy(struct e1000_adapter *adapter)
{
    43e8:	48 89 e5             	mov    %rsp,%rbp
    43eb:	53                   	push   %rbx
    43ec:	48 83 ec 08          	sub    $0x8,%rsp
	struct e1000_hw *hw = &adapter->hw;
	u16 mii_reg = 0;

	/* Just clear the power down bit to wake the phy back up */
	if (hw->media_type == e1000_media_type_copper) {
    43f0:	8b 97 e4 03 00 00    	mov    0x3e4(%rdi),%edx
 * *** this routine MUST be followed by a call to e1000_reset ***
 **/
void e1000_power_up_phy(struct e1000_adapter *adapter)
{
	struct e1000_hw *hw = &adapter->hw;
	u16 mii_reg = 0;
    43f6:	66 89 45 f6          	mov    %ax,-0xa(%rbp)

	/* Just clear the power down bit to wake the phy back up */
	if (hw->media_type == e1000_media_type_copper) {
    43fa:	85 d2                	test   %edx,%edx
    43fc:	75 2d                	jne    442b <e1000_power_up_phy+0x4b>
 * driver is unloaded and wake on lan is not enabled (among others)
 * *** this routine MUST be followed by a call to e1000_reset ***
 **/
void e1000_power_up_phy(struct e1000_adapter *adapter)
{
	struct e1000_hw *hw = &adapter->hw;
    43fe:	48 8d 9f c0 03 00 00 	lea    0x3c0(%rdi),%rbx
	/* Just clear the power down bit to wake the phy back up */
	if (hw->media_type == e1000_media_type_copper) {
		/* according to the manual, the phy will retain its
		 * settings across a power-down/up cycle
		 */
		e1000_read_phy_reg(hw, PHY_CTRL, &mii_reg);
    4405:	48 8d 55 f6          	lea    -0xa(%rbp),%rdx
    4409:	31 f6                	xor    %esi,%esi
    440b:	48 89 df             	mov    %rbx,%rdi
    440e:	e8 00 00 00 00       	callq  4413 <e1000_power_up_phy+0x33>
		mii_reg &= ~MII_CR_POWER_DOWN;
    4413:	0f b7 55 f6          	movzwl -0xa(%rbp),%edx
		e1000_write_phy_reg(hw, PHY_CTRL, mii_reg);
    4417:	31 f6                	xor    %esi,%esi
    4419:	48 89 df             	mov    %rbx,%rdi
	if (hw->media_type == e1000_media_type_copper) {
		/* according to the manual, the phy will retain its
		 * settings across a power-down/up cycle
		 */
		e1000_read_phy_reg(hw, PHY_CTRL, &mii_reg);
		mii_reg &= ~MII_CR_POWER_DOWN;
    441c:	80 e6 f7             	and    $0xf7,%dh
    441f:	66 89 55 f6          	mov    %dx,-0xa(%rbp)
		e1000_write_phy_reg(hw, PHY_CTRL, mii_reg);
    4423:	0f b7 d2             	movzwl %dx,%edx
    4426:	e8 00 00 00 00       	callq  442b <e1000_power_up_phy+0x4b>
	}
}
    442b:	48 83 c4 08          	add    $0x8,%rsp
    442f:	5b                   	pop    %rbx
    4430:	5d                   	pop    %rbp
    4431:	c3                   	retq   
    4432:	66 66 66 66 66 2e 0f 	data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
    4439:	1f 84 00 00 00 00 00 

0000000000004440 <e1000_reset>:
	e1000_up(adapter);
	clear_bit(__E1000_RESETTING, &adapter->flags);
}

void e1000_reset(struct e1000_adapter *adapter)
{
    4440:	e8 00 00 00 00       	callq  4445 <e1000_reset+0x5>
    4445:	55                   	push   %rbp
    4446:	48 89 e5             	mov    %rsp,%rbp
    4449:	41 54                	push   %r12
	struct e1000_hw *hw = &adapter->hw;
    444b:	4c 8d a7 c0 03 00 00 	lea    0x3c0(%rdi),%r12
	e1000_up(adapter);
	clear_bit(__E1000_RESETTING, &adapter->flags);
}

void e1000_reset(struct e1000_adapter *adapter)
{
    4452:	53                   	push   %rbx

	/* Repartition Pba for greater than 9k mtu
	 * To take effect CTRL.RST is required.
	 */

	switch (hw->mac_type) {
    4453:	8b 97 d8 03 00 00    	mov    0x3d8(%rdi),%edx
	e1000_up(adapter);
	clear_bit(__E1000_RESETTING, &adapter->flags);
}

void e1000_reset(struct e1000_adapter *adapter)
{
    4459:	48 89 fb             	mov    %rdi,%rbx
    445c:	8d 4a ff             	lea    -0x1(%rdx),%ecx
    445f:	83 f9 0d             	cmp    $0xd,%ecx
    4462:	0f 87 1c 01 00 00    	ja     4584 <e1000_reset+0x144>
    4468:	b8 01 00 00 00       	mov    $0x1,%eax
    446d:	48 d3 e0             	shl    %cl,%rax
    4470:	a9 1f 0c 00 00       	test   $0xc1f,%eax
    4475:	0f 84 8c 01 00 00    	je     4607 <e1000_reset+0x1c7>
	case e1000_82544:
	case e1000_82540:
	case e1000_82541:
	case e1000_82541_rev_2:
		legacy_pba_adjust = true;
		pba = E1000_PBA_48K;
    447b:	b8 30 00 00 00       	mov    $0x30,%eax
		break;
	}

	if (legacy_pba_adjust) {
		if (hw->max_frame_size > E1000_RXBUFFER_8192)
			pba -= 8; /* allocate more FIFO for Tx */
    4480:	81 bb 58 04 00 00 01 	cmpl   $0x2001,0x458(%rbx)
    4487:	20 00 00 
    448a:	8d 48 f8             	lea    -0x8(%rax),%ecx
    448d:	0f 43 c1             	cmovae %ecx,%eax

		if (hw->mac_type == e1000_82547) {
    4490:	83 fa 0d             	cmp    $0xd,%edx
    4493:	0f 84 dd 01 00 00    	je     4676 <e1000_reset+0x236>
			if (pba < min_rx_space)
				pba = min_rx_space;
		}
	}

	ew32(PBA, pba);
    4499:	48 8b 93 c0 03 00 00 	mov    0x3c0(%rbx),%rdx
    44a0:	89 82 00 10 00 00    	mov    %eax,0x1000(%rdx)
	 * - 90% of the Rx FIFO size, and
	 * - the full Rx FIFO size minus the early receive size (for parts
	 *   with ERT support assuming ERT set to E1000_ERT_2048), or
	 * - the full Rx FIFO size minus one full frame
	 */
	hwm = min(((pba << 10) * 9 / 10),
    44a6:	89 c1                	mov    %eax,%ecx
    44a8:	8d 04 c0             	lea    (%rax,%rax,8),%eax
    44ab:	ba cd cc cc cc       	mov    $0xcccccccd,%edx
    44b0:	c1 e1 0a             	shl    $0xa,%ecx
    44b3:	2b 8b 58 04 00 00    	sub    0x458(%rbx),%ecx
		  ((pba << 10) - hw->max_frame_size));

	hw->fc_high_water = hwm & 0xFFF8;	/* 8-byte granularity */
	hw->fc_low_water = hw->fc_high_water - 8;
	hw->fc_pause_time = E1000_FC_PAUSE_TIME;
	hw->fc_send_xon = 1;
    44b9:	c6 83 d3 04 00 00 01 	movb   $0x1,0x4d3(%rbx)
	 * - 90% of the Rx FIFO size, and
	 * - the full Rx FIFO size minus the early receive size (for parts
	 *   with ERT support assuming ERT set to E1000_ERT_2048), or
	 * - the full Rx FIFO size minus one full frame
	 */
	hwm = min(((pba << 10) * 9 / 10),
    44c0:	c1 e0 0a             	shl    $0xa,%eax
	hw->fc_pause_time = E1000_FC_PAUSE_TIME;
	hw->fc_send_xon = 1;
	hw->fc = hw->original_fc;

	/* Allow time for pending master requests to run */
	e1000_reset_hw(hw);
    44c3:	4c 89 e7             	mov    %r12,%rdi
	 * - 90% of the Rx FIFO size, and
	 * - the full Rx FIFO size minus the early receive size (for parts
	 *   with ERT support assuming ERT set to E1000_ERT_2048), or
	 * - the full Rx FIFO size minus one full frame
	 */
	hwm = min(((pba << 10) * 9 / 10),
    44c6:	f7 e2                	mul    %edx

	hw->fc_high_water = hwm & 0xFFF8;	/* 8-byte granularity */
	hw->fc_low_water = hw->fc_high_water - 8;
	hw->fc_pause_time = E1000_FC_PAUSE_TIME;
	hw->fc_send_xon = 1;
	hw->fc = hw->original_fc;
    44c8:	8b 83 4c 04 00 00    	mov    0x44c(%rbx),%eax
	 * - 90% of the Rx FIFO size, and
	 * - the full Rx FIFO size minus the early receive size (for parts
	 *   with ERT support assuming ERT set to E1000_ERT_2048), or
	 * - the full Rx FIFO size minus one full frame
	 */
	hwm = min(((pba << 10) * 9 / 10),
    44ce:	c1 ea 03             	shr    $0x3,%edx

	hw->fc_high_water = hwm & 0xFFF8;	/* 8-byte granularity */
	hw->fc_low_water = hw->fc_high_water - 8;
	hw->fc_pause_time = E1000_FC_PAUSE_TIME;
	hw->fc_send_xon = 1;
	hw->fc = hw->original_fc;
    44d1:	89 83 00 04 00 00    	mov    %eax,0x400(%rbx)
	 * - 90% of the Rx FIFO size, and
	 * - the full Rx FIFO size minus the early receive size (for parts
	 *   with ERT support assuming ERT set to E1000_ERT_2048), or
	 * - the full Rx FIFO size minus one full frame
	 */
	hwm = min(((pba << 10) * 9 / 10),
    44d7:	39 d1                	cmp    %edx,%ecx
    44d9:	0f 46 d1             	cmovbe %ecx,%edx
		  ((pba << 10) - hw->max_frame_size));

	hw->fc_high_water = hwm & 0xFFF8;	/* 8-byte granularity */
    44dc:	83 e2 f8             	and    $0xfffffff8,%edx
    44df:	66 89 93 96 04 00 00 	mov    %dx,0x496(%rbx)
	hw->fc_low_water = hw->fc_high_water - 8;
    44e6:	83 ea 08             	sub    $0x8,%edx
    44e9:	66 89 93 98 04 00 00 	mov    %dx,0x498(%rbx)
	hw->fc_pause_time = E1000_FC_PAUSE_TIME;
    44f0:	ba ff ff ff ff       	mov    $0xffffffff,%edx
    44f5:	66 89 93 9a 04 00 00 	mov    %dx,0x49a(%rbx)
	hw->fc_send_xon = 1;
	hw->fc = hw->original_fc;

	/* Allow time for pending master requests to run */
	e1000_reset_hw(hw);
    44fc:	e8 00 00 00 00       	callq  4501 <e1000_reset+0xc1>
	if (hw->mac_type >= e1000_82544)
    4501:	83 bb d8 03 00 00 03 	cmpl   $0x3,0x3d8(%rbx)
    4508:	76 0f                	jbe    4519 <e1000_reset+0xd9>
		ew32(WUC, 0);
    450a:	48 8b 93 c0 03 00 00 	mov    0x3c0(%rbx),%rdx
    4511:	31 c0                	xor    %eax,%eax
    4513:	89 82 00 58 00 00    	mov    %eax,0x5800(%rdx)

	if (e1000_init_hw(hw))
    4519:	4c 89 e7             	mov    %r12,%rdi
    451c:	e8 00 00 00 00       	callq  4521 <e1000_reset+0xe1>
    4521:	85 c0                	test   %eax,%eax
    4523:	0f 85 f8 00 00 00    	jne    4621 <e1000_reset+0x1e1>
		e_dev_err("Hardware Error\n");
	e1000_update_mng_vlan(adapter);
    4529:	48 89 df             	mov    %rbx,%rdi
    452c:	e8 7f c5 ff ff       	callq  ab0 <e1000_update_mng_vlan>

	/* if (adapter->hwflags & HWFLAGS_PHY_PWR_BIT) { */
	if (hw->mac_type >= e1000_82544 &&
    4531:	83 bb d8 03 00 00 03 	cmpl   $0x3,0x3d8(%rbx)
    4538:	76 0d                	jbe    4547 <e1000_reset+0x107>
    453a:	80 bb af 04 00 00 01 	cmpb   $0x1,0x4af(%rbx)
    4541:	0f 84 fb 00 00 00    	je     4642 <e1000_reset+0x202>
		ctrl &= ~E1000_CTRL_SWDPIN3;
		ew32(CTRL, ctrl);
	}

	/* Enable h/w to recognize an 802.1Q VLAN Ethernet packet */
	ew32(VET, ETHERNET_IEEE_VLAN_TYPE);
    4547:	48 8b 93 c0 03 00 00 	mov    0x3c0(%rbx),%rdx
    454e:	b8 00 81 00 00       	mov    $0x8100,%eax
    4553:	89 42 38             	mov    %eax,0x38(%rdx)

	e1000_reset_adaptive(hw);
    4556:	4c 89 e7             	mov    %r12,%rdi
    4559:	e8 00 00 00 00       	callq  455e <e1000_reset+0x11e>
	e1000_phy_get_info(hw, &adapter->phy_info);
    455e:	48 8d b3 08 07 00 00 	lea    0x708(%rbx),%rsi
    4565:	4c 89 e7             	mov    %r12,%rdi
    4568:	e8 00 00 00 00       	callq  456d <e1000_reset+0x12d>

static void e1000_release_manageability(struct e1000_adapter *adapter)
{
	struct e1000_hw *hw = &adapter->hw;

	if (adapter->en_mng_pt) {
    456d:	8b 83 14 02 00 00    	mov    0x214(%rbx),%eax
    4573:	85 c0                	test   %eax,%eax
    4575:	74 08                	je     457f <e1000_reset+0x13f>
    4577:	48 89 df             	mov    %rbx,%rdi
    457a:	e8 61 c8 ff ff       	callq  de0 <e1000_release_manageability.part.32>

	e1000_reset_adaptive(hw);
	e1000_phy_get_info(hw, &adapter->phy_info);

	e1000_release_manageability(adapter);
}
    457f:	5b                   	pop    %rbx
    4580:	41 5c                	pop    %r12
    4582:	5d                   	pop    %rbp
    4583:	c3                   	retq   
}

void e1000_reset(struct e1000_adapter *adapter)
{
	struct e1000_hw *hw = &adapter->hw;
	u32 pba = 0, tx_space, min_tx_space, min_rx_space;
    4584:	31 c0                	xor    %eax,%eax
			adapter->tx_head_addr = pba << E1000_TX_HEAD_ADDR_SHIFT;
			adapter->tx_fifo_size =
				(E1000_PBA_40K - pba) << E1000_PBA_BYTES_SHIFT;
			atomic_set(&adapter->tx_fifo_stall, 0);
		}
	} else if (hw->max_frame_size >  ETH_FRAME_LEN + ETH_FCS_LEN) {
    4586:	81 bb 58 04 00 00 ee 	cmpl   $0x5ee,0x458(%rbx)
    458d:	05 00 00 
    4590:	0f 86 03 ff ff ff    	jbe    4499 <e1000_reset+0x59>
		/* adjust PBA for jumbo frames */
		ew32(PBA, pba);
    4596:	48 8b 93 c0 03 00 00 	mov    0x3c0(%rbx),%rdx
    459d:	89 82 00 10 00 00    	mov    %eax,0x1000(%rdx)
		 * rounded up to the next 1KB and expressed in KB.  Likewise,
		 * the Rx FIFO should be large enough to accommodate at least
		 * one full receive packet and is similarly rounded up and
		 * expressed in KB.
		 */
		pba = er32(PBA);
    45a3:	48 8b 83 c0 03 00 00 	mov    0x3c0(%rbx),%rax
{ asm volatile("mov" size " %0,%1": :reg (val), \
"m" (*(volatile type __force *)addr) barrier); }

build_mmio_read(readb, "b", unsigned char, "=q", :"memory")
build_mmio_read(readw, "w", unsigned short, "=r", :"memory")
build_mmio_read(readl, "l", unsigned int, "=r", :"memory")
    45aa:	8b 80 00 10 00 00    	mov    0x1000(%rax),%eax
		/* lower 16 bits has Rx packet buffer allocation size in KB */
		pba &= 0xffff;
		/* the Tx fifo also stores 16 bytes of information about the Tx
		 * but don't include ethernet FCS because hardware appends it
		 */
		min_tx_space = (hw->max_frame_size +
    45b0:	8b b3 58 04 00 00    	mov    0x458(%rbx),%esi
		 * one full receive packet and is similarly rounded up and
		 * expressed in KB.
		 */
		pba = er32(PBA);
		/* upper 16 bits has Tx packet buffer allocation size in KB */
		tx_space = pba >> 16;
    45b6:	89 c1                	mov    %eax,%ecx
		/* lower 16 bits has Rx packet buffer allocation size in KB */
		pba &= 0xffff;
    45b8:	0f b7 c0             	movzwl %ax,%eax
		 * one full receive packet and is similarly rounded up and
		 * expressed in KB.
		 */
		pba = er32(PBA);
		/* upper 16 bits has Tx packet buffer allocation size in KB */
		tx_space = pba >> 16;
    45bb:	c1 e9 10             	shr    $0x10,%ecx
		 * but don't include ethernet FCS because hardware appends it
		 */
		min_tx_space = (hw->max_frame_size +
		                sizeof(struct e1000_tx_desc) -
		                ETH_FCS_LEN) * 2;
		min_tx_space = ALIGN(min_tx_space, 1024);
    45be:	8d 94 36 17 04 00 00 	lea    0x417(%rsi,%rsi,1),%edx
		min_tx_space >>= 10;
    45c5:	c1 ea 0a             	shr    $0xa,%edx

		/* If current Tx allocation is less than the min Tx FIFO size,
		 * and the min Tx FIFO size is less than the current Rx FIFO
		 * allocation, take space away from current Rx allocation
		 */
		if (tx_space < min_tx_space &&
    45c8:	39 d1                	cmp    %edx,%ecx
    45ca:	0f 83 c9 fe ff ff    	jae    4499 <e1000_reset+0x59>
		    ((min_tx_space - tx_space) < pba)) {
    45d0:	89 d7                	mov    %edx,%edi
    45d2:	29 cf                	sub    %ecx,%edi

		/* If current Tx allocation is less than the min Tx FIFO size,
		 * and the min Tx FIFO size is less than the current Rx FIFO
		 * allocation, take space away from current Rx allocation
		 */
		if (tx_space < min_tx_space &&
    45d4:	39 f8                	cmp    %edi,%eax
    45d6:	0f 86 bd fe ff ff    	jbe    4499 <e1000_reset+0x59>
		    ((min_tx_space - tx_space) < pba)) {
			pba = pba - (min_tx_space - tx_space);

			/* PCI/PCIx hardware has PBA alignment constraints */
			switch (hw->mac_type) {
    45dc:	8b bb d8 03 00 00    	mov    0x3d8(%rbx),%edi
		 * and the min Tx FIFO size is less than the current Rx FIFO
		 * allocation, take space away from current Rx allocation
		 */
		if (tx_space < min_tx_space &&
		    ((min_tx_space - tx_space) < pba)) {
			pba = pba - (min_tx_space - tx_space);
    45e2:	01 c8                	add    %ecx,%eax
    45e4:	29 d0                	sub    %edx,%eax

			/* PCI/PCIx hardware has PBA alignment constraints */
			switch (hw->mac_type) {
			case e1000_82545 ... e1000_82546_rev_3:
				pba &= ~(E1000_PBA_8K - 1);
    45e6:	89 c2                	mov    %eax,%edx
		if (tx_space < min_tx_space &&
		    ((min_tx_space - tx_space) < pba)) {
			pba = pba - (min_tx_space - tx_space);

			/* PCI/PCIx hardware has PBA alignment constraints */
			switch (hw->mac_type) {
    45e8:	8d 4f fa             	lea    -0x6(%rdi),%ecx
			case e1000_82545 ... e1000_82546_rev_3:
				pba &= ~(E1000_PBA_8K - 1);
    45eb:	83 e2 f8             	and    $0xfffffff8,%edx
    45ee:	83 f9 04             	cmp    $0x4,%ecx
    45f1:	0f 46 c2             	cmovbe %edx,%eax
		                ETH_FCS_LEN) * 2;
		min_tx_space = ALIGN(min_tx_space, 1024);
		min_tx_space >>= 10;
		/* software strips receive CRC, so leave room for it */
		min_rx_space = hw->max_frame_size;
		min_rx_space = ALIGN(min_rx_space, 1024);
    45f4:	81 c6 ff 03 00 00    	add    $0x3ff,%esi
		min_rx_space >>= 10;
    45fa:	c1 ee 0a             	shr    $0xa,%esi
    45fd:	39 f0                	cmp    %esi,%eax
    45ff:	0f 42 c6             	cmovb  %esi,%eax
    4602:	e9 92 fe ff ff       	jmpq   4499 <e1000_reset+0x59>
    4607:	f6 c4 30             	test   $0x30,%ah
    460a:	75 60                	jne    466c <e1000_reset+0x22c>
    460c:	25 e0 03 00 00       	and    $0x3e0,%eax
}

void e1000_reset(struct e1000_adapter *adapter)
{
	struct e1000_hw *hw = &adapter->hw;
	u32 pba = 0, tx_space, min_tx_space, min_rx_space;
    4611:	48 83 f8 01          	cmp    $0x1,%rax
    4615:	19 c0                	sbb    %eax,%eax
    4617:	f7 d0                	not    %eax
    4619:	83 e0 30             	and    $0x30,%eax
    461c:	e9 65 ff ff ff       	jmpq   4586 <e1000_reset+0x146>
	e1000_reset_hw(hw);
	if (hw->mac_type >= e1000_82544)
		ew32(WUC, 0);

	if (e1000_init_hw(hw))
		e_dev_err("Hardware Error\n");
    4621:	48 8b 83 b8 03 00 00 	mov    0x3b8(%rbx),%rax
    4628:	48 c7 c6 00 00 00 00 	mov    $0x0,%rsi
    462f:	48 8d b8 98 00 00 00 	lea    0x98(%rax),%rdi
    4636:	31 c0                	xor    %eax,%eax
    4638:	e8 00 00 00 00       	callq  463d <e1000_reset+0x1fd>
    463d:	e9 e7 fe ff ff       	jmpq   4529 <e1000_reset+0xe9>
	e1000_update_mng_vlan(adapter);

	/* if (adapter->hwflags & HWFLAGS_PHY_PWR_BIT) { */
	if (hw->mac_type >= e1000_82544 &&
	    hw->autoneg == 1 &&
    4642:	66 83 bb 92 04 00 00 	cmpw   $0x20,0x492(%rbx)
    4649:	20 
    464a:	0f 85 f7 fe ff ff    	jne    4547 <e1000_reset+0x107>
	    hw->autoneg_advertised == ADVERTISE_1000_FULL) {
		u32 ctrl = er32(CTRL);
    4650:	48 8b 83 c0 03 00 00 	mov    0x3c0(%rbx),%rax
    4657:	8b 00                	mov    (%rax),%eax
		/* clear phy power management bit if we are in gig only mode,
		 * which if enabled will attempt negotiation to 100Mb, which
		 * can cause a loss of link at power off or driver unload
		 */
		ctrl &= ~E1000_CTRL_SWDPIN3;
    4659:	25 ff ff df ff       	and    $0xffdfffff,%eax
		ew32(CTRL, ctrl);
    465e:	48 8b 93 c0 03 00 00 	mov    0x3c0(%rbx),%rdx
build_mmio_read(__readw, "w", unsigned short, "=r", )
build_mmio_read(__readl, "l", unsigned int, "=r", )

build_mmio_write(writeb, "b", unsigned char, "q", :"memory")
build_mmio_write(writew, "w", unsigned short, "r", :"memory")
build_mmio_write(writel, "l", unsigned int, "r", :"memory")
    4665:	89 02                	mov    %eax,(%rdx)
    4667:	e9 db fe ff ff       	jmpq   4547 <e1000_reset+0x107>
		pba = E1000_PBA_48K;
		break;
	case e1000_82547:
	case e1000_82547_rev_2:
		legacy_pba_adjust = true;
		pba = E1000_PBA_30K;
    466c:	b8 1e 00 00 00       	mov    $0x1e,%eax
    4671:	e9 0a fe ff ff       	jmpq   4480 <e1000_reset+0x40>
		if (hw->max_frame_size > E1000_RXBUFFER_8192)
			pba -= 8; /* allocate more FIFO for Tx */

		if (hw->mac_type == e1000_82547) {
			adapter->tx_fifo_head = 0;
			adapter->tx_head_addr = pba << E1000_TX_HEAD_ADDR_SHIFT;
    4676:	89 c2                	mov    %eax,%edx
	if (legacy_pba_adjust) {
		if (hw->max_frame_size > E1000_RXBUFFER_8192)
			pba -= 8; /* allocate more FIFO for Tx */

		if (hw->mac_type == e1000_82547) {
			adapter->tx_fifo_head = 0;
    4678:	c7 83 7c 02 00 00 00 	movl   $0x0,0x27c(%rbx)
    467f:	00 00 00 
    4682:	c7 83 8c 02 00 00 00 	movl   $0x0,0x28c(%rbx)
    4689:	00 00 00 
			adapter->tx_head_addr = pba << E1000_TX_HEAD_ADDR_SHIFT;
    468c:	c1 e2 07             	shl    $0x7,%edx
    468f:	89 93 80 02 00 00    	mov    %edx,0x280(%rbx)
			adapter->tx_fifo_size =
				(E1000_PBA_40K - pba) << E1000_PBA_BYTES_SHIFT;
    4695:	ba 28 00 00 00       	mov    $0x28,%edx
    469a:	29 c2                	sub    %eax,%edx
    469c:	c1 e2 0a             	shl    $0xa,%edx
    469f:	89 93 84 02 00 00    	mov    %edx,0x284(%rbx)
    46a5:	e9 ef fd ff ff       	jmpq   4499 <e1000_reset+0x59>
    46aa:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)

00000000000046b0 <e1000_io_slot_reset>:
 *
 * Restart the card from scratch, as if from a cold-boot. Implementation
 * resembles the first-half of the e1000_resume routine.
 */
static pci_ers_result_t e1000_io_slot_reset(struct pci_dev *pdev)
{
    46b0:	e8 00 00 00 00       	callq  46b5 <e1000_io_slot_reset+0x5>
    46b5:	55                   	push   %rbp
    46b6:	48 89 e5             	mov    %rsp,%rbp
    46b9:	41 55                	push   %r13
    46bb:	41 54                	push   %r12
    46bd:	53                   	push   %rbx
    46be:	4c 8b a7 38 01 00 00 	mov    0x138(%rdi),%r12
    46c5:	48 89 fb             	mov    %rdi,%rbx
	struct net_device *netdev = pci_get_drvdata(pdev);
	struct e1000_adapter *adapter = netdev_priv(netdev);
	struct e1000_hw *hw = &adapter->hw;
	int err;

	if (adapter->need_ioport)
    46c8:	41 8b 84 24 f8 0f 00 	mov    0xff8(%r12),%eax
    46cf:	00 
 * resembles the first-half of the e1000_resume routine.
 */
static pci_ers_result_t e1000_io_slot_reset(struct pci_dev *pdev)
{
	struct net_device *netdev = pci_get_drvdata(pdev);
	struct e1000_adapter *adapter = netdev_priv(netdev);
    46d0:	4d 8d ac 24 40 08 00 	lea    0x840(%r12),%r13
    46d7:	00 
	struct e1000_hw *hw = &adapter->hw;
	int err;

	if (adapter->need_ioport)
    46d8:	85 c0                	test   %eax,%eax
    46da:	74 5a                	je     4736 <e1000_io_slot_reset+0x86>
		err = pci_enable_device(pdev);
    46dc:	e8 00 00 00 00       	callq  46e1 <e1000_io_slot_reset+0x31>
	else
		err = pci_enable_device_mem(pdev);
	if (err) {
    46e1:	85 c0                	test   %eax,%eax
    46e3:	75 58                	jne    473d <e1000_io_slot_reset+0x8d>
		pr_err("Cannot re-enable PCI device after reset.\n");
		return PCI_ERS_RESULT_DISCONNECT;
	}
	pci_set_master(pdev);
    46e5:	48 89 df             	mov    %rbx,%rdi
    46e8:	e8 00 00 00 00       	callq  46ed <e1000_io_slot_reset+0x3d>
void pci_pme_wakeup_bus(struct pci_bus *bus);

static inline int pci_enable_wake(struct pci_dev *dev, pci_power_t state,
				  bool enable)
{
	return __pci_enable_wake(dev, state, false, enable);
    46ed:	31 c9                	xor    %ecx,%ecx
    46ef:	31 d2                	xor    %edx,%edx
    46f1:	48 89 df             	mov    %rbx,%rdi
    46f4:	be 03 00 00 00       	mov    $0x3,%esi
    46f9:	e8 00 00 00 00       	callq  46fe <e1000_io_slot_reset+0x4e>
    46fe:	31 d2                	xor    %edx,%edx
    4700:	31 c9                	xor    %ecx,%ecx
    4702:	be 04 00 00 00       	mov    $0x4,%esi
    4707:	48 89 df             	mov    %rbx,%rdi
    470a:	e8 00 00 00 00       	callq  470f <e1000_io_slot_reset+0x5f>

	pci_enable_wake(pdev, PCI_D3hot, 0);
	pci_enable_wake(pdev, PCI_D3cold, 0);

	e1000_reset(adapter);
    470f:	4c 89 ef             	mov    %r13,%rdi
    4712:	e8 00 00 00 00       	callq  4717 <e1000_io_slot_reset+0x67>
	ew32(WUS, ~0);
    4717:	49 8b 94 24 00 0c 00 	mov    0xc00(%r12),%rdx
    471e:	00 
    471f:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
    4724:	89 82 10 58 00 00    	mov    %eax,0x5810(%rdx)

	return PCI_ERS_RESULT_RECOVERED;
    472a:	b8 05 00 00 00       	mov    $0x5,%eax
}
    472f:	5b                   	pop    %rbx
    4730:	41 5c                	pop    %r12
    4732:	41 5d                	pop    %r13
    4734:	5d                   	pop    %rbp
    4735:	c3                   	retq   
	int err;

	if (adapter->need_ioport)
		err = pci_enable_device(pdev);
	else
		err = pci_enable_device_mem(pdev);
    4736:	e8 00 00 00 00       	callq  473b <e1000_io_slot_reset+0x8b>
    473b:	eb a4                	jmp    46e1 <e1000_io_slot_reset+0x31>
	if (err) {
		pr_err("Cannot re-enable PCI device after reset.\n");
    473d:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
    4744:	31 c0                	xor    %eax,%eax
    4746:	e8 00 00 00 00       	callq  474b <e1000_io_slot_reset+0x9b>
		return PCI_ERS_RESULT_DISCONNECT;
    474b:	b8 04 00 00 00       	mov    $0x4,%eax
    4750:	eb dd                	jmp    472f <e1000_io_slot_reset+0x7f>
    4752:	66 66 66 66 66 2e 0f 	data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
    4759:	1f 84 00 00 00 00 00 

0000000000004760 <e1000_probe>:
		printk("xiehuan index[%d],start=%08X,end=%08X\n",i,pdev->resource[i].start,pdev->resource[i].end);
	return 0;
}

static int e1000_probe(struct pci_dev *pdev, const struct pci_device_id *ent)
{
    4760:	e8 00 00 00 00       	callq  4765 <e1000_probe+0x5>
    4765:	55                   	push   %rbp
	struct e1000_hw *hw;

	static int cards_found = 0;
	static int global_quad_port_a = 0; /* global ksp3 port a indication */
	int i, err, pci_using_dac;
	u16 eeprom_data = 0;
    4766:	31 f6                	xor    %esi,%esi
		printk("xiehuan index[%d],start=%08X,end=%08X\n",i,pdev->resource[i].start,pdev->resource[i].end);
	return 0;
}

static int e1000_probe(struct pci_dev *pdev, const struct pci_device_id *ent)
{
    4768:	48 89 e5             	mov    %rsp,%rbp
    476b:	41 57                	push   %r15
    476d:	41 56                	push   %r14
    476f:	41 55                	push   %r13
    4771:	41 54                	push   %r12
    4773:	53                   	push   %rbx
    4774:	48 89 fb             	mov    %rdi,%rbx

	static int cards_found = 0;
	static int global_quad_port_a = 0; /* global ksp3 port a indication */
	int i, err, pci_using_dac;
	u16 eeprom_data = 0;
	u16 tmp = 0;
    4777:	31 ff                	xor    %edi,%edi
		printk("xiehuan index[%d],start=%08X,end=%08X\n",i,pdev->resource[i].start,pdev->resource[i].end);
	return 0;
}

static int e1000_probe(struct pci_dev *pdev, const struct pci_device_id *ent)
{
    4779:	48 83 ec 48          	sub    $0x48,%rsp
 **/
static int print_dev_resource(struct pci_dev *pdev)
{
	int i;

	if(!pdev){
    477d:	48 85 db             	test   %rbx,%rbx
	struct e1000_hw *hw;

	static int cards_found = 0;
	static int global_quad_port_a = 0; /* global ksp3 port a indication */
	int i, err, pci_using_dac;
	u16 eeprom_data = 0;
    4780:	66 89 75 c4          	mov    %si,-0x3c(%rbp)
	u16 tmp = 0;
    4784:	66 89 7d c6          	mov    %di,-0x3a(%rbp)
 **/
static int print_dev_resource(struct pci_dev *pdev)
{
	int i;

	if(!pdev){
    4788:	0f 84 d2 0f 00 00    	je     5760 <e1000_probe+0x1000>
    478e:	4c 8d ab 80 03 00 00 	lea    0x380(%rbx),%r13
    4795:	45 31 e4             	xor    %r12d,%r12d
		printk("pdev is NULL\n");
		return -1;
	}
	for(i = 0;i < sizeof(pdev->resource)/sizeof(pdev->resource[0]);i++)
		printk("xiehuan index[%d],start=%08X,end=%08X\n",i,pdev->resource[i].start,pdev->resource[i].end);
    4798:	49 8b 55 f8          	mov    -0x8(%r13),%rdx
    479c:	49 8b 4d 00          	mov    0x0(%r13),%rcx
    47a0:	44 89 e6             	mov    %r12d,%esi
    47a3:	31 c0                	xor    %eax,%eax
    47a5:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi

	if(!pdev){
		printk("pdev is NULL\n");
		return -1;
	}
	for(i = 0;i < sizeof(pdev->resource)/sizeof(pdev->resource[0]);i++)
    47ac:	41 83 c4 01          	add    $0x1,%r12d
    47b0:	49 83 c5 38          	add    $0x38,%r13
		printk("xiehuan index[%d],start=%08X,end=%08X\n",i,pdev->resource[i].start,pdev->resource[i].end);
    47b4:	e8 00 00 00 00       	callq  47b9 <e1000_probe+0x59>

	if(!pdev){
		printk("pdev is NULL\n");
		return -1;
	}
	for(i = 0;i < sizeof(pdev->resource)/sizeof(pdev->resource[0]);i++)
    47b9:	41 83 fc 11          	cmp    $0x11,%r12d
    47bd:	75 d9                	jne    4798 <e1000_probe+0x38>
 *
 * Return true if an adapter needs ioport resources
 **/
static int e1000_is_need_ioport(struct pci_dev *pdev)
{
	switch (pdev->device) {
    47bf:	0f b7 43 3e          	movzwl 0x3e(%rbx),%eax
    47c3:	66 3d 1e 10          	cmp    $0x101e,%ax
    47c7:	77 3d                	ja     4806 <e1000_probe+0xa6>
    47c9:	66 3d 1d 10          	cmp    $0x101d,%ax
    47cd:	73 49                	jae    4818 <e1000_probe+0xb8>
    47cf:	66 3d 08 10          	cmp    $0x1008,%ax
    47d3:	72 10                	jb     47e5 <e1000_probe+0x85>
    47d5:	66 3d 09 10          	cmp    $0x1009,%ax
    47d9:	76 3d                	jbe    4818 <e1000_probe+0xb8>
    47db:	66 2d 0c 10          	sub    $0x100c,%ax
    47df:	66 83 f8 0c          	cmp    $0xc,%ax
    47e3:	76 33                	jbe    4818 <e1000_probe+0xb8>
	need_ioport = e1000_is_need_ioport(pdev);
	if (need_ioport) {
		bars = pci_select_bars(pdev, IORESOURCE_MEM | IORESOURCE_IO);
		err = pci_enable_device(pdev);
	} else {
		bars = pci_select_bars(pdev, IORESOURCE_MEM);
    47e5:	be 00 02 00 00       	mov    $0x200,%esi
    47ea:	48 89 df             	mov    %rbx,%rdi
    47ed:	e8 00 00 00 00       	callq  47f2 <e1000_probe+0x92>
		err = pci_enable_device_mem(pdev);
    47f2:	48 89 df             	mov    %rbx,%rdi
	need_ioport = e1000_is_need_ioport(pdev);
	if (need_ioport) {
		bars = pci_select_bars(pdev, IORESOURCE_MEM | IORESOURCE_IO);
		err = pci_enable_device(pdev);
	} else {
		bars = pci_select_bars(pdev, IORESOURCE_MEM);
    47f5:	41 89 c4             	mov    %eax,%r12d
		err = pci_enable_device_mem(pdev);
    47f8:	e8 00 00 00 00       	callq  47fd <e1000_probe+0x9d>
	case E1000_DEV_ID_82546EB_COPPER:
	case E1000_DEV_ID_82546EB_FIBER:
	case E1000_DEV_ID_82546EB_QUAD_COPPER:
		return true;
	default:
		return false;
    47fd:	c7 45 b8 00 00 00 00 	movl   $0x0,-0x48(%rbp)
    4804:	eb 31                	jmp    4837 <e1000_probe+0xd7>
 *
 * Return true if an adapter needs ioport resources
 **/
static int e1000_is_need_ioport(struct pci_dev *pdev)
{
	switch (pdev->device) {
    4806:	66 3d 76 10          	cmp    $0x1076,%ax
    480a:	72 d9                	jb     47e5 <e1000_probe+0x85>
    480c:	66 3d 78 10          	cmp    $0x1078,%ax
    4810:	76 06                	jbe    4818 <e1000_probe+0xb8>
    4812:	66 3d 7c 10          	cmp    $0x107c,%ax
    4816:	75 cd                	jne    47e5 <e1000_probe+0x85>

	print_dev_resource(pdev);
	/* do not allocate ioport bars when not needed */
	need_ioport = e1000_is_need_ioport(pdev);
	if (need_ioport) {
		bars = pci_select_bars(pdev, IORESOURCE_MEM | IORESOURCE_IO);
    4818:	be 00 03 00 00       	mov    $0x300,%esi
    481d:	48 89 df             	mov    %rbx,%rdi
    4820:	e8 00 00 00 00       	callq  4825 <e1000_probe+0xc5>
		err = pci_enable_device(pdev);
    4825:	48 89 df             	mov    %rbx,%rdi

	print_dev_resource(pdev);
	/* do not allocate ioport bars when not needed */
	need_ioport = e1000_is_need_ioport(pdev);
	if (need_ioport) {
		bars = pci_select_bars(pdev, IORESOURCE_MEM | IORESOURCE_IO);
    4828:	41 89 c4             	mov    %eax,%r12d
		err = pci_enable_device(pdev);
    482b:	e8 00 00 00 00       	callq  4830 <e1000_probe+0xd0>
	case E1000_DEV_ID_82545EM_COPPER:
	case E1000_DEV_ID_82545EM_FIBER:
	case E1000_DEV_ID_82546EB_COPPER:
	case E1000_DEV_ID_82546EB_FIBER:
	case E1000_DEV_ID_82546EB_QUAD_COPPER:
		return true;
    4830:	c7 45 b8 01 00 00 00 	movl   $0x1,-0x48(%rbp)
		err = pci_enable_device(pdev);
	} else {
		bars = pci_select_bars(pdev, IORESOURCE_MEM);
		err = pci_enable_device_mem(pdev);
	}
	if (err)
    4837:	85 c0                	test   %eax,%eax
    4839:	41 89 c6             	mov    %eax,%r14d
    483c:	75 32                	jne    4870 <e1000_probe+0x110>
		return err;
#ifdef DEBUG
	e_info(probe,"need_ioport=%d,bars=%08X,debuglevel=%d\n",need_ioport,bars,debug);
    483e:	f6 04 25 a0 07 00 00 	testb  $0x2,0x7a0
    4845:	02 
    4846:	0f 85 26 02 00 00    	jne    4a72 <e1000_probe+0x312>
#endif
	err = pci_request_selected_regions(pdev, bars, e1000_driver_name);
    484c:	48 c7 c2 00 00 00 00 	mov    $0x0,%rdx
    4853:	44 89 e6             	mov    %r12d,%esi
    4856:	48 89 df             	mov    %rbx,%rdi
    4859:	e8 00 00 00 00       	callq  485e <e1000_probe+0xfe>
	if (err)
    485e:	85 c0                	test   %eax,%eax
	if (err)
		return err;
#ifdef DEBUG
	e_info(probe,"need_ioport=%d,bars=%08X,debuglevel=%d\n",need_ioport,bars,debug);
#endif
	err = pci_request_selected_regions(pdev, bars, e1000_driver_name);
    4860:	41 89 c5             	mov    %eax,%r13d
	if (err)
    4863:	74 1d                	je     4882 <e1000_probe+0x122>
err_ioremap:
	free_netdev(netdev);
err_alloc_etherdev:
	pci_release_selected_regions(pdev, bars);
err_pci_reg:
	pci_disable_device(pdev);
    4865:	48 89 df             	mov    %rbx,%rdi
	return err;
    4868:	45 89 ee             	mov    %r13d,%r14d
err_ioremap:
	free_netdev(netdev);
err_alloc_etherdev:
	pci_release_selected_regions(pdev, bars);
err_pci_reg:
	pci_disable_device(pdev);
    486b:	e8 00 00 00 00       	callq  4870 <e1000_probe+0x110>
	return err;
}
    4870:	48 83 c4 48          	add    $0x48,%rsp
    4874:	44 89 f0             	mov    %r14d,%eax
    4877:	5b                   	pop    %rbx
    4878:	41 5c                	pop    %r12
    487a:	41 5d                	pop    %r13
    487c:	41 5e                	pop    %r14
    487e:	41 5f                	pop    %r15
    4880:	5d                   	pop    %rbp
    4881:	c3                   	retq   
	e_info(probe,"need_ioport=%d,bars=%08X,debuglevel=%d\n",need_ioport,bars,debug);
#endif
	err = pci_request_selected_regions(pdev, bars, e1000_driver_name);
	if (err)
		goto err_pci_reg;
	pci_set_master(pdev);
    4882:	48 89 df             	mov    %rbx,%rdi
    4885:	e8 00 00 00 00       	callq  488a <e1000_probe+0x12a>
	err = pci_save_state(pdev);
    488a:	48 89 df             	mov    %rbx,%rdi
    488d:	e8 00 00 00 00       	callq  4892 <e1000_probe+0x132>
	if (err)
    4892:	85 c0                	test   %eax,%eax
#endif
	err = pci_request_selected_regions(pdev, bars, e1000_driver_name);
	if (err)
		goto err_pci_reg;
	pci_set_master(pdev);
	err = pci_save_state(pdev);
    4894:	41 89 c5             	mov    %eax,%r13d
	if (err)
    4897:	0f 85 c5 01 00 00    	jne    4a62 <e1000_probe+0x302>
		goto err_alloc_etherdev;

	err = -ENOMEM;
	netdev = alloc_etherdev(sizeof(struct e1000_adapter));
    489d:	ba 01 00 00 00       	mov    $0x1,%edx
    48a2:	be 01 00 00 00       	mov    $0x1,%esi
    48a7:	bf 60 09 00 00       	mov    $0x960,%edi
    48ac:	e8 00 00 00 00       	callq  48b1 <e1000_probe+0x151>
	if (!netdev)
    48b1:	48 85 c0             	test   %rax,%rax
	err = pci_save_state(pdev);
	if (err)
		goto err_alloc_etherdev;

	err = -ENOMEM;
	netdev = alloc_etherdev(sizeof(struct e1000_adapter));
    48b4:	49 89 c7             	mov    %rax,%r15
	if (!netdev)
    48b7:	0f 84 24 06 00 00    	je     4ee1 <e1000_probe+0x781>
		goto err_alloc_etherdev;

	SET_NETDEV_DEV(netdev, &pdev->dev);
    48bd:	4c 8d b3 98 00 00 00 	lea    0x98(%rbx),%r14

	pci_set_drvdata(pdev, netdev);
	adapter = netdev_priv(netdev);
	adapter->netdev = netdev;
	adapter->pdev = pdev;
	adapter->msg_enable = netif_msg_init(debug, DEFAULT_MSG_ENABLE);
    48c4:	8b 0d 00 00 00 00    	mov    0x0(%rip),%ecx        # 48ca <e1000_probe+0x16a>
	err = -ENOMEM;
	netdev = alloc_etherdev(sizeof(struct e1000_adapter));
	if (!netdev)
		goto err_alloc_etherdev;

	SET_NETDEV_DEV(netdev, &pdev->dev);
    48ca:	4c 89 b0 a8 04 00 00 	mov    %r14,0x4a8(%rax)
	return dev->driver_data;
}

static inline void dev_set_drvdata(struct device *dev, void *data)
{
	dev->driver_data = data;
    48d1:	48 89 83 38 01 00 00 	mov    %rax,0x138(%rbx)

	pci_set_drvdata(pdev, netdev);
	adapter = netdev_priv(netdev);
    48d8:	48 8d 80 40 08 00 00 	lea    0x840(%rax),%rax
#define netif_msg_wol(p)	((p)->msg_enable & NETIF_MSG_WOL)

static inline u32 netif_msg_init(int debug_value, int default_msg_enable_bits)
{
	/* use default */
	if (debug_value < 0 || debug_value >= (sizeof(u32) * 8))
    48df:	83 f9 1f             	cmp    $0x1f,%ecx
	adapter->netdev = netdev;
    48e2:	4d 89 bf f0 0b 00 00 	mov    %r15,0xbf0(%r15)
	adapter->pdev = pdev;
    48e9:	49 89 9f f8 0b 00 00 	mov    %rbx,0xbf8(%r15)
		goto err_alloc_etherdev;

	SET_NETDEV_DEV(netdev, &pdev->dev);

	pci_set_drvdata(pdev, netdev);
	adapter = netdev_priv(netdev);
    48f0:	48 89 45 b0          	mov    %rax,-0x50(%rbp)
    48f4:	b8 07 00 00 00       	mov    $0x7,%eax
    48f9:	77 0a                	ja     4905 <e1000_probe+0x1a5>
		return default_msg_enable_bits;
	if (debug_value == 0)	/* no output */
    48fb:	30 c0                	xor    %al,%al
    48fd:	85 c9                	test   %ecx,%ecx
    48ff:	0f 85 63 02 00 00    	jne    4b68 <e1000_probe+0x408>
	adapter->netdev = netdev;
	adapter->pdev = pdev;
	adapter->msg_enable = netif_msg_init(debug, DEFAULT_MSG_ENABLE);
    4905:	41 89 87 e0 0f 00 00 	mov    %eax,0xfe0(%r15)
	adapter->bars = bars;
	adapter->need_ioport = need_ioport;
    490c:	8b 45 b8             	mov    -0x48(%rbp),%eax

	hw = &adapter->hw;
	hw->back = adapter;

	err = -EIO;
	hw->hw_addr = pci_ioremap_bar(pdev, BAR_0);
    490f:	31 f6                	xor    %esi,%esi
	pci_set_drvdata(pdev, netdev);
	adapter = netdev_priv(netdev);
	adapter->netdev = netdev;
	adapter->pdev = pdev;
	adapter->msg_enable = netif_msg_init(debug, DEFAULT_MSG_ENABLE);
	adapter->bars = bars;
    4911:	45 89 a7 f4 0f 00 00 	mov    %r12d,0xff4(%r15)

	hw = &adapter->hw;
	hw->back = adapter;

	err = -EIO;
	hw->hw_addr = pci_ioremap_bar(pdev, BAR_0);
    4918:	48 89 df             	mov    %rbx,%rdi
	adapter = netdev_priv(netdev);
	adapter->netdev = netdev;
	adapter->pdev = pdev;
	adapter->msg_enable = netif_msg_init(debug, DEFAULT_MSG_ENABLE);
	adapter->bars = bars;
	adapter->need_ioport = need_ioport;
    491b:	41 89 87 f8 0f 00 00 	mov    %eax,0xff8(%r15)

	hw = &adapter->hw;
    4922:	49 8d 87 00 0c 00 00 	lea    0xc00(%r15),%rax
    4929:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
	hw->back = adapter;
    492d:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
    4931:	49 89 87 28 0c 00 00 	mov    %rax,0xc28(%r15)

	err = -EIO;
	hw->hw_addr = pci_ioremap_bar(pdev, BAR_0);
    4938:	e8 00 00 00 00       	callq  493d <e1000_probe+0x1dd>
	if (!hw->hw_addr)
    493d:	48 85 c0             	test   %rax,%rax

	hw = &adapter->hw;
	hw->back = adapter;

	err = -EIO;
	hw->hw_addr = pci_ioremap_bar(pdev, BAR_0);
    4940:	49 89 87 00 0c 00 00 	mov    %rax,0xc00(%r15)
	if (!hw->hw_addr)
    4947:	0f 84 0d 0b 00 00    	je     545a <e1000_probe+0xcfa>
		goto err_ioremap;
#ifdef DEBUG
	e_info(probe,"hw_addr=%08X\n",hw->hw_addr);
    494d:	41 f6 87 e0 0f 00 00 	testb  $0x2,0xfe0(%r15)
    4954:	02 
    4955:	0f 85 e4 04 00 00    	jne    4e3f <e1000_probe+0x6df>
#endif	
	if (adapter->need_ioport) {
    495b:	41 8b 8f f8 0f 00 00 	mov    0xff8(%r15),%ecx
    4962:	85 c9                	test   %ecx,%ecx
    4964:	74 3f                	je     49a5 <e1000_probe+0x245>
    4966:	48 89 d8             	mov    %rbx,%rax
    4969:	b9 05 00 00 00       	mov    $0x5,%ecx
		for (i = BAR_1; i <= BAR_5; i++) {
			if (pci_resource_len(pdev, i) == 0)
    496e:	48 8b 90 b0 03 00 00 	mov    0x3b0(%rax),%rdx
    4975:	48 8b b0 b8 03 00 00 	mov    0x3b8(%rax),%rsi
    497c:	48 85 d2             	test   %rdx,%rdx
    497f:	75 05                	jne    4986 <e1000_probe+0x226>
    4981:	48 85 f6             	test   %rsi,%rsi
    4984:	74 16                	je     499c <e1000_probe+0x23c>
    4986:	48 29 d6             	sub    %rdx,%rsi
    4989:	48 83 fe ff          	cmp    $0xffffffffffffffff,%rsi
    498d:	74 0d                	je     499c <e1000_probe+0x23c>
				continue;
			if (pci_resource_flags(pdev, i) & IORESOURCE_IO) {
    498f:	f6 80 c9 03 00 00 01 	testb  $0x1,0x3c9(%rax)
    4996:	0f 85 c9 0a 00 00    	jne    5465 <e1000_probe+0xd05>
    499c:	48 83 c0 38          	add    $0x38,%rax
		goto err_ioremap;
#ifdef DEBUG
	e_info(probe,"hw_addr=%08X\n",hw->hw_addr);
#endif	
	if (adapter->need_ioport) {
		for (i = BAR_1; i <= BAR_5; i++) {
    49a0:	83 e9 01             	sub    $0x1,%ecx
    49a3:	75 c9                	jne    496e <e1000_probe+0x20e>
 * Returns negative error codes if MAC type setup fails.
 */
static int e1000_init_hw_struct(struct e1000_adapter *adapter,
				struct e1000_hw *hw)
{
	struct pci_dev *pdev = adapter->pdev;
    49a5:	49 8b 87 f8 0b 00 00 	mov    0xbf8(%r15),%rax
	hw->device_id = pdev->device;
	hw->subsystem_vendor_id = pdev->subsystem_vendor;
	hw->subsystem_id = pdev->subsystem_device;
	hw->revision_id = pdev->revision;

	pci_read_config_word(pdev, PCI_COMMAND, &hw->pci_cmd_word);
    49ac:	49 8d 8f d4 0c 00 00 	lea    0xcd4(%r15),%rcx
				struct e1000_hw *hw)
{
	struct pci_dev *pdev = adapter->pdev;

	/* PCI config space info */
	hw->vendor_id = pdev->vendor;
    49b3:	0f b7 50 3c          	movzwl 0x3c(%rax),%edx
    49b7:	66 41 89 97 e8 0c 00 	mov    %dx,0xce8(%r15)
    49be:	00 
	hw->device_id = pdev->device;
    49bf:	0f b7 50 3e          	movzwl 0x3e(%rax),%edx
    49c3:	66 41 89 97 e6 0c 00 	mov    %dx,0xce6(%r15)
    49ca:	00 
	hw->subsystem_vendor_id = pdev->subsystem_vendor;
    49cb:	0f b7 50 40          	movzwl 0x40(%rax),%edx
    49cf:	66 41 89 97 ec 0c 00 	mov    %dx,0xcec(%r15)
    49d6:	00 
	hw->subsystem_id = pdev->subsystem_device;
    49d7:	0f b7 50 42          	movzwl 0x42(%rax),%edx
    49db:	66 41 89 97 ea 0c 00 	mov    %dx,0xcea(%r15)
    49e2:	00 
	hw->revision_id = pdev->revision;
    49e3:	0f b6 50 48          	movzbl 0x48(%rax),%edx
    49e7:	41 88 97 ee 0c 00 00 	mov    %dl,0xcee(%r15)
{
	return pci_bus_read_config_byte(dev->bus, dev->devfn, where, val);
}
static inline int pci_read_config_word(const struct pci_dev *dev, int where, u16 *val)
{
	return pci_bus_read_config_word(dev->bus, dev->devfn, where, val);
    49ee:	8b 70 38             	mov    0x38(%rax),%esi
    49f1:	ba 04 00 00 00       	mov    $0x4,%edx
    49f6:	48 8b 78 10          	mov    0x10(%rax),%rdi
    49fa:	e8 00 00 00 00       	callq  49ff <e1000_probe+0x29f>

	pci_read_config_word(pdev, PCI_COMMAND, &hw->pci_cmd_word);

	hw->max_frame_size = adapter->netdev->mtu +
    49ff:	49 8b 87 f0 0b 00 00 	mov    0xbf0(%r15),%rax
			     ENET_HEADER_SIZE + ETHERNET_FCS_SIZE;
	hw->min_frame_size = MINIMUM_ETHERNET_FRAME_SIZE;

	/* identify the MAC */
	if (e1000_set_mac_type(hw)) {
    4a06:	48 8b 7d b8          	mov    -0x48(%rbp),%rdi
	hw->revision_id = pdev->revision;

	pci_read_config_word(pdev, PCI_COMMAND, &hw->pci_cmd_word);

	hw->max_frame_size = adapter->netdev->mtu +
			     ENET_HEADER_SIZE + ETHERNET_FCS_SIZE;
    4a0a:	8b 80 30 02 00 00    	mov    0x230(%rax),%eax
	hw->min_frame_size = MINIMUM_ETHERNET_FRAME_SIZE;
    4a10:	41 c7 87 9c 0c 00 00 	movl   $0x40,0xc9c(%r15)
    4a17:	40 00 00 00 
	hw->revision_id = pdev->revision;

	pci_read_config_word(pdev, PCI_COMMAND, &hw->pci_cmd_word);

	hw->max_frame_size = adapter->netdev->mtu +
			     ENET_HEADER_SIZE + ETHERNET_FCS_SIZE;
    4a1b:	83 c0 12             	add    $0x12,%eax
	hw->subsystem_id = pdev->subsystem_device;
	hw->revision_id = pdev->revision;

	pci_read_config_word(pdev, PCI_COMMAND, &hw->pci_cmd_word);

	hw->max_frame_size = adapter->netdev->mtu +
    4a1e:	41 89 87 98 0c 00 00 	mov    %eax,0xc98(%r15)
			     ENET_HEADER_SIZE + ETHERNET_FCS_SIZE;
	hw->min_frame_size = MINIMUM_ETHERNET_FRAME_SIZE;

	/* identify the MAC */
	if (e1000_set_mac_type(hw)) {
    4a25:	e8 00 00 00 00       	callq  4a2a <e1000_probe+0x2ca>
    4a2a:	85 c0                	test   %eax,%eax
    4a2c:	74 6c                	je     4a9a <e1000_probe+0x33a>
		e_err(probe, "Unknown MAC Type\n");
    4a2e:	41 f6 87 e0 0f 00 00 	testb  $0x2,0xfe0(%r15)
    4a35:	02 
    4a36:	0f 85 e9 03 00 00    	jne    4e25 <e1000_probe+0x6c5>
    4a3c:	49 8b bf 10 0c 00 00 	mov    0xc10(%r15),%rdi

	err = e1000_sw_init(adapter);
	if (err)
		goto err_sw_init;

	err = -EIO;
    4a43:	41 bd fb ff ff ff    	mov    $0xfffffffb,%r13d
	kfree(adapter->tx_ring);
	kfree(adapter->rx_ring);
err_dma:
err_sw_init:
err_mdio_ioremap:
	iounmap(hw->ce4100_gbe_mdio_base_virt);
    4a49:	e8 00 00 00 00       	callq  4a4e <e1000_probe+0x2ee>
	iounmap(hw->hw_addr);
    4a4e:	49 8b bf 00 0c 00 00 	mov    0xc00(%r15),%rdi
    4a55:	e8 00 00 00 00       	callq  4a5a <e1000_probe+0x2fa>
err_ioremap:
	free_netdev(netdev);
    4a5a:	4c 89 ff             	mov    %r15,%rdi
    4a5d:	e8 00 00 00 00       	callq  4a62 <e1000_probe+0x302>
err_alloc_etherdev:
	pci_release_selected_regions(pdev, bars);
    4a62:	44 89 e6             	mov    %r12d,%esi
    4a65:	48 89 df             	mov    %rbx,%rdi
    4a68:	e8 00 00 00 00       	callq  4a6d <e1000_probe+0x30d>
    4a6d:	e9 f3 fd ff ff       	jmpq   4865 <e1000_probe+0x105>
		err = pci_enable_device_mem(pdev);
	}
	if (err)
		return err;
#ifdef DEBUG
	e_info(probe,"need_ioport=%d,bars=%08X,debuglevel=%d\n",need_ioport,bars,debug);
    4a72:	44 8b 05 00 00 00 00 	mov    0x0(%rip),%r8d        # 4a79 <e1000_probe+0x319>
    4a79:	8b 55 b8             	mov    -0x48(%rbp),%edx
    4a7c:	44 89 e1             	mov    %r12d,%ecx
    4a7f:	48 8b 3c 25 b0 03 00 	mov    0x3b0,%rdi
    4a86:	00 
    4a87:	48 c7 c6 00 00 00 00 	mov    $0x0,%rsi
    4a8e:	31 c0                	xor    %eax,%eax
    4a90:	e8 00 00 00 00       	callq  4a95 <e1000_probe+0x335>
    4a95:	e9 b2 fd ff ff       	jmpq   484c <e1000_probe+0xec>
	if (e1000_set_mac_type(hw)) {
		e_err(probe, "Unknown MAC Type\n");
		return -EIO;
	}

	switch (hw->mac_type) {
    4a9a:	41 8b 87 18 0c 00 00 	mov    0xc18(%r15),%eax
    4aa1:	83 e8 0b             	sub    $0xb,%eax
    4aa4:	83 f8 03             	cmp    $0x3,%eax
    4aa7:	0f 86 c7 00 00 00    	jbe    4b74 <e1000_probe+0x414>
	case e1000_82547_rev_2:
		hw->phy_init_script = 1;
		break;
	}

	e1000_set_media_type(hw);
    4aad:	4c 8b 6d b8          	mov    -0x48(%rbp),%r13
    4ab1:	4c 89 ef             	mov    %r13,%rdi
    4ab4:	e8 00 00 00 00       	callq  4ab9 <e1000_probe+0x359>
	e1000_get_bus_info(hw);
    4ab9:	4c 89 ef             	mov    %r13,%rdi
    4abc:	e8 00 00 00 00       	callq  4ac1 <e1000_probe+0x361>
	hw->tbi_compatibility_en = true;
	hw->adaptive_ifs = true;

	/* Copper options */

	if (hw->media_type == e1000_media_type_copper) {
    4ac1:	41 8b 97 24 0c 00 00 	mov    0xc24(%r15),%edx
	}

	e1000_set_media_type(hw);
	e1000_get_bus_info(hw);

	hw->wait_autoneg_complete = false;
    4ac8:	41 c6 87 f2 0c 00 00 	movb   $0x0,0xcf2(%r15)
    4acf:	00 
	hw->tbi_compatibility_en = true;
    4ad0:	41 c6 87 0e 0d 00 00 	movb   $0x1,0xd0e(%r15)
    4ad7:	01 
	hw->adaptive_ifs = true;
    4ad8:	41 c6 87 16 0d 00 00 	movb   $0x1,0xd16(%r15)
    4adf:	01 

	/* Copper options */

	if (hw->media_type == e1000_media_type_copper) {
    4ae0:	85 d2                	test   %edx,%edx
    4ae2:	75 1b                	jne    4aff <e1000_probe+0x39f>
		hw->mdix = AUTO_ALL_MODES;
    4ae4:	41 c6 87 f0 0c 00 00 	movb   $0x0,0xcf0(%r15)
    4aeb:	00 
		hw->disable_polarity_correction = false;
    4aec:	41 c6 87 00 0d 00 00 	movb   $0x0,0xd00(%r15)
    4af3:	00 
		hw->master_slave = E1000_MASTER_SLAVE;
    4af4:	41 c7 87 60 0c 00 00 	movl   $0x0,0xc60(%r15)
    4afb:	00 00 00 00 
	 * 64-bit DMA addresses to 64-bit hardware.  There are some
	 * 32-bit adapters that Tx hang when given 64-bit DMA addresses
	 */
	pci_using_dac = 0;
#ifdef DEBUG
	e_info(probe,"hw bus_type=%d\n",hw->bus_type);
    4aff:	41 f6 87 e0 0f 00 00 	testb  $0x2,0xfe0(%r15)
    4b06:	02 
    4b07:	0f 85 f7 02 00 00    	jne    4e04 <e1000_probe+0x6a4>
#endif	
	if ((hw->bus_type == e1000_bus_type_pcix) &&
    4b0d:	41 83 bf 4c 0c 00 00 	cmpl   $0x2,0xc4c(%r15)
    4b14:	02 
    4b15:	0f 84 63 03 00 00    	je     4e7e <e1000_probe+0x71e>
static inline struct dma_map_ops *get_dma_ops(struct device *dev)
{
#ifndef CONFIG_X86_DEV_DMA_OPS
	return dma_ops;
#else
	if (unlikely(!dev) || !dev->archdata.dma_ops)
    4b1b:	4d 85 f6             	test   %r14,%r14
    4b1e:	0f 84 79 08 00 00    	je     539d <e1000_probe+0xc3d>
    4b24:	48 8b 83 e8 02 00 00 	mov    0x2e8(%rbx),%rax
    4b2b:	48 85 c0             	test   %rax,%rax
    4b2e:	0f 84 69 08 00 00    	je     539d <e1000_probe+0xc3d>
#ifndef HAVE_ARCH_DMA_SET_MASK
static inline int dma_set_mask(struct device *dev, u64 mask)
{
	struct dma_map_ops *ops = get_dma_ops(dev);

	if (ops->set_dma_mask)
    4b34:	48 8b 40 70          	mov    0x70(%rax),%rax
    4b38:	48 85 c0             	test   %rax,%rax
    4b3b:	74 47                	je     4b84 <e1000_probe+0x424>
		return ops->set_dma_mask(dev, mask);
    4b3d:	be ff ff ff ff       	mov    $0xffffffff,%esi
    4b42:	4c 89 f7             	mov    %r14,%rdi
    4b45:	ff d0                	callq  *%rax
 * the same or smaller than the streaming DMA mask.
 */
static inline int dma_set_mask_and_coherent(struct device *dev, u64 mask)
{
	int rc = dma_set_mask(dev, mask);
	if (rc == 0)
    4b47:	85 c0                	test   %eax,%eax
    4b49:	41 89 c5             	mov    %eax,%r13d
    4b4c:	74 68                	je     4bb6 <e1000_probe+0x456>
	    !dma_set_mask_and_coherent(&pdev->dev, DMA_BIT_MASK(64))) {
		pci_using_dac = 1;
	} else {
		err = dma_set_mask_and_coherent(&pdev->dev, DMA_BIT_MASK(32));
		if (err) {
			pr_err("No usable DMA config, aborting\n");
    4b4e:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
    4b55:	31 c0                	xor    %eax,%eax
    4b57:	e8 00 00 00 00       	callq  4b5c <e1000_probe+0x3fc>
    4b5c:	49 8b bf 10 0c 00 00 	mov    0xc10(%r15),%rdi
			goto err_dma;
    4b63:	e9 e1 fe ff ff       	jmpq   4a49 <e1000_probe+0x2e9>
		return 0;
	/* set low N bits */
	return (1 << debug_value) - 1;
    4b68:	b0 01                	mov    $0x1,%al
    4b6a:	d3 e0                	shl    %cl,%eax
    4b6c:	83 e8 01             	sub    $0x1,%eax
    4b6f:	e9 91 fd ff ff       	jmpq   4905 <e1000_probe+0x1a5>
		break;
	case e1000_82541:
	case e1000_82547:
	case e1000_82541_rev_2:
	case e1000_82547_rev_2:
		hw->phy_init_script = 1;
    4b74:	41 c7 87 20 0c 00 00 	movl   $0x1,0xc20(%r15)
    4b7b:	01 00 00 00 
    4b7f:	e9 29 ff ff ff       	jmpq   4aad <e1000_probe+0x34d>

	if (!dev->dma_mask || !dma_supported(dev, mask))
    4b84:	48 83 bb b0 02 00 00 	cmpq   $0x0,0x2b0(%rbx)
    4b8b:	00 
    4b8c:	0f 84 12 0a 00 00    	je     55a4 <e1000_probe+0xe44>
    4b92:	be ff ff ff ff       	mov    $0xffffffff,%esi
    4b97:	4c 89 f7             	mov    %r14,%rdi
    4b9a:	e8 00 00 00 00       	callq  4b9f <e1000_probe+0x43f>
    4b9f:	85 c0                	test   %eax,%eax
    4ba1:	0f 84 fd 09 00 00    	je     55a4 <e1000_probe+0xe44>
		return -EIO;
	*dev->dma_mask = mask;
    4ba7:	48 8b 83 b0 02 00 00 	mov    0x2b0(%rbx),%rax
    4bae:	b9 ff ff ff ff       	mov    $0xffffffff,%ecx
    4bb3:	48 89 08             	mov    %rcx,(%rax)
#ifdef CONFIG_ARCH_HAS_DMA_SET_COHERENT_MASK
int dma_set_coherent_mask(struct device *dev, u64 mask);
#else
static inline int dma_set_coherent_mask(struct device *dev, u64 mask)
{
	if (!dma_supported(dev, mask))
    4bb6:	be ff ff ff ff       	mov    $0xffffffff,%esi
    4bbb:	4c 89 f7             	mov    %r14,%rdi
    4bbe:	e8 00 00 00 00       	callq  4bc3 <e1000_probe+0x463>
    4bc3:	85 c0                	test   %eax,%eax
    4bc5:	74 0c                	je     4bd3 <e1000_probe+0x473>
		return -EIO;
	dev->coherent_dma_mask = mask;
    4bc7:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
    4bcc:	48 89 83 b8 02 00 00 	mov    %rax,0x2b8(%rbx)

	/* there is a workaround being applied below that limits
	 * 64-bit DMA addresses to 64-bit hardware.  There are some
	 * 32-bit adapters that Tx hang when given 64-bit DMA addresses
	 */
	pci_using_dac = 0;
    4bd3:	45 31 f6             	xor    %r14d,%r14d
			pr_err("No usable DMA config, aborting\n");
			goto err_dma;
		}
	}

	netdev->netdev_ops = &e1000_netdev_ops;
    4bd6:	49 c7 87 00 02 00 00 	movq   $0x0,0x200(%r15)
    4bdd:	00 00 00 00 
	e1000_set_ethtool_ops(netdev);
    4be1:	4c 89 ff             	mov    %r15,%rdi
    4be4:	e8 00 00 00 00       	callq  4be9 <e1000_probe+0x489>
	netdev->watchdog_timeo = 5 * HZ;
#ifdef DEBUG
	e_info(probe,"watchdog_Time=%d,pci_using_dac=%d\n",netdev->watchdog_timeo,pci_using_dac);
    4be9:	41 f6 87 e0 0f 00 00 	testb  $0x2,0xfe0(%r15)
    4bf0:	02 
		}
	}

	netdev->netdev_ops = &e1000_netdev_ops;
	e1000_set_ethtool_ops(netdev);
	netdev->watchdog_timeo = 5 * HZ;
    4bf1:	41 c7 87 e4 03 00 00 	movl   $0x4e2,0x3e4(%r15)
    4bf8:	e2 04 00 00 
#ifdef DEBUG
	e_info(probe,"watchdog_Time=%d,pci_using_dac=%d\n",netdev->watchdog_timeo,pci_using_dac);
    4bfc:	0f 85 5a 02 00 00    	jne    4e5c <e1000_probe+0x6fc>
#endif	
	
	netif_napi_add(netdev, &adapter->napi, e1000_clean, 64);
    4c02:	49 8d b7 f0 0a 00 00 	lea    0xaf0(%r15),%rsi
    4c09:	b9 40 00 00 00       	mov    $0x40,%ecx
    4c0e:	48 c7 c2 00 00 00 00 	mov    $0x0,%rdx
    4c15:	4c 89 ff             	mov    %r15,%rdi
    4c18:	e8 00 00 00 00       	callq  4c1d <e1000_probe+0x4bd>
#include <linux/pm_wakeup.h>

static inline const char *dev_name(const struct device *dev)
{
	/* Use the init name until the kobject becomes available */
	if (dev->init_name)
    4c1d:	48 8b b3 e8 00 00 00 	mov    0xe8(%rbx),%rsi
    4c24:	48 85 f6             	test   %rsi,%rsi
    4c27:	0f 84 11 07 00 00    	je     533e <e1000_probe+0xbde>

	strncpy(netdev->name, pci_name(pdev), sizeof(netdev->name) - 1);
    4c2d:	ba 0f 00 00 00       	mov    $0xf,%edx
    4c32:	4c 89 ff             	mov    %r15,%rdi
    4c35:	e8 00 00 00 00       	callq  4c3a <e1000_probe+0x4da>

	adapter->bd_number = cards_found;
    4c3a:	8b 05 00 00 00 00    	mov    0x0(%rip),%eax        # 4c40 <e1000_probe+0x4e0>
 * e1000_sw_init initializes the Adapter private data structure.
 * e1000_init_hw_struct MUST be called before this function
 **/
static int e1000_sw_init(struct e1000_adapter *adapter)
{
	adapter->rx_buffer_len = MAXIMUM_ETHERNET_VLAN_SIZE;
    4c40:	41 c7 87 48 0a 00 00 	movl   $0x5f2,0xa48(%r15)
    4c47:	f2 05 00 00 
 */
static inline void *kmalloc_array(size_t n, size_t size, gfp_t flags)
{
	if (size != 0 && n > SIZE_MAX / size)
		return NULL;
	return __kmalloc(n * size, flags);
    4c4b:	be c0 80 40 02       	mov    $0x24080c0,%esi

	adapter->num_tx_queues = 1;
    4c50:	41 c7 87 b8 0b 00 00 	movl   $0x1,0xbb8(%r15)
    4c57:	01 00 00 00 
	adapter->num_rx_queues = 1;
    4c5b:	41 c7 87 bc 0b 00 00 	movl   $0x1,0xbbc(%r15)
    4c62:	01 00 00 00 
    4c66:	bf 30 00 00 00       	mov    $0x30,%edi
	
	netif_napi_add(netdev, &adapter->napi, e1000_clean, 64);

	strncpy(netdev->name, pci_name(pdev), sizeof(netdev->name) - 1);

	adapter->bd_number = cards_found;
    4c6b:	41 89 87 44 0a 00 00 	mov    %eax,0xa44(%r15)
    4c72:	e8 00 00 00 00       	callq  4c77 <e1000_probe+0x517>
 **/
static int e1000_alloc_queues(struct e1000_adapter *adapter)
{
	adapter->tx_ring = kcalloc(adapter->num_tx_queues,
	                           sizeof(struct e1000_tx_ring), GFP_KERNEL);
	if (!adapter->tx_ring)
    4c77:	48 85 c0             	test   %rax,%rax
 * We allocate one ring per queue at run-time since we don't know the
 * number of queues at compile-time.
 **/
static int e1000_alloc_queues(struct e1000_adapter *adapter)
{
	adapter->tx_ring = kcalloc(adapter->num_tx_queues,
    4c7a:	49 89 87 80 0a 00 00 	mov    %rax,0xa80(%r15)
	                           sizeof(struct e1000_tx_ring), GFP_KERNEL);
	if (!adapter->tx_ring)
    4c81:	0f 84 a2 07 00 00    	je     5429 <e1000_probe+0xcc9>
		return -ENOMEM;

	adapter->rx_ring = kcalloc(adapter->num_rx_queues,
    4c87:	49 63 bf bc 0b 00 00 	movslq 0xbbc(%r15),%rdi
 * @size: element size.
 * @flags: the type of memory to allocate (see kmalloc).
 */
static inline void *kmalloc_array(size_t n, size_t size, gfp_t flags)
{
	if (size != 0 && n > SIZE_MAX / size)
    4c8e:	48 ba 92 24 49 92 24 	movabs $0x492492492492492,%rdx
    4c95:	49 92 04 
    4c98:	48 39 d7             	cmp    %rdx,%rdi
    4c9b:	0f 87 75 07 00 00    	ja     5416 <e1000_probe+0xcb6>
		return NULL;
	return __kmalloc(n * size, flags);
    4ca1:	48 8d 04 fd 00 00 00 	lea    0x0(,%rdi,8),%rax
    4ca8:	00 
    4ca9:	48 c1 e7 06          	shl    $0x6,%rdi
    4cad:	be c0 80 40 02       	mov    $0x24080c0,%esi
    4cb2:	48 29 c7             	sub    %rax,%rdi
    4cb5:	e8 00 00 00 00       	callq  4cba <e1000_probe+0x55a>
	                           sizeof(struct e1000_rx_ring), GFP_KERNEL);
	if (!adapter->rx_ring) {
    4cba:	48 85 c0             	test   %rax,%rax
	adapter->tx_ring = kcalloc(adapter->num_tx_queues,
	                           sizeof(struct e1000_tx_ring), GFP_KERNEL);
	if (!adapter->tx_ring)
		return -ENOMEM;

	adapter->rx_ring = kcalloc(adapter->num_rx_queues,
    4cbd:	49 89 87 e8 0a 00 00 	mov    %rax,0xae8(%r15)
	                           sizeof(struct e1000_rx_ring), GFP_KERNEL);
	if (!adapter->rx_ring) {
    4cc4:	0f 84 0e 09 00 00    	je     55d8 <e1000_probe+0xe78>
		e_err(probe, "Unable to allocate memory for queues\n");
		return -ENOMEM;
	}

	/* Explicitly disable IRQ since the NIC can be in any state. */
	e1000_irq_disable(adapter);
    4cca:	48 8b 7d b0          	mov    -0x50(%rbp),%rdi
    4cce:	e8 4d bc ff ff       	callq  920 <e1000_irq_disable>

	spin_lock_init(&adapter->stats_lock);
    4cd3:	41 c7 87 5c 0a 00 00 	movl   $0x0,0xa5c(%r15)
    4cda:	00 00 00 00 
 */
static __always_inline void
set_bit(long nr, volatile unsigned long *addr)
{
	if (IS_IMMEDIATE(nr)) {
		asm volatile(LOCK_PREFIX "orb %1,%0"
    4cde:	f0 41 80 8f e8 0f 00 	lock orb $0x4,0xfe8(%r15)
    4ce5:	00 04 
	err = e1000_sw_init(adapter);
	if (err)
		goto err_sw_init;

	err = -EIO;
	if (hw->mac_type == e1000_ce4100) {
    4ce7:	41 8b 87 18 0c 00 00 	mov    0xc18(%r15),%eax
    4cee:	83 f8 09             	cmp    $0x9,%eax
    4cf1:	0f 84 53 06 00 00    	je     534a <e1000_probe+0xbea>
	e_info(probe,"hw->ce4100_gbe_mdio_base_virt=%08X\n",hw->ce4100_gbe_mdio_base_virt);
#endif	
		if (!hw->ce4100_gbe_mdio_base_virt)
			goto err_mdio_ioremap;
	}
	if (hw->mac_type >= e1000_82543) {
    4cf7:	83 f8 02             	cmp    $0x2,%eax
    4cfa:	0f 87 07 02 00 00    	ja     4f07 <e1000_probe+0x7a7>
    4d00:	49 8b 97 f8 00 00 00 	mov    0xf8(%r15),%rdx
    4d07:	49 8b b7 f0 00 00 00 	mov    0xf0(%r15),%rsi
				   NETIF_F_HW_VLAN_CTAG_RX;
		netdev->features = NETIF_F_HW_VLAN_CTAG_TX |
				   NETIF_F_HW_VLAN_CTAG_FILTER;
	}

	if ((hw->mac_type >= e1000_82544) &&
    4d0e:	83 f8 0d             	cmp    $0xd,%eax
    4d11:	74 11                	je     4d24 <e1000_probe+0x5c4>
	   (hw->mac_type != e1000_82547))
		netdev->hw_features |= NETIF_F_TSO;
    4d13:	48 89 d1             	mov    %rdx,%rcx
    4d16:	48 81 c9 00 00 01 00 	or     $0x10000,%rcx
    4d1d:	83 f8 04             	cmp    $0x4,%eax
    4d20:	48 0f 43 d1          	cmovae %rcx,%rdx

	netdev->priv_flags |= IFF_SUPP_NOFCS;
    4d24:	41 8b 8f 24 02 00 00 	mov    0x224(%r15),%ecx

	netdev->features |= netdev->hw_features;
    4d2b:	48 09 d6             	or     %rdx,%rsi
    4d2e:	49 89 b7 f0 00 00 00 	mov    %rsi,0xf0(%r15)

	if ((hw->mac_type >= e1000_82544) &&
	   (hw->mac_type != e1000_82547))
		netdev->hw_features |= NETIF_F_TSO;

	netdev->priv_flags |= IFF_SUPP_NOFCS;
    4d35:	89 c8                	mov    %ecx,%eax
    4d37:	80 cc 40             	or     $0x40,%ah
    4d3a:	41 89 87 24 02 00 00 	mov    %eax,0x224(%r15)

	netdev->features |= netdev->hw_features;
	netdev->hw_features |= (NETIF_F_RXCSUM |
    4d41:	48 b8 00 00 00 00 64 	movabs $0x6400000000,%rax
    4d48:	00 00 00 
    4d4b:	48 09 d0             	or     %rdx,%rax
				NETIF_F_RXALL |
				NETIF_F_RXFCS);

	if (pci_using_dac) {
    4d4e:	45 85 f6             	test   %r14d,%r14d
		netdev->hw_features |= NETIF_F_TSO;

	netdev->priv_flags |= IFF_SUPP_NOFCS;

	netdev->features |= netdev->hw_features;
	netdev->hw_features |= (NETIF_F_RXCSUM |
    4d51:	49 89 87 f8 00 00 00 	mov    %rax,0xf8(%r15)
				NETIF_F_RXALL |
				NETIF_F_RXFCS);

	if (pci_using_dac) {
    4d58:	0f 85 8e 01 00 00    	jne    4eec <e1000_probe+0x78c>
    4d5e:	49 8b 87 08 01 00 00 	mov    0x108(%r15),%rax
		netdev->features |= NETIF_F_HIGHDMA;
		netdev->vlan_features |= NETIF_F_HIGHDMA;
	}

	netdev->vlan_features |= (NETIF_F_TSO |
    4d65:	48 0d 09 00 01 00    	or     $0x10009,%rax
				  NETIF_F_HW_CSUM |
				  NETIF_F_SG);

	/* Do not set IFF_UNICAST_FLT for VMWare's 82545EM */
	if (hw->device_id != E1000_DEV_ID_82545EM_COPPER ||
    4d6b:	66 41 81 bf e6 0c 00 	cmpw   $0x100f,0xce6(%r15)
    4d72:	00 0f 10 
	if (pci_using_dac) {
		netdev->features |= NETIF_F_HIGHDMA;
		netdev->vlan_features |= NETIF_F_HIGHDMA;
	}

	netdev->vlan_features |= (NETIF_F_TSO |
    4d75:	49 89 87 08 01 00 00 	mov    %rax,0x108(%r15)
				  NETIF_F_HW_CSUM |
				  NETIF_F_SG);

	/* Do not set IFF_UNICAST_FLT for VMWare's 82545EM */
	if (hw->device_id != E1000_DEV_ID_82545EM_COPPER ||
    4d7c:	0f 84 27 06 00 00    	je     53a9 <e1000_probe+0xc49>
	    hw->subsystem_vendor_id != PCI_VENDOR_ID_VMWARE)
		netdev->priv_flags |= IFF_UNICAST_FLT;
    4d82:	80 cd 50             	or     $0x50,%ch
    4d85:	41 89 8f 24 02 00 00 	mov    %ecx,0x224(%r15)

	adapter->en_mng_pt = e1000_enable_mng_pass_thru(hw);
    4d8c:	4c 8b 75 b8          	mov    -0x48(%rbp),%r14
    4d90:	4c 89 f7             	mov    %r14,%rdi
    4d93:	e8 00 00 00 00       	callq  4d98 <e1000_probe+0x638>

	/* initialize eeprom parameters */
	if (e1000_init_eeprom_params(hw)) {
    4d98:	4c 89 f7             	mov    %r14,%rdi
	/* Do not set IFF_UNICAST_FLT for VMWare's 82545EM */
	if (hw->device_id != E1000_DEV_ID_82545EM_COPPER ||
	    hw->subsystem_vendor_id != PCI_VENDOR_ID_VMWARE)
		netdev->priv_flags |= IFF_UNICAST_FLT;

	adapter->en_mng_pt = e1000_enable_mng_pass_thru(hw);
    4d9b:	41 89 87 54 0a 00 00 	mov    %eax,0xa54(%r15)

	/* initialize eeprom parameters */
	if (e1000_init_eeprom_params(hw)) {
    4da2:	e8 00 00 00 00       	callq  4da7 <e1000_probe+0x647>
    4da7:	85 c0                	test   %eax,%eax
    4da9:	41 89 c6             	mov    %eax,%r14d
    4dac:	0f 84 7a 01 00 00    	je     4f2c <e1000_probe+0x7cc>
		e_err(probe, "EEPROM initialization failed\n");
    4db2:	41 f6 87 e0 0f 00 00 	testb  $0x2,0xfe0(%r15)
    4db9:	02 
    4dba:	0f 85 36 06 00 00    	jne    53f6 <e1000_probe+0xc96>

	err = e1000_sw_init(adapter);
	if (err)
		goto err_sw_init;

	err = -EIO;
    4dc0:	41 bd fb ff ff ff    	mov    $0xfffffffb,%r13d
	cards_found++;
	return 0;

err_register:
err_eeprom:
	e1000_phy_hw_reset(hw);
    4dc6:	48 8b 7d b8          	mov    -0x48(%rbp),%rdi
    4dca:	e8 00 00 00 00       	callq  4dcf <e1000_probe+0x66f>

	if (hw->flash_address)
    4dcf:	49 8b bf 08 0c 00 00 	mov    0xc08(%r15),%rdi
    4dd6:	48 85 ff             	test   %rdi,%rdi
    4dd9:	74 05                	je     4de0 <e1000_probe+0x680>
		iounmap(hw->flash_address);
    4ddb:	e8 00 00 00 00       	callq  4de0 <e1000_probe+0x680>
	kfree(adapter->tx_ring);
    4de0:	49 8b bf 80 0a 00 00 	mov    0xa80(%r15),%rdi
    4de7:	e8 00 00 00 00       	callq  4dec <e1000_probe+0x68c>
	kfree(adapter->rx_ring);
    4dec:	49 8b bf e8 0a 00 00 	mov    0xae8(%r15),%rdi
    4df3:	e8 00 00 00 00       	callq  4df8 <e1000_probe+0x698>
    4df8:	49 8b bf 10 0c 00 00 	mov    0xc10(%r15),%rdi
    4dff:	e9 45 fc ff ff       	jmpq   4a49 <e1000_probe+0x2e9>
	 * 64-bit DMA addresses to 64-bit hardware.  There are some
	 * 32-bit adapters that Tx hang when given 64-bit DMA addresses
	 */
	pci_using_dac = 0;
#ifdef DEBUG
	e_info(probe,"hw bus_type=%d\n",hw->bus_type);
    4e04:	41 8b 97 4c 0c 00 00 	mov    0xc4c(%r15),%edx
    4e0b:	49 8b bf f0 0b 00 00 	mov    0xbf0(%r15),%rdi
    4e12:	48 c7 c6 00 00 00 00 	mov    $0x0,%rsi
    4e19:	31 c0                	xor    %eax,%eax
    4e1b:	e8 00 00 00 00       	callq  4e20 <e1000_probe+0x6c0>
    4e20:	e9 e8 fc ff ff       	jmpq   4b0d <e1000_probe+0x3ad>
			     ENET_HEADER_SIZE + ETHERNET_FCS_SIZE;
	hw->min_frame_size = MINIMUM_ETHERNET_FRAME_SIZE;

	/* identify the MAC */
	if (e1000_set_mac_type(hw)) {
		e_err(probe, "Unknown MAC Type\n");
    4e25:	49 8b bf f0 0b 00 00 	mov    0xbf0(%r15),%rdi
    4e2c:	48 c7 c6 00 00 00 00 	mov    $0x0,%rsi
    4e33:	31 c0                	xor    %eax,%eax
    4e35:	e8 00 00 00 00       	callq  4e3a <e1000_probe+0x6da>
    4e3a:	e9 fd fb ff ff       	jmpq   4a3c <e1000_probe+0x2dc>
	err = -EIO;
	hw->hw_addr = pci_ioremap_bar(pdev, BAR_0);
	if (!hw->hw_addr)
		goto err_ioremap;
#ifdef DEBUG
	e_info(probe,"hw_addr=%08X\n",hw->hw_addr);
    4e3f:	49 8b bf f0 0b 00 00 	mov    0xbf0(%r15),%rdi
    4e46:	48 89 c2             	mov    %rax,%rdx
    4e49:	48 c7 c6 00 00 00 00 	mov    $0x0,%rsi
    4e50:	31 c0                	xor    %eax,%eax
    4e52:	e8 00 00 00 00       	callq  4e57 <e1000_probe+0x6f7>
    4e57:	e9 ff fa ff ff       	jmpq   495b <e1000_probe+0x1fb>

	netdev->netdev_ops = &e1000_netdev_ops;
	e1000_set_ethtool_ops(netdev);
	netdev->watchdog_timeo = 5 * HZ;
#ifdef DEBUG
	e_info(probe,"watchdog_Time=%d,pci_using_dac=%d\n",netdev->watchdog_timeo,pci_using_dac);
    4e5c:	49 8b bf f0 0b 00 00 	mov    0xbf0(%r15),%rdi
    4e63:	44 89 f1             	mov    %r14d,%ecx
    4e66:	ba e2 04 00 00       	mov    $0x4e2,%edx
    4e6b:	48 c7 c6 00 00 00 00 	mov    $0x0,%rsi
    4e72:	31 c0                	xor    %eax,%eax
    4e74:	e8 00 00 00 00       	callq  4e79 <e1000_probe+0x719>
    4e79:	e9 84 fd ff ff       	jmpq   4c02 <e1000_probe+0x4a2>
    4e7e:	4d 85 f6             	test   %r14,%r14
    4e81:	0f 84 e2 06 00 00    	je     5569 <e1000_probe+0xe09>
    4e87:	48 8b 83 e8 02 00 00 	mov    0x2e8(%rbx),%rax
    4e8e:	48 85 c0             	test   %rax,%rax
    4e91:	0f 84 d2 06 00 00    	je     5569 <e1000_probe+0xe09>
#ifndef HAVE_ARCH_DMA_SET_MASK
static inline int dma_set_mask(struct device *dev, u64 mask)
{
	struct dma_map_ops *ops = get_dma_ops(dev);

	if (ops->set_dma_mask)
    4e97:	48 8b 40 70          	mov    0x70(%rax),%rax
    4e9b:	48 85 c0             	test   %rax,%rax
    4e9e:	0f 84 1a 05 00 00    	je     53be <e1000_probe+0xc5e>
		return ops->set_dma_mask(dev, mask);
    4ea4:	48 c7 c6 ff ff ff ff 	mov    $0xffffffffffffffff,%rsi
    4eab:	4c 89 f7             	mov    %r14,%rdi
    4eae:	ff d0                	callq  *%rax
 * the same or smaller than the streaming DMA mask.
 */
static inline int dma_set_mask_and_coherent(struct device *dev, u64 mask)
{
	int rc = dma_set_mask(dev, mask);
	if (rc == 0)
    4eb0:	85 c0                	test   %eax,%eax
    4eb2:	0f 85 63 fc ff ff    	jne    4b1b <e1000_probe+0x3bb>
#ifdef CONFIG_ARCH_HAS_DMA_SET_COHERENT_MASK
int dma_set_coherent_mask(struct device *dev, u64 mask);
#else
static inline int dma_set_coherent_mask(struct device *dev, u64 mask)
{
	if (!dma_supported(dev, mask))
    4eb8:	48 c7 c6 ff ff ff ff 	mov    $0xffffffffffffffff,%rsi
    4ebf:	4c 89 f7             	mov    %r14,%rdi
    4ec2:	e8 00 00 00 00       	callq  4ec7 <e1000_probe+0x767>
    4ec7:	85 c0                	test   %eax,%eax
    4ec9:	74 0b                	je     4ed6 <e1000_probe+0x776>
		return -EIO;
	dev->coherent_dma_mask = mask;
    4ecb:	48 c7 83 b8 02 00 00 	movq   $0xffffffffffffffff,0x2b8(%rbx)
    4ed2:	ff ff ff ff 
#ifdef DEBUG
	e_info(probe,"hw bus_type=%d\n",hw->bus_type);
#endif	
	if ((hw->bus_type == e1000_bus_type_pcix) &&
	    !dma_set_mask_and_coherent(&pdev->dev, DMA_BIT_MASK(64))) {
		pci_using_dac = 1;
    4ed6:	41 be 01 00 00 00    	mov    $0x1,%r14d
    4edc:	e9 f5 fc ff ff       	jmpq   4bd6 <e1000_probe+0x476>
	pci_set_master(pdev);
	err = pci_save_state(pdev);
	if (err)
		goto err_alloc_etherdev;

	err = -ENOMEM;
    4ee1:	41 bd f4 ff ff ff    	mov    $0xfffffff4,%r13d
    4ee7:	e9 76 fb ff ff       	jmpq   4a62 <e1000_probe+0x302>
				NETIF_F_RXALL |
				NETIF_F_RXFCS);

	if (pci_using_dac) {
		netdev->features |= NETIF_F_HIGHDMA;
		netdev->vlan_features |= NETIF_F_HIGHDMA;
    4eec:	49 8b 87 08 01 00 00 	mov    0x108(%r15),%rax
	netdev->hw_features |= (NETIF_F_RXCSUM |
				NETIF_F_RXALL |
				NETIF_F_RXFCS);

	if (pci_using_dac) {
		netdev->features |= NETIF_F_HIGHDMA;
    4ef3:	48 83 ce 20          	or     $0x20,%rsi
    4ef7:	49 89 b7 f0 00 00 00 	mov    %rsi,0xf0(%r15)
		netdev->vlan_features |= NETIF_F_HIGHDMA;
    4efe:	48 83 c8 20          	or     $0x20,%rax
    4f02:	e9 5e fe ff ff       	jmpq   4d65 <e1000_probe+0x605>
#endif	
		if (!hw->ce4100_gbe_mdio_base_virt)
			goto err_mdio_ioremap;
	}
	if (hw->mac_type >= e1000_82543) {
		netdev->hw_features = NETIF_F_SG |
    4f07:	49 c7 87 f8 00 00 00 	movq   $0x109,0xf8(%r15)
    4f0e:	09 01 00 00 
				   NETIF_F_HW_CSUM |
				   NETIF_F_HW_VLAN_CTAG_RX;
		netdev->features = NETIF_F_HW_VLAN_CTAG_TX |
    4f12:	49 c7 87 f0 00 00 00 	movq   $0x280,0xf0(%r15)
    4f19:	80 02 00 00 
    4f1d:	be 80 02 00 00       	mov    $0x280,%esi
    4f22:	ba 09 01 00 00       	mov    $0x109,%edx
    4f27:	e9 e2 fd ff ff       	jmpq   4d0e <e1000_probe+0x5ae>

	/* before reading the EEPROM, reset the controller to
	 * put the device in a known good starting state
	 */

	e1000_reset_hw(hw);
    4f2c:	4c 8b 6d b8          	mov    -0x48(%rbp),%r13
    4f30:	4c 89 ef             	mov    %r13,%rdi
    4f33:	e8 00 00 00 00       	callq  4f38 <e1000_probe+0x7d8>

	/* make sure the EEPROM is good */
	if (e1000_validate_eeprom_checksum(hw) < 0) {
    4f38:	4c 89 ef             	mov    %r13,%rdi
    4f3b:	e8 00 00 00 00       	callq  4f40 <e1000_probe+0x7e0>
    4f40:	85 c0                	test   %eax,%eax
    4f42:	0f 88 9a 05 00 00    	js     54e2 <e1000_probe+0xd82>
		 * `ip set address`
		 */
		memset(hw->mac_addr, 0, netdev->addr_len);
	} else {
		/* copy the MAC address out of the EEPROM */
		if (e1000_read_mac_addr(hw))
    4f48:	48 8b 7d b8          	mov    -0x48(%rbp),%rdi
    4f4c:	e8 00 00 00 00       	callq  4f51 <e1000_probe+0x7f1>
    4f51:	85 c0                	test   %eax,%eax
    4f53:	74 1f                	je     4f74 <e1000_probe+0x814>
			e_err(probe, "EEPROM Read Error\n");
    4f55:	41 f6 87 e0 0f 00 00 	testb  $0x2,0xfe0(%r15)
    4f5c:	02 
    4f5d:	74 15                	je     4f74 <e1000_probe+0x814>
    4f5f:	49 8b bf f0 0b 00 00 	mov    0xbf0(%r15),%rdi
    4f66:	48 c7 c6 00 00 00 00 	mov    $0x0,%rsi
    4f6d:	31 c0                	xor    %eax,%eax
    4f6f:	e8 00 00 00 00       	callq  4f74 <e1000_probe+0x814>
    4f74:	4d 8d af f4 0c 00 00 	lea    0xcf4(%r15),%r13
	}
	/* don't block initialization here due to bad MAC address */
	memcpy(netdev->dev_addr, hw->mac_addr, netdev->addr_len);
    4f7b:	41 0f b6 97 5d 02 00 	movzbl 0x25d(%r15),%edx
    4f82:	00 
    4f83:	49 8b bf 20 03 00 00 	mov    0x320(%r15),%rdi
    4f8a:	4c 89 ee             	mov    %r13,%rsi
    4f8d:	e8 00 00 00 00       	callq  4f92 <e1000_probe+0x832>
	if (!is_valid_ether_addr(netdev->dev_addr))
    4f92:	49 8b 97 20 03 00 00 	mov    0x320(%r15),%rdx
 * By definition the broadcast address is also a multicast address.
 */
static inline bool is_multicast_ether_addr(const u8 *addr)
{
#if defined(CONFIG_HAVE_EFFICIENT_UNALIGNED_ACCESS)
	u32 a = *(const u32 *)addr;
    4f99:	8b 02                	mov    (%rdx),%eax
 */
static inline bool is_valid_ether_addr(const u8 *addr)
{
	/* FF:FF:FF:FF:FF:FF is a multicast address so we don't need to
	 * explicitly check for it here. */
	return !is_multicast_ether_addr(addr) && !is_zero_ether_addr(addr);
    4f9b:	a8 01                	test   $0x1,%al
    4f9d:	75 08                	jne    4fa7 <e1000_probe+0x847>
 * Please note: addr must be aligned to u16.
 */
static inline bool is_zero_ether_addr(const u8 *addr)
{
#if defined(CONFIG_HAVE_EFFICIENT_UNALIGNED_ACCESS)
	return ((*(const u32 *)addr) | (*(const u16 *)(addr + 4))) == 0;
    4f9f:	0f b7 52 04          	movzwl 0x4(%rdx),%edx
 */
static inline bool is_valid_ether_addr(const u8 *addr)
{
	/* FF:FF:FF:FF:FF:FF is a multicast address so we don't need to
	 * explicitly check for it here. */
	return !is_multicast_ether_addr(addr) && !is_zero_ether_addr(addr);
    4fa3:	09 c2                	or     %eax,%edx
    4fa5:	75 0e                	jne    4fb5 <e1000_probe+0x855>
		e_err(probe, "Invalid MAC Address\n");
    4fa7:	41 f6 87 e0 0f 00 00 	testb  $0x2,0xfe0(%r15)
    4fae:	02 
    4faf:	0f 85 fa 05 00 00    	jne    55af <e1000_probe+0xe4f>


	INIT_DELAYED_WORK(&adapter->watchdog_task, e1000_watchdog);
    4fb5:	48 b8 e0 ff ff ff 0f 	movabs $0xfffffffe0,%rax
    4fbc:	00 00 00 
    4fbf:	49 8d bf 40 10 00 00 	lea    0x1040(%r15),%rdi
    4fc6:	31 c9                	xor    %ecx,%ecx
    4fc8:	49 89 87 20 10 00 00 	mov    %rax,0x1020(%r15)
    4fcf:	49 8d 87 28 10 00 00 	lea    0x1028(%r15),%rax
    4fd6:	31 d2                	xor    %edx,%edx
    4fd8:	be 00 00 20 00       	mov    $0x200000,%esi
    4fdd:	49 c7 87 38 10 00 00 	movq   $0x0,0x1038(%r15)
    4fe4:	00 00 00 00 
#define LIST_HEAD(name) \
	struct list_head name = LIST_HEAD_INIT(name)

static inline void INIT_LIST_HEAD(struct list_head *list)
{
	list->next = list;
    4fe8:	49 89 87 28 10 00 00 	mov    %rax,0x1028(%r15)
	list->prev = list;
    4fef:	49 89 87 30 10 00 00 	mov    %rax,0x1030(%r15)
    4ff6:	e8 00 00 00 00       	callq  4ffb <e1000_probe+0x89b>
    4ffb:	49 8d 87 20 10 00 00 	lea    0x1020(%r15),%rax
	INIT_DELAYED_WORK(&adapter->fifo_stall_task,
    5002:	49 8d bf c0 10 00 00 	lea    0x10c0(%r15),%rdi
    5009:	31 c9                	xor    %ecx,%ecx
    500b:	31 d2                	xor    %edx,%edx
    500d:	be 00 00 20 00       	mov    $0x200000,%esi
	memcpy(netdev->dev_addr, hw->mac_addr, netdev->addr_len);
	if (!is_valid_ether_addr(netdev->dev_addr))
		e_err(probe, "Invalid MAC Address\n");


	INIT_DELAYED_WORK(&adapter->watchdog_task, e1000_watchdog);
    5012:	49 c7 87 58 10 00 00 	movq   $0x0,0x1058(%r15)
    5019:	00 00 00 00 
    501d:	49 89 87 60 10 00 00 	mov    %rax,0x1060(%r15)
	INIT_DELAYED_WORK(&adapter->fifo_stall_task,
    5024:	48 b8 e0 ff ff ff 0f 	movabs $0xfffffffe0,%rax
    502b:	00 00 00 
    502e:	49 c7 87 b8 10 00 00 	movq   $0x0,0x10b8(%r15)
    5035:	00 00 00 00 
    5039:	49 89 87 a0 10 00 00 	mov    %rax,0x10a0(%r15)
    5040:	49 8d 87 a8 10 00 00 	lea    0x10a8(%r15),%rax
#define LIST_HEAD(name) \
	struct list_head name = LIST_HEAD_INIT(name)

static inline void INIT_LIST_HEAD(struct list_head *list)
{
	list->next = list;
    5047:	49 89 87 a8 10 00 00 	mov    %rax,0x10a8(%r15)
	list->prev = list;
    504e:	49 89 87 b0 10 00 00 	mov    %rax,0x10b0(%r15)
    5055:	e8 00 00 00 00       	callq  505a <e1000_probe+0x8fa>
    505a:	49 8d 87 a0 10 00 00 	lea    0x10a0(%r15),%rax
			  e1000_82547_tx_fifo_stall_task);
	INIT_DELAYED_WORK(&adapter->phy_info_task, e1000_update_phy_info_task);
    5061:	49 8d bf 40 11 00 00 	lea    0x1140(%r15),%rdi
    5068:	31 c9                	xor    %ecx,%ecx
    506a:	31 d2                	xor    %edx,%edx
    506c:	be 00 00 20 00       	mov    $0x200000,%esi
	if (!is_valid_ether_addr(netdev->dev_addr))
		e_err(probe, "Invalid MAC Address\n");


	INIT_DELAYED_WORK(&adapter->watchdog_task, e1000_watchdog);
	INIT_DELAYED_WORK(&adapter->fifo_stall_task,
    5071:	49 c7 87 d8 10 00 00 	movq   $0x0,0x10d8(%r15)
    5078:	00 00 00 00 
    507c:	49 89 87 e0 10 00 00 	mov    %rax,0x10e0(%r15)
			  e1000_82547_tx_fifo_stall_task);
	INIT_DELAYED_WORK(&adapter->phy_info_task, e1000_update_phy_info_task);
    5083:	48 b8 e0 ff ff ff 0f 	movabs $0xfffffffe0,%rax
    508a:	00 00 00 
    508d:	49 c7 87 38 11 00 00 	movq   $0x0,0x1138(%r15)
    5094:	00 00 00 00 
    5098:	49 89 87 20 11 00 00 	mov    %rax,0x1120(%r15)
    509f:	49 8d 87 28 11 00 00 	lea    0x1128(%r15),%rax
#define LIST_HEAD(name) \
	struct list_head name = LIST_HEAD_INIT(name)

static inline void INIT_LIST_HEAD(struct list_head *list)
{
	list->next = list;
    50a6:	49 89 87 28 11 00 00 	mov    %rax,0x1128(%r15)
	list->prev = list;
    50ad:	49 89 87 30 11 00 00 	mov    %rax,0x1130(%r15)
    50b4:	e8 00 00 00 00       	callq  50b9 <e1000_probe+0x959>
    50b9:	49 8d 87 20 11 00 00 	lea    0x1120(%r15),%rax
	INIT_WORK(&adapter->reset_task, e1000_reset_task);

	e1000_check_options(adapter);
    50c0:	48 8b 7d b0          	mov    -0x50(%rbp),%rdi


	INIT_DELAYED_WORK(&adapter->watchdog_task, e1000_watchdog);
	INIT_DELAYED_WORK(&adapter->fifo_stall_task,
			  e1000_82547_tx_fifo_stall_task);
	INIT_DELAYED_WORK(&adapter->phy_info_task, e1000_update_phy_info_task);
    50c4:	49 c7 87 58 11 00 00 	movq   $0x0,0x1158(%r15)
    50cb:	00 00 00 00 
	INIT_WORK(&adapter->reset_task, e1000_reset_task);
    50cf:	49 c7 87 18 10 00 00 	movq   $0x0,0x1018(%r15)
    50d6:	00 00 00 00 


	INIT_DELAYED_WORK(&adapter->watchdog_task, e1000_watchdog);
	INIT_DELAYED_WORK(&adapter->fifo_stall_task,
			  e1000_82547_tx_fifo_stall_task);
	INIT_DELAYED_WORK(&adapter->phy_info_task, e1000_update_phy_info_task);
    50da:	49 89 87 60 11 00 00 	mov    %rax,0x1160(%r15)
	INIT_WORK(&adapter->reset_task, e1000_reset_task);
    50e1:	48 b8 e0 ff ff ff 0f 	movabs $0xfffffffe0,%rax
    50e8:	00 00 00 
    50eb:	49 89 87 00 10 00 00 	mov    %rax,0x1000(%r15)
    50f2:	49 8d 87 08 10 00 00 	lea    0x1008(%r15),%rax
#define LIST_HEAD(name) \
	struct list_head name = LIST_HEAD_INIT(name)

static inline void INIT_LIST_HEAD(struct list_head *list)
{
	list->next = list;
    50f9:	49 89 87 08 10 00 00 	mov    %rax,0x1008(%r15)
	list->prev = list;
    5100:	49 89 87 10 10 00 00 	mov    %rax,0x1010(%r15)

	e1000_check_options(adapter);
    5107:	e8 00 00 00 00       	callq  510c <e1000_probe+0x9ac>
	/* Initial Wake on LAN setting
	 * If APM wake is enabled in the EEPROM,
	 * enable the ACPI Magic Packet filter
	 */

	switch (hw->mac_type) {
    510c:	41 83 bf 18 0c 00 00 	cmpl   $0xa,0xc18(%r15)
    5113:	0a 
    5114:	77 20                	ja     5136 <e1000_probe+0x9d6>
    5116:	41 8b 87 18 0c 00 00 	mov    0xc18(%r15),%eax
    511d:	ff 24 c5 00 00 00 00 	jmpq   *0x0(,%rax,8)
			EEPROM_INIT_CONTROL2_REG, 1, &eeprom_data);
		eeprom_apme_mask = E1000_EEPROM_82544_APM;
		break;
	case e1000_82546:
	case e1000_82546_rev_3:
		if (er32(STATUS) & E1000_STATUS_FUNC_1){
    5124:	49 8b 87 00 0c 00 00 	mov    0xc00(%r15),%rax
{ asm volatile("mov" size " %0,%1": :reg (val), \
"m" (*(volatile type __force *)addr) barrier); }

build_mmio_read(readb, "b", unsigned char, "=q", :"memory")
build_mmio_read(readw, "w", unsigned short, "=r", :"memory")
build_mmio_read(readl, "l", unsigned int, "=r", :"memory")
    512b:	8b 40 08             	mov    0x8(%rax),%eax
    512e:	a8 04                	test   $0x4,%al
    5130:	0f 85 3d 06 00 00    	jne    5773 <e1000_probe+0x1013>
				EEPROM_INIT_CONTROL3_PORT_B, 1, &eeprom_data);
			break;
		}
		/* Fall Through */
	default:
		e1000_read_eeprom(hw,
    5136:	48 8b 7d b8          	mov    -0x48(%rbp),%rdi
    513a:	48 8d 4d c4          	lea    -0x3c(%rbp),%rcx
    513e:	ba 01 00 00 00       	mov    $0x1,%edx
    5143:	be 24 00 00 00       	mov    $0x24,%esi
    5148:	e8 00 00 00 00       	callq  514d <e1000_probe+0x9ed>
	static int cards_found = 0;
	static int global_quad_port_a = 0; /* global ksp3 port a indication */
	int i, err, pci_using_dac;
	u16 eeprom_data = 0;
	u16 tmp = 0;
	u16 eeprom_apme_mask = E1000_EEPROM_APME;
    514d:	b8 00 04 00 00       	mov    $0x400,%eax
	default:
		e1000_read_eeprom(hw,
			EEPROM_INIT_CONTROL3_PORT_A, 1, &eeprom_data);
		break;
	}
	if (eeprom_data & eeprom_apme_mask)
    5152:	66 85 45 c4          	test   %ax,-0x3c(%rbp)
    5156:	74 08                	je     5160 <e1000_probe+0xa00>
		adapter->eeprom_wol |= E1000_WUFC_MAG;
    5158:	41 83 8f f0 0f 00 00 	orl    $0x2,0xff0(%r15)
    515f:	02 

	/* now that we have the eeprom settings, apply the special cases
	 * where the eeprom may be wrong or the board simply won't support
	 * wake on lan on a particular port
	 */
	switch (pdev->device) {
    5160:	0f b7 43 3e          	movzwl 0x3e(%rbx),%eax
    5164:	66 3d 7a 10          	cmp    $0x107a,%ax
    5168:	0f 84 52 03 00 00    	je     54c0 <e1000_probe+0xd60>
    516e:	0f 86 46 03 00 00    	jbe    54ba <e1000_probe+0xd5a>
    5174:	66 3d 8a 10          	cmp    $0x108a,%ax
    5178:	0f 84 50 03 00 00    	je     54ce <e1000_probe+0xd6e>
    517e:	66 3d b5 10          	cmp    $0x10b5,%ax
    5182:	0f 85 1e 03 00 00    	jne    54a6 <e1000_probe+0xd46>
		if (er32(STATUS) & E1000_STATUS_FUNC_1)
			adapter->eeprom_wol = 0;
		break;
	case E1000_DEV_ID_82546GB_QUAD_COPPER_KSP3:
		/* if quad port adapter, disable WoL on all but port A */
		if (global_quad_port_a != 0)
    5188:	8b 05 00 00 00 00    	mov    0x0(%rip),%eax        # 518e <e1000_probe+0xa2e>
    518e:	85 c0                	test   %eax,%eax
    5190:	0f 84 fe 02 00 00    	je     5494 <e1000_probe+0xd34>
			adapter->eeprom_wol = 0;
		else
			adapter->quad_port_a = true;
		/* Reset for multiple quad port adapters */
		if (++global_quad_port_a == 4)
    5196:	83 c0 01             	add    $0x1,%eax
			adapter->eeprom_wol = 0;
		break;
	case E1000_DEV_ID_82546GB_QUAD_COPPER_KSP3:
		/* if quad port adapter, disable WoL on all but port A */
		if (global_quad_port_a != 0)
			adapter->eeprom_wol = 0;
    5199:	41 c7 87 f0 0f 00 00 	movl   $0x0,0xff0(%r15)
    51a0:	00 00 00 00 
		else
			adapter->quad_port_a = true;
		/* Reset for multiple quad port adapters */
		if (++global_quad_port_a == 4)
    51a4:	83 f8 04             	cmp    $0x4,%eax
    51a7:	0f 85 1c 04 00 00    	jne    55c9 <e1000_probe+0xe69>
			global_quad_port_a = 0;
    51ad:	c7 05 00 00 00 00 00 	movl   $0x0,0x0(%rip)        # 51b7 <e1000_probe+0xa57>
    51b4:	00 00 00 
    51b7:	31 f6                	xor    %esi,%esi
    51b9:	31 c0                	xor    %eax,%eax
		break;
	}

	/* initialize the wol settings based on the eeprom settings */
	adapter->wol = adapter->eeprom_wol;
    51bb:	41 89 87 4c 0a 00 00 	mov    %eax,0xa4c(%r15)
	device_set_wakeup_enable(&adapter->pdev->dev, adapter->wol);
    51c2:	49 8b 87 f8 0b 00 00 	mov    0xbf8(%r15),%rax
    51c9:	48 8d b8 98 00 00 00 	lea    0x98(%rax),%rdi
    51d0:	e8 00 00 00 00       	callq  51d5 <e1000_probe+0xa75>

	/* Auto detect PHY address */
	if (hw->mac_type == e1000_ce4100) {
    51d5:	41 83 bf 18 0c 00 00 	cmpl   $0x9,0xc18(%r15)
    51dc:	09 
    51dd:	75 3b                	jne    521a <e1000_probe+0xaba>
    51df:	45 31 ed             	xor    %r13d,%r13d
    51e2:	eb 0e                	jmp    51f2 <e1000_probe+0xa92>
		for (i = 0; i < 32; i++) {
			hw->phy_addr = i;
			e1000_read_phy_reg(hw, PHY_ID2, &tmp);
			if (tmp == 0 || tmp == 0xFF) {
				if (i == 31)
    51e4:	41 83 fd 1f          	cmp    $0x1f,%r13d
    51e8:	0f 84 d2 fb ff ff    	je     4dc0 <e1000_probe+0x660>
	adapter->wol = adapter->eeprom_wol;
	device_set_wakeup_enable(&adapter->pdev->dev, adapter->wol);

	/* Auto detect PHY address */
	if (hw->mac_type == e1000_ce4100) {
		for (i = 0; i < 32; i++) {
    51ee:	41 83 c5 01          	add    $0x1,%r13d
			hw->phy_addr = i;
			e1000_read_phy_reg(hw, PHY_ID2, &tmp);
    51f2:	48 8b 7d b8          	mov    -0x48(%rbp),%rdi
    51f6:	48 8d 55 c6          	lea    -0x3a(%rbp),%rdx
	device_set_wakeup_enable(&adapter->pdev->dev, adapter->wol);

	/* Auto detect PHY address */
	if (hw->mac_type == e1000_ce4100) {
		for (i = 0; i < 32; i++) {
			hw->phy_addr = i;
    51fa:	45 89 af 88 0c 00 00 	mov    %r13d,0xc88(%r15)
			e1000_read_phy_reg(hw, PHY_ID2, &tmp);
    5201:	be 03 00 00 00       	mov    $0x3,%esi
    5206:	e8 00 00 00 00       	callq  520b <e1000_probe+0xaab>
			if (tmp == 0 || tmp == 0xFF) {
    520b:	0f b7 45 c6          	movzwl -0x3a(%rbp),%eax
    520f:	66 3d ff 00          	cmp    $0xff,%ax
    5213:	74 cf                	je     51e4 <e1000_probe+0xa84>
    5215:	66 85 c0             	test   %ax,%ax
    5218:	74 ca                	je     51e4 <e1000_probe+0xa84>
				break;
		}
	}

	/* reset the hardware with the new settings */
	e1000_reset(adapter);
    521a:	48 8b 7d b0          	mov    -0x50(%rbp),%rdi
    521e:	e8 00 00 00 00       	callq  5223 <e1000_probe+0xac3>

	strcpy(netdev->name, "jeff_net%d");
    5223:	48 b8 6a 65 66 66 5f 	movabs $0x74656e5f6666656a,%rax
    522a:	6e 65 74 
    522d:	41 c6 47 0a 00       	movb   $0x0,0xa(%r15)
	err = register_netdev(netdev);
    5232:	4c 89 ff             	mov    %r15,%rdi
	}

	/* reset the hardware with the new settings */
	e1000_reset(adapter);

	strcpy(netdev->name, "jeff_net%d");
    5235:	49 89 07             	mov    %rax,(%r15)
    5238:	b8 25 64 00 00       	mov    $0x6425,%eax
    523d:	66 41 89 47 08       	mov    %ax,0x8(%r15)
	err = register_netdev(netdev);
    5242:	e8 00 00 00 00       	callq  5247 <e1000_probe+0xae7>
	if (err)
    5247:	85 c0                	test   %eax,%eax

	/* reset the hardware with the new settings */
	e1000_reset(adapter);

	strcpy(netdev->name, "jeff_net%d");
	err = register_netdev(netdev);
    5249:	41 89 c5             	mov    %eax,%r13d
	if (err)
    524c:	0f 85 74 fb ff ff    	jne    4dc6 <e1000_probe+0x666>
		goto err_register;

	e1000_vlan_filter_on_off(adapter, false);
    5252:	48 8b 7d b0          	mov    -0x50(%rbp),%rdi
    5256:	31 f6                	xor    %esi,%esi
    5258:	e8 13 b9 ff ff       	callq  b70 <e1000_vlan_filter_on_off>

	/* print bus type/speed/width info */
	e_info(probe, "(PCI%s:%dMHz:%d-bit) %pM\n",
    525d:	41 f6 87 e0 0f 00 00 	testb  $0x2,0xfe0(%r15)
    5264:	02 
    5265:	74 79                	je     52e0 <e1000_probe+0xb80>
    5267:	41 83 bf 48 0c 00 00 	cmpl   $0x2,0xc48(%r15)
    526e:	02 
    526f:	b8 20 00 00 00       	mov    $0x20,%eax
    5274:	41 b8 40 00 00 00    	mov    $0x40,%r8d
    527a:	4d 8b 8f 20 03 00 00 	mov    0x320(%r15),%r9
    5281:	b9 85 00 00 00       	mov    $0x85,%ecx
    5286:	44 0f 45 c0          	cmovne %eax,%r8d
    528a:	41 8b 87 44 0c 00 00 	mov    0xc44(%r15),%eax
    5291:	83 f8 05             	cmp    $0x5,%eax
    5294:	74 1b                	je     52b1 <e1000_probe+0xb51>
    5296:	83 f8 04             	cmp    $0x4,%eax
    5299:	b1 78                	mov    $0x78,%cl
    529b:	74 14                	je     52b1 <e1000_probe+0xb51>
    529d:	83 f8 03             	cmp    $0x3,%eax
    52a0:	b1 64                	mov    $0x64,%cl
    52a2:	74 0d                	je     52b1 <e1000_probe+0xb51>
    52a4:	83 f8 02             	cmp    $0x2,%eax
    52a7:	b1 42                	mov    $0x42,%cl
    52a9:	b8 21 00 00 00       	mov    $0x21,%eax
    52ae:	0f 45 c8             	cmovne %eax,%ecx
    52b1:	41 83 bf 4c 0c 00 00 	cmpl   $0x2,0xc4c(%r15)
    52b8:	02 
    52b9:	49 8b bf f0 0b 00 00 	mov    0xbf0(%r15),%rdi
    52c0:	48 c7 c0 00 00 00 00 	mov    $0x0,%rax
    52c7:	48 c7 c2 00 00 00 00 	mov    $0x0,%rdx
    52ce:	48 c7 c6 00 00 00 00 	mov    $0x0,%rsi
    52d5:	48 0f 45 d0          	cmovne %rax,%rdx
    52d9:	31 c0                	xor    %eax,%eax
    52db:	e8 00 00 00 00       	callq  52e0 <e1000_probe+0xb80>
		(hw->bus_speed == e1000_bus_speed_66) ? 66 : 33),
	       ((hw->bus_width == e1000_bus_width_64) ? 64 : 32),
	       netdev->dev_addr);

	/* carrier off reporting is important to ethtool even BEFORE open */
	netif_carrier_off(netdev);
    52e0:	4c 89 ff             	mov    %r15,%rdi
    52e3:	e8 00 00 00 00       	callq  52e8 <e1000_probe+0xb88>

	e_info(probe, "Intel(R) PRO/1000 Network Connection\n");
    52e8:	41 f6 87 e0 0f 00 00 	testb  $0x2,0xfe0(%r15)
    52ef:	02 
    52f0:	74 15                	je     5307 <e1000_probe+0xba7>
    52f2:	49 8b bf f0 0b 00 00 	mov    0xbf0(%r15),%rdi
    52f9:	48 c7 c6 00 00 00 00 	mov    $0x0,%rsi
    5300:	31 c0                	xor    %eax,%eax
    5302:	e8 00 00 00 00       	callq  5307 <e1000_probe+0xba7>

	cards_found++;
    5307:	83 05 00 00 00 00 01 	addl   $0x1,0x0(%rip)        # 530e <e1000_probe+0xbae>
	return 0;
    530e:	e9 5d f5 ff ff       	jmpq   4870 <e1000_probe+0x110>
	case e1000_82542_rev2_0:
	case e1000_82542_rev2_1:
	case e1000_82543:
		break;
	case e1000_82544:
		e1000_read_eeprom(hw,
    5313:	48 8b 7d b8          	mov    -0x48(%rbp),%rdi
    5317:	48 8d 4d c4          	lea    -0x3c(%rbp),%rcx
    531b:	ba 01 00 00 00       	mov    $0x1,%edx
    5320:	be 0f 00 00 00       	mov    $0xf,%esi
    5325:	e8 00 00 00 00       	callq  532a <e1000_probe+0xbca>
			EEPROM_INIT_CONTROL2_REG, 1, &eeprom_data);
		eeprom_apme_mask = E1000_EEPROM_82544_APM;
    532a:	b8 04 00 00 00       	mov    $0x4,%eax
		break;
    532f:	e9 1e fe ff ff       	jmpq   5152 <e1000_probe+0x9f2>
	static int cards_found = 0;
	static int global_quad_port_a = 0; /* global ksp3 port a indication */
	int i, err, pci_using_dac;
	u16 eeprom_data = 0;
	u16 tmp = 0;
	u16 eeprom_apme_mask = E1000_EEPROM_APME;
    5334:	b8 00 04 00 00       	mov    $0x400,%eax
    5339:	e9 14 fe ff ff       	jmpq   5152 <e1000_probe+0x9f2>
		return dev->init_name;

	return kobject_name(&dev->kobj);
    533e:	48 8b b3 a8 00 00 00 	mov    0xa8(%rbx),%rsi
    5345:	e9 e3 f8 ff ff       	jmpq   4c2d <e1000_probe+0x4cd>

	err = -EIO;
	if (hw->mac_type == e1000_ce4100) {
		hw->ce4100_gbe_mdio_base_virt =
					ioremap(pci_resource_start(pdev, BAR_1),
		                                pci_resource_len(pdev, BAR_1));
    534a:	48 8b bb b0 03 00 00 	mov    0x3b0(%rbx),%rdi
    5351:	48 8b 83 b8 03 00 00 	mov    0x3b8(%rbx),%rax
		goto err_sw_init;

	err = -EIO;
	if (hw->mac_type == e1000_ce4100) {
		hw->ce4100_gbe_mdio_base_virt =
					ioremap(pci_resource_start(pdev, BAR_1),
    5358:	48 85 ff             	test   %rdi,%rdi
    535b:	75 07                	jne    5364 <e1000_probe+0xc04>
    535d:	31 f6                	xor    %esi,%esi
		                                pci_resource_len(pdev, BAR_1));
    535f:	48 85 c0             	test   %rax,%rax
    5362:	74 07                	je     536b <e1000_probe+0xc0b>
    5364:	48 29 f8             	sub    %rdi,%rax
		goto err_sw_init;

	err = -EIO;
	if (hw->mac_type == e1000_ce4100) {
		hw->ce4100_gbe_mdio_base_virt =
					ioremap(pci_resource_start(pdev, BAR_1),
    5367:	48 8d 70 01          	lea    0x1(%rax),%rsi
/*
 * The default ioremap() behavior is non-cached:
 */
static inline void __iomem *ioremap(resource_size_t offset, unsigned long size)
{
	return ioremap_nocache(offset, size);
    536b:	e8 00 00 00 00       	callq  5370 <e1000_probe+0xc10>
		                                pci_resource_len(pdev, BAR_1));
#ifdef DEBUG
	e_info(probe,"hw->ce4100_gbe_mdio_base_virt=%08X\n",hw->ce4100_gbe_mdio_base_virt);
    5370:	41 f6 87 e0 0f 00 00 	testb  $0x2,0xfe0(%r15)
    5377:	02 
    5378:	48 89 c7             	mov    %rax,%rdi
	if (err)
		goto err_sw_init;

	err = -EIO;
	if (hw->mac_type == e1000_ce4100) {
		hw->ce4100_gbe_mdio_base_virt =
    537b:	49 89 87 10 0c 00 00 	mov    %rax,0xc10(%r15)
					ioremap(pci_resource_start(pdev, BAR_1),
		                                pci_resource_len(pdev, BAR_1));
#ifdef DEBUG
	e_info(probe,"hw->ce4100_gbe_mdio_base_virt=%08X\n",hw->ce4100_gbe_mdio_base_virt);
    5382:	0f 85 ed 01 00 00    	jne    5575 <e1000_probe+0xe15>
#endif	
		if (!hw->ce4100_gbe_mdio_base_virt)
    5388:	48 85 ff             	test   %rdi,%rdi
    538b:	0f 84 08 02 00 00    	je     5599 <e1000_probe+0xe39>
    5391:	41 8b 87 18 0c 00 00 	mov    0xc18(%r15),%eax
    5398:	e9 5a f9 ff ff       	jmpq   4cf7 <e1000_probe+0x597>
		return dma_ops;
    539d:	48 8b 05 00 00 00 00 	mov    0x0(%rip),%rax        # 53a4 <e1000_probe+0xc44>
    53a4:	e9 8b f7 ff ff       	jmpq   4b34 <e1000_probe+0x3d4>
	netdev->vlan_features |= (NETIF_F_TSO |
				  NETIF_F_HW_CSUM |
				  NETIF_F_SG);

	/* Do not set IFF_UNICAST_FLT for VMWare's 82545EM */
	if (hw->device_id != E1000_DEV_ID_82545EM_COPPER ||
    53a9:	66 41 81 bf ec 0c 00 	cmpw   $0x15ad,0xcec(%r15)
    53b0:	00 ad 15 
    53b3:	0f 85 c9 f9 ff ff    	jne    4d82 <e1000_probe+0x622>
    53b9:	e9 ce f9 ff ff       	jmpq   4d8c <e1000_probe+0x62c>

	if (!dev->dma_mask || !dma_supported(dev, mask))
    53be:	48 83 bb b0 02 00 00 	cmpq   $0x0,0x2b0(%rbx)
    53c5:	00 
    53c6:	0f 84 4f f7 ff ff    	je     4b1b <e1000_probe+0x3bb>
    53cc:	48 c7 c6 ff ff ff ff 	mov    $0xffffffffffffffff,%rsi
    53d3:	4c 89 f7             	mov    %r14,%rdi
    53d6:	e8 00 00 00 00       	callq  53db <e1000_probe+0xc7b>
    53db:	85 c0                	test   %eax,%eax
    53dd:	0f 84 38 f7 ff ff    	je     4b1b <e1000_probe+0x3bb>
		return -EIO;
	*dev->dma_mask = mask;
    53e3:	48 8b 83 b0 02 00 00 	mov    0x2b0(%rbx),%rax
    53ea:	48 c7 00 ff ff ff ff 	movq   $0xffffffffffffffff,(%rax)
    53f1:	e9 c2 fa ff ff       	jmpq   4eb8 <e1000_probe+0x758>

	adapter->en_mng_pt = e1000_enable_mng_pass_thru(hw);

	/* initialize eeprom parameters */
	if (e1000_init_eeprom_params(hw)) {
		e_err(probe, "EEPROM initialization failed\n");
    53f6:	49 8b bf f0 0b 00 00 	mov    0xbf0(%r15),%rdi
    53fd:	48 c7 c6 00 00 00 00 	mov    $0x0,%rsi
    5404:	31 c0                	xor    %eax,%eax

	err = e1000_sw_init(adapter);
	if (err)
		goto err_sw_init;

	err = -EIO;
    5406:	41 bd fb ff ff ff    	mov    $0xfffffffb,%r13d

	adapter->en_mng_pt = e1000_enable_mng_pass_thru(hw);

	/* initialize eeprom parameters */
	if (e1000_init_eeprom_params(hw)) {
		e_err(probe, "EEPROM initialization failed\n");
    540c:	e8 00 00 00 00       	callq  5411 <e1000_probe+0xcb1>
    5411:	e9 b0 f9 ff ff       	jmpq   4dc6 <e1000_probe+0x666>
	adapter->tx_ring = kcalloc(adapter->num_tx_queues,
	                           sizeof(struct e1000_tx_ring), GFP_KERNEL);
	if (!adapter->tx_ring)
		return -ENOMEM;

	adapter->rx_ring = kcalloc(adapter->num_rx_queues,
    5416:	49 c7 87 e8 0a 00 00 	movq   $0x0,0xae8(%r15)
    541d:	00 00 00 00 
    5421:	48 89 c7             	mov    %rax,%rdi
	                           sizeof(struct e1000_rx_ring), GFP_KERNEL);
	if (!adapter->rx_ring) {
		kfree(adapter->tx_ring);
    5424:	e8 00 00 00 00       	callq  5429 <e1000_probe+0xcc9>

	adapter->num_tx_queues = 1;
	adapter->num_rx_queues = 1;

	if (e1000_alloc_queues(adapter)) {
		e_err(probe, "Unable to allocate memory for queues\n");
    5429:	41 f6 87 e0 0f 00 00 	testb  $0x2,0xfe0(%r15)
    5430:	02 
    5431:	74 15                	je     5448 <e1000_probe+0xce8>
    5433:	49 8b bf f0 0b 00 00 	mov    0xbf0(%r15),%rdi
    543a:	48 c7 c6 00 00 00 00 	mov    $0x0,%rsi
    5441:	31 c0                	xor    %eax,%eax
    5443:	e8 00 00 00 00       	callq  5448 <e1000_probe+0xce8>
    5448:	49 8b bf 10 0c 00 00 	mov    0xc10(%r15),%rdi

	err = e1000_sw_init(adapter);
	if (err)
		goto err_sw_init;

	err = -EIO;
    544f:	41 bd f4 ff ff ff    	mov    $0xfffffff4,%r13d
    5455:	e9 ef f5 ff ff       	jmpq   4a49 <e1000_probe+0x2e9>
	adapter->need_ioport = need_ioport;

	hw = &adapter->hw;
	hw->back = adapter;

	err = -EIO;
    545a:	41 bd fb ff ff ff    	mov    $0xfffffffb,%r13d
    5460:	e9 f5 f5 ff ff       	jmpq   4a5a <e1000_probe+0x2fa>
			if (pci_resource_len(pdev, i) == 0)
				continue;
			if (pci_resource_flags(pdev, i) & IORESOURCE_IO) {
				hw->io_base = pci_resource_start(pdev, i);
#ifdef DEBUG
	e_info(probe,"iobase=%ld\n",hw->io_base);
    5465:	41 f6 87 e0 0f 00 00 	testb  $0x2,0xfe0(%r15)
    546c:	02 
	if (adapter->need_ioport) {
		for (i = BAR_1; i <= BAR_5; i++) {
			if (pci_resource_len(pdev, i) == 0)
				continue;
			if (pci_resource_flags(pdev, i) & IORESOURCE_IO) {
				hw->io_base = pci_resource_start(pdev, i);
    546d:	49 89 97 78 0c 00 00 	mov    %rdx,0xc78(%r15)
#ifdef DEBUG
	e_info(probe,"iobase=%ld\n",hw->io_base);
    5474:	0f 84 2b f5 ff ff    	je     49a5 <e1000_probe+0x245>
    547a:	49 8b bf f0 0b 00 00 	mov    0xbf0(%r15),%rdi
    5481:	48 c7 c6 00 00 00 00 	mov    $0x0,%rsi
    5488:	31 c0                	xor    %eax,%eax
    548a:	e8 00 00 00 00       	callq  548f <e1000_probe+0xd2f>
    548f:	e9 11 f5 ff ff       	jmpq   49a5 <e1000_probe+0x245>
	case E1000_DEV_ID_82546GB_QUAD_COPPER_KSP3:
		/* if quad port adapter, disable WoL on all but port A */
		if (global_quad_port_a != 0)
			adapter->eeprom_wol = 0;
		else
			adapter->quad_port_a = true;
    5494:	41 c6 87 e6 0f 00 00 	movb   $0x1,0xfe6(%r15)
    549b:	01 
		/* Reset for multiple quad port adapters */
		if (++global_quad_port_a == 4)
    549c:	c7 05 00 00 00 00 01 	movl   $0x1,0x0(%rip)        # 54a6 <e1000_probe+0xd46>
    54a3:	00 00 00 
    54a6:	41 8b 87 f0 0f 00 00 	mov    0xff0(%r15),%eax
    54ad:	31 f6                	xor    %esi,%esi
    54af:	85 c0                	test   %eax,%eax
    54b1:	40 0f 95 c6          	setne  %sil
    54b5:	e9 01 fd ff ff       	jmpq   51bb <e1000_probe+0xa5b>

	/* now that we have the eeprom settings, apply the special cases
	 * where the eeprom may be wrong or the board simply won't support
	 * wake on lan on a particular port
	 */
	switch (pdev->device) {
    54ba:	66 3d 12 10          	cmp    $0x1012,%ax
    54be:	75 e6                	jne    54a6 <e1000_probe+0xd46>
	case E1000_DEV_ID_82546EB_FIBER:
	case E1000_DEV_ID_82546GB_FIBER:
		/* Wake events only supported on port A for dual fiber
		 * regardless of eeprom setting
		 */
		if (er32(STATUS) & E1000_STATUS_FUNC_1)
    54c0:	49 8b 87 00 0c 00 00 	mov    0xc00(%r15),%rax
{ asm volatile("mov" size " %0,%1": :reg (val), \
"m" (*(volatile type __force *)addr) barrier); }

build_mmio_read(readb, "b", unsigned char, "=q", :"memory")
build_mmio_read(readw, "w", unsigned short, "=r", :"memory")
build_mmio_read(readl, "l", unsigned int, "=r", :"memory")
    54c7:	8b 40 08             	mov    0x8(%rax),%eax
    54ca:	a8 04                	test   $0x4,%al
    54cc:	74 d8                	je     54a6 <e1000_probe+0xd46>
			adapter->eeprom_wol = 0;
    54ce:	41 c7 87 f0 0f 00 00 	movl   $0x0,0xff0(%r15)
    54d5:	00 00 00 00 
    54d9:	31 f6                	xor    %esi,%esi
    54db:	31 c0                	xor    %eax,%eax
    54dd:	e9 d9 fc ff ff       	jmpq   51bb <e1000_probe+0xa5b>

	e1000_reset_hw(hw);

	/* make sure the EEPROM is good */
	if (e1000_validate_eeprom_checksum(hw) < 0) {
		e_err(probe, "The EEPROM Checksum Is Not Valid\n");
    54e2:	41 f6 87 e0 0f 00 00 	testb  $0x2,0xfe0(%r15)
    54e9:	02 
    54ea:	74 15                	je     5501 <e1000_probe+0xda1>
    54ec:	49 8b bf f0 0b 00 00 	mov    0xbf0(%r15),%rdi
    54f3:	48 c7 c6 00 00 00 00 	mov    $0x0,%rsi
    54fa:	31 c0                	xor    %eax,%eax
    54fc:	e8 00 00 00 00       	callq  5501 <e1000_probe+0xda1>
}

static int e1000_probe(struct pci_dev *pdev, const struct pci_device_id *ent)
{
	struct net_device *netdev;
	struct e1000_adapter *adapter;
    5501:	49 8b 8f f0 0b 00 00 	mov    0xbf0(%r15),%rcx
/* Dump the eeprom for users having checksum issues */
static void e1000_dump_eeprom(struct e1000_adapter *adapter)
{
	struct net_device *netdev = adapter->netdev;
	struct ethtool_eeprom eeprom;
	const struct ethtool_ops *ops = netdev->ethtool_ops;
    5508:	48 8b 81 08 02 00 00 	mov    0x208(%rcx),%rax
	u8 *data;
	int i;
	u16 csum_old, csum_new = 0;

	eeprom.len = ops->get_eeprom_len(netdev);
    550f:	48 89 cf             	mov    %rcx,%rdi
    5512:	48 89 4d a0          	mov    %rcx,-0x60(%rbp)
/* Dump the eeprom for users having checksum issues */
static void e1000_dump_eeprom(struct e1000_adapter *adapter)
{
	struct net_device *netdev = adapter->netdev;
	struct ethtool_eeprom eeprom;
	const struct ethtool_ops *ops = netdev->ethtool_ops;
    5516:	48 89 45 a8          	mov    %rax,-0x58(%rbp)
	u8 *data;
	int i;
	u16 csum_old, csum_new = 0;

	eeprom.len = ops->get_eeprom_len(netdev);
    551a:	ff 50 58             	callq  *0x58(%rax)
	eeprom.offset = 0;

	data = kmalloc(eeprom.len, GFP_KERNEL);
    551d:	48 8b 4d a0          	mov    -0x60(%rbp),%rcx
    5521:	89 c7                	mov    %eax,%edi
			return kmem_cache_alloc_trace(kmalloc_caches[index],
					flags, size);
		}
#endif
	}
	return __kmalloc(size, flags);
    5523:	be c0 00 40 02       	mov    $0x24000c0,%esi
	const struct ethtool_ops *ops = netdev->ethtool_ops;
	u8 *data;
	int i;
	u16 csum_old, csum_new = 0;

	eeprom.len = ops->get_eeprom_len(netdev);
    5528:	89 45 d4             	mov    %eax,-0x2c(%rbp)
	eeprom.offset = 0;
    552b:	c7 45 d0 00 00 00 00 	movl   $0x0,-0x30(%rbp)
    5532:	48 89 4d a0          	mov    %rcx,-0x60(%rbp)
    5536:	e8 00 00 00 00       	callq  553b <e1000_probe+0xddb>

	data = kmalloc(eeprom.len, GFP_KERNEL);
	if (!data)
    553b:	48 85 c0             	test   %rax,%rax
    553e:	49 89 c5             	mov    %rax,%r13
    5541:	48 8b 4d a0          	mov    -0x60(%rbp),%rcx
    5545:	0f 85 99 00 00 00    	jne    55e4 <e1000_probe+0xe84>
		 * traffic while still permitting ethtool ioctls from reaching
		 * the hardware as well as allowing the user to run the
		 * interface after manually setting a hw addr using
		 * `ip set address`
		 */
		memset(hw->mac_addr, 0, netdev->addr_len);
    554b:	41 0f b6 97 5d 02 00 	movzbl 0x25d(%r15),%edx
    5552:	00 
    5553:	4d 8d af f4 0c 00 00 	lea    0xcf4(%r15),%r13
    555a:	31 f6                	xor    %esi,%esi
    555c:	4c 89 ef             	mov    %r13,%rdi
    555f:	e8 00 00 00 00       	callq  5564 <e1000_probe+0xe04>
    5564:	e9 12 fa ff ff       	jmpq   4f7b <e1000_probe+0x81b>
    5569:	48 8b 05 00 00 00 00 	mov    0x0(%rip),%rax        # 5570 <e1000_probe+0xe10>
    5570:	e9 22 f9 ff ff       	jmpq   4e97 <e1000_probe+0x737>
	if (hw->mac_type == e1000_ce4100) {
		hw->ce4100_gbe_mdio_base_virt =
					ioremap(pci_resource_start(pdev, BAR_1),
		                                pci_resource_len(pdev, BAR_1));
#ifdef DEBUG
	e_info(probe,"hw->ce4100_gbe_mdio_base_virt=%08X\n",hw->ce4100_gbe_mdio_base_virt);
    5575:	49 8b bf f0 0b 00 00 	mov    0xbf0(%r15),%rdi
    557c:	48 89 c2             	mov    %rax,%rdx
    557f:	48 c7 c6 00 00 00 00 	mov    $0x0,%rsi
    5586:	31 c0                	xor    %eax,%eax
    5588:	e8 00 00 00 00       	callq  558d <e1000_probe+0xe2d>
    558d:	49 8b bf 10 0c 00 00 	mov    0xc10(%r15),%rdi
    5594:	e9 ef fd ff ff       	jmpq   5388 <e1000_probe+0xc28>

	err = e1000_sw_init(adapter);
	if (err)
		goto err_sw_init;

	err = -EIO;
    5599:	41 bd fb ff ff ff    	mov    $0xfffffffb,%r13d
    559f:	e9 a5 f4 ff ff       	jmpq   4a49 <e1000_probe+0x2e9>
	free_netdev(netdev);
err_alloc_etherdev:
	pci_release_selected_regions(pdev, bars);
err_pci_reg:
	pci_disable_device(pdev);
	return err;
    55a4:	41 bd fb ff ff ff    	mov    $0xfffffffb,%r13d
    55aa:	e9 9f f5 ff ff       	jmpq   4b4e <e1000_probe+0x3ee>
			e_err(probe, "EEPROM Read Error\n");
	}
	/* don't block initialization here due to bad MAC address */
	memcpy(netdev->dev_addr, hw->mac_addr, netdev->addr_len);
	if (!is_valid_ether_addr(netdev->dev_addr))
		e_err(probe, "Invalid MAC Address\n");
    55af:	49 8b bf f0 0b 00 00 	mov    0xbf0(%r15),%rdi
    55b6:	48 c7 c6 00 00 00 00 	mov    $0x0,%rsi
    55bd:	31 c0                	xor    %eax,%eax
    55bf:	e8 00 00 00 00       	callq  55c4 <e1000_probe+0xe64>
    55c4:	e9 ec f9 ff ff       	jmpq   4fb5 <e1000_probe+0x855>
		if (global_quad_port_a != 0)
			adapter->eeprom_wol = 0;
		else
			adapter->quad_port_a = true;
		/* Reset for multiple quad port adapters */
		if (++global_quad_port_a == 4)
    55c9:	89 05 00 00 00 00    	mov    %eax,0x0(%rip)        # 55cf <e1000_probe+0xe6f>
    55cf:	31 f6                	xor    %esi,%esi
    55d1:	31 c0                	xor    %eax,%eax
    55d3:	e9 e3 fb ff ff       	jmpq   51bb <e1000_probe+0xa5b>
    55d8:	49 8b bf 80 0a 00 00 	mov    0xa80(%r15),%rdi
    55df:	e9 40 fe ff ff       	jmpq   5424 <e1000_probe+0xcc4>

	data = kmalloc(eeprom.len, GFP_KERNEL);
	if (!data)
		return;

	ops->get_eeprom(netdev, &eeprom, data);
    55e4:	48 89 c2             	mov    %rax,%rdx
    55e7:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
    55eb:	48 8d 75 c8          	lea    -0x38(%rbp),%rsi
    55ef:	48 89 cf             	mov    %rcx,%rdi
    55f2:	ff 50 60             	callq  *0x60(%rax)

	csum_old = (data[EEPROM_CHECKSUM_REG * 2]) +
    55f5:	41 0f b6 45 7f       	movzbl 0x7f(%r13),%eax
    55fa:	41 0f b6 55 7e       	movzbl 0x7e(%r13),%edx
    55ff:	c1 e0 08             	shl    $0x8,%eax
    5602:	01 d0                	add    %edx,%eax
	struct net_device *netdev = adapter->netdev;
	struct ethtool_eeprom eeprom;
	const struct ethtool_ops *ops = netdev->ethtool_ops;
	u8 *data;
	int i;
	u16 csum_old, csum_new = 0;
    5604:	31 d2                	xor    %edx,%edx
	if (!data)
		return;

	ops->get_eeprom(netdev, &eeprom, data);

	csum_old = (data[EEPROM_CHECKSUM_REG * 2]) +
    5606:	66 89 45 a8          	mov    %ax,-0x58(%rbp)
    560a:	31 c0                	xor    %eax,%eax
		   (data[EEPROM_CHECKSUM_REG * 2 + 1] << 8);
	for (i = 0; i < EEPROM_CHECKSUM_REG * 2; i += 2)
		csum_new += data[i] + (data[i + 1] << 8);
    560c:	41 0f b6 4c 05 01    	movzbl 0x1(%r13,%rax,1),%ecx
    5612:	41 0f b6 74 05 00    	movzbl 0x0(%r13,%rax,1),%esi
    5618:	48 83 c0 02          	add    $0x2,%rax
    561c:	c1 e1 08             	shl    $0x8,%ecx
    561f:	01 f1                	add    %esi,%ecx
    5621:	01 ca                	add    %ecx,%edx

	ops->get_eeprom(netdev, &eeprom, data);

	csum_old = (data[EEPROM_CHECKSUM_REG * 2]) +
		   (data[EEPROM_CHECKSUM_REG * 2 + 1] << 8);
	for (i = 0; i < EEPROM_CHECKSUM_REG * 2; i += 2)
    5623:	48 83 f8 7e          	cmp    $0x7e,%rax
    5627:	75 e3                	jne    560c <e1000_probe+0xeac>
		csum_new += data[i] + (data[i + 1] << 8);
	csum_new = EEPROM_SUM - csum_new;

	pr_err("/*********************/\n");
    5629:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
    5630:	31 c0                	xor    %eax,%eax
    5632:	89 55 a0             	mov    %edx,-0x60(%rbp)
    5635:	e8 00 00 00 00       	callq  563a <e1000_probe+0xeda>
	pr_err("Current EEPROM Checksum : 0x%04x\n", csum_old);
    563a:	0f b7 75 a8          	movzwl -0x58(%rbp),%esi
    563e:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
    5645:	31 c0                	xor    %eax,%eax
    5647:	e8 00 00 00 00       	callq  564c <e1000_probe+0xeec>

	csum_old = (data[EEPROM_CHECKSUM_REG * 2]) +
		   (data[EEPROM_CHECKSUM_REG * 2 + 1] << 8);
	for (i = 0; i < EEPROM_CHECKSUM_REG * 2; i += 2)
		csum_new += data[i] + (data[i + 1] << 8);
	csum_new = EEPROM_SUM - csum_new;
    564c:	8b 55 a0             	mov    -0x60(%rbp),%edx
    564f:	b8 ba ba ff ff       	mov    $0xffffbaba,%eax

	pr_err("/*********************/\n");
	pr_err("Current EEPROM Checksum : 0x%04x\n", csum_old);
	pr_err("Calculated              : 0x%04x\n", csum_new);
    5654:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi

	csum_old = (data[EEPROM_CHECKSUM_REG * 2]) +
		   (data[EEPROM_CHECKSUM_REG * 2 + 1] << 8);
	for (i = 0; i < EEPROM_CHECKSUM_REG * 2; i += 2)
		csum_new += data[i] + (data[i + 1] << 8);
	csum_new = EEPROM_SUM - csum_new;
    565b:	29 d0                	sub    %edx,%eax

	pr_err("/*********************/\n");
	pr_err("Current EEPROM Checksum : 0x%04x\n", csum_old);
	pr_err("Calculated              : 0x%04x\n", csum_new);
    565d:	0f b7 f0             	movzwl %ax,%esi
    5660:	31 c0                	xor    %eax,%eax
    5662:	e8 00 00 00 00       	callq  5667 <e1000_probe+0xf07>

	pr_err("Offset    Values\n");
    5667:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
    566e:	31 c0                	xor    %eax,%eax
    5670:	e8 00 00 00 00       	callq  5675 <e1000_probe+0xf15>
	pr_err("========  ======\n");
    5675:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
    567c:	31 c0                	xor    %eax,%eax
    567e:	e8 00 00 00 00       	callq  5683 <e1000_probe+0xf23>
	print_hex_dump(KERN_ERR, "", DUMP_PREFIX_OFFSET, 16, 1, data, 128, 0);
    5683:	4d 89 e9             	mov    %r13,%r9
    5686:	41 b8 01 00 00 00    	mov    $0x1,%r8d
    568c:	b9 10 00 00 00       	mov    $0x10,%ecx
    5691:	ba 02 00 00 00       	mov    $0x2,%edx
    5696:	48 c7 c6 00 00 00 00 	mov    $0x0,%rsi
    569d:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%rsp)
    56a4:	00 
    56a5:	48 c7 04 24 80 00 00 	movq   $0x80,(%rsp)
    56ac:	00 
    56ad:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
    56b4:	e8 00 00 00 00       	callq  56b9 <e1000_probe+0xf59>

	pr_err("Include this output when contacting your support provider.\n");
    56b9:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
    56c0:	31 c0                	xor    %eax,%eax
    56c2:	e8 00 00 00 00       	callq  56c7 <e1000_probe+0xf67>
	pr_err("This is not a software error! Something bad happened to\n");
    56c7:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
    56ce:	31 c0                	xor    %eax,%eax
    56d0:	e8 00 00 00 00       	callq  56d5 <e1000_probe+0xf75>
	pr_err("your hardware or EEPROM image. Ignoring this problem could\n");
    56d5:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
    56dc:	31 c0                	xor    %eax,%eax
    56de:	e8 00 00 00 00       	callq  56e3 <e1000_probe+0xf83>
	pr_err("result in further problems, possibly loss of data,\n");
    56e3:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
    56ea:	31 c0                	xor    %eax,%eax
    56ec:	e8 00 00 00 00       	callq  56f1 <e1000_probe+0xf91>
	pr_err("corruption or system hangs!\n");
    56f1:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
    56f8:	31 c0                	xor    %eax,%eax
    56fa:	e8 00 00 00 00       	callq  56ff <e1000_probe+0xf9f>
	pr_err("The MAC Address will be reset to 00:00:00:00:00:00,\n");
    56ff:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
    5706:	31 c0                	xor    %eax,%eax
    5708:	e8 00 00 00 00       	callq  570d <e1000_probe+0xfad>
	pr_err("which is invalid and requires you to set the proper MAC\n");
    570d:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
    5714:	31 c0                	xor    %eax,%eax
    5716:	e8 00 00 00 00       	callq  571b <e1000_probe+0xfbb>
	pr_err("address manually before continuing to enable this network\n");
    571b:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
    5722:	31 c0                	xor    %eax,%eax
    5724:	e8 00 00 00 00       	callq  5729 <e1000_probe+0xfc9>
	pr_err("device. Please inspect the EEPROM dump and report the\n");
    5729:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
    5730:	31 c0                	xor    %eax,%eax
    5732:	e8 00 00 00 00       	callq  5737 <e1000_probe+0xfd7>
	pr_err("issue to your hardware vendor or Intel Customer Support.\n");
    5737:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
    573e:	31 c0                	xor    %eax,%eax
    5740:	e8 00 00 00 00       	callq  5745 <e1000_probe+0xfe5>
	pr_err("/*********************/\n");
    5745:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
    574c:	31 c0                	xor    %eax,%eax
    574e:	e8 00 00 00 00       	callq  5753 <e1000_probe+0xff3>

	kfree(data);
    5753:	4c 89 ef             	mov    %r13,%rdi
    5756:	e8 00 00 00 00       	callq  575b <e1000_probe+0xffb>
    575b:	e9 eb fd ff ff       	jmpq   554b <e1000_probe+0xdeb>
static int print_dev_resource(struct pci_dev *pdev)
{
	int i;

	if(!pdev){
		printk("pdev is NULL\n");
    5760:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
    5767:	31 c0                	xor    %eax,%eax
    5769:	e8 00 00 00 00       	callq  576e <e1000_probe+0x100e>
    576e:	e9 4c f0 ff ff       	jmpq   47bf <e1000_probe+0x5f>
		eeprom_apme_mask = E1000_EEPROM_82544_APM;
		break;
	case e1000_82546:
	case e1000_82546_rev_3:
		if (er32(STATUS) & E1000_STATUS_FUNC_1){
			e1000_read_eeprom(hw,
    5773:	48 8b 7d b8          	mov    -0x48(%rbp),%rdi
    5777:	48 8d 4d c4          	lea    -0x3c(%rbp),%rcx
    577b:	ba 01 00 00 00       	mov    $0x1,%edx
    5780:	be 14 00 00 00       	mov    $0x14,%esi
    5785:	e8 00 00 00 00       	callq  578a <e1000_probe+0x102a>
	static int cards_found = 0;
	static int global_quad_port_a = 0; /* global ksp3 port a indication */
	int i, err, pci_using_dac;
	u16 eeprom_data = 0;
	u16 tmp = 0;
	u16 eeprom_apme_mask = E1000_EEPROM_APME;
    578a:	b8 00 04 00 00       	mov    $0x400,%eax
	case e1000_82546:
	case e1000_82546_rev_3:
		if (er32(STATUS) & E1000_STATUS_FUNC_1){
			e1000_read_eeprom(hw,
				EEPROM_INIT_CONTROL3_PORT_B, 1, &eeprom_data);
			break;
    578f:	e9 be f9 ff ff       	jmpq   5152 <e1000_probe+0x9f2>
    5794:	66 66 66 2e 0f 1f 84 	data32 data32 nopw %cs:0x0(%rax,%rax,1)
    579b:	00 00 00 00 00 

00000000000057a0 <e1000_down>:
	if (!test_bit(__E1000_RESETTING, &adapter->flags))
		cancel_work_sync(&adapter->reset_task);
}

void e1000_down(struct e1000_adapter *adapter)
{
    57a0:	e8 00 00 00 00       	callq  57a5 <e1000_down+0x5>
    57a5:	55                   	push   %rbp
    57a6:	48 89 e5             	mov    %rsp,%rbp
    57a9:	41 57                	push   %r15
    57ab:	41 56                	push   %r14
    57ad:	41 55                	push   %r13
    57af:	41 54                	push   %r12
    57b1:	49 89 fc             	mov    %rdi,%r12
    57b4:	53                   	push   %rbx
    57b5:	48 83 ec 08          	sub    $0x8,%rsp
	struct e1000_hw *hw = &adapter->hw;
	struct net_device *netdev = adapter->netdev;
    57b9:	4c 8b bf b0 03 00 00 	mov    0x3b0(%rdi),%r15
	u32 rctl, tctl;

	netif_carrier_off(netdev);
    57c0:	4c 89 ff             	mov    %r15,%rdi
    57c3:	e8 00 00 00 00       	callq  57c8 <e1000_down+0x28>

	/* disable receives in the hardware */
	rctl = er32(RCTL);
    57c8:	49 8b 84 24 c0 03 00 	mov    0x3c0(%r12),%rax
    57cf:	00 
    57d0:	8b 80 00 01 00 00    	mov    0x100(%rax),%eax
	ew32(RCTL, rctl & ~E1000_RCTL_EN);
    57d6:	49 8b 8c 24 c0 03 00 	mov    0x3c0(%r12),%rcx
    57dd:	00 
    57de:	83 e0 fd             	and    $0xfffffffd,%eax
build_mmio_read(__readw, "w", unsigned short, "=r", )
build_mmio_read(__readl, "l", unsigned int, "=r", )

build_mmio_write(writeb, "b", unsigned char, "q", :"memory")
build_mmio_write(writew, "w", unsigned short, "r", :"memory")
build_mmio_write(writel, "l", unsigned int, "r", :"memory")
    57e1:	89 81 00 01 00 00    	mov    %eax,0x100(%rcx)
 * The various preempt_count add/sub methods
 */

static __always_inline void __preempt_count_add(int val)
{
	raw_cpu_add_4(__preempt_count, val);
    57e7:	65 81 05 00 00 00 00 	addl   $0x200,%gs:0x0(%rip)        # 57f2 <e1000_down+0x52>
    57ee:	00 02 00 00 
	unsigned int i;
	int cpu;

	local_bh_disable();
	cpu = smp_processor_id();
	for (i = 0; i < dev->num_tx_queues; i++) {
    57f2:	41 8b b7 c8 03 00 00 	mov    0x3c8(%r15),%esi
    57f9:	45 31 ed             	xor    %r13d,%r13d
{
	unsigned int i;
	int cpu;

	local_bh_disable();
	cpu = smp_processor_id();
    57fc:	65 8b 05 00 00 00 00 	mov    %gs:0x0(%rip),%eax        # 5803 <e1000_down+0x63>
    5803:	89 45 d4             	mov    %eax,-0x2c(%rbp)
	for (i = 0; i < dev->num_tx_queues; i++) {
    5806:	85 f6                	test   %esi,%esi
    5808:	74 53                	je     585d <e1000_down+0xbd>

static inline
struct netdev_queue *netdev_get_tx_queue(const struct net_device *dev,
					 unsigned int index)
{
	return &dev->_tx[index];
    580a:	44 89 e8             	mov    %r13d,%eax
    580d:	48 8d 1c 40          	lea    (%rax,%rax,2),%rbx
    5811:	48 c1 e3 07          	shl    $0x7,%rbx
    5815:	49 03 9f c0 03 00 00 	add    0x3c0(%r15),%rbx
	raw_spin_lock_init(&(_lock)->rlock);		\
} while (0)

static __always_inline void spin_lock(spinlock_t *lock)
{
	raw_spin_lock(&lock->rlock);
    581c:	4c 8d b3 80 00 00 00 	lea    0x80(%rbx),%r14
    5823:	4c 89 f7             	mov    %r14,%rdi
    5826:	e8 00 00 00 00       	callq  582b <e1000_down+0x8b>
}

static inline void __netif_tx_lock(struct netdev_queue *txq, int cpu)
{
	spin_lock(&txq->_xmit_lock);
	txq->xmit_lock_owner = cpu;
    582b:	8b 45 d4             	mov    -0x2c(%rbp),%eax
    582e:	89 83 84 00 00 00    	mov    %eax,0x84(%rbx)
    5834:	f0 80 8b 98 00 00 00 	lock orb $0x1,0x98(%rbx)
    583b:	01 
	return ok;
}

static inline void __netif_tx_unlock(struct netdev_queue *txq)
{
	txq->xmit_lock_owner = -1;
    583c:	c7 83 84 00 00 00 ff 	movl   $0xffffffff,0x84(%rbx)
    5843:	ff ff ff 
	PVOP_VCALL2(pv_lock_ops.queued_spin_lock_slowpath, lock, val);
}

static __always_inline void pv_queued_spin_unlock(struct qspinlock *lock)
{
	PVOP_VCALLEE1(pv_lock_ops.queued_spin_unlock, lock);
    5846:	4c 89 f7             	mov    %r14,%rdi
    5849:	ff 14 25 00 00 00 00 	callq  *0x0
	unsigned int i;
	int cpu;

	local_bh_disable();
	cpu = smp_processor_id();
	for (i = 0; i < dev->num_tx_queues; i++) {
    5850:	41 83 c5 01          	add    $0x1,%r13d
    5854:	45 3b af c8 03 00 00 	cmp    0x3c8(%r15),%r13d
    585b:	72 ad                	jb     580a <e1000_down+0x6a>
	__local_bh_enable_ip(ip, SOFTIRQ_DISABLE_OFFSET);
}

static inline void local_bh_enable(void)
{
	__local_bh_enable_ip(_THIS_IP_, SOFTIRQ_DISABLE_OFFSET);
    585d:	be 00 02 00 00       	mov    $0x200,%esi
    5862:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
    5869:	e8 00 00 00 00       	callq  586e <e1000_down+0xce>
	/* flush and sleep below */

	netif_tx_disable(netdev);

	/* disable transmits in the hardware */
	tctl = er32(TCTL);
    586e:	49 8b 84 24 c0 03 00 	mov    0x3c0(%r12),%rax
    5875:	00 
{ asm volatile("mov" size " %0,%1": :reg (val), \
"m" (*(volatile type __force *)addr) barrier); }

build_mmio_read(readb, "b", unsigned char, "=q", :"memory")
build_mmio_read(readw, "w", unsigned short, "=r", :"memory")
build_mmio_read(readl, "l", unsigned int, "=r", :"memory")
    5876:	8b 80 00 04 00 00    	mov    0x400(%rax),%eax
	tctl &= ~E1000_TCTL_EN;
    587c:	83 e0 fd             	and    $0xfffffffd,%eax
	ew32(TCTL, tctl);
    587f:	49 8b 94 24 c0 03 00 	mov    0x3c0(%r12),%rdx
    5886:	00 
build_mmio_read(__readw, "w", unsigned short, "=r", )
build_mmio_read(__readl, "l", unsigned int, "=r", )

build_mmio_write(writeb, "b", unsigned char, "q", :"memory")
build_mmio_write(writew, "w", unsigned short, "r", :"memory")
build_mmio_write(writel, "l", unsigned int, "r", :"memory")
    5887:	89 82 00 04 00 00    	mov    %eax,0x400(%rdx)
	/* flush both disables and wait for them to finish */
	E1000_WRITE_FLUSH();
    588d:	49 8b 84 24 c0 03 00 	mov    0x3c0(%r12),%rax
    5894:	00 
{ asm volatile("mov" size " %0,%1": :reg (val), \
"m" (*(volatile type __force *)addr) barrier); }

build_mmio_read(readb, "b", unsigned char, "=q", :"memory")
build_mmio_read(readw, "w", unsigned short, "=r", :"memory")
build_mmio_read(readl, "l", unsigned int, "=r", :"memory")
    5895:	8b 40 08             	mov    0x8(%rax),%eax
	msleep(10);
    5898:	bf 0a 00 00 00       	mov    $0xa,%edi
 **/
static void e1000_clean_all_tx_rings(struct e1000_adapter *adapter)
{
	int i;

	for (i = 0; i < adapter->num_tx_queues; i++)
    589d:	31 db                	xor    %ebx,%ebx
	tctl = er32(TCTL);
	tctl &= ~E1000_TCTL_EN;
	ew32(TCTL, tctl);
	/* flush both disables and wait for them to finish */
	E1000_WRITE_FLUSH();
	msleep(10);
    589f:	e8 00 00 00 00       	callq  58a4 <e1000_down+0x104>

	napi_disable(&adapter->napi);
    58a4:	49 8d bc 24 b0 02 00 	lea    0x2b0(%r12),%rdi
    58ab:	00 
    58ac:	e8 00 00 00 00       	callq  58b1 <e1000_down+0x111>

	e1000_irq_disable(adapter);
    58b1:	4c 89 e7             	mov    %r12,%rdi
    58b4:	e8 67 b0 ff ff       	callq  920 <e1000_irq_disable>

	/* Setting DOWN must be after irq_disable to prevent
	 * a screaming interrupt.  Setting DOWN also prevents
	 * tasks from rescheduling.
	 */
	e1000_down_and_stop(adapter);
    58b9:	4c 89 e7             	mov    %r12,%rdi
    58bc:	e8 ef ad ff ff       	callq  6b0 <e1000_down_and_stop>

	adapter->link_speed = 0;
    58c1:	31 c0                	xor    %eax,%eax
	adapter->link_duplex = 0;
    58c3:	31 d2                	xor    %edx,%edx

	e1000_reset(adapter);
    58c5:	4c 89 e7             	mov    %r12,%rdi
	 * a screaming interrupt.  Setting DOWN also prevents
	 * tasks from rescheduling.
	 */
	e1000_down_and_stop(adapter);

	adapter->link_speed = 0;
    58c8:	66 41 89 84 24 18 02 	mov    %ax,0x218(%r12)
    58cf:	00 00 
	adapter->link_duplex = 0;
    58d1:	66 41 89 94 24 1a 02 	mov    %dx,0x21a(%r12)
    58d8:	00 00 

	e1000_reset(adapter);
    58da:	e8 00 00 00 00       	callq  58df <e1000_down+0x13f>
 **/
static void e1000_clean_all_tx_rings(struct e1000_adapter *adapter)
{
	int i;

	for (i = 0; i < adapter->num_tx_queues; i++)
    58df:	41 8b 8c 24 78 03 00 	mov    0x378(%r12),%ecx
    58e6:	00 
    58e7:	85 c9                	test   %ecx,%ecx
    58e9:	7e 28                	jle    5913 <e1000_down+0x173>
		e1000_clean_tx_ring(adapter, &adapter->tx_ring[i]);
    58eb:	48 63 c3             	movslq %ebx,%rax
    58ee:	4c 89 e7             	mov    %r12,%rdi
 **/
static void e1000_clean_all_tx_rings(struct e1000_adapter *adapter)
{
	int i;

	for (i = 0; i < adapter->num_tx_queues; i++)
    58f1:	83 c3 01             	add    $0x1,%ebx
		e1000_clean_tx_ring(adapter, &adapter->tx_ring[i]);
    58f4:	48 8d 34 40          	lea    (%rax,%rax,2),%rsi
    58f8:	48 c1 e6 04          	shl    $0x4,%rsi
    58fc:	49 03 b4 24 40 02 00 	add    0x240(%r12),%rsi
    5903:	00 
    5904:	e8 47 ce ff ff       	callq  2750 <e1000_clean_tx_ring>
 **/
static void e1000_clean_all_tx_rings(struct e1000_adapter *adapter)
{
	int i;

	for (i = 0; i < adapter->num_tx_queues; i++)
    5909:	41 3b 9c 24 78 03 00 	cmp    0x378(%r12),%ebx
    5910:	00 
    5911:	7c d8                	jl     58eb <e1000_down+0x14b>
	adapter->link_speed = 0;
	adapter->link_duplex = 0;

	e1000_reset(adapter);
	e1000_clean_all_tx_rings(adapter);
	e1000_clean_all_rx_rings(adapter);
    5913:	4c 89 e7             	mov    %r12,%rdi
    5916:	e8 d5 d2 ff ff       	callq  2bf0 <e1000_clean_all_rx_rings>
}
    591b:	48 83 c4 08          	add    $0x8,%rsp
    591f:	5b                   	pop    %rbx
    5920:	41 5c                	pop    %r12
    5922:	41 5d                	pop    %r13
    5924:	41 5e                	pop    %r14
    5926:	41 5f                	pop    %r15
    5928:	5d                   	pop    %rbp
    5929:	c3                   	retq   
    592a:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)

0000000000005930 <e1000_io_error_detected>:
 * This function is called after a PCI bus error affecting
 * this device has been detected.
 */
static pci_ers_result_t e1000_io_error_detected(struct pci_dev *pdev,
						pci_channel_state_t state)
{
    5930:	e8 00 00 00 00       	callq  5935 <e1000_io_error_detected+0x5>
    5935:	55                   	push   %rbp
    5936:	48 89 e5             	mov    %rsp,%rbp
    5939:	41 55                	push   %r13
    593b:	41 89 f5             	mov    %esi,%r13d
    593e:	41 54                	push   %r12
    5940:	49 89 fc             	mov    %rdi,%r12
    5943:	53                   	push   %rbx
 * driver-specific data.  They are really just a wrapper around
 * the generic device structure functions of these calls.
 */
static inline void *pci_get_drvdata(struct pci_dev *pdev)
{
	return dev_get_drvdata(&pdev->dev);
    5944:	48 8b 9f 38 01 00 00 	mov    0x138(%rdi),%rbx
	struct net_device *netdev = pci_get_drvdata(pdev);
	struct e1000_adapter *adapter = netdev_priv(netdev);

	netif_device_detach(netdev);
    594b:	48 89 df             	mov    %rbx,%rdi
    594e:	e8 00 00 00 00       	callq  5953 <e1000_io_error_detected+0x23>

	if (state == pci_channel_io_perm_failure)
    5953:	41 83 fd 03          	cmp    $0x3,%r13d
    5957:	74 2a                	je     5983 <e1000_io_error_detected+0x53>
}

static __always_inline int constant_test_bit(long nr, const volatile unsigned long *addr)
{
	return ((1UL << (nr & (BITS_PER_LONG-1))) &
		(addr[nr >> _BITOPS_LONG_SHIFT])) != 0;
    5959:	48 8b 43 48          	mov    0x48(%rbx),%rax
		return PCI_ERS_RESULT_DISCONNECT;

	if (netif_running(netdev))
    595d:	a8 01                	test   $0x1,%al
    595f:	75 14                	jne    5975 <e1000_io_error_detected+0x45>
		e1000_down(adapter);
	pci_disable_device(pdev);
    5961:	4c 89 e7             	mov    %r12,%rdi
    5964:	e8 00 00 00 00       	callq  5969 <e1000_io_error_detected+0x39>

	/* Request a slot slot reset. */
	return PCI_ERS_RESULT_NEED_RESET;
}
    5969:	5b                   	pop    %rbx
    596a:	41 5c                	pop    %r12
    596c:	41 5d                	pop    %r13
	if (netif_running(netdev))
		e1000_down(adapter);
	pci_disable_device(pdev);

	/* Request a slot slot reset. */
	return PCI_ERS_RESULT_NEED_RESET;
    596e:	b8 03 00 00 00       	mov    $0x3,%eax
}
    5973:	5d                   	pop    %rbp
    5974:	c3                   	retq   
 */
static pci_ers_result_t e1000_io_error_detected(struct pci_dev *pdev,
						pci_channel_state_t state)
{
	struct net_device *netdev = pci_get_drvdata(pdev);
	struct e1000_adapter *adapter = netdev_priv(netdev);
    5975:	48 8d bb 40 08 00 00 	lea    0x840(%rbx),%rdi

	if (state == pci_channel_io_perm_failure)
		return PCI_ERS_RESULT_DISCONNECT;

	if (netif_running(netdev))
		e1000_down(adapter);
    597c:	e8 00 00 00 00       	callq  5981 <e1000_io_error_detected+0x51>
    5981:	eb de                	jmp    5961 <e1000_io_error_detected+0x31>
	pci_disable_device(pdev);

	/* Request a slot slot reset. */
	return PCI_ERS_RESULT_NEED_RESET;
}
    5983:	5b                   	pop    %rbx
    5984:	41 5c                	pop    %r12
    5986:	41 5d                	pop    %r13
	struct e1000_adapter *adapter = netdev_priv(netdev);

	netif_device_detach(netdev);

	if (state == pci_channel_io_perm_failure)
		return PCI_ERS_RESULT_DISCONNECT;
    5988:	b8 04 00 00 00       	mov    $0x4,%eax
		e1000_down(adapter);
	pci_disable_device(pdev);

	/* Request a slot slot reset. */
	return PCI_ERS_RESULT_NEED_RESET;
}
    598d:	5d                   	pop    %rbp
    598e:	c3                   	retq   
    598f:	90                   	nop

0000000000005990 <e1000_setup_all_tx_resources>:
 * @adapter: board private structure
 *
 * Return 0 on success, negative on failure
 **/
int e1000_setup_all_tx_resources(struct e1000_adapter *adapter)
{
    5990:	e8 00 00 00 00       	callq  5995 <e1000_setup_all_tx_resources+0x5>
    5995:	55                   	push   %rbp
    5996:	48 89 e5             	mov    %rsp,%rbp
    5999:	41 57                	push   %r15
    599b:	41 56                	push   %r14
    599d:	41 55                	push   %r13
    599f:	41 54                	push   %r12
    59a1:	53                   	push   %rbx
    59a2:	48 89 fb             	mov    %rdi,%rbx
    59a5:	48 83 ec 48          	sub    $0x48,%rsp
	int i, err = 0;

	for (i = 0; i < adapter->num_tx_queues; i++) {
    59a9:	8b 87 78 03 00 00    	mov    0x378(%rdi),%eax
    59af:	c7 45 bc 00 00 00 00 	movl   $0x0,-0x44(%rbp)
    59b6:	85 c0                	test   %eax,%eax
    59b8:	7f 41                	jg     59fb <e1000_setup_all_tx_resources+0x6b>
    59ba:	e9 0d 04 00 00       	jmpq   5dcc <e1000_setup_all_tx_resources+0x43c>

	/* First rev 82545 and 82546 need to not allow any memory
	 * write location to cross 64k boundary due to errata 23
	 */
	if (hw->mac_type == e1000_82545 ||
	    hw->mac_type == e1000_ce4100 ||
    59bf:	83 e8 08             	sub    $0x8,%eax
    59c2:	4c 89 d7             	mov    %r10,%rdi
    59c5:	83 f8 01             	cmp    $0x1,%eax
    59c8:	0f 86 0f 01 00 00    	jbe    5add <e1000_setup_all_tx_resources+0x14d>
			/* Free old allocation, new allocation was successful */
			dma_free_coherent(&pdev->dev, txdr->size, olddesc,
					  olddma);
		}
	}
	memset(txdr->desc, 0, txdr->size);
    59ce:	31 f6                	xor    %esi,%esi
    59d0:	4c 89 da             	mov    %r11,%rdx
    59d3:	e8 00 00 00 00       	callq  59d8 <e1000_setup_all_tx_resources+0x48>
 **/
int e1000_setup_all_tx_resources(struct e1000_adapter *adapter)
{
	int i, err = 0;

	for (i = 0; i < adapter->num_tx_queues; i++) {
    59d8:	83 45 bc 01          	addl   $0x1,-0x44(%rbp)
					  olddma);
		}
	}
	memset(txdr->desc, 0, txdr->size);

	txdr->next_to_use = 0;
    59dc:	41 c7 46 18 00 00 00 	movl   $0x0,0x18(%r14)
    59e3:	00 
	txdr->next_to_clean = 0;
    59e4:	41 c7 46 1c 00 00 00 	movl   $0x0,0x1c(%r14)
    59eb:	00 
 **/
int e1000_setup_all_tx_resources(struct e1000_adapter *adapter)
{
	int i, err = 0;

	for (i = 0; i < adapter->num_tx_queues; i++) {
    59ec:	8b 45 bc             	mov    -0x44(%rbp),%eax
    59ef:	39 83 78 03 00 00    	cmp    %eax,0x378(%rbx)
    59f5:	0f 8e d1 03 00 00    	jle    5dcc <e1000_setup_all_tx_resources+0x43c>
		err = e1000_setup_tx_resources(adapter, &adapter->tx_ring[i]);
    59fb:	48 63 45 bc          	movslq -0x44(%rbp),%rax
 * Return 0 on success, negative on failure
 **/
static int e1000_setup_tx_resources(struct e1000_adapter *adapter,
				    struct e1000_tx_ring *txdr)
{
	struct pci_dev *pdev = adapter->pdev;
    59ff:	4c 8b ab b8 03 00 00 	mov    0x3b8(%rbx),%r13
int e1000_setup_all_tx_resources(struct e1000_adapter *adapter)
{
	int i, err = 0;

	for (i = 0; i < adapter->num_tx_queues; i++) {
		err = e1000_setup_tx_resources(adapter, &adapter->tx_ring[i]);
    5a06:	4c 8d 34 40          	lea    (%rax,%rax,2),%r14
    5a0a:	49 c1 e6 04          	shl    $0x4,%r14
    5a0e:	4c 03 b3 40 02 00 00 	add    0x240(%rbx),%r14
				    struct e1000_tx_ring *txdr)
{
	struct pci_dev *pdev = adapter->pdev;
	int size;

	size = sizeof(struct e1000_tx_buffer) * txdr->count;
    5a15:	41 8b 46 14          	mov    0x14(%r14),%eax
    5a19:	8d 3c 80             	lea    (%rax,%rax,4),%edi
    5a1c:	c1 e7 03             	shl    $0x3,%edi
	txdr->buffer_info = vzalloc(size);
    5a1f:	48 63 ff             	movslq %edi,%rdi
    5a22:	e8 00 00 00 00       	callq  5a27 <e1000_setup_all_tx_resources+0x97>
	if (!txdr->buffer_info)
    5a27:	48 85 c0             	test   %rax,%rax
{
	struct pci_dev *pdev = adapter->pdev;
	int size;

	size = sizeof(struct e1000_tx_buffer) * txdr->count;
	txdr->buffer_info = vzalloc(size);
    5a2a:	49 89 46 20          	mov    %rax,0x20(%r14)
	if (!txdr->buffer_info)
    5a2e:	0f 84 c9 02 00 00    	je     5cfd <e1000_setup_all_tx_resources+0x36d>
		return -ENOMEM;

	/* round up to nearest 4K */

	txdr->size = txdr->count * sizeof(struct e1000_tx_desc);
    5a34:	41 8b 46 14          	mov    0x14(%r14),%eax
	txdr->size = ALIGN(txdr->size, 4096);

	txdr->desc = dma_alloc_coherent(&pdev->dev, txdr->size, &txdr->dma,
    5a38:	4d 8d a5 98 00 00 00 	lea    0x98(%r13),%r12
    5a3f:	4d 8d 7e 08          	lea    0x8(%r14),%r15
    5a43:	c7 45 c0 c0 00 40 02 	movl   $0x24000c0,-0x40(%rbp)
    5a4a:	4c 89 65 c8          	mov    %r12,-0x38(%rbp)
	if (!txdr->buffer_info)
		return -ENOMEM;

	/* round up to nearest 4K */

	txdr->size = txdr->count * sizeof(struct e1000_tx_desc);
    5a4e:	c1 e0 04             	shl    $0x4,%eax
	txdr->size = ALIGN(txdr->size, 4096);
    5a51:	05 ff 0f 00 00       	add    $0xfff,%eax
    5a56:	25 00 f0 ff ff       	and    $0xfffff000,%eax
static inline struct dma_map_ops *get_dma_ops(struct device *dev)
{
#ifndef CONFIG_X86_DEV_DMA_OPS
	return dma_ops;
#else
	if (unlikely(!dev) || !dev->archdata.dma_ops)
    5a5b:	4d 85 e4             	test   %r12,%r12
    5a5e:	41 89 46 10          	mov    %eax,0x10(%r14)

	txdr->desc = dma_alloc_coherent(&pdev->dev, txdr->size, &txdr->dma,
    5a62:	48 89 45 a8          	mov    %rax,-0x58(%rbp)
    5a66:	0f 84 6f 02 00 00    	je     5cdb <e1000_setup_all_tx_resources+0x34b>
    5a6c:	49 8b 95 e8 02 00 00 	mov    0x2e8(%r13),%rdx
    5a73:	48 85 d2             	test   %rdx,%rdx
    5a76:	0f 84 5f 02 00 00    	je     5cdb <e1000_setup_all_tx_resources+0x34b>
	BUG_ON(!ops);

	if (dma_alloc_from_coherent(dev, size, dma_handle, &cpu_addr))
		return cpu_addr;

	if (!arch_dma_alloc_attrs(&dev, &flag))
    5a7c:	48 8d 75 c0          	lea    -0x40(%rbp),%rsi
    5a80:	48 8d 7d c8          	lea    -0x38(%rbp),%rdi
    5a84:	48 89 55 b0          	mov    %rdx,-0x50(%rbp)
    5a88:	e8 00 00 00 00       	callq  5a8d <e1000_setup_all_tx_resources+0xfd>
    5a8d:	84 c0                	test   %al,%al
    5a8f:	0f 84 58 02 00 00    	je     5ced <e1000_setup_all_tx_resources+0x35d>
		return NULL;
	if (!ops->alloc)
    5a95:	48 8b 55 b0          	mov    -0x50(%rbp),%rdx
    5a99:	48 8b 02             	mov    (%rdx),%rax
    5a9c:	48 85 c0             	test   %rax,%rax
    5a9f:	0f 84 48 02 00 00    	je     5ced <e1000_setup_all_tx_resources+0x35d>
		return NULL;

	cpu_addr = ops->alloc(dev, size, dma_handle, flag, attrs);
    5aa5:	45 31 c0             	xor    %r8d,%r8d
    5aa8:	8b 4d c0             	mov    -0x40(%rbp),%ecx
    5aab:	4c 89 fa             	mov    %r15,%rdx
    5aae:	48 8b 75 a8          	mov    -0x58(%rbp),%rsi
    5ab2:	48 8b 7d c8          	mov    -0x38(%rbp),%rdi
    5ab6:	ff d0                	callq  *%rax
					GFP_KERNEL);
	if (!txdr->desc) {
    5ab8:	48 85 c0             	test   %rax,%rax
    5abb:	49 89 c2             	mov    %rax,%r10
	/* round up to nearest 4K */

	txdr->size = txdr->count * sizeof(struct e1000_tx_desc);
	txdr->size = ALIGN(txdr->size, 4096);

	txdr->desc = dma_alloc_coherent(&pdev->dev, txdr->size, &txdr->dma,
    5abe:	49 89 06             	mov    %rax,(%r14)
					GFP_KERNEL);
	if (!txdr->desc) {
    5ac1:	0f 84 2d 02 00 00    	je     5cf4 <e1000_setup_all_tx_resources+0x364>
	unsigned long end = begin + len;

	/* First rev 82545 and 82546 need to not allow any memory
	 * write location to cross 64k boundary due to errata 23
	 */
	if (hw->mac_type == e1000_82545 ||
    5ac7:	8b 83 d8 03 00 00    	mov    0x3d8(%rbx),%eax
		vfree(txdr->buffer_info);
		return -ENOMEM;
	}

	/* Fix for errata 23, can't cross 64kB boundary */
	if (!e1000_check_64k_bound(adapter, txdr->desc, txdr->size)) {
    5acd:	41 8b 56 10          	mov    0x10(%r14),%edx
	unsigned long end = begin + len;

	/* First rev 82545 and 82546 need to not allow any memory
	 * write location to cross 64k boundary due to errata 23
	 */
	if (hw->mac_type == e1000_82545 ||
    5ad1:	83 f8 06             	cmp    $0x6,%eax
		vfree(txdr->buffer_info);
		return -ENOMEM;
	}

	/* Fix for errata 23, can't cross 64kB boundary */
	if (!e1000_check_64k_bound(adapter, txdr->desc, txdr->size)) {
    5ad4:	41 89 d3             	mov    %edx,%r11d
	unsigned long end = begin + len;

	/* First rev 82545 and 82546 need to not allow any memory
	 * write location to cross 64k boundary due to errata 23
	 */
	if (hw->mac_type == e1000_82545 ||
    5ad7:	0f 85 e2 fe ff ff    	jne    59bf <e1000_setup_all_tx_resources+0x2f>
	    hw->mac_type == e1000_ce4100 ||
	    hw->mac_type == e1000_82546) {
		return ((begin ^ (end - 1)) >> 16) != 0 ? false : true;
    5add:	4b 8d 44 1a ff       	lea    -0x1(%r10,%r11,1),%rax
    5ae2:	4c 31 d0             	xor    %r10,%rax
    5ae5:	48 c1 e8 10          	shr    $0x10,%rax
		vfree(txdr->buffer_info);
		return -ENOMEM;
	}

	/* Fix for errata 23, can't cross 64kB boundary */
	if (!e1000_check_64k_bound(adapter, txdr->desc, txdr->size)) {
    5ae9:	48 85 c0             	test   %rax,%rax
    5aec:	0f 84 d7 03 00 00    	je     5ec9 <e1000_setup_all_tx_resources+0x539>
		void *olddesc = txdr->desc;
		dma_addr_t olddma = txdr->dma;
		e_err(tx_err, "txdr align check failed: %u bytes at %p\n",
    5af2:	f6 83 a0 07 00 00 80 	testb  $0x80,0x7a0(%rbx)
	}

	/* Fix for errata 23, can't cross 64kB boundary */
	if (!e1000_check_64k_bound(adapter, txdr->desc, txdr->size)) {
		void *olddesc = txdr->desc;
		dma_addr_t olddma = txdr->dma;
    5af9:	49 8b 46 08          	mov    0x8(%r14),%rax
    5afd:	48 89 45 98          	mov    %rax,-0x68(%rbp)
		e_err(tx_err, "txdr align check failed: %u bytes at %p\n",
    5b01:	0f 85 ab 01 00 00    	jne    5cb2 <e1000_setup_all_tx_resources+0x322>
    5b07:	4d 85 e4             	test   %r12,%r12
    5b0a:	4c 89 65 d0          	mov    %r12,-0x30(%rbp)
    5b0e:	c7 45 c4 c0 00 40 02 	movl   $0x24000c0,-0x3c(%rbp)
    5b15:	0f 84 35 02 00 00    	je     5d50 <e1000_setup_all_tx_resources+0x3c0>
    5b1b:	49 8b 95 e8 02 00 00 	mov    0x2e8(%r13),%rdx
    5b22:	48 85 d2             	test   %rdx,%rdx
    5b25:	0f 84 25 02 00 00    	je     5d50 <e1000_setup_all_tx_resources+0x3c0>
	BUG_ON(!ops);

	if (dma_alloc_from_coherent(dev, size, dma_handle, &cpu_addr))
		return cpu_addr;

	if (!arch_dma_alloc_attrs(&dev, &flag))
    5b2b:	48 8d 75 c4          	lea    -0x3c(%rbp),%rsi
    5b2f:	48 8d 7d d0          	lea    -0x30(%rbp),%rdi
    5b33:	4c 89 55 b0          	mov    %r10,-0x50(%rbp)
    5b37:	48 89 55 a8          	mov    %rdx,-0x58(%rbp)
    5b3b:	4c 89 5d a0          	mov    %r11,-0x60(%rbp)
    5b3f:	e8 00 00 00 00       	callq  5b44 <e1000_setup_all_tx_resources+0x1b4>
    5b44:	84 c0                	test   %al,%al
    5b46:	4c 8b 55 b0          	mov    -0x50(%rbp),%r10
    5b4a:	0f 84 24 02 00 00    	je     5d74 <e1000_setup_all_tx_resources+0x3e4>
		return NULL;
	if (!ops->alloc)
    5b50:	48 8b 55 a8          	mov    -0x58(%rbp),%rdx
    5b54:	48 8b 02             	mov    (%rdx),%rax
    5b57:	48 85 c0             	test   %rax,%rax
    5b5a:	0f 84 14 02 00 00    	je     5d74 <e1000_setup_all_tx_resources+0x3e4>
		return NULL;

	cpu_addr = ops->alloc(dev, size, dma_handle, flag, attrs);
    5b60:	4c 8b 5d a0          	mov    -0x60(%rbp),%r11
    5b64:	45 31 c0             	xor    %r8d,%r8d
    5b67:	4c 89 fa             	mov    %r15,%rdx
    5b6a:	8b 4d c4             	mov    -0x3c(%rbp),%ecx
    5b6d:	48 8b 7d d0          	mov    -0x30(%rbp),%rdi
    5b71:	4c 89 de             	mov    %r11,%rsi
    5b74:	ff d0                	callq  *%rax
		      txdr->size, txdr->desc);
		/* Try again, without freeing the previous */
		txdr->desc = dma_alloc_coherent(&pdev->dev, txdr->size,
						&txdr->dma, GFP_KERNEL);
		/* Failed allocation, critical failure */
		if (!txdr->desc) {
    5b76:	48 85 c0             	test   %rax,%rax
    5b79:	48 89 c2             	mov    %rax,%rdx
		void *olddesc = txdr->desc;
		dma_addr_t olddma = txdr->dma;
		e_err(tx_err, "txdr align check failed: %u bytes at %p\n",
		      txdr->size, txdr->desc);
		/* Try again, without freeing the previous */
		txdr->desc = dma_alloc_coherent(&pdev->dev, txdr->size,
    5b7c:	49 89 06             	mov    %rax,(%r14)
						&txdr->dma, GFP_KERNEL);
		/* Failed allocation, critical failure */
		if (!txdr->desc) {
    5b7f:	4c 8b 55 b0          	mov    -0x50(%rbp),%r10
    5b83:	0f 84 f2 01 00 00    	je     5d7b <e1000_setup_all_tx_resources+0x3eb>
	unsigned long end = begin + len;

	/* First rev 82545 and 82546 need to not allow any memory
	 * write location to cross 64k boundary due to errata 23
	 */
	if (hw->mac_type == e1000_82545 ||
    5b89:	8b 83 d8 03 00 00    	mov    0x3d8(%rbx),%eax
			dma_free_coherent(&pdev->dev, txdr->size, olddesc,
					  olddma);
			goto setup_tx_desc_die;
		}

		if (!e1000_check_64k_bound(adapter, txdr->desc, txdr->size)) {
    5b8f:	45 8b 7e 10          	mov    0x10(%r14),%r15d
	unsigned long end = begin + len;

	/* First rev 82545 and 82546 need to not allow any memory
	 * write location to cross 64k boundary due to errata 23
	 */
	if (hw->mac_type == e1000_82545 ||
    5b93:	83 f8 06             	cmp    $0x6,%eax
    5b96:	74 58                	je     5bf0 <e1000_setup_all_tx_resources+0x260>
	    hw->mac_type == e1000_ce4100 ||
    5b98:	83 e8 08             	sub    $0x8,%eax
    5b9b:	83 f8 01             	cmp    $0x1,%eax
    5b9e:	76 50                	jbe    5bf0 <e1000_setup_all_tx_resources+0x260>
    5ba0:	4d 85 e4             	test   %r12,%r12
    5ba3:	0f 84 b9 01 00 00    	je     5d62 <e1000_setup_all_tx_resources+0x3d2>
    5ba9:	4d 8b ad e8 02 00 00 	mov    0x2e8(%r13),%r13
    5bb0:	4d 85 ed             	test   %r13,%r13
    5bb3:	0f 84 a9 01 00 00    	je     5d62 <e1000_setup_all_tx_resources+0x3d2>
#define __PV_IS_CALLEE_SAVE(func)			\
	((struct paravirt_callee_save) { func })

static inline notrace unsigned long arch_local_save_flags(void)
{
	return PVOP_CALLEE0(unsigned long, pv_irq_ops.save_fl);
    5bb9:	ff 14 25 00 00 00 00 	callq  *0x0
				     struct dma_attrs *attrs)
{
	struct dma_map_ops *ops = get_dma_ops(dev);

	BUG_ON(!ops);
	WARN_ON(irqs_disabled());
    5bc0:	f6 c4 02             	test   $0x2,%ah
    5bc3:	0f 84 70 02 00 00    	je     5e39 <e1000_setup_all_tx_resources+0x4a9>

	if (dma_release_from_coherent(dev, get_order(size), cpu_addr))
		return;

	if (!ops->free)
    5bc9:	49 8b 45 08          	mov    0x8(%r13),%rax
    5bcd:	48 85 c0             	test   %rax,%rax
    5bd0:	74 12                	je     5be4 <e1000_setup_all_tx_resources+0x254>
		return;

	debug_dma_free_coherent(dev, size, cpu_addr, dma_handle);
	ops->free(dev, size, cpu_addr, dma_handle, attrs);
    5bd2:	45 31 c0             	xor    %r8d,%r8d
    5bd5:	48 8b 4d 98          	mov    -0x68(%rbp),%rcx
    5bd9:	4c 89 d2             	mov    %r10,%rdx
    5bdc:	4c 89 fe             	mov    %r15,%rsi
    5bdf:	4c 89 e7             	mov    %r12,%rdi
    5be2:	ff d0                	callq  *%rax
    5be4:	45 8b 5e 10          	mov    0x10(%r14),%r11d
    5be8:	49 8b 3e             	mov    (%r14),%rdi
    5beb:	e9 de fd ff ff       	jmpq   59ce <e1000_setup_all_tx_resources+0x3e>
	    hw->mac_type == e1000_82546) {
		return ((begin ^ (end - 1)) >> 16) != 0 ? false : true;
    5bf0:	4a 8d 44 3a ff       	lea    -0x1(%rdx,%r15,1),%rax
    5bf5:	48 31 d0             	xor    %rdx,%rax
    5bf8:	48 c1 e8 10          	shr    $0x10,%rax
			dma_free_coherent(&pdev->dev, txdr->size, olddesc,
					  olddma);
			goto setup_tx_desc_die;
		}

		if (!e1000_check_64k_bound(adapter, txdr->desc, txdr->size)) {
    5bfc:	48 85 c0             	test   %rax,%rax
    5bff:	74 9f                	je     5ba0 <e1000_setup_all_tx_resources+0x210>
    5c01:	4d 85 e4             	test   %r12,%r12
			/* give up */
			dma_free_coherent(&pdev->dev, txdr->size, txdr->desc,
    5c04:	49 8b 4e 08          	mov    0x8(%r14),%rcx
    5c08:	0f 84 ec 01 00 00    	je     5dfa <e1000_setup_all_tx_resources+0x46a>
    5c0e:	4d 8b 85 e8 02 00 00 	mov    0x2e8(%r13),%r8
    5c15:	4d 85 c0             	test   %r8,%r8
    5c18:	0f 84 dc 01 00 00    	je     5dfa <e1000_setup_all_tx_resources+0x46a>
    5c1e:	ff 14 25 00 00 00 00 	callq  *0x0
				     struct dma_attrs *attrs)
{
	struct dma_map_ops *ops = get_dma_ops(dev);

	BUG_ON(!ops);
	WARN_ON(irqs_disabled());
    5c25:	f6 c4 02             	test   $0x2,%ah
    5c28:	0f 84 65 02 00 00    	je     5e93 <e1000_setup_all_tx_resources+0x503>

	if (dma_release_from_coherent(dev, get_order(size), cpu_addr))
		return;

	if (!ops->free)
    5c2e:	49 8b 40 08          	mov    0x8(%r8),%rax
    5c32:	48 85 c0             	test   %rax,%rax
    5c35:	74 13                	je     5c4a <e1000_setup_all_tx_resources+0x2ba>
    5c37:	4c 89 55 b0          	mov    %r10,-0x50(%rbp)
		return;

	debug_dma_free_coherent(dev, size, cpu_addr, dma_handle);
	ops->free(dev, size, cpu_addr, dma_handle, attrs);
    5c3b:	45 31 c0             	xor    %r8d,%r8d
    5c3e:	4c 89 fe             	mov    %r15,%rsi
    5c41:	4c 89 e7             	mov    %r12,%rdi
    5c44:	ff d0                	callq  *%rax
    5c46:	4c 8b 55 b0          	mov    -0x50(%rbp),%r10
    5c4a:	4d 85 e4             	test   %r12,%r12
					  txdr->dma);
			dma_free_coherent(&pdev->dev, txdr->size, olddesc,
    5c4d:	45 8b 7e 10          	mov    0x10(%r14),%r15d
    5c51:	0f 84 b8 01 00 00    	je     5e0f <e1000_setup_all_tx_resources+0x47f>
    5c57:	4d 8b ad e8 02 00 00 	mov    0x2e8(%r13),%r13
    5c5e:	4d 85 ed             	test   %r13,%r13
    5c61:	0f 84 a8 01 00 00    	je     5e0f <e1000_setup_all_tx_resources+0x47f>
    5c67:	ff 14 25 00 00 00 00 	callq  *0x0
				     struct dma_attrs *attrs)
{
	struct dma_map_ops *ops = get_dma_ops(dev);

	BUG_ON(!ops);
	WARN_ON(irqs_disabled());
    5c6e:	f6 c4 02             	test   $0x2,%ah
    5c71:	0f 84 e0 01 00 00    	je     5e57 <e1000_setup_all_tx_resources+0x4c7>

	if (dma_release_from_coherent(dev, get_order(size), cpu_addr))
		return;

	if (!ops->free)
    5c77:	49 8b 45 08          	mov    0x8(%r13),%rax
    5c7b:	48 85 c0             	test   %rax,%rax
    5c7e:	74 12                	je     5c92 <e1000_setup_all_tx_resources+0x302>
		return;

	debug_dma_free_coherent(dev, size, cpu_addr, dma_handle);
	ops->free(dev, size, cpu_addr, dma_handle, attrs);
    5c80:	45 31 c0             	xor    %r8d,%r8d
    5c83:	48 8b 4d 98          	mov    -0x68(%rbp),%rcx
    5c87:	4c 89 d2             	mov    %r10,%rdx
    5c8a:	4c 89 fe             	mov    %r15,%rsi
    5c8d:	4c 89 e7             	mov    %r12,%rdi
    5c90:	ff d0                	callq  *%rax
					  olddma);
			e_err(probe, "Unable to allocate aligned memory "
    5c92:	f6 83 a0 07 00 00 02 	testb  $0x2,0x7a0(%rbx)
    5c99:	74 59                	je     5cf4 <e1000_setup_all_tx_resources+0x364>
    5c9b:	48 8b bb b0 03 00 00 	mov    0x3b0(%rbx),%rdi
    5ca2:	48 c7 c6 00 00 00 00 	mov    $0x0,%rsi
    5ca9:	31 c0                	xor    %eax,%eax
    5cab:	e8 00 00 00 00       	callq  5cb0 <e1000_setup_all_tx_resources+0x320>
    5cb0:	eb 42                	jmp    5cf4 <e1000_setup_all_tx_resources+0x364>

	/* Fix for errata 23, can't cross 64kB boundary */
	if (!e1000_check_64k_bound(adapter, txdr->desc, txdr->size)) {
		void *olddesc = txdr->desc;
		dma_addr_t olddma = txdr->dma;
		e_err(tx_err, "txdr align check failed: %u bytes at %p\n",
    5cb2:	48 8b bb b0 03 00 00 	mov    0x3b0(%rbx),%rdi
    5cb9:	4c 89 d1             	mov    %r10,%rcx
    5cbc:	48 c7 c6 00 00 00 00 	mov    $0x0,%rsi
    5cc3:	31 c0                	xor    %eax,%eax
    5cc5:	4c 89 55 b0          	mov    %r10,-0x50(%rbp)
    5cc9:	e8 00 00 00 00       	callq  5cce <e1000_setup_all_tx_resources+0x33e>
    5cce:	45 8b 5e 10          	mov    0x10(%r14),%r11d
    5cd2:	4c 8b 55 b0          	mov    -0x50(%rbp),%r10
    5cd6:	e9 2c fe ff ff       	jmpq   5b07 <e1000_setup_all_tx_resources+0x177>
		return dma_ops;
    5cdb:	48 8b 15 00 00 00 00 	mov    0x0(%rip),%rdx        # 5ce2 <e1000_setup_all_tx_resources+0x352>
				       struct dma_attrs *attrs)
{
	struct dma_map_ops *ops = get_dma_ops(dev);
	void *cpu_addr;

	BUG_ON(!ops);
    5ce2:	48 85 d2             	test   %rdx,%rdx
    5ce5:	0f 85 91 fd ff ff    	jne    5a7c <e1000_setup_all_tx_resources+0xec>
    5ceb:	0f 0b                	ud2    
	/* round up to nearest 4K */

	txdr->size = txdr->count * sizeof(struct e1000_tx_desc);
	txdr->size = ALIGN(txdr->size, 4096);

	txdr->desc = dma_alloc_coherent(&pdev->dev, txdr->size, &txdr->dma,
    5ced:	49 c7 06 00 00 00 00 	movq   $0x0,(%r14)
					  txdr->dma);
			dma_free_coherent(&pdev->dev, txdr->size, olddesc,
					  olddma);
			e_err(probe, "Unable to allocate aligned memory "
			      "for the transmit descriptor ring\n");
			vfree(txdr->buffer_info);
    5cf4:	49 8b 7e 20          	mov    0x20(%r14),%rdi
    5cf8:	e8 00 00 00 00       	callq  5cfd <e1000_setup_all_tx_resources+0x36d>
	int i, err = 0;

	for (i = 0; i < adapter->num_tx_queues; i++) {
		err = e1000_setup_tx_resources(adapter, &adapter->tx_ring[i]);
		if (err) {
			e_err(probe, "Allocation for Tx Queue %u failed\n", i);
    5cfd:	f6 83 a0 07 00 00 02 	testb  $0x2,0x7a0(%rbx)
    5d04:	0f 85 d3 00 00 00    	jne    5ddd <e1000_setup_all_tx_resources+0x44d>
			for (i-- ; i >= 0; i--)
    5d0a:	44 8b 75 bc          	mov    -0x44(%rbp),%r14d
    5d0e:	41 83 ee 01          	sub    $0x1,%r14d
    5d12:	41 83 fe ff          	cmp    $0xffffffff,%r14d
    5d16:	74 24                	je     5d3c <e1000_setup_all_tx_resources+0x3ac>
				e1000_free_tx_resources(adapter,
    5d18:	49 63 c6             	movslq %r14d,%rax
    5d1b:	48 89 df             	mov    %rbx,%rdi

	for (i = 0; i < adapter->num_tx_queues; i++) {
		err = e1000_setup_tx_resources(adapter, &adapter->tx_ring[i]);
		if (err) {
			e_err(probe, "Allocation for Tx Queue %u failed\n", i);
			for (i-- ; i >= 0; i--)
    5d1e:	41 83 ee 01          	sub    $0x1,%r14d
				e1000_free_tx_resources(adapter,
							&adapter->tx_ring[i]);
    5d22:	48 8d 34 40          	lea    (%rax,%rax,2),%rsi
    5d26:	48 c1 e6 04          	shl    $0x4,%rsi
	for (i = 0; i < adapter->num_tx_queues; i++) {
		err = e1000_setup_tx_resources(adapter, &adapter->tx_ring[i]);
		if (err) {
			e_err(probe, "Allocation for Tx Queue %u failed\n", i);
			for (i-- ; i >= 0; i--)
				e1000_free_tx_resources(adapter,
    5d2a:	48 03 b3 40 02 00 00 	add    0x240(%rbx),%rsi
    5d31:	e8 ca e5 ff ff       	callq  4300 <e1000_free_tx_resources>

	for (i = 0; i < adapter->num_tx_queues; i++) {
		err = e1000_setup_tx_resources(adapter, &adapter->tx_ring[i]);
		if (err) {
			e_err(probe, "Allocation for Tx Queue %u failed\n", i);
			for (i-- ; i >= 0; i--)
    5d36:	41 83 fe ff          	cmp    $0xffffffff,%r14d
    5d3a:	75 dc                	jne    5d18 <e1000_setup_all_tx_resources+0x388>
			break;
		}
	}

	return err;
}
    5d3c:	48 83 c4 48          	add    $0x48,%rsp

	/* First rev 82545 and 82546 need to not allow any memory
	 * write location to cross 64k boundary due to errata 23
	 */
	if (hw->mac_type == e1000_82545 ||
	    hw->mac_type == e1000_ce4100 ||
    5d40:	b8 f4 ff ff ff       	mov    $0xfffffff4,%eax
			break;
		}
	}

	return err;
}
    5d45:	5b                   	pop    %rbx
    5d46:	41 5c                	pop    %r12
    5d48:	41 5d                	pop    %r13
    5d4a:	41 5e                	pop    %r14
    5d4c:	41 5f                	pop    %r15
    5d4e:	5d                   	pop    %rbp
    5d4f:	c3                   	retq   
    5d50:	48 8b 15 00 00 00 00 	mov    0x0(%rip),%rdx        # 5d57 <e1000_setup_all_tx_resources+0x3c7>
    5d57:	48 85 d2             	test   %rdx,%rdx
    5d5a:	0f 85 cb fd ff ff    	jne    5b2b <e1000_setup_all_tx_resources+0x19b>
    5d60:	eb 89                	jmp    5ceb <e1000_setup_all_tx_resources+0x35b>
    5d62:	4c 8b 2d 00 00 00 00 	mov    0x0(%rip),%r13        # 5d69 <e1000_setup_all_tx_resources+0x3d9>
				     void *cpu_addr, dma_addr_t dma_handle,
				     struct dma_attrs *attrs)
{
	struct dma_map_ops *ops = get_dma_ops(dev);

	BUG_ON(!ops);
    5d69:	4d 85 ed             	test   %r13,%r13
    5d6c:	0f 85 47 fe ff ff    	jne    5bb9 <e1000_setup_all_tx_resources+0x229>
    5d72:	0f 0b                	ud2    
		void *olddesc = txdr->desc;
		dma_addr_t olddma = txdr->dma;
		e_err(tx_err, "txdr align check failed: %u bytes at %p\n",
		      txdr->size, txdr->desc);
		/* Try again, without freeing the previous */
		txdr->desc = dma_alloc_coherent(&pdev->dev, txdr->size,
    5d74:	49 c7 06 00 00 00 00 	movq   $0x0,(%r14)
static inline struct dma_map_ops *get_dma_ops(struct device *dev)
{
#ifndef CONFIG_X86_DEV_DMA_OPS
	return dma_ops;
#else
	if (unlikely(!dev) || !dev->archdata.dma_ops)
    5d7b:	4d 85 e4             	test   %r12,%r12
						&txdr->dma, GFP_KERNEL);
		/* Failed allocation, critical failure */
		if (!txdr->desc) {
			dma_free_coherent(&pdev->dev, txdr->size, olddesc,
    5d7e:	45 8b 7e 10          	mov    0x10(%r14),%r15d
    5d82:	0f 84 9c 00 00 00    	je     5e24 <e1000_setup_all_tx_resources+0x494>
    5d88:	4d 8b ad e8 02 00 00 	mov    0x2e8(%r13),%r13
    5d8f:	4d 85 ed             	test   %r13,%r13
    5d92:	0f 84 8c 00 00 00    	je     5e24 <e1000_setup_all_tx_resources+0x494>
    5d98:	ff 14 25 00 00 00 00 	callq  *0x0
	WARN_ON(irqs_disabled());
    5d9f:	f6 c4 02             	test   $0x2,%ah
    5da2:	0f 84 cd 00 00 00    	je     5e75 <e1000_setup_all_tx_resources+0x4e5>

	if (dma_release_from_coherent(dev, get_order(size), cpu_addr))
		return;

	if (!ops->free)
    5da8:	49 8b 45 08          	mov    0x8(%r13),%rax
    5dac:	48 85 c0             	test   %rax,%rax
    5daf:	0f 84 3f ff ff ff    	je     5cf4 <e1000_setup_all_tx_resources+0x364>
		return;

	debug_dma_free_coherent(dev, size, cpu_addr, dma_handle);
	ops->free(dev, size, cpu_addr, dma_handle, attrs);
    5db5:	45 31 c0             	xor    %r8d,%r8d
    5db8:	48 8b 4d 98          	mov    -0x68(%rbp),%rcx
    5dbc:	4c 89 d2             	mov    %r10,%rdx
    5dbf:	4c 89 fe             	mov    %r15,%rsi
    5dc2:	4c 89 e7             	mov    %r12,%rdi
    5dc5:	ff d0                	callq  *%rax
    5dc7:	e9 28 ff ff ff       	jmpq   5cf4 <e1000_setup_all_tx_resources+0x364>
			break;
		}
	}

	return err;
}
    5dcc:	48 83 c4 48          	add    $0x48,%rsp
 *
 * Return 0 on success, negative on failure
 **/
int e1000_setup_all_tx_resources(struct e1000_adapter *adapter)
{
	int i, err = 0;
    5dd0:	31 c0                	xor    %eax,%eax
			break;
		}
	}

	return err;
}
    5dd2:	5b                   	pop    %rbx
    5dd3:	41 5c                	pop    %r12
    5dd5:	41 5d                	pop    %r13
    5dd7:	41 5e                	pop    %r14
    5dd9:	41 5f                	pop    %r15
    5ddb:	5d                   	pop    %rbp
    5ddc:	c3                   	retq   
	int i, err = 0;

	for (i = 0; i < adapter->num_tx_queues; i++) {
		err = e1000_setup_tx_resources(adapter, &adapter->tx_ring[i]);
		if (err) {
			e_err(probe, "Allocation for Tx Queue %u failed\n", i);
    5ddd:	48 8b bb b0 03 00 00 	mov    0x3b0(%rbx),%rdi
    5de4:	8b 55 bc             	mov    -0x44(%rbp),%edx
    5de7:	48 c7 c6 00 00 00 00 	mov    $0x0,%rsi
    5dee:	31 c0                	xor    %eax,%eax
    5df0:	e8 00 00 00 00       	callq  5df5 <e1000_setup_all_tx_resources+0x465>
    5df5:	e9 10 ff ff ff       	jmpq   5d0a <e1000_setup_all_tx_resources+0x37a>
		return dma_ops;
    5dfa:	4c 8b 05 00 00 00 00 	mov    0x0(%rip),%r8        # 5e01 <e1000_setup_all_tx_resources+0x471>
				     void *cpu_addr, dma_addr_t dma_handle,
				     struct dma_attrs *attrs)
{
	struct dma_map_ops *ops = get_dma_ops(dev);

	BUG_ON(!ops);
    5e01:	4d 85 c0             	test   %r8,%r8
    5e04:	0f 85 14 fe ff ff    	jne    5c1e <e1000_setup_all_tx_resources+0x28e>
    5e0a:	e9 63 ff ff ff       	jmpq   5d72 <e1000_setup_all_tx_resources+0x3e2>
    5e0f:	4c 8b 2d 00 00 00 00 	mov    0x0(%rip),%r13        # 5e16 <e1000_setup_all_tx_resources+0x486>
    5e16:	4d 85 ed             	test   %r13,%r13
    5e19:	0f 85 48 fe ff ff    	jne    5c67 <e1000_setup_all_tx_resources+0x2d7>
    5e1f:	e9 4e ff ff ff       	jmpq   5d72 <e1000_setup_all_tx_resources+0x3e2>
    5e24:	4c 8b 2d 00 00 00 00 	mov    0x0(%rip),%r13        # 5e2b <e1000_setup_all_tx_resources+0x49b>
    5e2b:	4d 85 ed             	test   %r13,%r13
    5e2e:	0f 85 64 ff ff ff    	jne    5d98 <e1000_setup_all_tx_resources+0x408>
    5e34:	e9 39 ff ff ff       	jmpq   5d72 <e1000_setup_all_tx_resources+0x3e2>
	WARN_ON(irqs_disabled());
    5e39:	be 12 01 00 00       	mov    $0x112,%esi
    5e3e:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
    5e45:	4c 89 55 b0          	mov    %r10,-0x50(%rbp)
    5e49:	e8 00 00 00 00       	callq  5e4e <e1000_setup_all_tx_resources+0x4be>
    5e4e:	4c 8b 55 b0          	mov    -0x50(%rbp),%r10
    5e52:	e9 72 fd ff ff       	jmpq   5bc9 <e1000_setup_all_tx_resources+0x239>
    5e57:	be 12 01 00 00       	mov    $0x112,%esi
    5e5c:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
    5e63:	4c 89 55 b0          	mov    %r10,-0x50(%rbp)
    5e67:	e8 00 00 00 00       	callq  5e6c <e1000_setup_all_tx_resources+0x4dc>
    5e6c:	4c 8b 55 b0          	mov    -0x50(%rbp),%r10
    5e70:	e9 02 fe ff ff       	jmpq   5c77 <e1000_setup_all_tx_resources+0x2e7>
    5e75:	be 12 01 00 00       	mov    $0x112,%esi
    5e7a:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
    5e81:	4c 89 55 b0          	mov    %r10,-0x50(%rbp)
    5e85:	e8 00 00 00 00       	callq  5e8a <e1000_setup_all_tx_resources+0x4fa>
    5e8a:	4c 8b 55 b0          	mov    -0x50(%rbp),%r10
    5e8e:	e9 15 ff ff ff       	jmpq   5da8 <e1000_setup_all_tx_resources+0x418>
    5e93:	be 12 01 00 00       	mov    $0x112,%esi
    5e98:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
    5e9f:	4c 89 45 90          	mov    %r8,-0x70(%rbp)
    5ea3:	48 89 55 a0          	mov    %rdx,-0x60(%rbp)
    5ea7:	4c 89 55 a8          	mov    %r10,-0x58(%rbp)
    5eab:	48 89 4d b0          	mov    %rcx,-0x50(%rbp)
    5eaf:	e8 00 00 00 00       	callq  5eb4 <e1000_setup_all_tx_resources+0x524>
    5eb4:	4c 8b 45 90          	mov    -0x70(%rbp),%r8
    5eb8:	48 8b 55 a0          	mov    -0x60(%rbp),%rdx
    5ebc:	4c 8b 55 a8          	mov    -0x58(%rbp),%r10
    5ec0:	48 8b 4d b0          	mov    -0x50(%rbp),%rcx
    5ec4:	e9 65 fd ff ff       	jmpq   5c2e <e1000_setup_all_tx_resources+0x29e>
		vfree(txdr->buffer_info);
		return -ENOMEM;
	}

	/* Fix for errata 23, can't cross 64kB boundary */
	if (!e1000_check_64k_bound(adapter, txdr->desc, txdr->size)) {
    5ec9:	4c 89 d7             	mov    %r10,%rdi
    5ecc:	e9 fd fa ff ff       	jmpq   59ce <e1000_setup_all_tx_resources+0x3e>
    5ed1:	66 66 66 66 66 66 2e 	data32 data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
    5ed8:	0f 1f 84 00 00 00 00 
    5edf:	00 

0000000000005ee0 <e1000_setup_all_rx_resources>:
 * @adapter: board private structure
 *
 * Return 0 on success, negative on failure
 **/
int e1000_setup_all_rx_resources(struct e1000_adapter *adapter)
{
    5ee0:	e8 00 00 00 00       	callq  5ee5 <e1000_setup_all_rx_resources+0x5>
    5ee5:	55                   	push   %rbp
    5ee6:	48 89 e5             	mov    %rsp,%rbp
    5ee9:	41 57                	push   %r15
    5eeb:	41 56                	push   %r14
    5eed:	41 55                	push   %r13
    5eef:	41 54                	push   %r12
    5ef1:	53                   	push   %rbx
    5ef2:	48 89 fb             	mov    %rdi,%rbx
    5ef5:	48 83 ec 48          	sub    $0x48,%rsp
	int i, err = 0;

	for (i = 0; i < adapter->num_rx_queues; i++) {
    5ef9:	8b 87 7c 03 00 00    	mov    0x37c(%rdi),%eax
    5eff:	c7 45 bc 00 00 00 00 	movl   $0x0,-0x44(%rbp)
    5f06:	85 c0                	test   %eax,%eax
    5f08:	7f 49                	jg     5f53 <e1000_setup_all_rx_resources+0x73>
    5f0a:	e9 23 04 00 00       	jmpq   6332 <e1000_setup_all_rx_resources+0x452>

	/* First rev 82545 and 82546 need to not allow any memory
	 * write location to cross 64k boundary due to errata 23
	 */
	if (hw->mac_type == e1000_82545 ||
	    hw->mac_type == e1000_ce4100 ||
    5f0f:	83 e8 08             	sub    $0x8,%eax
    5f12:	4c 89 d7             	mov    %r10,%rdi
    5f15:	83 f8 01             	cmp    $0x1,%eax
    5f18:	0f 86 1e 01 00 00    	jbe    603c <e1000_setup_all_rx_resources+0x15c>
			/* Free old allocation, new allocation was successful */
			dma_free_coherent(&pdev->dev, rxdr->size, olddesc,
					  olddma);
		}
	}
	memset(rxdr->desc, 0, rxdr->size);
    5f1e:	31 f6                	xor    %esi,%esi
    5f20:	4c 89 da             	mov    %r11,%rdx
    5f23:	e8 00 00 00 00       	callq  5f28 <e1000_setup_all_rx_resources+0x48>
 **/
int e1000_setup_all_rx_resources(struct e1000_adapter *adapter)
{
	int i, err = 0;

	for (i = 0; i < adapter->num_rx_queues; i++) {
    5f28:	83 45 bc 01          	addl   $0x1,-0x44(%rbp)
					  olddma);
		}
	}
	memset(rxdr->desc, 0, rxdr->size);

	rxdr->next_to_clean = 0;
    5f2c:	41 c7 46 1c 00 00 00 	movl   $0x0,0x1c(%r14)
    5f33:	00 
	rxdr->next_to_use = 0;
    5f34:	41 c7 46 18 00 00 00 	movl   $0x0,0x18(%r14)
    5f3b:	00 
	rxdr->rx_skb_top = NULL;
    5f3c:	49 c7 46 28 00 00 00 	movq   $0x0,0x28(%r14)
    5f43:	00 
 **/
int e1000_setup_all_rx_resources(struct e1000_adapter *adapter)
{
	int i, err = 0;

	for (i = 0; i < adapter->num_rx_queues; i++) {
    5f44:	8b 45 bc             	mov    -0x44(%rbp),%eax
    5f47:	39 83 7c 03 00 00    	cmp    %eax,0x37c(%rbx)
    5f4d:	0f 8e df 03 00 00    	jle    6332 <e1000_setup_all_rx_resources+0x452>
		err = e1000_setup_rx_resources(adapter, &adapter->rx_ring[i]);
    5f53:	4c 63 4d bc          	movslq -0x44(%rbp),%r9
 * Returns 0 on success, negative on failure
 **/
static int e1000_setup_rx_resources(struct e1000_adapter *adapter,
				    struct e1000_rx_ring *rxdr)
{
	struct pci_dev *pdev = adapter->pdev;
    5f57:	4c 8b ab b8 03 00 00 	mov    0x3b8(%rbx),%r13
int e1000_setup_all_rx_resources(struct e1000_adapter *adapter)
{
	int i, err = 0;

	for (i = 0; i < adapter->num_rx_queues; i++) {
		err = e1000_setup_rx_resources(adapter, &adapter->rx_ring[i]);
    5f5e:	4a 8d 04 cd 00 00 00 	lea    0x0(,%r9,8),%rax
    5f65:	00 
    5f66:	49 c1 e1 06          	shl    $0x6,%r9
    5f6a:	4d 89 ce             	mov    %r9,%r14
    5f6d:	49 29 c6             	sub    %rax,%r14
    5f70:	4c 03 b3 a8 02 00 00 	add    0x2a8(%rbx),%r14
				    struct e1000_rx_ring *rxdr)
{
	struct pci_dev *pdev = adapter->pdev;
	int size, desc_len;

	size = sizeof(struct e1000_rx_buffer) * rxdr->count;
    5f77:	41 8b 7e 14          	mov    0x14(%r14),%edi
    5f7b:	c1 e7 04             	shl    $0x4,%edi
	rxdr->buffer_info = vzalloc(size);
    5f7e:	48 63 ff             	movslq %edi,%rdi
    5f81:	e8 00 00 00 00       	callq  5f86 <e1000_setup_all_rx_resources+0xa6>
	if (!rxdr->buffer_info)
    5f86:	48 85 c0             	test   %rax,%rax
{
	struct pci_dev *pdev = adapter->pdev;
	int size, desc_len;

	size = sizeof(struct e1000_rx_buffer) * rxdr->count;
	rxdr->buffer_info = vzalloc(size);
    5f89:	49 89 46 20          	mov    %rax,0x20(%r14)
	if (!rxdr->buffer_info)
    5f8d:	0f 84 c9 02 00 00    	je     625c <e1000_setup_all_rx_resources+0x37c>

	desc_len = sizeof(struct e1000_rx_desc);

	/* Round up to nearest 4K */

	rxdr->size = rxdr->count * desc_len;
    5f93:	41 8b 46 14          	mov    0x14(%r14),%eax
	rxdr->size = ALIGN(rxdr->size, 4096);

	rxdr->desc = dma_alloc_coherent(&pdev->dev, rxdr->size, &rxdr->dma,
    5f97:	4d 8d a5 98 00 00 00 	lea    0x98(%r13),%r12
    5f9e:	4d 8d 7e 08          	lea    0x8(%r14),%r15
    5fa2:	c7 45 c0 c0 00 40 02 	movl   $0x24000c0,-0x40(%rbp)
    5fa9:	4c 89 65 c8          	mov    %r12,-0x38(%rbp)

	desc_len = sizeof(struct e1000_rx_desc);

	/* Round up to nearest 4K */

	rxdr->size = rxdr->count * desc_len;
    5fad:	c1 e0 04             	shl    $0x4,%eax
	rxdr->size = ALIGN(rxdr->size, 4096);
    5fb0:	05 ff 0f 00 00       	add    $0xfff,%eax
    5fb5:	25 00 f0 ff ff       	and    $0xfffff000,%eax
static inline struct dma_map_ops *get_dma_ops(struct device *dev)
{
#ifndef CONFIG_X86_DEV_DMA_OPS
	return dma_ops;
#else
	if (unlikely(!dev) || !dev->archdata.dma_ops)
    5fba:	4d 85 e4             	test   %r12,%r12
    5fbd:	41 89 46 10          	mov    %eax,0x10(%r14)

	rxdr->desc = dma_alloc_coherent(&pdev->dev, rxdr->size, &rxdr->dma,
    5fc1:	48 89 45 a8          	mov    %rax,-0x58(%rbp)
    5fc5:	0f 84 6f 02 00 00    	je     623a <e1000_setup_all_rx_resources+0x35a>
    5fcb:	49 8b 95 e8 02 00 00 	mov    0x2e8(%r13),%rdx
    5fd2:	48 85 d2             	test   %rdx,%rdx
    5fd5:	0f 84 5f 02 00 00    	je     623a <e1000_setup_all_rx_resources+0x35a>
	BUG_ON(!ops);

	if (dma_alloc_from_coherent(dev, size, dma_handle, &cpu_addr))
		return cpu_addr;

	if (!arch_dma_alloc_attrs(&dev, &flag))
    5fdb:	48 8d 75 c0          	lea    -0x40(%rbp),%rsi
    5fdf:	48 8d 7d c8          	lea    -0x38(%rbp),%rdi
    5fe3:	48 89 55 b0          	mov    %rdx,-0x50(%rbp)
    5fe7:	e8 00 00 00 00       	callq  5fec <e1000_setup_all_rx_resources+0x10c>
    5fec:	84 c0                	test   %al,%al
    5fee:	0f 84 58 02 00 00    	je     624c <e1000_setup_all_rx_resources+0x36c>
		return NULL;
	if (!ops->alloc)
    5ff4:	48 8b 55 b0          	mov    -0x50(%rbp),%rdx
    5ff8:	48 8b 02             	mov    (%rdx),%rax
    5ffb:	48 85 c0             	test   %rax,%rax
    5ffe:	0f 84 48 02 00 00    	je     624c <e1000_setup_all_rx_resources+0x36c>
		return NULL;

	cpu_addr = ops->alloc(dev, size, dma_handle, flag, attrs);
    6004:	45 31 c0             	xor    %r8d,%r8d
    6007:	8b 4d c0             	mov    -0x40(%rbp),%ecx
    600a:	4c 89 fa             	mov    %r15,%rdx
    600d:	48 8b 75 a8          	mov    -0x58(%rbp),%rsi
    6011:	48 8b 7d c8          	mov    -0x38(%rbp),%rdi
    6015:	ff d0                	callq  *%rax
					GFP_KERNEL);
	if (!rxdr->desc) {
    6017:	48 85 c0             	test   %rax,%rax
    601a:	49 89 c2             	mov    %rax,%r10
	/* Round up to nearest 4K */

	rxdr->size = rxdr->count * desc_len;
	rxdr->size = ALIGN(rxdr->size, 4096);

	rxdr->desc = dma_alloc_coherent(&pdev->dev, rxdr->size, &rxdr->dma,
    601d:	49 89 06             	mov    %rax,(%r14)
					GFP_KERNEL);
	if (!rxdr->desc) {
    6020:	0f 84 2d 02 00 00    	je     6253 <e1000_setup_all_rx_resources+0x373>
	unsigned long end = begin + len;

	/* First rev 82545 and 82546 need to not allow any memory
	 * write location to cross 64k boundary due to errata 23
	 */
	if (hw->mac_type == e1000_82545 ||
    6026:	8b 83 d8 03 00 00    	mov    0x3d8(%rbx),%eax
		vfree(rxdr->buffer_info);
		return -ENOMEM;
	}

	/* Fix for errata 23, can't cross 64kB boundary */
	if (!e1000_check_64k_bound(adapter, rxdr->desc, rxdr->size)) {
    602c:	41 8b 56 10          	mov    0x10(%r14),%edx
	unsigned long end = begin + len;

	/* First rev 82545 and 82546 need to not allow any memory
	 * write location to cross 64k boundary due to errata 23
	 */
	if (hw->mac_type == e1000_82545 ||
    6030:	83 f8 06             	cmp    $0x6,%eax
		vfree(rxdr->buffer_info);
		return -ENOMEM;
	}

	/* Fix for errata 23, can't cross 64kB boundary */
	if (!e1000_check_64k_bound(adapter, rxdr->desc, rxdr->size)) {
    6033:	41 89 d3             	mov    %edx,%r11d
	unsigned long end = begin + len;

	/* First rev 82545 and 82546 need to not allow any memory
	 * write location to cross 64k boundary due to errata 23
	 */
	if (hw->mac_type == e1000_82545 ||
    6036:	0f 85 d3 fe ff ff    	jne    5f0f <e1000_setup_all_rx_resources+0x2f>
	    hw->mac_type == e1000_ce4100 ||
	    hw->mac_type == e1000_82546) {
		return ((begin ^ (end - 1)) >> 16) != 0 ? false : true;
    603c:	4b 8d 44 1a ff       	lea    -0x1(%r10,%r11,1),%rax
    6041:	4c 31 d0             	xor    %r10,%rax
    6044:	48 c1 e8 10          	shr    $0x10,%rax
		vfree(rxdr->buffer_info);
		return -ENOMEM;
	}

	/* Fix for errata 23, can't cross 64kB boundary */
	if (!e1000_check_64k_bound(adapter, rxdr->desc, rxdr->size)) {
    6048:	48 85 c0             	test   %rax,%rax
    604b:	0f 84 de 03 00 00    	je     642f <e1000_setup_all_rx_resources+0x54f>
		void *olddesc = rxdr->desc;
		dma_addr_t olddma = rxdr->dma;
		e_err(rx_err, "rxdr align check failed: %u bytes at %p\n",
    6051:	f6 83 a0 07 00 00 40 	testb  $0x40,0x7a0(%rbx)
	}

	/* Fix for errata 23, can't cross 64kB boundary */
	if (!e1000_check_64k_bound(adapter, rxdr->desc, rxdr->size)) {
		void *olddesc = rxdr->desc;
		dma_addr_t olddma = rxdr->dma;
    6058:	49 8b 46 08          	mov    0x8(%r14),%rax
    605c:	48 89 45 98          	mov    %rax,-0x68(%rbp)
		e_err(rx_err, "rxdr align check failed: %u bytes at %p\n",
    6060:	0f 85 ab 01 00 00    	jne    6211 <e1000_setup_all_rx_resources+0x331>
    6066:	4d 85 e4             	test   %r12,%r12
    6069:	4c 89 65 d0          	mov    %r12,-0x30(%rbp)
    606d:	c7 45 c4 c0 00 40 02 	movl   $0x24000c0,-0x3c(%rbp)
    6074:	0f 84 3c 02 00 00    	je     62b6 <e1000_setup_all_rx_resources+0x3d6>
    607a:	49 8b 95 e8 02 00 00 	mov    0x2e8(%r13),%rdx
    6081:	48 85 d2             	test   %rdx,%rdx
    6084:	0f 84 2c 02 00 00    	je     62b6 <e1000_setup_all_rx_resources+0x3d6>
	BUG_ON(!ops);

	if (dma_alloc_from_coherent(dev, size, dma_handle, &cpu_addr))
		return cpu_addr;

	if (!arch_dma_alloc_attrs(&dev, &flag))
    608a:	48 8d 75 c4          	lea    -0x3c(%rbp),%rsi
    608e:	48 8d 7d d0          	lea    -0x30(%rbp),%rdi
    6092:	4c 89 55 b0          	mov    %r10,-0x50(%rbp)
    6096:	48 89 55 a8          	mov    %rdx,-0x58(%rbp)
    609a:	4c 89 5d a0          	mov    %r11,-0x60(%rbp)
    609e:	e8 00 00 00 00       	callq  60a3 <e1000_setup_all_rx_resources+0x1c3>
    60a3:	84 c0                	test   %al,%al
    60a5:	4c 8b 55 b0          	mov    -0x50(%rbp),%r10
    60a9:	0f 84 2b 02 00 00    	je     62da <e1000_setup_all_rx_resources+0x3fa>
		return NULL;
	if (!ops->alloc)
    60af:	48 8b 55 a8          	mov    -0x58(%rbp),%rdx
    60b3:	48 8b 02             	mov    (%rdx),%rax
    60b6:	48 85 c0             	test   %rax,%rax
    60b9:	0f 84 1b 02 00 00    	je     62da <e1000_setup_all_rx_resources+0x3fa>
		return NULL;

	cpu_addr = ops->alloc(dev, size, dma_handle, flag, attrs);
    60bf:	4c 8b 5d a0          	mov    -0x60(%rbp),%r11
    60c3:	45 31 c0             	xor    %r8d,%r8d
    60c6:	4c 89 fa             	mov    %r15,%rdx
    60c9:	8b 4d c4             	mov    -0x3c(%rbp),%ecx
    60cc:	48 8b 7d d0          	mov    -0x30(%rbp),%rdi
    60d0:	4c 89 de             	mov    %r11,%rsi
    60d3:	ff d0                	callq  *%rax
		      rxdr->size, rxdr->desc);
		/* Try again, without freeing the previous */
		rxdr->desc = dma_alloc_coherent(&pdev->dev, rxdr->size,
						&rxdr->dma, GFP_KERNEL);
		/* Failed allocation, critical failure */
		if (!rxdr->desc) {
    60d5:	48 85 c0             	test   %rax,%rax
    60d8:	48 89 c2             	mov    %rax,%rdx
		void *olddesc = rxdr->desc;
		dma_addr_t olddma = rxdr->dma;
		e_err(rx_err, "rxdr align check failed: %u bytes at %p\n",
		      rxdr->size, rxdr->desc);
		/* Try again, without freeing the previous */
		rxdr->desc = dma_alloc_coherent(&pdev->dev, rxdr->size,
    60db:	49 89 06             	mov    %rax,(%r14)
						&rxdr->dma, GFP_KERNEL);
		/* Failed allocation, critical failure */
		if (!rxdr->desc) {
    60de:	4c 8b 55 b0          	mov    -0x50(%rbp),%r10
    60e2:	0f 84 f9 01 00 00    	je     62e1 <e1000_setup_all_rx_resources+0x401>
	unsigned long end = begin + len;

	/* First rev 82545 and 82546 need to not allow any memory
	 * write location to cross 64k boundary due to errata 23
	 */
	if (hw->mac_type == e1000_82545 ||
    60e8:	8b 83 d8 03 00 00    	mov    0x3d8(%rbx),%eax
			dma_free_coherent(&pdev->dev, rxdr->size, olddesc,
					  olddma);
			goto setup_rx_desc_die;
		}

		if (!e1000_check_64k_bound(adapter, rxdr->desc, rxdr->size)) {
    60ee:	45 8b 7e 10          	mov    0x10(%r14),%r15d
	unsigned long end = begin + len;

	/* First rev 82545 and 82546 need to not allow any memory
	 * write location to cross 64k boundary due to errata 23
	 */
	if (hw->mac_type == e1000_82545 ||
    60f2:	83 f8 06             	cmp    $0x6,%eax
    60f5:	74 58                	je     614f <e1000_setup_all_rx_resources+0x26f>
	    hw->mac_type == e1000_ce4100 ||
    60f7:	83 e8 08             	sub    $0x8,%eax
    60fa:	83 f8 01             	cmp    $0x1,%eax
    60fd:	76 50                	jbe    614f <e1000_setup_all_rx_resources+0x26f>
    60ff:	4d 85 e4             	test   %r12,%r12
    6102:	0f 84 c0 01 00 00    	je     62c8 <e1000_setup_all_rx_resources+0x3e8>
    6108:	4d 8b ad e8 02 00 00 	mov    0x2e8(%r13),%r13
    610f:	4d 85 ed             	test   %r13,%r13
    6112:	0f 84 b0 01 00 00    	je     62c8 <e1000_setup_all_rx_resources+0x3e8>
    6118:	ff 14 25 00 00 00 00 	callq  *0x0
				     struct dma_attrs *attrs)
{
	struct dma_map_ops *ops = get_dma_ops(dev);

	BUG_ON(!ops);
	WARN_ON(irqs_disabled());
    611f:	f6 c4 02             	test   $0x2,%ah
    6122:	0f 84 77 02 00 00    	je     639f <e1000_setup_all_rx_resources+0x4bf>

	if (dma_release_from_coherent(dev, get_order(size), cpu_addr))
		return;

	if (!ops->free)
    6128:	49 8b 45 08          	mov    0x8(%r13),%rax
    612c:	48 85 c0             	test   %rax,%rax
    612f:	74 12                	je     6143 <e1000_setup_all_rx_resources+0x263>
		return;

	debug_dma_free_coherent(dev, size, cpu_addr, dma_handle);
	ops->free(dev, size, cpu_addr, dma_handle, attrs);
    6131:	45 31 c0             	xor    %r8d,%r8d
    6134:	48 8b 4d 98          	mov    -0x68(%rbp),%rcx
    6138:	4c 89 d2             	mov    %r10,%rdx
    613b:	4c 89 fe             	mov    %r15,%rsi
    613e:	4c 89 e7             	mov    %r12,%rdi
    6141:	ff d0                	callq  *%rax
    6143:	45 8b 5e 10          	mov    0x10(%r14),%r11d
    6147:	49 8b 3e             	mov    (%r14),%rdi
    614a:	e9 cf fd ff ff       	jmpq   5f1e <e1000_setup_all_rx_resources+0x3e>
	    hw->mac_type == e1000_82546) {
		return ((begin ^ (end - 1)) >> 16) != 0 ? false : true;
    614f:	4a 8d 44 3a ff       	lea    -0x1(%rdx,%r15,1),%rax
    6154:	48 31 d0             	xor    %rdx,%rax
    6157:	48 c1 e8 10          	shr    $0x10,%rax
			dma_free_coherent(&pdev->dev, rxdr->size, olddesc,
					  olddma);
			goto setup_rx_desc_die;
		}

		if (!e1000_check_64k_bound(adapter, rxdr->desc, rxdr->size)) {
    615b:	48 85 c0             	test   %rax,%rax
    615e:	74 9f                	je     60ff <e1000_setup_all_rx_resources+0x21f>
    6160:	4d 85 e4             	test   %r12,%r12
			/* give up */
			dma_free_coherent(&pdev->dev, rxdr->size, rxdr->desc,
    6163:	49 8b 4e 08          	mov    0x8(%r14),%rcx
    6167:	0f 84 f3 01 00 00    	je     6360 <e1000_setup_all_rx_resources+0x480>
    616d:	4d 8b 85 e8 02 00 00 	mov    0x2e8(%r13),%r8
    6174:	4d 85 c0             	test   %r8,%r8
    6177:	0f 84 e3 01 00 00    	je     6360 <e1000_setup_all_rx_resources+0x480>
    617d:	ff 14 25 00 00 00 00 	callq  *0x0
				     struct dma_attrs *attrs)
{
	struct dma_map_ops *ops = get_dma_ops(dev);

	BUG_ON(!ops);
	WARN_ON(irqs_disabled());
    6184:	f6 c4 02             	test   $0x2,%ah
    6187:	0f 84 6c 02 00 00    	je     63f9 <e1000_setup_all_rx_resources+0x519>

	if (dma_release_from_coherent(dev, get_order(size), cpu_addr))
		return;

	if (!ops->free)
    618d:	49 8b 40 08          	mov    0x8(%r8),%rax
    6191:	48 85 c0             	test   %rax,%rax
    6194:	74 13                	je     61a9 <e1000_setup_all_rx_resources+0x2c9>
    6196:	4c 89 55 b0          	mov    %r10,-0x50(%rbp)
		return;

	debug_dma_free_coherent(dev, size, cpu_addr, dma_handle);
	ops->free(dev, size, cpu_addr, dma_handle, attrs);
    619a:	45 31 c0             	xor    %r8d,%r8d
    619d:	4c 89 fe             	mov    %r15,%rsi
    61a0:	4c 89 e7             	mov    %r12,%rdi
    61a3:	ff d0                	callq  *%rax
    61a5:	4c 8b 55 b0          	mov    -0x50(%rbp),%r10
    61a9:	4d 85 e4             	test   %r12,%r12
					  rxdr->dma);
			dma_free_coherent(&pdev->dev, rxdr->size, olddesc,
    61ac:	45 8b 7e 10          	mov    0x10(%r14),%r15d
    61b0:	0f 84 bf 01 00 00    	je     6375 <e1000_setup_all_rx_resources+0x495>
    61b6:	4d 8b ad e8 02 00 00 	mov    0x2e8(%r13),%r13
    61bd:	4d 85 ed             	test   %r13,%r13
    61c0:	0f 84 af 01 00 00    	je     6375 <e1000_setup_all_rx_resources+0x495>
    61c6:	ff 14 25 00 00 00 00 	callq  *0x0
				     struct dma_attrs *attrs)
{
	struct dma_map_ops *ops = get_dma_ops(dev);

	BUG_ON(!ops);
	WARN_ON(irqs_disabled());
    61cd:	f6 c4 02             	test   $0x2,%ah
    61d0:	0f 84 e7 01 00 00    	je     63bd <e1000_setup_all_rx_resources+0x4dd>

	if (dma_release_from_coherent(dev, get_order(size), cpu_addr))
		return;

	if (!ops->free)
    61d6:	49 8b 45 08          	mov    0x8(%r13),%rax
    61da:	48 85 c0             	test   %rax,%rax
    61dd:	74 12                	je     61f1 <e1000_setup_all_rx_resources+0x311>
		return;

	debug_dma_free_coherent(dev, size, cpu_addr, dma_handle);
	ops->free(dev, size, cpu_addr, dma_handle, attrs);
    61df:	45 31 c0             	xor    %r8d,%r8d
    61e2:	48 8b 4d 98          	mov    -0x68(%rbp),%rcx
    61e6:	4c 89 d2             	mov    %r10,%rdx
    61e9:	4c 89 fe             	mov    %r15,%rsi
    61ec:	4c 89 e7             	mov    %r12,%rdi
    61ef:	ff d0                	callq  *%rax
					  olddma);
			e_err(probe, "Unable to allocate aligned memory for "
    61f1:	f6 83 a0 07 00 00 02 	testb  $0x2,0x7a0(%rbx)
    61f8:	74 59                	je     6253 <e1000_setup_all_rx_resources+0x373>
    61fa:	48 8b bb b0 03 00 00 	mov    0x3b0(%rbx),%rdi
    6201:	48 c7 c6 00 00 00 00 	mov    $0x0,%rsi
    6208:	31 c0                	xor    %eax,%eax
    620a:	e8 00 00 00 00       	callq  620f <e1000_setup_all_rx_resources+0x32f>
    620f:	eb 42                	jmp    6253 <e1000_setup_all_rx_resources+0x373>

	/* Fix for errata 23, can't cross 64kB boundary */
	if (!e1000_check_64k_bound(adapter, rxdr->desc, rxdr->size)) {
		void *olddesc = rxdr->desc;
		dma_addr_t olddma = rxdr->dma;
		e_err(rx_err, "rxdr align check failed: %u bytes at %p\n",
    6211:	48 8b bb b0 03 00 00 	mov    0x3b0(%rbx),%rdi
    6218:	4c 89 d1             	mov    %r10,%rcx
    621b:	48 c7 c6 00 00 00 00 	mov    $0x0,%rsi
    6222:	31 c0                	xor    %eax,%eax
    6224:	4c 89 55 b0          	mov    %r10,-0x50(%rbp)
    6228:	e8 00 00 00 00       	callq  622d <e1000_setup_all_rx_resources+0x34d>
    622d:	45 8b 5e 10          	mov    0x10(%r14),%r11d
    6231:	4c 8b 55 b0          	mov    -0x50(%rbp),%r10
    6235:	e9 2c fe ff ff       	jmpq   6066 <e1000_setup_all_rx_resources+0x186>
		return dma_ops;
    623a:	48 8b 15 00 00 00 00 	mov    0x0(%rip),%rdx        # 6241 <e1000_setup_all_rx_resources+0x361>
				       struct dma_attrs *attrs)
{
	struct dma_map_ops *ops = get_dma_ops(dev);
	void *cpu_addr;

	BUG_ON(!ops);
    6241:	48 85 d2             	test   %rdx,%rdx
    6244:	0f 85 91 fd ff ff    	jne    5fdb <e1000_setup_all_rx_resources+0xfb>
    624a:	0f 0b                	ud2    
	/* Round up to nearest 4K */

	rxdr->size = rxdr->count * desc_len;
	rxdr->size = ALIGN(rxdr->size, 4096);

	rxdr->desc = dma_alloc_coherent(&pdev->dev, rxdr->size, &rxdr->dma,
    624c:	49 c7 06 00 00 00 00 	movq   $0x0,(%r14)
					GFP_KERNEL);
	if (!rxdr->desc) {
setup_rx_desc_die:
		vfree(rxdr->buffer_info);
    6253:	49 8b 7e 20          	mov    0x20(%r14),%rdi
    6257:	e8 00 00 00 00       	callq  625c <e1000_setup_all_rx_resources+0x37c>
	int i, err = 0;

	for (i = 0; i < adapter->num_rx_queues; i++) {
		err = e1000_setup_rx_resources(adapter, &adapter->rx_ring[i]);
		if (err) {
			e_err(probe, "Allocation for Rx Queue %u failed\n", i);
    625c:	f6 83 a0 07 00 00 02 	testb  $0x2,0x7a0(%rbx)
    6263:	0f 85 da 00 00 00    	jne    6343 <e1000_setup_all_rx_resources+0x463>
			for (i-- ; i >= 0; i--)
    6269:	44 8b 75 bc          	mov    -0x44(%rbp),%r14d
    626d:	41 83 ee 01          	sub    $0x1,%r14d
    6271:	41 83 fe ff          	cmp    $0xffffffff,%r14d
    6275:	74 2b                	je     62a2 <e1000_setup_all_rx_resources+0x3c2>
				e1000_free_rx_resources(adapter,
    6277:	49 63 f6             	movslq %r14d,%rsi
    627a:	48 89 df             	mov    %rbx,%rdi

	for (i = 0; i < adapter->num_rx_queues; i++) {
		err = e1000_setup_rx_resources(adapter, &adapter->rx_ring[i]);
		if (err) {
			e_err(probe, "Allocation for Rx Queue %u failed\n", i);
			for (i-- ; i >= 0; i--)
    627d:	41 83 ee 01          	sub    $0x1,%r14d
				e1000_free_rx_resources(adapter,
							&adapter->rx_ring[i]);
    6281:	48 8d 04 f5 00 00 00 	lea    0x0(,%rsi,8),%rax
    6288:	00 
    6289:	48 c1 e6 06          	shl    $0x6,%rsi
    628d:	48 29 c6             	sub    %rax,%rsi
	for (i = 0; i < adapter->num_rx_queues; i++) {
		err = e1000_setup_rx_resources(adapter, &adapter->rx_ring[i]);
		if (err) {
			e_err(probe, "Allocation for Rx Queue %u failed\n", i);
			for (i-- ; i >= 0; i--)
				e1000_free_rx_resources(adapter,
    6290:	48 03 b3 a8 02 00 00 	add    0x2a8(%rbx),%rsi
    6297:	e8 a4 df ff ff       	callq  4240 <e1000_free_rx_resources>

	for (i = 0; i < adapter->num_rx_queues; i++) {
		err = e1000_setup_rx_resources(adapter, &adapter->rx_ring[i]);
		if (err) {
			e_err(probe, "Allocation for Rx Queue %u failed\n", i);
			for (i-- ; i >= 0; i--)
    629c:	41 83 fe ff          	cmp    $0xffffffff,%r14d
    62a0:	75 d5                	jne    6277 <e1000_setup_all_rx_resources+0x397>
			break;
		}
	}

	return err;
}
    62a2:	48 83 c4 48          	add    $0x48,%rsp

	/* First rev 82545 and 82546 need to not allow any memory
	 * write location to cross 64k boundary due to errata 23
	 */
	if (hw->mac_type == e1000_82545 ||
	    hw->mac_type == e1000_ce4100 ||
    62a6:	b8 f4 ff ff ff       	mov    $0xfffffff4,%eax
			break;
		}
	}

	return err;
}
    62ab:	5b                   	pop    %rbx
    62ac:	41 5c                	pop    %r12
    62ae:	41 5d                	pop    %r13
    62b0:	41 5e                	pop    %r14
    62b2:	41 5f                	pop    %r15
    62b4:	5d                   	pop    %rbp
    62b5:	c3                   	retq   
    62b6:	48 8b 15 00 00 00 00 	mov    0x0(%rip),%rdx        # 62bd <e1000_setup_all_rx_resources+0x3dd>
    62bd:	48 85 d2             	test   %rdx,%rdx
    62c0:	0f 85 c4 fd ff ff    	jne    608a <e1000_setup_all_rx_resources+0x1aa>
    62c6:	eb 82                	jmp    624a <e1000_setup_all_rx_resources+0x36a>
    62c8:	4c 8b 2d 00 00 00 00 	mov    0x0(%rip),%r13        # 62cf <e1000_setup_all_rx_resources+0x3ef>
				     void *cpu_addr, dma_addr_t dma_handle,
				     struct dma_attrs *attrs)
{
	struct dma_map_ops *ops = get_dma_ops(dev);

	BUG_ON(!ops);
    62cf:	4d 85 ed             	test   %r13,%r13
    62d2:	0f 85 40 fe ff ff    	jne    6118 <e1000_setup_all_rx_resources+0x238>
    62d8:	0f 0b                	ud2    
		void *olddesc = rxdr->desc;
		dma_addr_t olddma = rxdr->dma;
		e_err(rx_err, "rxdr align check failed: %u bytes at %p\n",
		      rxdr->size, rxdr->desc);
		/* Try again, without freeing the previous */
		rxdr->desc = dma_alloc_coherent(&pdev->dev, rxdr->size,
    62da:	49 c7 06 00 00 00 00 	movq   $0x0,(%r14)
static inline struct dma_map_ops *get_dma_ops(struct device *dev)
{
#ifndef CONFIG_X86_DEV_DMA_OPS
	return dma_ops;
#else
	if (unlikely(!dev) || !dev->archdata.dma_ops)
    62e1:	4d 85 e4             	test   %r12,%r12
						&rxdr->dma, GFP_KERNEL);
		/* Failed allocation, critical failure */
		if (!rxdr->desc) {
			dma_free_coherent(&pdev->dev, rxdr->size, olddesc,
    62e4:	45 8b 7e 10          	mov    0x10(%r14),%r15d
    62e8:	0f 84 9c 00 00 00    	je     638a <e1000_setup_all_rx_resources+0x4aa>
    62ee:	4d 8b ad e8 02 00 00 	mov    0x2e8(%r13),%r13
    62f5:	4d 85 ed             	test   %r13,%r13
    62f8:	0f 84 8c 00 00 00    	je     638a <e1000_setup_all_rx_resources+0x4aa>
    62fe:	ff 14 25 00 00 00 00 	callq  *0x0
	WARN_ON(irqs_disabled());
    6305:	f6 c4 02             	test   $0x2,%ah
    6308:	0f 84 cd 00 00 00    	je     63db <e1000_setup_all_rx_resources+0x4fb>

	if (dma_release_from_coherent(dev, get_order(size), cpu_addr))
		return;

	if (!ops->free)
    630e:	49 8b 45 08          	mov    0x8(%r13),%rax
    6312:	48 85 c0             	test   %rax,%rax
    6315:	0f 84 38 ff ff ff    	je     6253 <e1000_setup_all_rx_resources+0x373>
		return;

	debug_dma_free_coherent(dev, size, cpu_addr, dma_handle);
	ops->free(dev, size, cpu_addr, dma_handle, attrs);
    631b:	45 31 c0             	xor    %r8d,%r8d
    631e:	48 8b 4d 98          	mov    -0x68(%rbp),%rcx
    6322:	4c 89 d2             	mov    %r10,%rdx
    6325:	4c 89 fe             	mov    %r15,%rsi
    6328:	4c 89 e7             	mov    %r12,%rdi
    632b:	ff d0                	callq  *%rax
    632d:	e9 21 ff ff ff       	jmpq   6253 <e1000_setup_all_rx_resources+0x373>
			break;
		}
	}

	return err;
}
    6332:	48 83 c4 48          	add    $0x48,%rsp
 *
 * Return 0 on success, negative on failure
 **/
int e1000_setup_all_rx_resources(struct e1000_adapter *adapter)
{
	int i, err = 0;
    6336:	31 c0                	xor    %eax,%eax
			break;
		}
	}

	return err;
}
    6338:	5b                   	pop    %rbx
    6339:	41 5c                	pop    %r12
    633b:	41 5d                	pop    %r13
    633d:	41 5e                	pop    %r14
    633f:	41 5f                	pop    %r15
    6341:	5d                   	pop    %rbp
    6342:	c3                   	retq   
	int i, err = 0;

	for (i = 0; i < adapter->num_rx_queues; i++) {
		err = e1000_setup_rx_resources(adapter, &adapter->rx_ring[i]);
		if (err) {
			e_err(probe, "Allocation for Rx Queue %u failed\n", i);
    6343:	48 8b bb b0 03 00 00 	mov    0x3b0(%rbx),%rdi
    634a:	8b 55 bc             	mov    -0x44(%rbp),%edx
    634d:	48 c7 c6 00 00 00 00 	mov    $0x0,%rsi
    6354:	31 c0                	xor    %eax,%eax
    6356:	e8 00 00 00 00       	callq  635b <e1000_setup_all_rx_resources+0x47b>
    635b:	e9 09 ff ff ff       	jmpq   6269 <e1000_setup_all_rx_resources+0x389>
		return dma_ops;
    6360:	4c 8b 05 00 00 00 00 	mov    0x0(%rip),%r8        # 6367 <e1000_setup_all_rx_resources+0x487>
				     void *cpu_addr, dma_addr_t dma_handle,
				     struct dma_attrs *attrs)
{
	struct dma_map_ops *ops = get_dma_ops(dev);

	BUG_ON(!ops);
    6367:	4d 85 c0             	test   %r8,%r8
    636a:	0f 85 0d fe ff ff    	jne    617d <e1000_setup_all_rx_resources+0x29d>
    6370:	e9 63 ff ff ff       	jmpq   62d8 <e1000_setup_all_rx_resources+0x3f8>
    6375:	4c 8b 2d 00 00 00 00 	mov    0x0(%rip),%r13        # 637c <e1000_setup_all_rx_resources+0x49c>
    637c:	4d 85 ed             	test   %r13,%r13
    637f:	0f 85 41 fe ff ff    	jne    61c6 <e1000_setup_all_rx_resources+0x2e6>
    6385:	e9 4e ff ff ff       	jmpq   62d8 <e1000_setup_all_rx_resources+0x3f8>
    638a:	4c 8b 2d 00 00 00 00 	mov    0x0(%rip),%r13        # 6391 <e1000_setup_all_rx_resources+0x4b1>
    6391:	4d 85 ed             	test   %r13,%r13
    6394:	0f 85 64 ff ff ff    	jne    62fe <e1000_setup_all_rx_resources+0x41e>
    639a:	e9 39 ff ff ff       	jmpq   62d8 <e1000_setup_all_rx_resources+0x3f8>
	WARN_ON(irqs_disabled());
    639f:	be 12 01 00 00       	mov    $0x112,%esi
    63a4:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
    63ab:	4c 89 55 b0          	mov    %r10,-0x50(%rbp)
    63af:	e8 00 00 00 00       	callq  63b4 <e1000_setup_all_rx_resources+0x4d4>
    63b4:	4c 8b 55 b0          	mov    -0x50(%rbp),%r10
    63b8:	e9 6b fd ff ff       	jmpq   6128 <e1000_setup_all_rx_resources+0x248>
    63bd:	be 12 01 00 00       	mov    $0x112,%esi
    63c2:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
    63c9:	4c 89 55 b0          	mov    %r10,-0x50(%rbp)
    63cd:	e8 00 00 00 00       	callq  63d2 <e1000_setup_all_rx_resources+0x4f2>
    63d2:	4c 8b 55 b0          	mov    -0x50(%rbp),%r10
    63d6:	e9 fb fd ff ff       	jmpq   61d6 <e1000_setup_all_rx_resources+0x2f6>
    63db:	be 12 01 00 00       	mov    $0x112,%esi
    63e0:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
    63e7:	4c 89 55 b0          	mov    %r10,-0x50(%rbp)
    63eb:	e8 00 00 00 00       	callq  63f0 <e1000_setup_all_rx_resources+0x510>
    63f0:	4c 8b 55 b0          	mov    -0x50(%rbp),%r10
    63f4:	e9 15 ff ff ff       	jmpq   630e <e1000_setup_all_rx_resources+0x42e>
    63f9:	be 12 01 00 00       	mov    $0x112,%esi
    63fe:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
    6405:	4c 89 45 90          	mov    %r8,-0x70(%rbp)
    6409:	48 89 55 a0          	mov    %rdx,-0x60(%rbp)
    640d:	4c 89 55 a8          	mov    %r10,-0x58(%rbp)
    6411:	48 89 4d b0          	mov    %rcx,-0x50(%rbp)
    6415:	e8 00 00 00 00       	callq  641a <e1000_setup_all_rx_resources+0x53a>
    641a:	4c 8b 45 90          	mov    -0x70(%rbp),%r8
    641e:	48 8b 55 a0          	mov    -0x60(%rbp),%rdx
    6422:	4c 8b 55 a8          	mov    -0x58(%rbp),%r10
    6426:	48 8b 4d b0          	mov    -0x50(%rbp),%rcx
    642a:	e9 5e fd ff ff       	jmpq   618d <e1000_setup_all_rx_resources+0x2ad>
		vfree(rxdr->buffer_info);
		return -ENOMEM;
	}

	/* Fix for errata 23, can't cross 64kB boundary */
	if (!e1000_check_64k_bound(adapter, rxdr->desc, rxdr->size)) {
    642f:	4c 89 d7             	mov    %r10,%rdi
    6432:	e9 e7 fa ff ff       	jmpq   5f1e <e1000_setup_all_rx_resources+0x3e>
    6437:	66 0f 1f 84 00 00 00 	nopw   0x0(%rax,%rax,1)
    643e:	00 00 

0000000000006440 <e1000_free_all_tx_resources>:
 * @adapter: board private structure
 *
 * Free all transmit software resources
 **/
void e1000_free_all_tx_resources(struct e1000_adapter *adapter)
{
    6440:	e8 00 00 00 00       	callq  6445 <e1000_free_all_tx_resources+0x5>
    6445:	55                   	push   %rbp
    6446:	48 89 e5             	mov    %rsp,%rbp
    6449:	41 54                	push   %r12
    644b:	49 89 fc             	mov    %rdi,%r12
    644e:	53                   	push   %rbx
	int i;

	for (i = 0; i < adapter->num_tx_queues; i++)
    644f:	8b 87 78 03 00 00    	mov    0x378(%rdi),%eax
    6455:	31 db                	xor    %ebx,%ebx
    6457:	85 c0                	test   %eax,%eax
    6459:	7e 28                	jle    6483 <e1000_free_all_tx_resources+0x43>
		e1000_free_tx_resources(adapter, &adapter->tx_ring[i]);
    645b:	48 63 c3             	movslq %ebx,%rax
    645e:	4c 89 e7             	mov    %r12,%rdi
 **/
void e1000_free_all_tx_resources(struct e1000_adapter *adapter)
{
	int i;

	for (i = 0; i < adapter->num_tx_queues; i++)
    6461:	83 c3 01             	add    $0x1,%ebx
		e1000_free_tx_resources(adapter, &adapter->tx_ring[i]);
    6464:	48 8d 34 40          	lea    (%rax,%rax,2),%rsi
    6468:	48 c1 e6 04          	shl    $0x4,%rsi
    646c:	49 03 b4 24 40 02 00 	add    0x240(%r12),%rsi
    6473:	00 
    6474:	e8 87 de ff ff       	callq  4300 <e1000_free_tx_resources>
 **/
void e1000_free_all_tx_resources(struct e1000_adapter *adapter)
{
	int i;

	for (i = 0; i < adapter->num_tx_queues; i++)
    6479:	41 39 9c 24 78 03 00 	cmp    %ebx,0x378(%r12)
    6480:	00 
    6481:	7f d8                	jg     645b <e1000_free_all_tx_resources+0x1b>
		e1000_free_tx_resources(adapter, &adapter->tx_ring[i]);
}
    6483:	5b                   	pop    %rbx
    6484:	41 5c                	pop    %r12
    6486:	5d                   	pop    %rbp
    6487:	c3                   	retq   
    6488:	0f 1f 84 00 00 00 00 	nopl   0x0(%rax,%rax,1)
    648f:	00 

0000000000006490 <e1000_free_all_rx_resources>:
 * @adapter: board private structure
 *
 * Free all receive software resources
 **/
void e1000_free_all_rx_resources(struct e1000_adapter *adapter)
{
    6490:	e8 00 00 00 00       	callq  6495 <e1000_free_all_rx_resources+0x5>
    6495:	55                   	push   %rbp
    6496:	48 89 e5             	mov    %rsp,%rbp
    6499:	41 54                	push   %r12
    649b:	49 89 fc             	mov    %rdi,%r12
    649e:	53                   	push   %rbx
	int i;

	for (i = 0; i < adapter->num_rx_queues; i++)
    649f:	8b 87 7c 03 00 00    	mov    0x37c(%rdi),%eax
    64a5:	31 db                	xor    %ebx,%ebx
    64a7:	85 c0                	test   %eax,%eax
    64a9:	7e 2f                	jle    64da <e1000_free_all_rx_resources+0x4a>
		e1000_free_rx_resources(adapter, &adapter->rx_ring[i]);
    64ab:	48 63 f3             	movslq %ebx,%rsi
    64ae:	4c 89 e7             	mov    %r12,%rdi
 **/
void e1000_free_all_rx_resources(struct e1000_adapter *adapter)
{
	int i;

	for (i = 0; i < adapter->num_rx_queues; i++)
    64b1:	83 c3 01             	add    $0x1,%ebx
		e1000_free_rx_resources(adapter, &adapter->rx_ring[i]);
    64b4:	48 8d 04 f5 00 00 00 	lea    0x0(,%rsi,8),%rax
    64bb:	00 
    64bc:	48 c1 e6 06          	shl    $0x6,%rsi
    64c0:	48 29 c6             	sub    %rax,%rsi
    64c3:	49 03 b4 24 a8 02 00 	add    0x2a8(%r12),%rsi
    64ca:	00 
    64cb:	e8 70 dd ff ff       	callq  4240 <e1000_free_rx_resources>
 **/
void e1000_free_all_rx_resources(struct e1000_adapter *adapter)
{
	int i;

	for (i = 0; i < adapter->num_rx_queues; i++)
    64d0:	41 39 9c 24 7c 03 00 	cmp    %ebx,0x37c(%r12)
    64d7:	00 
    64d8:	7f d1                	jg     64ab <e1000_free_all_rx_resources+0x1b>
		e1000_free_rx_resources(adapter, &adapter->rx_ring[i]);
}
    64da:	5b                   	pop    %rbx
    64db:	41 5c                	pop    %r12
    64dd:	5d                   	pop    %rbp
    64de:	c3                   	retq   
    64df:	90                   	nop

00000000000064e0 <e1000_close>:
 * by the OS.  The hardware is still under the drivers control, but
 * needs to be disabled.  A global MAC reset is issued to stop the
 * hardware, and all transmit and receive resources are freed.
 **/
static int e1000_close(struct net_device *netdev)
{
    64e0:	e8 00 00 00 00       	callq  64e5 <e1000_close+0x5>
    64e5:	55                   	push   %rbp
    64e6:	48 89 e5             	mov    %rsp,%rbp
    64e9:	41 55                	push   %r13
	struct e1000_adapter *adapter = netdev_priv(netdev);
    64eb:	4c 8d af 40 08 00 00 	lea    0x840(%rdi),%r13
 * by the OS.  The hardware is still under the drivers control, but
 * needs to be disabled.  A global MAC reset is issued to stop the
 * hardware, and all transmit and receive resources are freed.
 **/
static int e1000_close(struct net_device *netdev)
{
    64f2:	41 54                	push   %r12
    64f4:	49 89 fc             	mov    %rdi,%r12
    64f7:	53                   	push   %rbx
    64f8:	48 8b 87 e8 0f 00 00 	mov    0xfe8(%rdi),%rax
	struct e1000_adapter *adapter = netdev_priv(netdev);
	struct e1000_hw *hw = &adapter->hw;
	int count = E1000_CHECK_RESET_COUNT;

	while (test_bit(__E1000_RESETTING, &adapter->flags) && count--)
    64ff:	bb 32 00 00 00       	mov    $0x32,%ebx
    6504:	a8 02                	test   $0x2,%al
    6506:	75 07                	jne    650f <e1000_close+0x2f>
    6508:	eb 20                	jmp    652a <e1000_close+0x4a>
    650a:	83 eb 01             	sub    $0x1,%ebx
    650d:	74 1b                	je     652a <e1000_close+0x4a>
		usleep_range(10000, 20000);
    650f:	be 20 4e 00 00       	mov    $0x4e20,%esi
    6514:	bf 10 27 00 00       	mov    $0x2710,%edi
    6519:	e8 00 00 00 00       	callq  651e <e1000_close+0x3e>
    651e:	49 8b 84 24 e8 0f 00 	mov    0xfe8(%r12),%rax
    6525:	00 
{
	struct e1000_adapter *adapter = netdev_priv(netdev);
	struct e1000_hw *hw = &adapter->hw;
	int count = E1000_CHECK_RESET_COUNT;

	while (test_bit(__E1000_RESETTING, &adapter->flags) && count--)
    6526:	a8 02                	test   $0x2,%al
    6528:	75 e0                	jne    650a <e1000_close+0x2a>
    652a:	49 8b 84 24 e8 0f 00 	mov    0xfe8(%r12),%rax
    6531:	00 
		usleep_range(10000, 20000);

	WARN_ON(test_bit(__E1000_RESETTING, &adapter->flags));
    6532:	a8 02                	test   $0x2,%al
    6534:	0f 85 83 00 00 00    	jne    65bd <e1000_close+0xdd>
	e1000_down(adapter);
    653a:	4c 89 ef             	mov    %r13,%rdi
    653d:	e8 00 00 00 00       	callq  6542 <e1000_close+0x62>
	e1000_power_down_phy(adapter);
    6542:	4c 89 ef             	mov    %r13,%rdi
    6545:	e8 d6 a7 ff ff       	callq  d20 <e1000_power_down_phy>

static void e1000_free_irq(struct e1000_adapter *adapter)
{
	struct net_device *netdev = adapter->netdev;

	free_irq(adapter->pdev->irq, netdev);
    654a:	49 8b 84 24 f8 0b 00 	mov    0xbf8(%r12),%rax
    6551:	00 
    6552:	49 8b b4 24 f0 0b 00 	mov    0xbf0(%r12),%rsi
    6559:	00 
    655a:	8b b8 74 03 00 00    	mov    0x374(%rax),%edi
    6560:	e8 00 00 00 00       	callq  6565 <e1000_close+0x85>
	WARN_ON(test_bit(__E1000_RESETTING, &adapter->flags));
	e1000_down(adapter);
	e1000_power_down_phy(adapter);
	e1000_free_irq(adapter);

	e1000_free_all_tx_resources(adapter);
    6565:	4c 89 ef             	mov    %r13,%rdi
    6568:	e8 00 00 00 00       	callq  656d <e1000_close+0x8d>
	e1000_free_all_rx_resources(adapter);
    656d:	4c 89 ef             	mov    %r13,%rdi
    6570:	e8 00 00 00 00       	callq  6575 <e1000_close+0x95>

	/* kill manageability vlan ID if supported, but not if a vlan with
	 * the same ID is registered on the host OS (let 8021q kill it)
	 */
	if ((hw->mng_cookie.status &
    6575:	41 f6 84 24 c4 0c 00 	testb  $0x2,0xcc4(%r12)
    657c:	00 02 
    657e:	74 1b                	je     659b <e1000_close+0xbb>
	     E1000_MNG_DHCP_COOKIE_STATUS_VLAN_SUPPORT) &&
	    !test_bit(adapter->mng_vlan_id, adapter->active_vlans)) {
    6580:	41 0f b7 84 24 40 0a 	movzwl 0xa40(%r12),%eax
    6587:	00 00 
    6589:	0f b7 d0             	movzwl %ax,%edx

static inline int variable_test_bit(long nr, volatile const unsigned long *addr)
{
	int oldbit;

	asm volatile("bt %2,%1\n\t"
    658c:	49 0f a3 94 24 40 08 	bt     %rdx,0x840(%r12)
    6593:	00 00 
    6595:	19 d2                	sbb    %edx,%edx

	/* kill manageability vlan ID if supported, but not if a vlan with
	 * the same ID is registered on the host OS (let 8021q kill it)
	 */
	if ((hw->mng_cookie.status &
	     E1000_MNG_DHCP_COOKIE_STATUS_VLAN_SUPPORT) &&
    6597:	85 d2                	test   %edx,%edx
    6599:	74 09                	je     65a4 <e1000_close+0xc4>
		e1000_vlan_rx_kill_vid(netdev, htons(ETH_P_8021Q),
				       adapter->mng_vlan_id);
	}

	return 0;
}
    659b:	5b                   	pop    %rbx
    659c:	41 5c                	pop    %r12
    659e:	41 5d                	pop    %r13
    65a0:	31 c0                	xor    %eax,%eax
    65a2:	5d                   	pop    %rbp
    65a3:	c3                   	retq   
	 * the same ID is registered on the host OS (let 8021q kill it)
	 */
	if ((hw->mng_cookie.status &
	     E1000_MNG_DHCP_COOKIE_STATUS_VLAN_SUPPORT) &&
	    !test_bit(adapter->mng_vlan_id, adapter->active_vlans)) {
		e1000_vlan_rx_kill_vid(netdev, htons(ETH_P_8021Q),
    65a4:	4c 89 e7             	mov    %r12,%rdi
	/* kill manageability vlan ID if supported, but not if a vlan with
	 * the same ID is registered on the host OS (let 8021q kill it)
	 */
	if ((hw->mng_cookie.status &
	     E1000_MNG_DHCP_COOKIE_STATUS_VLAN_SUPPORT) &&
	    !test_bit(adapter->mng_vlan_id, adapter->active_vlans)) {
    65a7:	0f b7 d0             	movzwl %ax,%edx
		e1000_vlan_rx_kill_vid(netdev, htons(ETH_P_8021Q),
    65aa:	be 81 00 00 00       	mov    $0x81,%esi
    65af:	e8 0c a4 ff ff       	callq  9c0 <e1000_vlan_rx_kill_vid>
				       adapter->mng_vlan_id);
	}

	return 0;
}
    65b4:	5b                   	pop    %rbx
    65b5:	41 5c                	pop    %r12
    65b7:	41 5d                	pop    %r13
    65b9:	31 c0                	xor    %eax,%eax
    65bb:	5d                   	pop    %rbp
    65bc:	c3                   	retq   
	int count = E1000_CHECK_RESET_COUNT;

	while (test_bit(__E1000_RESETTING, &adapter->flags) && count--)
		usleep_range(10000, 20000);

	WARN_ON(test_bit(__E1000_RESETTING, &adapter->flags));
    65bd:	be c8 05 00 00       	mov    $0x5c8,%esi
    65c2:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
    65c9:	e8 00 00 00 00       	callq  65ce <e1000_close+0xee>
    65ce:	e9 67 ff ff ff       	jmpq   653a <e1000_close+0x5a>
    65d3:	66 66 66 66 2e 0f 1f 	data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
    65da:	84 00 00 00 00 00 

00000000000065e0 <e1000_has_link>:
		}
	}
}

bool e1000_has_link(struct e1000_adapter *adapter)
{
    65e0:	e8 00 00 00 00       	callq  65e5 <e1000_has_link+0x5>
    65e5:	55                   	push   %rbp
    65e6:	48 89 e5             	mov    %rsp,%rbp
    65e9:	53                   	push   %rbx
    65ea:	48 89 fb             	mov    %rdi,%rbx
	 * sequence error interrupt (except on intel ce4100).
	 * get_link_status will stay false until the
	 * e1000_check_for_link establishes link for copper adapters
	 * ONLY
	 */
	switch (hw->media_type) {
    65ed:	8b 83 e4 03 00 00    	mov    0x3e4(%rbx),%eax
	}
}

bool e1000_has_link(struct e1000_adapter *adapter)
{
	struct e1000_hw *hw = &adapter->hw;
    65f3:	48 8d bf c0 03 00 00 	lea    0x3c0(%rdi),%rdi
	 * sequence error interrupt (except on intel ce4100).
	 * get_link_status will stay false until the
	 * e1000_check_for_link establishes link for copper adapters
	 * ONLY
	 */
	switch (hw->media_type) {
    65fa:	83 f8 01             	cmp    $0x1,%eax
    65fd:	74 3a                	je     6639 <e1000_has_link+0x59>
    65ff:	72 1e                	jb     661f <e1000_has_link+0x3f>
    6601:	83 f8 02             	cmp    $0x2,%eax
    6604:	74 05                	je     660b <e1000_has_link+0x2b>
}

bool e1000_has_link(struct e1000_adapter *adapter)
{
	struct e1000_hw *hw = &adapter->hw;
	bool link_active = false;
    6606:	31 c0                	xor    %eax,%eax
	default:
		break;
	}

	return link_active;
}
    6608:	5b                   	pop    %rbx
    6609:	5d                   	pop    %rbp
    660a:	c3                   	retq   
    660b:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)
	case e1000_media_type_fiber:
		e1000_check_for_link(hw);
		link_active = !!(er32(STATUS) & E1000_STATUS_LU);
		break;
	case e1000_media_type_internal_serdes:
		e1000_check_for_link(hw);
    6610:	e8 00 00 00 00       	callq  6615 <e1000_has_link+0x35>
		link_active = hw->serdes_has_link;
    6615:	0f b6 83 cd 04 00 00 	movzbl 0x4cd(%rbx),%eax
	default:
		break;
	}

	return link_active;
}
    661c:	5b                   	pop    %rbx
    661d:	5d                   	pop    %rbp
    661e:	c3                   	retq   
	 * e1000_check_for_link establishes link for copper adapters
	 * ONLY
	 */
	switch (hw->media_type) {
	case e1000_media_type_copper:
		if (hw->mac_type == e1000_ce4100)
    661f:	83 bb d8 03 00 00 09 	cmpl   $0x9,0x3d8(%rbx)
    6626:	74 28                	je     6650 <e1000_has_link+0x70>
			hw->get_link_status = 1;
		if (hw->get_link_status) {
    6628:	80 bb cc 04 00 00 00 	cmpb   $0x0,0x4cc(%rbx)
    662f:	75 26                	jne    6657 <e1000_has_link+0x77>
	default:
		break;
	}

	return link_active;
}
    6631:	5b                   	pop    %rbx
			hw->get_link_status = 1;
		if (hw->get_link_status) {
			e1000_check_for_link(hw);
			link_active = !hw->get_link_status;
		} else {
			link_active = true;
    6632:	b8 01 00 00 00       	mov    $0x1,%eax
	default:
		break;
	}

	return link_active;
}
    6637:	5d                   	pop    %rbp
    6638:	c3                   	retq   
		} else {
			link_active = true;
		}
		break;
	case e1000_media_type_fiber:
		e1000_check_for_link(hw);
    6639:	e8 00 00 00 00       	callq  663e <e1000_has_link+0x5e>
		link_active = !!(er32(STATUS) & E1000_STATUS_LU);
    663e:	48 8b 83 c0 03 00 00 	mov    0x3c0(%rbx),%rax
    6645:	8b 40 08             	mov    0x8(%rax),%eax
    6648:	d1 e8                	shr    %eax
	default:
		break;
	}

	return link_active;
}
    664a:	5b                   	pop    %rbx
			link_active = true;
		}
		break;
	case e1000_media_type_fiber:
		e1000_check_for_link(hw);
		link_active = !!(er32(STATUS) & E1000_STATUS_LU);
    664b:	83 e0 01             	and    $0x1,%eax
	default:
		break;
	}

	return link_active;
}
    664e:	5d                   	pop    %rbp
    664f:	c3                   	retq   
	 * ONLY
	 */
	switch (hw->media_type) {
	case e1000_media_type_copper:
		if (hw->mac_type == e1000_ce4100)
			hw->get_link_status = 1;
    6650:	c6 83 cc 04 00 00 01 	movb   $0x1,0x4cc(%rbx)
		if (hw->get_link_status) {
			e1000_check_for_link(hw);
    6657:	e8 00 00 00 00       	callq  665c <e1000_has_link+0x7c>
			link_active = !hw->get_link_status;
    665c:	0f b6 83 cc 04 00 00 	movzbl 0x4cc(%rbx),%eax
    6663:	83 f0 01             	xor    $0x1,%eax
    6666:	eb a0                	jmp    6608 <e1000_has_link+0x28>
    6668:	0f 1f 84 00 00 00 00 	nopl   0x0(%rax,%rax,1)
    666f:	00 

0000000000006670 <e1000_update_stats>:
/**
 * e1000_update_stats - Update the board statistics counters
 * @adapter: board private structure
 **/
void e1000_update_stats(struct e1000_adapter *adapter)
{
    6670:	e8 00 00 00 00       	callq  6675 <e1000_update_stats+0x5>
    6675:	55                   	push   %rbp
    6676:	48 89 e5             	mov    %rsp,%rbp
    6679:	41 56                	push   %r14
    667b:	41 55                	push   %r13
    667d:	41 54                	push   %r12
    667f:	53                   	push   %rbx
    6680:	48 89 fb             	mov    %rdi,%rbx
    6683:	48 83 ec 08          	sub    $0x8,%rsp
#define PHY_IDLE_ERROR_COUNT_MASK 0x00FF

	/* Prevent stats update while adapter is being reset, or if the pci
	 * connection is down.
	 */
	if (adapter->link_speed == 0)
    6687:	66 83 bf 18 02 00 00 	cmpw   $0x0,0x218(%rdi)
    668e:	00 
 * e1000_update_stats - Update the board statistics counters
 * @adapter: board private structure
 **/
void e1000_update_stats(struct e1000_adapter *adapter)
{
	struct net_device *netdev = adapter->netdev;
    668f:	4c 8b a7 b0 03 00 00 	mov    0x3b0(%rdi),%r12
	struct e1000_hw *hw = &adapter->hw;
	struct pci_dev *pdev = adapter->pdev;
    6696:	48 8b 87 b8 03 00 00 	mov    0x3b8(%rdi),%rax
#define PHY_IDLE_ERROR_COUNT_MASK 0x00FF

	/* Prevent stats update while adapter is being reset, or if the pci
	 * connection is down.
	 */
	if (adapter->link_speed == 0)
    669d:	74 09                	je     66a8 <e1000_update_stats+0x38>
		return;
	if (pci_channel_offline(pdev))
    669f:	83 b8 90 00 00 00 01 	cmpl   $0x1,0x90(%rax)
    66a6:	74 0d                	je     66b5 <e1000_update_stats+0x45>
		adapter->stats.mgprc += er32(MGTPRC);
		adapter->stats.mgpdc += er32(MGTPDC);
	}

	spin_unlock_irqrestore(&adapter->stats_lock, flags);
}
    66a8:	48 83 c4 08          	add    $0x8,%rsp
    66ac:	5b                   	pop    %rbx
    66ad:	41 5c                	pop    %r12
    66af:	41 5d                	pop    %r13
    66b1:	41 5e                	pop    %r14
    66b3:	5d                   	pop    %rbp
    66b4:	c3                   	retq   
	if (adapter->link_speed == 0)
		return;
	if (pci_channel_offline(pdev))
		return;

	spin_lock_irqsave(&adapter->stats_lock, flags);
    66b5:	4c 8d af 1c 02 00 00 	lea    0x21c(%rdi),%r13
    66bc:	4c 89 ef             	mov    %r13,%rdi
    66bf:	e8 00 00 00 00       	callq  66c4 <e1000_update_stats+0x54>
	/* these counters are modified from e1000_tbi_adjust_stats,
	 * called from the interrupt context, so they must only
	 * be written while holding adapter->stats_lock
	 */

	adapter->stats.crcerrs += er32(CRCERRS);
    66c4:	48 8b 93 e0 04 00 00 	mov    0x4e0(%rbx),%rdx
	if (adapter->link_speed == 0)
		return;
	if (pci_channel_offline(pdev))
		return;

	spin_lock_irqsave(&adapter->stats_lock, flags);
    66cb:	49 89 c6             	mov    %rax,%r14
	/* these counters are modified from e1000_tbi_adjust_stats,
	 * called from the interrupt context, so they must only
	 * be written while holding adapter->stats_lock
	 */

	adapter->stats.crcerrs += er32(CRCERRS);
    66ce:	48 8b 83 c0 03 00 00 	mov    0x3c0(%rbx),%rax
    66d5:	8b 80 00 40 00 00    	mov    0x4000(%rax),%eax
    66db:	89 c0                	mov    %eax,%eax
    66dd:	48 01 d0             	add    %rdx,%rax
	adapter->stats.gprc += er32(GPRC);
    66e0:	48 8b 93 b8 05 00 00 	mov    0x5b8(%rbx),%rdx
	/* these counters are modified from e1000_tbi_adjust_stats,
	 * called from the interrupt context, so they must only
	 * be written while holding adapter->stats_lock
	 */

	adapter->stats.crcerrs += er32(CRCERRS);
    66e7:	48 89 83 e0 04 00 00 	mov    %rax,0x4e0(%rbx)
	adapter->stats.gprc += er32(GPRC);
    66ee:	48 8b 83 c0 03 00 00 	mov    0x3c0(%rbx),%rax
    66f5:	8b 80 74 40 00 00    	mov    0x4074(%rax),%eax
    66fb:	89 c0                	mov    %eax,%eax
    66fd:	48 01 d0             	add    %rdx,%rax
	adapter->stats.gorcl += er32(GORCL);
    6700:	48 8b 93 d8 05 00 00 	mov    0x5d8(%rbx),%rdx
	 * called from the interrupt context, so they must only
	 * be written while holding adapter->stats_lock
	 */

	adapter->stats.crcerrs += er32(CRCERRS);
	adapter->stats.gprc += er32(GPRC);
    6707:	48 89 83 b8 05 00 00 	mov    %rax,0x5b8(%rbx)
	adapter->stats.gorcl += er32(GORCL);
    670e:	48 8b 83 c0 03 00 00 	mov    0x3c0(%rbx),%rax
    6715:	8b 80 88 40 00 00    	mov    0x4088(%rax),%eax
    671b:	89 c0                	mov    %eax,%eax
    671d:	48 01 d0             	add    %rdx,%rax
	adapter->stats.gorch += er32(GORCH);
    6720:	48 8b 93 e0 05 00 00 	mov    0x5e0(%rbx),%rdx
	 * be written while holding adapter->stats_lock
	 */

	adapter->stats.crcerrs += er32(CRCERRS);
	adapter->stats.gprc += er32(GPRC);
	adapter->stats.gorcl += er32(GORCL);
    6727:	48 89 83 d8 05 00 00 	mov    %rax,0x5d8(%rbx)
	adapter->stats.gorch += er32(GORCH);
    672e:	48 8b 83 c0 03 00 00 	mov    0x3c0(%rbx),%rax
    6735:	8b 80 8c 40 00 00    	mov    0x408c(%rax),%eax
    673b:	89 c0                	mov    %eax,%eax
    673d:	48 01 d0             	add    %rdx,%rax
	adapter->stats.bprc += er32(BPRC);
    6740:	48 8b 93 c0 05 00 00 	mov    0x5c0(%rbx),%rdx
	 */

	adapter->stats.crcerrs += er32(CRCERRS);
	adapter->stats.gprc += er32(GPRC);
	adapter->stats.gorcl += er32(GORCL);
	adapter->stats.gorch += er32(GORCH);
    6747:	48 89 83 e0 05 00 00 	mov    %rax,0x5e0(%rbx)
	adapter->stats.bprc += er32(BPRC);
    674e:	48 8b 83 c0 03 00 00 	mov    0x3c0(%rbx),%rax
    6755:	8b 80 78 40 00 00    	mov    0x4078(%rax),%eax
    675b:	89 c0                	mov    %eax,%eax
    675d:	48 01 d0             	add    %rdx,%rax
	adapter->stats.mprc += er32(MPRC);
    6760:	48 8b 93 c8 05 00 00 	mov    0x5c8(%rbx),%rdx

	adapter->stats.crcerrs += er32(CRCERRS);
	adapter->stats.gprc += er32(GPRC);
	adapter->stats.gorcl += er32(GORCL);
	adapter->stats.gorch += er32(GORCH);
	adapter->stats.bprc += er32(BPRC);
    6767:	48 89 83 c0 05 00 00 	mov    %rax,0x5c0(%rbx)
	adapter->stats.mprc += er32(MPRC);
    676e:	48 8b 83 c0 03 00 00 	mov    0x3c0(%rbx),%rax
    6775:	8b 80 7c 40 00 00    	mov    0x407c(%rax),%eax
    677b:	89 c0                	mov    %eax,%eax
    677d:	48 01 d0             	add    %rdx,%rax
	adapter->stats.roc += er32(ROC);
    6780:	48 8b 93 10 06 00 00 	mov    0x610(%rbx),%rdx
	adapter->stats.crcerrs += er32(CRCERRS);
	adapter->stats.gprc += er32(GPRC);
	adapter->stats.gorcl += er32(GORCL);
	adapter->stats.gorch += er32(GORCH);
	adapter->stats.bprc += er32(BPRC);
	adapter->stats.mprc += er32(MPRC);
    6787:	48 89 83 c8 05 00 00 	mov    %rax,0x5c8(%rbx)
	adapter->stats.roc += er32(ROC);
    678e:	48 8b 83 c0 03 00 00 	mov    0x3c0(%rbx),%rax
    6795:	8b 80 ac 40 00 00    	mov    0x40ac(%rax),%eax
    679b:	89 c0                	mov    %eax,%eax
    679d:	48 01 d0             	add    %rdx,%rax

	adapter->stats.prc64 += er32(PRC64);
    67a0:	48 8b 93 88 05 00 00 	mov    0x588(%rbx),%rdx
	adapter->stats.gprc += er32(GPRC);
	adapter->stats.gorcl += er32(GORCL);
	adapter->stats.gorch += er32(GORCH);
	adapter->stats.bprc += er32(BPRC);
	adapter->stats.mprc += er32(MPRC);
	adapter->stats.roc += er32(ROC);
    67a7:	48 89 83 10 06 00 00 	mov    %rax,0x610(%rbx)

	adapter->stats.prc64 += er32(PRC64);
    67ae:	48 8b 83 c0 03 00 00 	mov    0x3c0(%rbx),%rax
    67b5:	8b 80 5c 40 00 00    	mov    0x405c(%rax),%eax
    67bb:	89 c0                	mov    %eax,%eax
    67bd:	48 01 d0             	add    %rdx,%rax
	adapter->stats.prc127 += er32(PRC127);
    67c0:	48 8b 93 90 05 00 00 	mov    0x590(%rbx),%rdx
	adapter->stats.gorch += er32(GORCH);
	adapter->stats.bprc += er32(BPRC);
	adapter->stats.mprc += er32(MPRC);
	adapter->stats.roc += er32(ROC);

	adapter->stats.prc64 += er32(PRC64);
    67c7:	48 89 83 88 05 00 00 	mov    %rax,0x588(%rbx)
	adapter->stats.prc127 += er32(PRC127);
    67ce:	48 8b 83 c0 03 00 00 	mov    0x3c0(%rbx),%rax
    67d5:	8b 80 60 40 00 00    	mov    0x4060(%rax),%eax
    67db:	89 c0                	mov    %eax,%eax
    67dd:	48 01 d0             	add    %rdx,%rax
	adapter->stats.prc255 += er32(PRC255);
    67e0:	48 8b 93 98 05 00 00 	mov    0x598(%rbx),%rdx
	adapter->stats.bprc += er32(BPRC);
	adapter->stats.mprc += er32(MPRC);
	adapter->stats.roc += er32(ROC);

	adapter->stats.prc64 += er32(PRC64);
	adapter->stats.prc127 += er32(PRC127);
    67e7:	48 89 83 90 05 00 00 	mov    %rax,0x590(%rbx)
	adapter->stats.prc255 += er32(PRC255);
    67ee:	48 8b 83 c0 03 00 00 	mov    0x3c0(%rbx),%rax
    67f5:	8b 80 64 40 00 00    	mov    0x4064(%rax),%eax
    67fb:	89 c0                	mov    %eax,%eax
    67fd:	48 01 d0             	add    %rdx,%rax
	adapter->stats.prc511 += er32(PRC511);
    6800:	48 8b 93 a0 05 00 00 	mov    0x5a0(%rbx),%rdx
	adapter->stats.mprc += er32(MPRC);
	adapter->stats.roc += er32(ROC);

	adapter->stats.prc64 += er32(PRC64);
	adapter->stats.prc127 += er32(PRC127);
	adapter->stats.prc255 += er32(PRC255);
    6807:	48 89 83 98 05 00 00 	mov    %rax,0x598(%rbx)
	adapter->stats.prc511 += er32(PRC511);
    680e:	48 8b 83 c0 03 00 00 	mov    0x3c0(%rbx),%rax
    6815:	8b 80 68 40 00 00    	mov    0x4068(%rax),%eax
    681b:	89 c0                	mov    %eax,%eax
    681d:	48 01 d0             	add    %rdx,%rax
	adapter->stats.prc1023 += er32(PRC1023);
    6820:	48 8b 93 a8 05 00 00 	mov    0x5a8(%rbx),%rdx
	adapter->stats.roc += er32(ROC);

	adapter->stats.prc64 += er32(PRC64);
	adapter->stats.prc127 += er32(PRC127);
	adapter->stats.prc255 += er32(PRC255);
	adapter->stats.prc511 += er32(PRC511);
    6827:	48 89 83 a0 05 00 00 	mov    %rax,0x5a0(%rbx)
	adapter->stats.prc1023 += er32(PRC1023);
    682e:	48 8b 83 c0 03 00 00 	mov    0x3c0(%rbx),%rax
    6835:	8b 80 6c 40 00 00    	mov    0x406c(%rax),%eax
    683b:	89 c0                	mov    %eax,%eax
    683d:	48 01 d0             	add    %rdx,%rax
	adapter->stats.prc1522 += er32(PRC1522);
    6840:	48 8b 93 b0 05 00 00 	mov    0x5b0(%rbx),%rdx

	adapter->stats.prc64 += er32(PRC64);
	adapter->stats.prc127 += er32(PRC127);
	adapter->stats.prc255 += er32(PRC255);
	adapter->stats.prc511 += er32(PRC511);
	adapter->stats.prc1023 += er32(PRC1023);
    6847:	48 89 83 a8 05 00 00 	mov    %rax,0x5a8(%rbx)
	adapter->stats.prc1522 += er32(PRC1522);
    684e:	48 8b 83 c0 03 00 00 	mov    0x3c0(%rbx),%rax
    6855:	8b 80 70 40 00 00    	mov    0x4070(%rax),%eax
    685b:	89 c0                	mov    %eax,%eax
    685d:	48 01 d0             	add    %rdx,%rax

	adapter->stats.symerrs += er32(SYMERRS);
    6860:	48 8b 93 f0 04 00 00 	mov    0x4f0(%rbx),%rdx
	adapter->stats.prc64 += er32(PRC64);
	adapter->stats.prc127 += er32(PRC127);
	adapter->stats.prc255 += er32(PRC255);
	adapter->stats.prc511 += er32(PRC511);
	adapter->stats.prc1023 += er32(PRC1023);
	adapter->stats.prc1522 += er32(PRC1522);
    6867:	48 89 83 b0 05 00 00 	mov    %rax,0x5b0(%rbx)

	adapter->stats.symerrs += er32(SYMERRS);
    686e:	48 8b 83 c0 03 00 00 	mov    0x3c0(%rbx),%rax
    6875:	8b 80 08 40 00 00    	mov    0x4008(%rax),%eax
    687b:	89 c0                	mov    %eax,%eax
    687d:	48 01 d0             	add    %rdx,%rax
	adapter->stats.mpc += er32(MPC);
    6880:	48 8b 93 08 05 00 00 	mov    0x508(%rbx),%rdx
	adapter->stats.prc255 += er32(PRC255);
	adapter->stats.prc511 += er32(PRC511);
	adapter->stats.prc1023 += er32(PRC1023);
	adapter->stats.prc1522 += er32(PRC1522);

	adapter->stats.symerrs += er32(SYMERRS);
    6887:	48 89 83 f0 04 00 00 	mov    %rax,0x4f0(%rbx)
	adapter->stats.mpc += er32(MPC);
    688e:	48 8b 83 c0 03 00 00 	mov    0x3c0(%rbx),%rax
    6895:	8b 80 10 40 00 00    	mov    0x4010(%rax),%eax
    689b:	89 c0                	mov    %eax,%eax
    689d:	48 01 d0             	add    %rdx,%rax
	adapter->stats.scc += er32(SCC);
    68a0:	48 8b 93 10 05 00 00 	mov    0x510(%rbx),%rdx
	adapter->stats.prc511 += er32(PRC511);
	adapter->stats.prc1023 += er32(PRC1023);
	adapter->stats.prc1522 += er32(PRC1522);

	adapter->stats.symerrs += er32(SYMERRS);
	adapter->stats.mpc += er32(MPC);
    68a7:	48 89 83 08 05 00 00 	mov    %rax,0x508(%rbx)
	adapter->stats.scc += er32(SCC);
    68ae:	48 8b 83 c0 03 00 00 	mov    0x3c0(%rbx),%rax
    68b5:	8b 80 14 40 00 00    	mov    0x4014(%rax),%eax
    68bb:	89 c0                	mov    %eax,%eax
    68bd:	48 01 d0             	add    %rdx,%rax
	adapter->stats.ecol += er32(ECOL);
    68c0:	48 8b 93 18 05 00 00 	mov    0x518(%rbx),%rdx
	adapter->stats.prc1023 += er32(PRC1023);
	adapter->stats.prc1522 += er32(PRC1522);

	adapter->stats.symerrs += er32(SYMERRS);
	adapter->stats.mpc += er32(MPC);
	adapter->stats.scc += er32(SCC);
    68c7:	48 89 83 10 05 00 00 	mov    %rax,0x510(%rbx)
	adapter->stats.ecol += er32(ECOL);
    68ce:	48 8b 83 c0 03 00 00 	mov    0x3c0(%rbx),%rax
    68d5:	8b 80 18 40 00 00    	mov    0x4018(%rax),%eax
    68db:	89 c0                	mov    %eax,%eax
    68dd:	48 01 d0             	add    %rdx,%rax
	adapter->stats.mcc += er32(MCC);
    68e0:	48 8b 93 20 05 00 00 	mov    0x520(%rbx),%rdx
	adapter->stats.prc1522 += er32(PRC1522);

	adapter->stats.symerrs += er32(SYMERRS);
	adapter->stats.mpc += er32(MPC);
	adapter->stats.scc += er32(SCC);
	adapter->stats.ecol += er32(ECOL);
    68e7:	48 89 83 18 05 00 00 	mov    %rax,0x518(%rbx)
	adapter->stats.mcc += er32(MCC);
    68ee:	48 8b 83 c0 03 00 00 	mov    0x3c0(%rbx),%rax
    68f5:	8b 80 1c 40 00 00    	mov    0x401c(%rax),%eax
    68fb:	89 c0                	mov    %eax,%eax
    68fd:	48 01 d0             	add    %rdx,%rax
	adapter->stats.latecol += er32(LATECOL);
    6900:	48 8b 93 28 05 00 00 	mov    0x528(%rbx),%rdx

	adapter->stats.symerrs += er32(SYMERRS);
	adapter->stats.mpc += er32(MPC);
	adapter->stats.scc += er32(SCC);
	adapter->stats.ecol += er32(ECOL);
	adapter->stats.mcc += er32(MCC);
    6907:	48 89 83 20 05 00 00 	mov    %rax,0x520(%rbx)
	adapter->stats.latecol += er32(LATECOL);
    690e:	48 8b 83 c0 03 00 00 	mov    0x3c0(%rbx),%rax
    6915:	8b 80 20 40 00 00    	mov    0x4020(%rax),%eax
    691b:	89 c0                	mov    %eax,%eax
    691d:	48 01 d0             	add    %rdx,%rax
	adapter->stats.dc += er32(DC);
    6920:	48 8b 93 38 05 00 00 	mov    0x538(%rbx),%rdx
	adapter->stats.symerrs += er32(SYMERRS);
	adapter->stats.mpc += er32(MPC);
	adapter->stats.scc += er32(SCC);
	adapter->stats.ecol += er32(ECOL);
	adapter->stats.mcc += er32(MCC);
	adapter->stats.latecol += er32(LATECOL);
    6927:	48 89 83 28 05 00 00 	mov    %rax,0x528(%rbx)
	adapter->stats.dc += er32(DC);
    692e:	48 8b 83 c0 03 00 00 	mov    0x3c0(%rbx),%rax
    6935:	8b 80 30 40 00 00    	mov    0x4030(%rax),%eax
    693b:	89 c0                	mov    %eax,%eax
    693d:	48 01 d0             	add    %rdx,%rax
	adapter->stats.sec += er32(SEC);
    6940:	48 8b 93 48 05 00 00 	mov    0x548(%rbx),%rdx
	adapter->stats.mpc += er32(MPC);
	adapter->stats.scc += er32(SCC);
	adapter->stats.ecol += er32(ECOL);
	adapter->stats.mcc += er32(MCC);
	adapter->stats.latecol += er32(LATECOL);
	adapter->stats.dc += er32(DC);
    6947:	48 89 83 38 05 00 00 	mov    %rax,0x538(%rbx)
	adapter->stats.sec += er32(SEC);
    694e:	48 8b 83 c0 03 00 00 	mov    0x3c0(%rbx),%rax
    6955:	8b 80 38 40 00 00    	mov    0x4038(%rax),%eax
    695b:	89 c0                	mov    %eax,%eax
    695d:	48 01 d0             	add    %rdx,%rax
	adapter->stats.rlec += er32(RLEC);
    6960:	48 8b 93 58 05 00 00 	mov    0x558(%rbx),%rdx
	adapter->stats.scc += er32(SCC);
	adapter->stats.ecol += er32(ECOL);
	adapter->stats.mcc += er32(MCC);
	adapter->stats.latecol += er32(LATECOL);
	adapter->stats.dc += er32(DC);
	adapter->stats.sec += er32(SEC);
    6967:	48 89 83 48 05 00 00 	mov    %rax,0x548(%rbx)
	adapter->stats.rlec += er32(RLEC);
    696e:	48 8b 83 c0 03 00 00 	mov    0x3c0(%rbx),%rax
    6975:	8b 80 40 40 00 00    	mov    0x4040(%rax),%eax
    697b:	89 c0                	mov    %eax,%eax
    697d:	48 01 d0             	add    %rdx,%rax
	adapter->stats.xonrxc += er32(XONRXC);
    6980:	48 8b 93 60 05 00 00 	mov    0x560(%rbx),%rdx
	adapter->stats.ecol += er32(ECOL);
	adapter->stats.mcc += er32(MCC);
	adapter->stats.latecol += er32(LATECOL);
	adapter->stats.dc += er32(DC);
	adapter->stats.sec += er32(SEC);
	adapter->stats.rlec += er32(RLEC);
    6987:	48 89 83 58 05 00 00 	mov    %rax,0x558(%rbx)
	adapter->stats.xonrxc += er32(XONRXC);
    698e:	48 8b 83 c0 03 00 00 	mov    0x3c0(%rbx),%rax
    6995:	8b 80 48 40 00 00    	mov    0x4048(%rax),%eax
    699b:	89 c0                	mov    %eax,%eax
    699d:	48 01 d0             	add    %rdx,%rax
	adapter->stats.xontxc += er32(XONTXC);
    69a0:	48 8b 93 68 05 00 00 	mov    0x568(%rbx),%rdx
	adapter->stats.mcc += er32(MCC);
	adapter->stats.latecol += er32(LATECOL);
	adapter->stats.dc += er32(DC);
	adapter->stats.sec += er32(SEC);
	adapter->stats.rlec += er32(RLEC);
	adapter->stats.xonrxc += er32(XONRXC);
    69a7:	48 89 83 60 05 00 00 	mov    %rax,0x560(%rbx)
	adapter->stats.xontxc += er32(XONTXC);
    69ae:	48 8b 83 c0 03 00 00 	mov    0x3c0(%rbx),%rax
    69b5:	8b 80 4c 40 00 00    	mov    0x404c(%rax),%eax
    69bb:	89 c0                	mov    %eax,%eax
    69bd:	48 01 d0             	add    %rdx,%rax
	adapter->stats.xoffrxc += er32(XOFFRXC);
    69c0:	48 8b 93 70 05 00 00 	mov    0x570(%rbx),%rdx
	adapter->stats.latecol += er32(LATECOL);
	adapter->stats.dc += er32(DC);
	adapter->stats.sec += er32(SEC);
	adapter->stats.rlec += er32(RLEC);
	adapter->stats.xonrxc += er32(XONRXC);
	adapter->stats.xontxc += er32(XONTXC);
    69c7:	48 89 83 68 05 00 00 	mov    %rax,0x568(%rbx)
	adapter->stats.xoffrxc += er32(XOFFRXC);
    69ce:	48 8b 83 c0 03 00 00 	mov    0x3c0(%rbx),%rax
    69d5:	8b 80 50 40 00 00    	mov    0x4050(%rax),%eax
    69db:	89 c0                	mov    %eax,%eax
    69dd:	48 01 d0             	add    %rdx,%rax
	adapter->stats.xofftxc += er32(XOFFTXC);
    69e0:	48 8b 93 78 05 00 00 	mov    0x578(%rbx),%rdx
	adapter->stats.dc += er32(DC);
	adapter->stats.sec += er32(SEC);
	adapter->stats.rlec += er32(RLEC);
	adapter->stats.xonrxc += er32(XONRXC);
	adapter->stats.xontxc += er32(XONTXC);
	adapter->stats.xoffrxc += er32(XOFFRXC);
    69e7:	48 89 83 70 05 00 00 	mov    %rax,0x570(%rbx)
	adapter->stats.xofftxc += er32(XOFFTXC);
    69ee:	48 8b 83 c0 03 00 00 	mov    0x3c0(%rbx),%rax
    69f5:	8b 80 54 40 00 00    	mov    0x4054(%rax),%eax
    69fb:	89 c0                	mov    %eax,%eax
    69fd:	48 01 d0             	add    %rdx,%rax
	adapter->stats.fcruc += er32(FCRUC);
    6a00:	48 8b 93 80 05 00 00 	mov    0x580(%rbx),%rdx
	adapter->stats.sec += er32(SEC);
	adapter->stats.rlec += er32(RLEC);
	adapter->stats.xonrxc += er32(XONRXC);
	adapter->stats.xontxc += er32(XONTXC);
	adapter->stats.xoffrxc += er32(XOFFRXC);
	adapter->stats.xofftxc += er32(XOFFTXC);
    6a07:	48 89 83 78 05 00 00 	mov    %rax,0x578(%rbx)
	adapter->stats.fcruc += er32(FCRUC);
    6a0e:	48 8b 83 c0 03 00 00 	mov    0x3c0(%rbx),%rax
    6a15:	8b 80 58 40 00 00    	mov    0x4058(%rax),%eax
    6a1b:	89 c0                	mov    %eax,%eax
    6a1d:	48 01 d0             	add    %rdx,%rax
	adapter->stats.gptc += er32(GPTC);
    6a20:	48 8b 93 d0 05 00 00 	mov    0x5d0(%rbx),%rdx
	adapter->stats.rlec += er32(RLEC);
	adapter->stats.xonrxc += er32(XONRXC);
	adapter->stats.xontxc += er32(XONTXC);
	adapter->stats.xoffrxc += er32(XOFFRXC);
	adapter->stats.xofftxc += er32(XOFFTXC);
	adapter->stats.fcruc += er32(FCRUC);
    6a27:	48 89 83 80 05 00 00 	mov    %rax,0x580(%rbx)
	adapter->stats.gptc += er32(GPTC);
    6a2e:	48 8b 83 c0 03 00 00 	mov    0x3c0(%rbx),%rax
    6a35:	8b 80 80 40 00 00    	mov    0x4080(%rax),%eax
    6a3b:	89 c0                	mov    %eax,%eax
    6a3d:	48 01 d0             	add    %rdx,%rax
	adapter->stats.gotcl += er32(GOTCL);
    6a40:	48 8b 93 e8 05 00 00 	mov    0x5e8(%rbx),%rdx
	adapter->stats.xonrxc += er32(XONRXC);
	adapter->stats.xontxc += er32(XONTXC);
	adapter->stats.xoffrxc += er32(XOFFRXC);
	adapter->stats.xofftxc += er32(XOFFTXC);
	adapter->stats.fcruc += er32(FCRUC);
	adapter->stats.gptc += er32(GPTC);
    6a47:	48 89 83 d0 05 00 00 	mov    %rax,0x5d0(%rbx)
	adapter->stats.gotcl += er32(GOTCL);
    6a4e:	48 8b 83 c0 03 00 00 	mov    0x3c0(%rbx),%rax
    6a55:	8b 80 90 40 00 00    	mov    0x4090(%rax),%eax
    6a5b:	89 c0                	mov    %eax,%eax
    6a5d:	48 01 d0             	add    %rdx,%rax
	adapter->stats.gotch += er32(GOTCH);
    6a60:	48 8b 93 f0 05 00 00 	mov    0x5f0(%rbx),%rdx
	adapter->stats.xontxc += er32(XONTXC);
	adapter->stats.xoffrxc += er32(XOFFRXC);
	adapter->stats.xofftxc += er32(XOFFTXC);
	adapter->stats.fcruc += er32(FCRUC);
	adapter->stats.gptc += er32(GPTC);
	adapter->stats.gotcl += er32(GOTCL);
    6a67:	48 89 83 e8 05 00 00 	mov    %rax,0x5e8(%rbx)
	adapter->stats.gotch += er32(GOTCH);
    6a6e:	48 8b 83 c0 03 00 00 	mov    0x3c0(%rbx),%rax
    6a75:	8b 80 94 40 00 00    	mov    0x4094(%rax),%eax
    6a7b:	89 c0                	mov    %eax,%eax
    6a7d:	48 01 d0             	add    %rdx,%rax
	adapter->stats.rnbc += er32(RNBC);
    6a80:	48 8b 93 f8 05 00 00 	mov    0x5f8(%rbx),%rdx
	adapter->stats.xoffrxc += er32(XOFFRXC);
	adapter->stats.xofftxc += er32(XOFFTXC);
	adapter->stats.fcruc += er32(FCRUC);
	adapter->stats.gptc += er32(GPTC);
	adapter->stats.gotcl += er32(GOTCL);
	adapter->stats.gotch += er32(GOTCH);
    6a87:	48 89 83 f0 05 00 00 	mov    %rax,0x5f0(%rbx)
	adapter->stats.rnbc += er32(RNBC);
    6a8e:	48 8b 83 c0 03 00 00 	mov    0x3c0(%rbx),%rax
    6a95:	8b 80 a0 40 00 00    	mov    0x40a0(%rax),%eax
    6a9b:	89 c0                	mov    %eax,%eax
    6a9d:	48 01 d0             	add    %rdx,%rax
	adapter->stats.ruc += er32(RUC);
    6aa0:	48 8b 93 00 06 00 00 	mov    0x600(%rbx),%rdx
	adapter->stats.xofftxc += er32(XOFFTXC);
	adapter->stats.fcruc += er32(FCRUC);
	adapter->stats.gptc += er32(GPTC);
	adapter->stats.gotcl += er32(GOTCL);
	adapter->stats.gotch += er32(GOTCH);
	adapter->stats.rnbc += er32(RNBC);
    6aa7:	48 89 83 f8 05 00 00 	mov    %rax,0x5f8(%rbx)
	adapter->stats.ruc += er32(RUC);
    6aae:	48 8b 83 c0 03 00 00 	mov    0x3c0(%rbx),%rax
    6ab5:	8b 80 a4 40 00 00    	mov    0x40a4(%rax),%eax
    6abb:	89 c0                	mov    %eax,%eax
    6abd:	48 01 d0             	add    %rdx,%rax
	adapter->stats.rfc += er32(RFC);
    6ac0:	48 8b 93 08 06 00 00 	mov    0x608(%rbx),%rdx
	adapter->stats.fcruc += er32(FCRUC);
	adapter->stats.gptc += er32(GPTC);
	adapter->stats.gotcl += er32(GOTCL);
	adapter->stats.gotch += er32(GOTCH);
	adapter->stats.rnbc += er32(RNBC);
	adapter->stats.ruc += er32(RUC);
    6ac7:	48 89 83 00 06 00 00 	mov    %rax,0x600(%rbx)
	adapter->stats.rfc += er32(RFC);
    6ace:	48 8b 83 c0 03 00 00 	mov    0x3c0(%rbx),%rax
    6ad5:	8b 80 a8 40 00 00    	mov    0x40a8(%rax),%eax
    6adb:	89 c0                	mov    %eax,%eax
    6add:	48 01 d0             	add    %rdx,%rax
	adapter->stats.rjc += er32(RJC);
    6ae0:	48 8b 93 20 06 00 00 	mov    0x620(%rbx),%rdx
	adapter->stats.gptc += er32(GPTC);
	adapter->stats.gotcl += er32(GOTCL);
	adapter->stats.gotch += er32(GOTCH);
	adapter->stats.rnbc += er32(RNBC);
	adapter->stats.ruc += er32(RUC);
	adapter->stats.rfc += er32(RFC);
    6ae7:	48 89 83 08 06 00 00 	mov    %rax,0x608(%rbx)
	adapter->stats.rjc += er32(RJC);
    6aee:	48 8b 83 c0 03 00 00 	mov    0x3c0(%rbx),%rax
    6af5:	8b 80 b0 40 00 00    	mov    0x40b0(%rax),%eax
    6afb:	89 c0                	mov    %eax,%eax
    6afd:	48 01 d0             	add    %rdx,%rax
	adapter->stats.torl += er32(TORL);
    6b00:	48 8b 93 40 06 00 00 	mov    0x640(%rbx),%rdx
	adapter->stats.gotcl += er32(GOTCL);
	adapter->stats.gotch += er32(GOTCH);
	adapter->stats.rnbc += er32(RNBC);
	adapter->stats.ruc += er32(RUC);
	adapter->stats.rfc += er32(RFC);
	adapter->stats.rjc += er32(RJC);
    6b07:	48 89 83 20 06 00 00 	mov    %rax,0x620(%rbx)
	adapter->stats.torl += er32(TORL);
    6b0e:	48 8b 83 c0 03 00 00 	mov    0x3c0(%rbx),%rax
    6b15:	8b 80 c0 40 00 00    	mov    0x40c0(%rax),%eax
    6b1b:	89 c0                	mov    %eax,%eax
    6b1d:	48 01 d0             	add    %rdx,%rax
	adapter->stats.torh += er32(TORH);
    6b20:	48 8b 93 48 06 00 00 	mov    0x648(%rbx),%rdx
	adapter->stats.gotch += er32(GOTCH);
	adapter->stats.rnbc += er32(RNBC);
	adapter->stats.ruc += er32(RUC);
	adapter->stats.rfc += er32(RFC);
	adapter->stats.rjc += er32(RJC);
	adapter->stats.torl += er32(TORL);
    6b27:	48 89 83 40 06 00 00 	mov    %rax,0x640(%rbx)
	adapter->stats.torh += er32(TORH);
    6b2e:	48 8b 83 c0 03 00 00 	mov    0x3c0(%rbx),%rax
    6b35:	8b 80 c4 40 00 00    	mov    0x40c4(%rax),%eax
    6b3b:	89 c0                	mov    %eax,%eax
    6b3d:	48 01 d0             	add    %rdx,%rax
	adapter->stats.totl += er32(TOTL);
    6b40:	48 8b 93 50 06 00 00 	mov    0x650(%rbx),%rdx
	adapter->stats.rnbc += er32(RNBC);
	adapter->stats.ruc += er32(RUC);
	adapter->stats.rfc += er32(RFC);
	adapter->stats.rjc += er32(RJC);
	adapter->stats.torl += er32(TORL);
	adapter->stats.torh += er32(TORH);
    6b47:	48 89 83 48 06 00 00 	mov    %rax,0x648(%rbx)
	adapter->stats.totl += er32(TOTL);
    6b4e:	48 8b 83 c0 03 00 00 	mov    0x3c0(%rbx),%rax
    6b55:	8b 80 c8 40 00 00    	mov    0x40c8(%rax),%eax
    6b5b:	89 c0                	mov    %eax,%eax
    6b5d:	48 01 d0             	add    %rdx,%rax
	adapter->stats.toth += er32(TOTH);
    6b60:	48 8b 93 58 06 00 00 	mov    0x658(%rbx),%rdx
	adapter->stats.ruc += er32(RUC);
	adapter->stats.rfc += er32(RFC);
	adapter->stats.rjc += er32(RJC);
	adapter->stats.torl += er32(TORL);
	adapter->stats.torh += er32(TORH);
	adapter->stats.totl += er32(TOTL);
    6b67:	48 89 83 50 06 00 00 	mov    %rax,0x650(%rbx)
	adapter->stats.toth += er32(TOTH);
    6b6e:	48 8b 83 c0 03 00 00 	mov    0x3c0(%rbx),%rax
    6b75:	8b 80 cc 40 00 00    	mov    0x40cc(%rax),%eax
    6b7b:	89 c0                	mov    %eax,%eax
    6b7d:	48 01 d0             	add    %rdx,%rax
	adapter->stats.tpr += er32(TPR);
    6b80:	48 8b 93 60 06 00 00 	mov    0x660(%rbx),%rdx
	adapter->stats.rfc += er32(RFC);
	adapter->stats.rjc += er32(RJC);
	adapter->stats.torl += er32(TORL);
	adapter->stats.torh += er32(TORH);
	adapter->stats.totl += er32(TOTL);
	adapter->stats.toth += er32(TOTH);
    6b87:	48 89 83 58 06 00 00 	mov    %rax,0x658(%rbx)
	adapter->stats.tpr += er32(TPR);
    6b8e:	48 8b 83 c0 03 00 00 	mov    0x3c0(%rbx),%rax
    6b95:	8b 80 d0 40 00 00    	mov    0x40d0(%rax),%eax
    6b9b:	89 c0                	mov    %eax,%eax
    6b9d:	48 01 d0             	add    %rdx,%rax

	adapter->stats.ptc64 += er32(PTC64);
    6ba0:	48 8b 93 70 06 00 00 	mov    0x670(%rbx),%rdx
	adapter->stats.rjc += er32(RJC);
	adapter->stats.torl += er32(TORL);
	adapter->stats.torh += er32(TORH);
	adapter->stats.totl += er32(TOTL);
	adapter->stats.toth += er32(TOTH);
	adapter->stats.tpr += er32(TPR);
    6ba7:	48 89 83 60 06 00 00 	mov    %rax,0x660(%rbx)

	adapter->stats.ptc64 += er32(PTC64);
    6bae:	48 8b 83 c0 03 00 00 	mov    0x3c0(%rbx),%rax
    6bb5:	8b 80 d8 40 00 00    	mov    0x40d8(%rax),%eax
    6bbb:	89 c0                	mov    %eax,%eax
    6bbd:	48 01 d0             	add    %rdx,%rax
	adapter->stats.ptc127 += er32(PTC127);
    6bc0:	48 8b 93 78 06 00 00 	mov    0x678(%rbx),%rdx
	adapter->stats.torh += er32(TORH);
	adapter->stats.totl += er32(TOTL);
	adapter->stats.toth += er32(TOTH);
	adapter->stats.tpr += er32(TPR);

	adapter->stats.ptc64 += er32(PTC64);
    6bc7:	48 89 83 70 06 00 00 	mov    %rax,0x670(%rbx)
	adapter->stats.ptc127 += er32(PTC127);
    6bce:	48 8b 83 c0 03 00 00 	mov    0x3c0(%rbx),%rax
    6bd5:	8b 80 dc 40 00 00    	mov    0x40dc(%rax),%eax
    6bdb:	89 c0                	mov    %eax,%eax
    6bdd:	48 01 d0             	add    %rdx,%rax
	adapter->stats.ptc255 += er32(PTC255);
    6be0:	48 8b 93 80 06 00 00 	mov    0x680(%rbx),%rdx
	adapter->stats.totl += er32(TOTL);
	adapter->stats.toth += er32(TOTH);
	adapter->stats.tpr += er32(TPR);

	adapter->stats.ptc64 += er32(PTC64);
	adapter->stats.ptc127 += er32(PTC127);
    6be7:	48 89 83 78 06 00 00 	mov    %rax,0x678(%rbx)
	adapter->stats.ptc255 += er32(PTC255);
    6bee:	48 8b 83 c0 03 00 00 	mov    0x3c0(%rbx),%rax
    6bf5:	8b 80 e0 40 00 00    	mov    0x40e0(%rax),%eax
    6bfb:	89 c0                	mov    %eax,%eax
    6bfd:	48 01 d0             	add    %rdx,%rax
	adapter->stats.ptc511 += er32(PTC511);
    6c00:	48 8b 93 88 06 00 00 	mov    0x688(%rbx),%rdx
	adapter->stats.toth += er32(TOTH);
	adapter->stats.tpr += er32(TPR);

	adapter->stats.ptc64 += er32(PTC64);
	adapter->stats.ptc127 += er32(PTC127);
	adapter->stats.ptc255 += er32(PTC255);
    6c07:	48 89 83 80 06 00 00 	mov    %rax,0x680(%rbx)
	adapter->stats.ptc511 += er32(PTC511);
    6c0e:	48 8b 83 c0 03 00 00 	mov    0x3c0(%rbx),%rax
    6c15:	8b 80 e4 40 00 00    	mov    0x40e4(%rax),%eax
    6c1b:	89 c0                	mov    %eax,%eax
    6c1d:	48 01 d0             	add    %rdx,%rax
	adapter->stats.ptc1023 += er32(PTC1023);
    6c20:	48 8b 93 90 06 00 00 	mov    0x690(%rbx),%rdx
	adapter->stats.tpr += er32(TPR);

	adapter->stats.ptc64 += er32(PTC64);
	adapter->stats.ptc127 += er32(PTC127);
	adapter->stats.ptc255 += er32(PTC255);
	adapter->stats.ptc511 += er32(PTC511);
    6c27:	48 89 83 88 06 00 00 	mov    %rax,0x688(%rbx)
	adapter->stats.ptc1023 += er32(PTC1023);
    6c2e:	48 8b 83 c0 03 00 00 	mov    0x3c0(%rbx),%rax
    6c35:	8b 80 e8 40 00 00    	mov    0x40e8(%rax),%eax
    6c3b:	89 c0                	mov    %eax,%eax
    6c3d:	48 01 d0             	add    %rdx,%rax
	adapter->stats.ptc1522 += er32(PTC1522);
    6c40:	48 8b 93 98 06 00 00 	mov    0x698(%rbx),%rdx

	adapter->stats.ptc64 += er32(PTC64);
	adapter->stats.ptc127 += er32(PTC127);
	adapter->stats.ptc255 += er32(PTC255);
	adapter->stats.ptc511 += er32(PTC511);
	adapter->stats.ptc1023 += er32(PTC1023);
    6c47:	48 89 83 90 06 00 00 	mov    %rax,0x690(%rbx)
	adapter->stats.ptc1522 += er32(PTC1522);
    6c4e:	48 8b 83 c0 03 00 00 	mov    0x3c0(%rbx),%rax
    6c55:	8b 80 ec 40 00 00    	mov    0x40ec(%rax),%eax
    6c5b:	89 c0                	mov    %eax,%eax
    6c5d:	48 01 d0             	add    %rdx,%rax

	adapter->stats.mptc += er32(MPTC);
    6c60:	48 8b 93 a0 06 00 00 	mov    0x6a0(%rbx),%rdx
	adapter->stats.ptc64 += er32(PTC64);
	adapter->stats.ptc127 += er32(PTC127);
	adapter->stats.ptc255 += er32(PTC255);
	adapter->stats.ptc511 += er32(PTC511);
	adapter->stats.ptc1023 += er32(PTC1023);
	adapter->stats.ptc1522 += er32(PTC1522);
    6c67:	48 89 83 98 06 00 00 	mov    %rax,0x698(%rbx)

	adapter->stats.mptc += er32(MPTC);
    6c6e:	48 8b 83 c0 03 00 00 	mov    0x3c0(%rbx),%rax
    6c75:	8b 80 f0 40 00 00    	mov    0x40f0(%rax),%eax
    6c7b:	89 c0                	mov    %eax,%eax
    6c7d:	48 01 d0             	add    %rdx,%rax
	adapter->stats.bptc += er32(BPTC);
    6c80:	48 8b 93 a8 06 00 00 	mov    0x6a8(%rbx),%rdx
	adapter->stats.ptc255 += er32(PTC255);
	adapter->stats.ptc511 += er32(PTC511);
	adapter->stats.ptc1023 += er32(PTC1023);
	adapter->stats.ptc1522 += er32(PTC1522);

	adapter->stats.mptc += er32(MPTC);
    6c87:	48 89 83 a0 06 00 00 	mov    %rax,0x6a0(%rbx)
	adapter->stats.bptc += er32(BPTC);
    6c8e:	48 8b 83 c0 03 00 00 	mov    0x3c0(%rbx),%rax
    6c95:	8b 80 f4 40 00 00    	mov    0x40f4(%rax),%eax
    6c9b:	89 c0                	mov    %eax,%eax
    6c9d:	48 01 d0             	add    %rdx,%rax
    6ca0:	48 89 83 a8 06 00 00 	mov    %rax,0x6a8(%rbx)

	/* used for adaptive IFS */

	hw->tx_packet_delta = er32(TPT);
    6ca7:	48 8b 83 c0 03 00 00 	mov    0x3c0(%rbx),%rax
    6cae:	8b 90 d4 40 00 00    	mov    0x40d4(%rax),%edx
    6cb4:	89 93 6c 04 00 00    	mov    %edx,0x46c(%rbx)
	adapter->stats.tpt += hw->tx_packet_delta;
	hw->collision_delta = er32(COLC);
    6cba:	48 8b 83 c0 03 00 00 	mov    0x3c0(%rbx),%rax
	adapter->stats.bptc += er32(BPTC);

	/* used for adaptive IFS */

	hw->tx_packet_delta = er32(TPT);
	adapter->stats.tpt += hw->tx_packet_delta;
    6cc1:	89 d2                	mov    %edx,%edx
    6cc3:	48 01 93 68 06 00 00 	add    %rdx,0x668(%rbx)
    6cca:	8b 90 28 40 00 00    	mov    0x4028(%rax),%edx
	hw->collision_delta = er32(COLC);
    6cd0:	89 93 68 04 00 00    	mov    %edx,0x468(%rbx)
	adapter->stats.colc += hw->collision_delta;
    6cd6:	89 d2                	mov    %edx,%edx
    6cd8:	48 01 93 30 05 00 00 	add    %rdx,0x530(%rbx)

	if (hw->mac_type >= e1000_82543) {
    6cdf:	83 bb d8 03 00 00 02 	cmpl   $0x2,0x3d8(%rbx)
    6ce6:	0f 86 c0 00 00 00    	jbe    6dac <e1000_update_stats+0x73c>
		adapter->stats.algnerrc += er32(ALGNERRC);
    6cec:	48 8b 93 e8 04 00 00 	mov    0x4e8(%rbx),%rdx
    6cf3:	48 8b 83 c0 03 00 00 	mov    0x3c0(%rbx),%rax
    6cfa:	8b 80 04 40 00 00    	mov    0x4004(%rax),%eax
    6d00:	89 c0                	mov    %eax,%eax
    6d02:	48 01 d0             	add    %rdx,%rax
		adapter->stats.rxerrc += er32(RXERRC);
    6d05:	48 8b 93 f8 04 00 00 	mov    0x4f8(%rbx),%rdx
	adapter->stats.tpt += hw->tx_packet_delta;
	hw->collision_delta = er32(COLC);
	adapter->stats.colc += hw->collision_delta;

	if (hw->mac_type >= e1000_82543) {
		adapter->stats.algnerrc += er32(ALGNERRC);
    6d0c:	48 89 83 e8 04 00 00 	mov    %rax,0x4e8(%rbx)
		adapter->stats.rxerrc += er32(RXERRC);
    6d13:	48 8b 83 c0 03 00 00 	mov    0x3c0(%rbx),%rax
    6d1a:	8b 80 0c 40 00 00    	mov    0x400c(%rax),%eax
    6d20:	89 c0                	mov    %eax,%eax
    6d22:	48 01 d0             	add    %rdx,%rax
		adapter->stats.tncrs += er32(TNCRS);
    6d25:	48 8b 93 40 05 00 00 	mov    0x540(%rbx),%rdx
	hw->collision_delta = er32(COLC);
	adapter->stats.colc += hw->collision_delta;

	if (hw->mac_type >= e1000_82543) {
		adapter->stats.algnerrc += er32(ALGNERRC);
		adapter->stats.rxerrc += er32(RXERRC);
    6d2c:	48 89 83 f8 04 00 00 	mov    %rax,0x4f8(%rbx)
		adapter->stats.tncrs += er32(TNCRS);
    6d33:	48 8b 83 c0 03 00 00 	mov    0x3c0(%rbx),%rax
    6d3a:	8b 80 34 40 00 00    	mov    0x4034(%rax),%eax
    6d40:	89 c0                	mov    %eax,%eax
    6d42:	48 01 d0             	add    %rdx,%rax
		adapter->stats.cexterr += er32(CEXTERR);
    6d45:	48 8b 93 50 05 00 00 	mov    0x550(%rbx),%rdx
	adapter->stats.colc += hw->collision_delta;

	if (hw->mac_type >= e1000_82543) {
		adapter->stats.algnerrc += er32(ALGNERRC);
		adapter->stats.rxerrc += er32(RXERRC);
		adapter->stats.tncrs += er32(TNCRS);
    6d4c:	48 89 83 40 05 00 00 	mov    %rax,0x540(%rbx)
		adapter->stats.cexterr += er32(CEXTERR);
    6d53:	48 8b 83 c0 03 00 00 	mov    0x3c0(%rbx),%rax
    6d5a:	8b 80 3c 40 00 00    	mov    0x403c(%rax),%eax
    6d60:	89 c0                	mov    %eax,%eax
    6d62:	48 01 d0             	add    %rdx,%rax
		adapter->stats.tsctc += er32(TSCTC);
    6d65:	48 8b 93 b0 06 00 00 	mov    0x6b0(%rbx),%rdx

	if (hw->mac_type >= e1000_82543) {
		adapter->stats.algnerrc += er32(ALGNERRC);
		adapter->stats.rxerrc += er32(RXERRC);
		adapter->stats.tncrs += er32(TNCRS);
		adapter->stats.cexterr += er32(CEXTERR);
    6d6c:	48 89 83 50 05 00 00 	mov    %rax,0x550(%rbx)
		adapter->stats.tsctc += er32(TSCTC);
    6d73:	48 8b 83 c0 03 00 00 	mov    0x3c0(%rbx),%rax
    6d7a:	8b 80 f8 40 00 00    	mov    0x40f8(%rax),%eax
    6d80:	89 c0                	mov    %eax,%eax
    6d82:	48 01 d0             	add    %rdx,%rax
		adapter->stats.tsctfc += er32(TSCTFC);
    6d85:	48 8b 93 b8 06 00 00 	mov    0x6b8(%rbx),%rdx
	if (hw->mac_type >= e1000_82543) {
		adapter->stats.algnerrc += er32(ALGNERRC);
		adapter->stats.rxerrc += er32(RXERRC);
		adapter->stats.tncrs += er32(TNCRS);
		adapter->stats.cexterr += er32(CEXTERR);
		adapter->stats.tsctc += er32(TSCTC);
    6d8c:	48 89 83 b0 06 00 00 	mov    %rax,0x6b0(%rbx)
		adapter->stats.tsctfc += er32(TSCTFC);
    6d93:	48 8b 83 c0 03 00 00 	mov    0x3c0(%rbx),%rax
    6d9a:	8b 80 fc 40 00 00    	mov    0x40fc(%rax),%eax
    6da0:	89 c0                	mov    %eax,%eax
    6da2:	48 01 d0             	add    %rdx,%rax
    6da5:	48 89 83 b8 06 00 00 	mov    %rax,0x6b8(%rbx)
	}

	/* Fill out the OS statistics structure */
	netdev->stats.multicast = adapter->stats.mprc;
    6dac:	48 8b 83 c8 05 00 00 	mov    0x5c8(%rbx),%rax
    6db3:	49 89 84 24 68 01 00 	mov    %rax,0x168(%r12)
    6dba:	00 
	netdev->stats.collisions = adapter->stats.colc;
    6dbb:	48 8b 83 30 05 00 00 	mov    0x530(%rbx),%rax
    6dc2:	49 89 84 24 70 01 00 	mov    %rax,0x170(%r12)
    6dc9:	00 
	/* Rx Errors */

	/* RLEC on some newer hardware can be incorrect so build
	 * our own version based on RUC and ROC
	 */
	netdev->stats.rx_errors = adapter->stats.rxerrc +
    6dca:	48 8b 93 e0 04 00 00 	mov    0x4e0(%rbx),%rdx
    6dd1:	48 03 93 f8 04 00 00 	add    0x4f8(%rbx),%rdx
		adapter->stats.crcerrs + adapter->stats.algnerrc +
    6dd8:	48 03 93 e8 04 00 00 	add    0x4e8(%rbx),%rdx
    6ddf:	48 03 93 00 06 00 00 	add    0x600(%rbx),%rdx
		adapter->stats.ruc + adapter->stats.roc +
    6de6:	48 03 93 10 06 00 00 	add    0x610(%rbx),%rdx
    6ded:	48 03 93 50 05 00 00 	add    0x550(%rbx),%rdx
	/* Rx Errors */

	/* RLEC on some newer hardware can be incorrect so build
	 * our own version based on RUC and ROC
	 */
	netdev->stats.rx_errors = adapter->stats.rxerrc +
    6df4:	49 89 94 24 48 01 00 	mov    %rdx,0x148(%r12)
    6dfb:	00 
		adapter->stats.crcerrs + adapter->stats.algnerrc +
		adapter->stats.ruc + adapter->stats.roc +
		adapter->stats.cexterr;
	adapter->stats.rlerrc = adapter->stats.ruc + adapter->stats.roc;
    6dfc:	48 8b 93 10 06 00 00 	mov    0x610(%rbx),%rdx
    6e03:	48 03 93 00 06 00 00 	add    0x600(%rbx),%rdx
    6e0a:	48 89 93 18 06 00 00 	mov    %rdx,0x618(%rbx)
	netdev->stats.rx_length_errors = adapter->stats.rlerrc;
    6e11:	49 89 94 24 78 01 00 	mov    %rdx,0x178(%r12)
    6e18:	00 
	netdev->stats.rx_crc_errors = adapter->stats.crcerrs;
    6e19:	48 8b 83 e0 04 00 00 	mov    0x4e0(%rbx),%rax
    6e20:	49 89 84 24 88 01 00 	mov    %rax,0x188(%r12)
    6e27:	00 
	netdev->stats.rx_frame_errors = adapter->stats.algnerrc;
    6e28:	48 8b 83 e8 04 00 00 	mov    0x4e8(%rbx),%rax
    6e2f:	49 89 84 24 90 01 00 	mov    %rax,0x190(%r12)
    6e36:	00 
	netdev->stats.rx_missed_errors = adapter->stats.mpc;
    6e37:	48 8b 83 08 05 00 00 	mov    0x508(%rbx),%rax
    6e3e:	49 89 84 24 a0 01 00 	mov    %rax,0x1a0(%r12)
    6e45:	00 

	/* Tx Errors */
	adapter->stats.txerrc = adapter->stats.ecol + adapter->stats.latecol;
    6e46:	48 8b 93 28 05 00 00 	mov    0x528(%rbx),%rdx
    6e4d:	48 03 93 18 05 00 00 	add    0x518(%rbx),%rdx
    6e54:	48 89 93 00 05 00 00 	mov    %rdx,0x500(%rbx)
	netdev->stats.tx_errors = adapter->stats.txerrc;
    6e5b:	49 89 94 24 50 01 00 	mov    %rdx,0x150(%r12)
    6e62:	00 
	netdev->stats.tx_aborted_errors = adapter->stats.ecol;
    6e63:	48 8b 83 18 05 00 00 	mov    0x518(%rbx),%rax
    6e6a:	49 89 84 24 a8 01 00 	mov    %rax,0x1a8(%r12)
    6e71:	00 
	netdev->stats.tx_window_errors = adapter->stats.latecol;
    6e72:	48 8b 83 28 05 00 00 	mov    0x528(%rbx),%rax
    6e79:	49 89 84 24 c8 01 00 	mov    %rax,0x1c8(%r12)
    6e80:	00 
	netdev->stats.tx_carrier_errors = adapter->stats.tncrs;
    6e81:	48 8b 83 40 05 00 00 	mov    0x540(%rbx),%rax
    6e88:	49 89 84 24 b0 01 00 	mov    %rax,0x1b0(%r12)
    6e8f:	00 
	if (hw->bad_tx_carr_stats_fd &&
    6e90:	80 bb db 04 00 00 00 	cmpb   $0x0,0x4db(%rbx)
    6e97:	74 21                	je     6eba <e1000_update_stats+0x84a>
    6e99:	66 83 bb 1a 02 00 00 	cmpw   $0x2,0x21a(%rbx)
    6ea0:	02 
    6ea1:	75 17                	jne    6eba <e1000_update_stats+0x84a>
	    adapter->link_duplex == FULL_DUPLEX) {
		netdev->stats.tx_carrier_errors = 0;
    6ea3:	49 c7 84 24 b0 01 00 	movq   $0x0,0x1b0(%r12)
    6eaa:	00 00 00 00 00 
		adapter->stats.tncrs = 0;
    6eaf:	48 c7 83 40 05 00 00 	movq   $0x0,0x540(%rbx)
    6eb6:	00 00 00 00 
	}

	/* Tx Dropped needs to be maintained elsewhere */

	/* Phy Stats */
	if (hw->media_type == e1000_media_type_copper) {
    6eba:	8b 93 e4 03 00 00    	mov    0x3e4(%rbx),%edx
    6ec0:	85 d2                	test   %edx,%edx
    6ec2:	75 48                	jne    6f0c <e1000_update_stats+0x89c>
		if ((adapter->link_speed == SPEED_1000) &&
    6ec4:	66 81 bb 18 02 00 00 	cmpw   $0x3e8,0x218(%rbx)
    6ecb:	e8 03 
 * @adapter: board private structure
 **/
void e1000_update_stats(struct e1000_adapter *adapter)
{
	struct net_device *netdev = adapter->netdev;
	struct e1000_hw *hw = &adapter->hw;
    6ecd:	4c 8d a3 c0 03 00 00 	lea    0x3c0(%rbx),%r12

	/* Tx Dropped needs to be maintained elsewhere */

	/* Phy Stats */
	if (hw->media_type == e1000_media_type_copper) {
		if ((adapter->link_speed == SPEED_1000) &&
    6ed4:	0f 84 ab 00 00 00    	je     6f85 <e1000_update_stats+0x915>
		   (!e1000_read_phy_reg(hw, PHY_1000T_STATUS, &phy_tmp))) {
			phy_tmp &= PHY_IDLE_ERROR_COUNT_MASK;
			adapter->phy_stats.idle_errors += phy_tmp;
		}

		if ((hw->mac_type <= e1000_82546) &&
    6eda:	83 bb d8 03 00 00 08 	cmpl   $0x8,0x3d8(%rbx)
    6ee1:	77 29                	ja     6f0c <e1000_update_stats+0x89c>
    6ee3:	8b 83 dc 03 00 00    	mov    0x3dc(%rbx),%eax
    6ee9:	85 c0                	test   %eax,%eax
    6eeb:	75 1f                	jne    6f0c <e1000_update_stats+0x89c>
		   (hw->phy_type == e1000_phy_m88) &&
		   !e1000_read_phy_reg(hw, M88E1000_RX_ERR_CNTR, &phy_tmp))
    6eed:	48 8d 55 de          	lea    -0x22(%rbp),%rdx
    6ef1:	be 15 00 00 00       	mov    $0x15,%esi
    6ef6:	4c 89 e7             	mov    %r12,%rdi
    6ef9:	e8 00 00 00 00       	callq  6efe <e1000_update_stats+0x88e>
			phy_tmp &= PHY_IDLE_ERROR_COUNT_MASK;
			adapter->phy_stats.idle_errors += phy_tmp;
		}

		if ((hw->mac_type <= e1000_82546) &&
		   (hw->phy_type == e1000_phy_m88) &&
    6efe:	85 c0                	test   %eax,%eax
    6f00:	75 0a                	jne    6f0c <e1000_update_stats+0x89c>
		   !e1000_read_phy_reg(hw, M88E1000_RX_ERR_CNTR, &phy_tmp))
			adapter->phy_stats.receive_errors += phy_tmp;
    6f02:	0f b7 45 de          	movzwl -0x22(%rbp),%eax
    6f06:	01 83 2c 07 00 00    	add    %eax,0x72c(%rbx)
	}

	/* Management Stats */
	if (hw->has_smbus) {
    6f0c:	80 bb dc 04 00 00 00 	cmpb   $0x0,0x4dc(%rbx)
    6f13:	74 60                	je     6f75 <e1000_update_stats+0x905>
		adapter->stats.mgptc += er32(MGTPTC);
    6f15:	48 8b 93 38 06 00 00 	mov    0x638(%rbx),%rdx
    6f1c:	48 8b 83 c0 03 00 00 	mov    0x3c0(%rbx),%rax
    6f23:	8b 80 bc 40 00 00    	mov    0x40bc(%rax),%eax
    6f29:	89 c0                	mov    %eax,%eax
    6f2b:	48 01 d0             	add    %rdx,%rax
		adapter->stats.mgprc += er32(MGTPRC);
    6f2e:	48 8b 93 28 06 00 00 	mov    0x628(%rbx),%rdx
			adapter->phy_stats.receive_errors += phy_tmp;
	}

	/* Management Stats */
	if (hw->has_smbus) {
		adapter->stats.mgptc += er32(MGTPTC);
    6f35:	48 89 83 38 06 00 00 	mov    %rax,0x638(%rbx)
		adapter->stats.mgprc += er32(MGTPRC);
    6f3c:	48 8b 83 c0 03 00 00 	mov    0x3c0(%rbx),%rax
    6f43:	8b 80 b4 40 00 00    	mov    0x40b4(%rax),%eax
    6f49:	89 c0                	mov    %eax,%eax
    6f4b:	48 01 d0             	add    %rdx,%rax
		adapter->stats.mgpdc += er32(MGTPDC);
    6f4e:	48 8b 93 30 06 00 00 	mov    0x630(%rbx),%rdx
	}

	/* Management Stats */
	if (hw->has_smbus) {
		adapter->stats.mgptc += er32(MGTPTC);
		adapter->stats.mgprc += er32(MGTPRC);
    6f55:	48 89 83 28 06 00 00 	mov    %rax,0x628(%rbx)
		adapter->stats.mgpdc += er32(MGTPDC);
    6f5c:	48 8b 83 c0 03 00 00 	mov    0x3c0(%rbx),%rax
    6f63:	8b 80 b8 40 00 00    	mov    0x40b8(%rax),%eax
    6f69:	89 c0                	mov    %eax,%eax
    6f6b:	48 01 d0             	add    %rdx,%rax
    6f6e:	48 89 83 30 06 00 00 	mov    %rax,0x630(%rbx)
	raw_spin_unlock_irq(&lock->rlock);
}

static __always_inline void spin_unlock_irqrestore(spinlock_t *lock, unsigned long flags)
{
	raw_spin_unlock_irqrestore(&lock->rlock, flags);
    6f75:	4c 89 f6             	mov    %r14,%rsi
    6f78:	4c 89 ef             	mov    %r13,%rdi
    6f7b:	e8 00 00 00 00       	callq  6f80 <e1000_update_stats+0x910>
    6f80:	e9 23 f7 ff ff       	jmpq   66a8 <e1000_update_stats+0x38>
	/* Tx Dropped needs to be maintained elsewhere */

	/* Phy Stats */
	if (hw->media_type == e1000_media_type_copper) {
		if ((adapter->link_speed == SPEED_1000) &&
		   (!e1000_read_phy_reg(hw, PHY_1000T_STATUS, &phy_tmp))) {
    6f85:	48 8d 55 de          	lea    -0x22(%rbp),%rdx
    6f89:	be 0a 00 00 00       	mov    $0xa,%esi
    6f8e:	4c 89 e7             	mov    %r12,%rdi
    6f91:	e8 00 00 00 00       	callq  6f96 <e1000_update_stats+0x926>

	/* Tx Dropped needs to be maintained elsewhere */

	/* Phy Stats */
	if (hw->media_type == e1000_media_type_copper) {
		if ((adapter->link_speed == SPEED_1000) &&
    6f96:	85 c0                	test   %eax,%eax
    6f98:	0f 85 3c ff ff ff    	jne    6eda <e1000_update_stats+0x86a>
		   (!e1000_read_phy_reg(hw, PHY_1000T_STATUS, &phy_tmp))) {
			phy_tmp &= PHY_IDLE_ERROR_COUNT_MASK;
    6f9e:	0f b6 45 de          	movzbl -0x22(%rbp),%eax
			adapter->phy_stats.idle_errors += phy_tmp;
    6fa2:	01 83 28 07 00 00    	add    %eax,0x728(%rbx)

	/* Phy Stats */
	if (hw->media_type == e1000_media_type_copper) {
		if ((adapter->link_speed == SPEED_1000) &&
		   (!e1000_read_phy_reg(hw, PHY_1000T_STATUS, &phy_tmp))) {
			phy_tmp &= PHY_IDLE_ERROR_COUNT_MASK;
    6fa8:	66 89 45 de          	mov    %ax,-0x22(%rbp)
    6fac:	e9 29 ff ff ff       	jmpq   6eda <e1000_update_stats+0x86a>
    6fb1:	66 66 66 66 66 66 2e 	data32 data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
    6fb8:	0f 1f 84 00 00 00 00 
    6fbf:	00 

0000000000006fc0 <e1000_watchdog>:
/**
 * e1000_watchdog - work function
 * @work: work struct contained inside adapter struct
 **/
static void e1000_watchdog(struct work_struct *work)
{
    6fc0:	e8 00 00 00 00       	callq  6fc5 <e1000_watchdog+0x5>
    6fc5:	55                   	push   %rbp
    6fc6:	48 89 e5             	mov    %rsp,%rbp
    6fc9:	41 57                	push   %r15
    6fcb:	41 56                	push   %r14
    6fcd:	41 55                	push   %r13
    6fcf:	41 54                	push   %r12
	struct e1000_adapter *adapter = container_of(work,
    6fd1:	4c 8d a7 20 f8 ff ff 	lea    -0x7e0(%rdi),%r12
/**
 * e1000_watchdog - work function
 * @work: work struct contained inside adapter struct
 **/
static void e1000_watchdog(struct work_struct *work)
{
    6fd8:	53                   	push   %rbx
    6fd9:	48 89 fb             	mov    %rdi,%rbx
	struct e1000_adapter *adapter = container_of(work,
						     struct e1000_adapter,
						     watchdog_task.work);
	struct e1000_hw *hw = &adapter->hw;
    6fdc:	4d 8d bc 24 c0 03 00 	lea    0x3c0(%r12),%r15
    6fe3:	00 
/**
 * e1000_watchdog - work function
 * @work: work struct contained inside adapter struct
 **/
static void e1000_watchdog(struct work_struct *work)
{
    6fe4:	48 83 ec 08          	sub    $0x8,%rsp
	struct e1000_adapter *adapter = container_of(work,
						     struct e1000_adapter,
						     watchdog_task.work);
	struct e1000_hw *hw = &adapter->hw;
	struct net_device *netdev = adapter->netdev;
    6fe8:	4c 8b af d0 fb ff ff 	mov    -0x430(%rdi),%r13
	struct e1000_tx_ring *txdr = adapter->tx_ring;
    6fef:	4c 8b b7 60 fa ff ff 	mov    -0x5a0(%rdi),%r14
	u32 link, tctl;

	link = e1000_has_link(adapter);
    6ff6:	4c 89 e7             	mov    %r12,%rdi
    6ff9:	e8 00 00 00 00       	callq  6ffe <e1000_watchdog+0x3e>
}

static __always_inline int constant_test_bit(long nr, const volatile unsigned long *addr)
{
	return ((1UL << (nr & (BITS_PER_LONG-1))) &
		(addr[nr >> _BITOPS_LONG_SHIFT])) != 0;
    6ffe:	49 8b 55 48          	mov    0x48(%r13),%rdx
    7002:	0f b6 c0             	movzbl %al,%eax
	if ((netif_carrier_ok(netdev)) && link)
    7005:	83 e2 04             	and    $0x4,%edx
    7008:	0f 85 08 01 00 00    	jne    7116 <e1000_watchdog+0x156>
    700e:	85 c0                	test   %eax,%eax
    7010:	0f 84 70 02 00 00    	je     7286 <e1000_watchdog+0x2c6>

		e1000_smartspeed(adapter);
	}

link_up:
	e1000_update_stats(adapter);
    7016:	4c 89 e7             	mov    %r12,%rdi
    7019:	e8 00 00 00 00       	callq  701e <e1000_watchdog+0x5e>

	hw->tx_packet_delta = adapter->stats.tpt - adapter->tpt_old;
    701e:	48 8b 83 88 fe ff ff 	mov    -0x178(%rbx),%rax
	adapter->gorcl = adapter->stats.gorcl - adapter->gorcl_old;
	adapter->gorcl_old = adapter->stats.gorcl;
	adapter->gotcl = adapter->stats.gotcl - adapter->gotcl_old;
	adapter->gotcl_old = adapter->stats.gotcl;

	e1000_update_adaptive(hw);
    7025:	4c 89 ff             	mov    %r15,%rdi
	}

link_up:
	e1000_update_stats(adapter);

	hw->tx_packet_delta = adapter->stats.tpt - adapter->tpt_old;
    7028:	89 c2                	mov    %eax,%edx
    702a:	2b 93 88 fa ff ff    	sub    -0x578(%rbx),%edx
	adapter->tpt_old = adapter->stats.tpt;
    7030:	48 89 83 88 fa ff ff 	mov    %rax,-0x578(%rbx)
	hw->collision_delta = adapter->stats.colc - adapter->colc_old;
    7037:	48 8b 83 50 fd ff ff 	mov    -0x2b0(%rbx),%rax
	}

link_up:
	e1000_update_stats(adapter);

	hw->tx_packet_delta = adapter->stats.tpt - adapter->tpt_old;
    703e:	89 93 8c fc ff ff    	mov    %edx,-0x374(%rbx)
	adapter->tpt_old = adapter->stats.tpt;
	hw->collision_delta = adapter->stats.colc - adapter->colc_old;
    7044:	89 c2                	mov    %eax,%edx
    7046:	2b 93 90 fa ff ff    	sub    -0x570(%rbx),%edx
	adapter->colc_old = adapter->stats.colc;
    704c:	48 89 83 90 fa ff ff 	mov    %rax,-0x570(%rbx)

	adapter->gorcl = adapter->stats.gorcl - adapter->gorcl_old;
    7053:	48 8b 83 f8 fd ff ff 	mov    -0x208(%rbx),%rax
link_up:
	e1000_update_stats(adapter);

	hw->tx_packet_delta = adapter->stats.tpt - adapter->tpt_old;
	adapter->tpt_old = adapter->stats.tpt;
	hw->collision_delta = adapter->stats.colc - adapter->colc_old;
    705a:	89 93 88 fc ff ff    	mov    %edx,-0x378(%rbx)
	adapter->colc_old = adapter->stats.colc;

	adapter->gorcl = adapter->stats.gorcl - adapter->gorcl_old;
    7060:	89 c2                	mov    %eax,%edx
    7062:	2b 93 c8 fb ff ff    	sub    -0x438(%rbx),%edx
	adapter->gorcl_old = adapter->stats.gorcl;
    7068:	48 89 83 c8 fb ff ff 	mov    %rax,-0x438(%rbx)
	adapter->gotcl = adapter->stats.gotcl - adapter->gotcl_old;
    706f:	48 8b 83 08 fe ff ff 	mov    -0x1f8(%rbx),%rax
	hw->tx_packet_delta = adapter->stats.tpt - adapter->tpt_old;
	adapter->tpt_old = adapter->stats.tpt;
	hw->collision_delta = adapter->stats.colc - adapter->colc_old;
	adapter->colc_old = adapter->stats.colc;

	adapter->gorcl = adapter->stats.gorcl - adapter->gorcl_old;
    7076:	89 93 c0 fb ff ff    	mov    %edx,-0x440(%rbx)
	adapter->gorcl_old = adapter->stats.gorcl;
	adapter->gotcl = adapter->stats.gotcl - adapter->gotcl_old;
    707c:	89 c2                	mov    %eax,%edx
    707e:	2b 93 80 fa ff ff    	sub    -0x580(%rbx),%edx
	adapter->gotcl_old = adapter->stats.gotcl;
    7084:	48 89 83 80 fa ff ff 	mov    %rax,-0x580(%rbx)
	hw->collision_delta = adapter->stats.colc - adapter->colc_old;
	adapter->colc_old = adapter->stats.colc;

	adapter->gorcl = adapter->stats.gorcl - adapter->gorcl_old;
	adapter->gorcl_old = adapter->stats.gorcl;
	adapter->gotcl = adapter->stats.gotcl - adapter->gotcl_old;
    708b:	89 93 78 fa ff ff    	mov    %edx,-0x588(%rbx)
	adapter->gotcl_old = adapter->stats.gotcl;

	e1000_update_adaptive(hw);
    7091:	e8 00 00 00 00       	callq  7096 <e1000_watchdog+0xd6>
    7096:	49 8b 45 48          	mov    0x48(%r13),%rax

	if (!netif_carrier_ok(netdev)) {
    709a:	a8 04                	test   $0x4,%al
    709c:	74 22                	je     70c0 <e1000_watchdog+0x100>
		if (E1000_DESC_UNUSED(txdr) + 1 < txdr->count) {
    709e:	41 8b 56 1c          	mov    0x1c(%r14),%edx
    70a2:	41 8b 46 18          	mov    0x18(%r14),%eax
    70a6:	39 c2                	cmp    %eax,%edx
    70a8:	0f 86 35 02 00 00    	jbe    72e3 <e1000_watchdog+0x323>
    70ae:	41 8b 76 14          	mov    0x14(%r14),%esi
    70b2:	31 c9                	xor    %ecx,%ecx
    70b4:	29 c2                	sub    %eax,%edx
    70b6:	01 d1                	add    %edx,%ecx
    70b8:	39 f1                	cmp    %esi,%ecx
    70ba:	0f 82 35 02 00 00    	jb     72f5 <e1000_watchdog+0x335>
			return;
		}
	}

	/* Simple mode for Interrupt Throttle Rate (ITR) */
	if (hw->mac_type >= e1000_82540 && adapter->itr_setting == 4) {
    70c0:	83 bb f8 fb ff ff 04 	cmpl   $0x4,-0x408(%rbx)
    70c7:	0f 87 44 01 00 00    	ja     7211 <e1000_watchdog+0x251>

		ew32(ITR, 1000000000 / (itr * 256));
	}

	/* Cause software interrupt to ensure rx ring is cleaned */
	ew32(ICS, E1000_ICS_RXDMT0);
    70cd:	48 8b 93 e0 fb ff ff 	mov    -0x420(%rbx),%rdx
build_mmio_read(__readw, "w", unsigned short, "=r", )
build_mmio_read(__readl, "l", unsigned int, "=r", )

build_mmio_write(writeb, "b", unsigned char, "q", :"memory")
build_mmio_write(writew, "w", unsigned short, "r", :"memory")
build_mmio_write(writel, "l", unsigned int, "r", :"memory")
    70d4:	b8 10 00 00 00       	mov    $0x10,%eax
    70d9:	89 82 c8 00 00 00    	mov    %eax,0xc8(%rdx)
    70df:	48 8b 43 c8          	mov    -0x38(%rbx),%rax

	/* Force detection of hung controller every watchdog period */
	adapter->detect_tx_hung = true;
    70e3:	c6 83 b1 fa ff ff 01 	movb   $0x1,-0x54f(%rbx)

	/* Reschedule the task */
	if (!test_bit(__E1000_DOWN, &adapter->flags))
    70ea:	a8 04                	test   $0x4,%al
    70ec:	75 19                	jne    7107 <e1000_watchdog+0x147>
    70ee:	48 8b 35 00 00 00 00 	mov    0x0(%rip),%rsi        # 70f5 <e1000_watchdog+0x135>
    70f5:	b9 f4 01 00 00       	mov    $0x1f4,%ecx
    70fa:	48 89 da             	mov    %rbx,%rdx
    70fd:	bf 00 01 00 00       	mov    $0x100,%edi
    7102:	e8 00 00 00 00       	callq  7107 <e1000_watchdog+0x147>
		schedule_delayed_work(&adapter->watchdog_task, 2 * HZ);
}
    7107:	48 83 c4 08          	add    $0x8,%rsp
    710b:	5b                   	pop    %rbx
    710c:	41 5c                	pop    %r12
    710e:	41 5d                	pop    %r13
    7110:	41 5e                	pop    %r14
    7112:	41 5f                	pop    %r15
    7114:	5d                   	pop    %rbp
    7115:	c3                   	retq   

	link = e1000_has_link(adapter);
	if ((netif_carrier_ok(netdev)) && link)
		goto link_up;

	if (link) {
    7116:	85 c0                	test   %eax,%eax
    7118:	0f 84 68 01 00 00    	je     7286 <e1000_watchdog+0x2c6>
    711e:	49 8b 45 48          	mov    0x48(%r13),%rax
		if (!netif_carrier_ok(netdev)) {
    7122:	a8 04                	test   $0x4,%al
    7124:	0f 84 ec fe ff ff    	je     7016 <e1000_watchdog+0x56>
			u32 ctrl;
			bool txb2b = true;
			/* update snapshot of PHY registers on LSC */
			e1000_get_speed_and_duplex(hw,
    712a:	49 8d 94 24 1a 02 00 	lea    0x21a(%r12),%rdx
    7131:	00 
    7132:	49 8d b4 24 18 02 00 	lea    0x218(%r12),%rsi
    7139:	00 
    713a:	4c 89 ff             	mov    %r15,%rdi
    713d:	e8 00 00 00 00       	callq  7142 <e1000_watchdog+0x182>
						   &adapter->link_speed,
						   &adapter->link_duplex);

			ctrl = er32(CTRL);
    7142:	48 8b 83 e0 fb ff ff 	mov    -0x420(%rbx),%rax
{ asm volatile("mov" size " %0,%1": :reg (val), \
"m" (*(volatile type __force *)addr) barrier); }

build_mmio_read(readb, "b", unsigned char, "=q", :"memory")
build_mmio_read(readw, "w", unsigned short, "=r", :"memory")
build_mmio_read(readl, "l", unsigned int, "=r", :"memory")
    7149:	8b 00                	mov    (%rax),%eax
			pr_info("%s NIC Link is Up %d Mbps %s, "
    714b:	89 c2                	mov    %eax,%edx
    714d:	49 c7 c0 00 00 00 00 	mov    $0x0,%r8
    7154:	81 e2 00 00 00 18    	and    $0x18000000,%edx
    715a:	81 fa 00 00 00 18    	cmp    $0x18000000,%edx
    7160:	74 25                	je     7187 <e1000_watchdog+0x1c7>
    7162:	a9 00 00 00 08       	test   $0x8000000,%eax
    7167:	49 c7 c0 00 00 00 00 	mov    $0x0,%r8
    716e:	75 17                	jne    7187 <e1000_watchdog+0x1c7>
    7170:	a9 00 00 00 10       	test   $0x10000000,%eax
    7175:	49 c7 c0 00 00 00 00 	mov    $0x0,%r8
    717c:	48 c7 c0 00 00 00 00 	mov    $0x0,%rax
    7183:	4c 0f 44 c0          	cmove  %rax,%r8
    7187:	66 83 bb 3a fa ff ff 	cmpw   $0x2,-0x5c6(%rbx)
    718e:	02 
    718f:	0f b7 93 38 fa ff ff 	movzwl -0x5c8(%rbx),%edx
    7196:	48 c7 c0 00 00 00 00 	mov    $0x0,%rax
    719d:	48 c7 c1 00 00 00 00 	mov    $0x0,%rcx
    71a4:	4c 89 ee             	mov    %r13,%rsi
    71a7:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
    71ae:	48 0f 45 c8          	cmovne %rax,%rcx
    71b2:	31 c0                	xor    %eax,%eax
    71b4:	e8 00 00 00 00       	callq  71b9 <e1000_watchdog+0x1f9>
				E1000_CTRL_RFCE) ? "RX" : ((ctrl &
				E1000_CTRL_TFCE) ? "TX" : "None")));

			/* adjust timeout factor according to speed/duplex */
			adapter->tx_timeout_factor = 1;
			switch (adapter->link_speed) {
    71b9:	66 83 bb 38 fa ff ff 	cmpw   $0xa,-0x5c8(%rbx)
    71c0:	0a 
				E1000_CTRL_RFCE)) ? "RX/TX" : ((ctrl &
				E1000_CTRL_RFCE) ? "RX" : ((ctrl &
				E1000_CTRL_TFCE) ? "TX" : "None")));

			/* adjust timeout factor according to speed/duplex */
			adapter->tx_timeout_factor = 1;
    71c1:	c6 83 a8 fa ff ff 01 	movb   $0x1,-0x558(%rbx)
			switch (adapter->link_speed) {
    71c8:	75 07                	jne    71d1 <e1000_watchdog+0x211>
			case SPEED_10:
				txb2b = false;
				adapter->tx_timeout_factor = 16;
    71ca:	c6 83 a8 fa ff ff 10 	movb   $0x10,-0x558(%rbx)
				/* maybe add some timeout factor ? */
				break;
			}

			/* enable transmits in the hardware */
			tctl = er32(TCTL);
    71d1:	48 8b 83 e0 fb ff ff 	mov    -0x420(%rbx),%rax
    71d8:	8b 80 00 04 00 00    	mov    0x400(%rax),%eax
			tctl |= E1000_TCTL_EN;
    71de:	83 c8 02             	or     $0x2,%eax
			ew32(TCTL, tctl);
    71e1:	48 8b 93 e0 fb ff ff 	mov    -0x420(%rbx),%rdx
build_mmio_read(__readw, "w", unsigned short, "=r", )
build_mmio_read(__readl, "l", unsigned int, "=r", )

build_mmio_write(writeb, "b", unsigned char, "q", :"memory")
build_mmio_write(writew, "w", unsigned short, "r", :"memory")
build_mmio_write(writel, "l", unsigned int, "r", :"memory")
    71e8:	89 82 00 04 00 00    	mov    %eax,0x400(%rdx)

			netif_carrier_on(netdev);
    71ee:	4c 89 ef             	mov    %r13,%rdi
    71f1:	e8 00 00 00 00       	callq  71f6 <e1000_watchdog+0x236>
    71f6:	48 8b 43 c8          	mov    -0x38(%rbx),%rax
			if (!test_bit(__E1000_DOWN, &adapter->flags))
    71fa:	a8 04                	test   $0x4,%al
    71fc:	0f 84 b0 02 00 00    	je     74b2 <e1000_watchdog+0x4f2>
			e1000_write_phy_reg(hw, PHY_CTRL, phy_ctrl);
		}
	}
	/* Restart process after E1000_SMARTSPEED_MAX iterations */
	if (adapter->smartspeed++ == E1000_SMARTSPEED_MAX)
		adapter->smartspeed = 0;
    7202:	c7 83 30 fa ff ff 00 	movl   $0x0,-0x5d0(%rbx)
    7209:	00 00 00 
    720c:	e9 05 fe ff ff       	jmpq   7016 <e1000_watchdog+0x56>
			return;
		}
	}

	/* Simple mode for Interrupt Throttle Rate (ITR) */
	if (hw->mac_type >= e1000_82540 && adapter->itr_setting == 4) {
    7211:	83 bb 54 fa ff ff 04 	cmpl   $0x4,-0x5ac(%rbx)
    7218:	0f 85 af fe ff ff    	jne    70cd <e1000_watchdog+0x10d>
		/* Symmetric Tx/Rx gets a reduced ITR=2000;
		 * Total asymmetrical Tx or Rx gets ITR=8000;
		 * everyone else is between 2000-8000.
		 */
		u32 goc = (adapter->gotcl + adapter->gorcl) / 10000;
    721e:	8b b3 78 fa ff ff    	mov    -0x588(%rbx),%esi
    7224:	8b bb c0 fb ff ff    	mov    -0x440(%rbx),%edi
    722a:	41 b8 59 17 b7 d1    	mov    $0xd1b71759,%r8d
    7230:	8d 0c 37             	lea    (%rdi,%rsi,1),%ecx
    7233:	89 c8                	mov    %ecx,%eax
    7235:	41 f7 e0             	mul    %r8d
    7238:	89 d1                	mov    %edx,%ecx
    723a:	c1 e9 0d             	shr    $0xd,%ecx
		u32 dif = (adapter->gotcl > adapter->gorcl ?
			    adapter->gotcl - adapter->gorcl :
			    adapter->gorcl - adapter->gotcl) / 10000;
    723d:	39 fe                	cmp    %edi,%esi
    723f:	0f 86 df 00 00 00    	jbe    7324 <e1000_watchdog+0x364>
		 * Total asymmetrical Tx or Rx gets ITR=8000;
		 * everyone else is between 2000-8000.
		 */
		u32 goc = (adapter->gotcl + adapter->gorcl) / 10000;
		u32 dif = (adapter->gotcl > adapter->gorcl ?
			    adapter->gotcl - adapter->gorcl :
    7245:	29 fe                	sub    %edi,%esi
			    adapter->gorcl - adapter->gotcl) / 10000;
    7247:	89 f0                	mov    %esi,%eax
    7249:	41 f7 e0             	mul    %r8d
    724c:	c1 ea 0d             	shr    $0xd,%edx
		u32 itr = goc > 0 ? (dif * 6000 / goc + 2000) : 8000;
    724f:	85 c9                	test   %ecx,%ecx
    7251:	b8 e8 01 00 00       	mov    $0x1e8,%eax
    7256:	74 1c                	je     7274 <e1000_watchdog+0x2b4>
    7258:	69 c2 70 17 00 00    	imul   $0x1770,%edx,%eax
    725e:	31 d2                	xor    %edx,%edx
    7260:	f7 f1                	div    %ecx
    7262:	31 d2                	xor    %edx,%edx
    7264:	8d 88 d0 07 00 00    	lea    0x7d0(%rax),%ecx
    726a:	b8 00 ca 9a 3b       	mov    $0x3b9aca00,%eax
    726f:	c1 e1 08             	shl    $0x8,%ecx
    7272:	f7 f1                	div    %ecx

		ew32(ITR, 1000000000 / (itr * 256));
    7274:	48 8b 93 e0 fb ff ff 	mov    -0x420(%rbx),%rdx
    727b:	89 82 c4 00 00 00    	mov    %eax,0xc4(%rdx)
    7281:	e9 47 fe ff ff       	jmpq   70cd <e1000_watchdog+0x10d>
    7286:	49 8b 45 48          	mov    0x48(%r13),%rax
				schedule_delayed_work(&adapter->phy_info_task,
						      2 * HZ);
			adapter->smartspeed = 0;
		}
	} else {
		if (netif_carrier_ok(netdev)) {
    728a:	a8 04                	test   $0x4,%al
    728c:	0f 84 c7 01 00 00    	je     7459 <e1000_watchdog+0x499>
{
	struct e1000_hw *hw = &adapter->hw;
	u16 phy_status;
	u16 phy_ctrl;

	if ((hw->phy_type != e1000_phy_igp) || !hw->autoneg ||
    7292:	83 bb fc fb ff ff 01 	cmpl   $0x1,-0x404(%rbx)
    7299:	0f 85 77 fd ff ff    	jne    7016 <e1000_watchdog+0x56>
    729f:	80 bb cf fc ff ff 00 	cmpb   $0x0,-0x331(%rbx)
    72a6:	0f 84 6a fd ff ff    	je     7016 <e1000_watchdog+0x56>
    72ac:	f6 83 b2 fc ff ff 20 	testb  $0x20,-0x34e(%rbx)
    72b3:	0f 84 5d fd ff ff    	je     7016 <e1000_watchdog+0x56>
	   !(hw->autoneg_advertised & ADVERTISE_1000_FULL))
		return;

	if (adapter->smartspeed == 0) {
    72b9:	8b 83 30 fa ff ff    	mov    -0x5d0(%rbx),%eax
    72bf:	85 c0                	test   %eax,%eax
    72c1:	74 70                	je     7333 <e1000_watchdog+0x373>
				e1000_write_phy_reg(hw, PHY_CTRL,
						    phy_ctrl);
			}
		}
		return;
	} else if (adapter->smartspeed == E1000_SMARTSPEED_DOWNSHIFT) {
    72c3:	83 f8 03             	cmp    $0x3,%eax
    72c6:	0f 84 1e 01 00 00    	je     73ea <e1000_watchdog+0x42a>
				     MII_CR_RESTART_AUTO_NEG);
			e1000_write_phy_reg(hw, PHY_CTRL, phy_ctrl);
		}
	}
	/* Restart process after E1000_SMARTSPEED_MAX iterations */
	if (adapter->smartspeed++ == E1000_SMARTSPEED_MAX)
    72cc:	83 f8 0f             	cmp    $0xf,%eax
    72cf:	0f 84 2d ff ff ff    	je     7202 <e1000_watchdog+0x242>
    72d5:	83 c0 01             	add    $0x1,%eax
    72d8:	89 83 30 fa ff ff    	mov    %eax,-0x5d0(%rbx)
    72de:	e9 33 fd ff ff       	jmpq   7016 <e1000_watchdog+0x56>
	adapter->gotcl_old = adapter->stats.gotcl;

	e1000_update_adaptive(hw);

	if (!netif_carrier_ok(netdev)) {
		if (E1000_DESC_UNUSED(txdr) + 1 < txdr->count) {
    72e3:	41 8b 4e 14          	mov    0x14(%r14),%ecx
    72e7:	29 c2                	sub    %eax,%edx
    72e9:	89 ce                	mov    %ecx,%esi
    72eb:	01 d1                	add    %edx,%ecx
    72ed:	39 f1                	cmp    %esi,%ecx
    72ef:	0f 83 cb fd ff ff    	jae    70c0 <e1000_watchdog+0x100>
			/* We've lost link, so the controller stops DMA,
			 * but we've got queued Tx work that's never going
			 * to get done, so reset controller to flush Tx.
			 * (Do the reset outside of interrupt context).
			 */
			adapter->tx_timeout_count++;
    72f5:	83 83 98 fa ff ff 01 	addl   $0x1,-0x568(%rbx)
			schedule_work(&adapter->reset_task);
    72fc:	49 8d 94 24 c0 07 00 	lea    0x7c0(%r12),%rdx
    7303:	00 
 * it can be processed by another CPU.
 */
static inline bool queue_work(struct workqueue_struct *wq,
			      struct work_struct *work)
{
	return queue_work_on(WORK_CPU_UNBOUND, wq, work);
    7304:	bf 00 01 00 00       	mov    $0x100,%edi
    7309:	48 8b 35 00 00 00 00 	mov    0x0(%rip),%rsi        # 7310 <e1000_watchdog+0x350>
    7310:	e8 00 00 00 00       	callq  7315 <e1000_watchdog+0x355>
	adapter->detect_tx_hung = true;

	/* Reschedule the task */
	if (!test_bit(__E1000_DOWN, &adapter->flags))
		schedule_delayed_work(&adapter->watchdog_task, 2 * HZ);
}
    7315:	48 83 c4 08          	add    $0x8,%rsp
    7319:	5b                   	pop    %rbx
    731a:	41 5c                	pop    %r12
    731c:	41 5d                	pop    %r13
    731e:	41 5e                	pop    %r14
    7320:	41 5f                	pop    %r15
    7322:	5d                   	pop    %rbp
    7323:	c3                   	retq   
		 * everyone else is between 2000-8000.
		 */
		u32 goc = (adapter->gotcl + adapter->gorcl) / 10000;
		u32 dif = (adapter->gotcl > adapter->gorcl ?
			    adapter->gotcl - adapter->gorcl :
			    adapter->gorcl - adapter->gotcl) / 10000;
    7324:	29 f7                	sub    %esi,%edi
    7326:	89 f8                	mov    %edi,%eax
    7328:	41 f7 e0             	mul    %r8d
    732b:	c1 ea 0d             	shr    $0xd,%edx
    732e:	e9 1c ff ff ff       	jmpq   724f <e1000_watchdog+0x28f>

	if (adapter->smartspeed == 0) {
		/* If Master/Slave config fault is asserted twice,
		 * we assume back-to-back
		 */
		e1000_read_phy_reg(hw, PHY_1000T_STATUS, &phy_status);
    7333:	48 8d 55 d4          	lea    -0x2c(%rbp),%rdx
    7337:	be 0a 00 00 00       	mov    $0xa,%esi
    733c:	4c 89 ff             	mov    %r15,%rdi
    733f:	e8 00 00 00 00       	callq  7344 <e1000_watchdog+0x384>
		if (!(phy_status & SR_1000T_MS_CONFIG_FAULT)) return;
    7344:	66 83 7d d4 00       	cmpw   $0x0,-0x2c(%rbp)
    7349:	0f 89 c7 fc ff ff    	jns    7016 <e1000_watchdog+0x56>
		e1000_read_phy_reg(hw, PHY_1000T_STATUS, &phy_status);
    734f:	48 8d 55 d4          	lea    -0x2c(%rbp),%rdx
    7353:	be 0a 00 00 00       	mov    $0xa,%esi
    7358:	4c 89 ff             	mov    %r15,%rdi
    735b:	e8 00 00 00 00       	callq  7360 <e1000_watchdog+0x3a0>
		if (!(phy_status & SR_1000T_MS_CONFIG_FAULT)) return;
    7360:	66 83 7d d4 00       	cmpw   $0x0,-0x2c(%rbp)
    7365:	0f 89 ab fc ff ff    	jns    7016 <e1000_watchdog+0x56>
		e1000_read_phy_reg(hw, PHY_1000T_CTRL, &phy_ctrl);
    736b:	48 8d 55 d6          	lea    -0x2a(%rbp),%rdx
    736f:	be 09 00 00 00       	mov    $0x9,%esi
    7374:	4c 89 ff             	mov    %r15,%rdi
    7377:	e8 00 00 00 00       	callq  737c <e1000_watchdog+0x3bc>
		if (phy_ctrl & CR_1000T_MS_ENABLE) {
    737c:	0f b7 45 d6          	movzwl -0x2a(%rbp),%eax
    7380:	f6 c4 10             	test   $0x10,%ah
    7383:	0f 84 8d fc ff ff    	je     7016 <e1000_watchdog+0x56>
			phy_ctrl &= ~CR_1000T_MS_ENABLE;
    7389:	80 e4 ef             	and    $0xef,%ah
			e1000_write_phy_reg(hw, PHY_1000T_CTRL,
    738c:	be 09 00 00 00       	mov    $0x9,%esi
    7391:	4c 89 ff             	mov    %r15,%rdi
    7394:	0f b7 d0             	movzwl %ax,%edx
		if (!(phy_status & SR_1000T_MS_CONFIG_FAULT)) return;
		e1000_read_phy_reg(hw, PHY_1000T_STATUS, &phy_status);
		if (!(phy_status & SR_1000T_MS_CONFIG_FAULT)) return;
		e1000_read_phy_reg(hw, PHY_1000T_CTRL, &phy_ctrl);
		if (phy_ctrl & CR_1000T_MS_ENABLE) {
			phy_ctrl &= ~CR_1000T_MS_ENABLE;
    7397:	66 89 45 d6          	mov    %ax,-0x2a(%rbp)
			e1000_write_phy_reg(hw, PHY_1000T_CTRL,
    739b:	e8 00 00 00 00       	callq  73a0 <e1000_watchdog+0x3e0>
					    phy_ctrl);
			adapter->smartspeed++;
    73a0:	83 83 30 fa ff ff 01 	addl   $0x1,-0x5d0(%rbx)
			if (!e1000_phy_setup_autoneg(hw) &&
    73a7:	4c 89 ff             	mov    %r15,%rdi
    73aa:	e8 00 00 00 00       	callq  73af <e1000_watchdog+0x3ef>
    73af:	85 c0                	test   %eax,%eax
    73b1:	0f 85 5f fc ff ff    	jne    7016 <e1000_watchdog+0x56>
			   !e1000_read_phy_reg(hw, PHY_CTRL,
    73b7:	48 8d 55 d6          	lea    -0x2a(%rbp),%rdx
    73bb:	31 f6                	xor    %esi,%esi
    73bd:	4c 89 ff             	mov    %r15,%rdi
    73c0:	e8 00 00 00 00       	callq  73c5 <e1000_watchdog+0x405>
		if (phy_ctrl & CR_1000T_MS_ENABLE) {
			phy_ctrl &= ~CR_1000T_MS_ENABLE;
			e1000_write_phy_reg(hw, PHY_1000T_CTRL,
					    phy_ctrl);
			adapter->smartspeed++;
			if (!e1000_phy_setup_autoneg(hw) &&
    73c5:	85 c0                	test   %eax,%eax
    73c7:	0f 85 49 fc ff ff    	jne    7016 <e1000_watchdog+0x56>
			   !e1000_read_phy_reg(hw, PHY_CTRL,
					       &phy_ctrl)) {
				phy_ctrl |= (MII_CR_AUTO_NEG_EN |
    73cd:	0f b7 45 d6          	movzwl -0x2a(%rbp),%eax
					     MII_CR_RESTART_AUTO_NEG);
				e1000_write_phy_reg(hw, PHY_CTRL,
    73d1:	31 f6                	xor    %esi,%esi
    73d3:	4c 89 ff             	mov    %r15,%rdi
					    phy_ctrl);
			adapter->smartspeed++;
			if (!e1000_phy_setup_autoneg(hw) &&
			   !e1000_read_phy_reg(hw, PHY_CTRL,
					       &phy_ctrl)) {
				phy_ctrl |= (MII_CR_AUTO_NEG_EN |
    73d6:	80 cc 12             	or     $0x12,%ah
					     MII_CR_RESTART_AUTO_NEG);
				e1000_write_phy_reg(hw, PHY_CTRL,
    73d9:	0f b7 d0             	movzwl %ax,%edx
					    phy_ctrl);
			adapter->smartspeed++;
			if (!e1000_phy_setup_autoneg(hw) &&
			   !e1000_read_phy_reg(hw, PHY_CTRL,
					       &phy_ctrl)) {
				phy_ctrl |= (MII_CR_AUTO_NEG_EN |
    73dc:	66 89 45 d6          	mov    %ax,-0x2a(%rbp)
					     MII_CR_RESTART_AUTO_NEG);
				e1000_write_phy_reg(hw, PHY_CTRL,
    73e0:	e8 00 00 00 00       	callq  73e5 <e1000_watchdog+0x425>
    73e5:	e9 2c fc ff ff       	jmpq   7016 <e1000_watchdog+0x56>
			}
		}
		return;
	} else if (adapter->smartspeed == E1000_SMARTSPEED_DOWNSHIFT) {
		/* If still no link, perhaps using 2/3 pair cable */
		e1000_read_phy_reg(hw, PHY_1000T_CTRL, &phy_ctrl);
    73ea:	48 8d 55 d6          	lea    -0x2a(%rbp),%rdx
    73ee:	be 09 00 00 00       	mov    $0x9,%esi
    73f3:	4c 89 ff             	mov    %r15,%rdi
    73f6:	e8 00 00 00 00       	callq  73fb <e1000_watchdog+0x43b>
		phy_ctrl |= CR_1000T_MS_ENABLE;
    73fb:	0f b7 45 d6          	movzwl -0x2a(%rbp),%eax
		e1000_write_phy_reg(hw, PHY_1000T_CTRL, phy_ctrl);
    73ff:	be 09 00 00 00       	mov    $0x9,%esi
    7404:	4c 89 ff             	mov    %r15,%rdi
		}
		return;
	} else if (adapter->smartspeed == E1000_SMARTSPEED_DOWNSHIFT) {
		/* If still no link, perhaps using 2/3 pair cable */
		e1000_read_phy_reg(hw, PHY_1000T_CTRL, &phy_ctrl);
		phy_ctrl |= CR_1000T_MS_ENABLE;
    7407:	80 cc 10             	or     $0x10,%ah
		e1000_write_phy_reg(hw, PHY_1000T_CTRL, phy_ctrl);
    740a:	0f b7 d0             	movzwl %ax,%edx
		}
		return;
	} else if (adapter->smartspeed == E1000_SMARTSPEED_DOWNSHIFT) {
		/* If still no link, perhaps using 2/3 pair cable */
		e1000_read_phy_reg(hw, PHY_1000T_CTRL, &phy_ctrl);
		phy_ctrl |= CR_1000T_MS_ENABLE;
    740d:	66 89 45 d6          	mov    %ax,-0x2a(%rbp)
		e1000_write_phy_reg(hw, PHY_1000T_CTRL, phy_ctrl);
    7411:	e8 00 00 00 00       	callq  7416 <e1000_watchdog+0x456>
		if (!e1000_phy_setup_autoneg(hw) &&
    7416:	4c 89 ff             	mov    %r15,%rdi
    7419:	e8 00 00 00 00       	callq  741e <e1000_watchdog+0x45e>
    741e:	85 c0                	test   %eax,%eax
    7420:	74 0b                	je     742d <e1000_watchdog+0x46d>
    7422:	8b 83 30 fa ff ff    	mov    -0x5d0(%rbx),%eax
    7428:	e9 9f fe ff ff       	jmpq   72cc <e1000_watchdog+0x30c>
		   !e1000_read_phy_reg(hw, PHY_CTRL, &phy_ctrl)) {
    742d:	48 8d 55 d6          	lea    -0x2a(%rbp),%rdx
    7431:	31 f6                	xor    %esi,%esi
    7433:	4c 89 ff             	mov    %r15,%rdi
    7436:	e8 00 00 00 00       	callq  743b <e1000_watchdog+0x47b>
	} else if (adapter->smartspeed == E1000_SMARTSPEED_DOWNSHIFT) {
		/* If still no link, perhaps using 2/3 pair cable */
		e1000_read_phy_reg(hw, PHY_1000T_CTRL, &phy_ctrl);
		phy_ctrl |= CR_1000T_MS_ENABLE;
		e1000_write_phy_reg(hw, PHY_1000T_CTRL, phy_ctrl);
		if (!e1000_phy_setup_autoneg(hw) &&
    743b:	85 c0                	test   %eax,%eax
    743d:	75 e3                	jne    7422 <e1000_watchdog+0x462>
		   !e1000_read_phy_reg(hw, PHY_CTRL, &phy_ctrl)) {
			phy_ctrl |= (MII_CR_AUTO_NEG_EN |
    743f:	0f b7 45 d6          	movzwl -0x2a(%rbp),%eax
				     MII_CR_RESTART_AUTO_NEG);
			e1000_write_phy_reg(hw, PHY_CTRL, phy_ctrl);
    7443:	31 f6                	xor    %esi,%esi
    7445:	4c 89 ff             	mov    %r15,%rdi
		e1000_read_phy_reg(hw, PHY_1000T_CTRL, &phy_ctrl);
		phy_ctrl |= CR_1000T_MS_ENABLE;
		e1000_write_phy_reg(hw, PHY_1000T_CTRL, phy_ctrl);
		if (!e1000_phy_setup_autoneg(hw) &&
		   !e1000_read_phy_reg(hw, PHY_CTRL, &phy_ctrl)) {
			phy_ctrl |= (MII_CR_AUTO_NEG_EN |
    7448:	80 cc 12             	or     $0x12,%ah
				     MII_CR_RESTART_AUTO_NEG);
			e1000_write_phy_reg(hw, PHY_CTRL, phy_ctrl);
    744b:	0f b7 d0             	movzwl %ax,%edx
		e1000_read_phy_reg(hw, PHY_1000T_CTRL, &phy_ctrl);
		phy_ctrl |= CR_1000T_MS_ENABLE;
		e1000_write_phy_reg(hw, PHY_1000T_CTRL, phy_ctrl);
		if (!e1000_phy_setup_autoneg(hw) &&
		   !e1000_read_phy_reg(hw, PHY_CTRL, &phy_ctrl)) {
			phy_ctrl |= (MII_CR_AUTO_NEG_EN |
    744e:	66 89 45 d6          	mov    %ax,-0x2a(%rbp)
				     MII_CR_RESTART_AUTO_NEG);
			e1000_write_phy_reg(hw, PHY_CTRL, phy_ctrl);
    7452:	e8 00 00 00 00       	callq  7457 <e1000_watchdog+0x497>
    7457:	eb c9                	jmp    7422 <e1000_watchdog+0x462>
		}
	} else {
		if (netif_carrier_ok(netdev)) {
			adapter->link_speed = 0;
			adapter->link_duplex = 0;
			pr_info("%s NIC Link is Down\n",
    7459:	4c 89 ee             	mov    %r13,%rsi
    745c:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
    7463:	31 c0                	xor    %eax,%eax
						      2 * HZ);
			adapter->smartspeed = 0;
		}
	} else {
		if (netif_carrier_ok(netdev)) {
			adapter->link_speed = 0;
    7465:	66 c7 83 38 fa ff ff 	movw   $0x0,-0x5c8(%rbx)
    746c:	00 00 
			adapter->link_duplex = 0;
    746e:	66 c7 83 3a fa ff ff 	movw   $0x0,-0x5c6(%rbx)
    7475:	00 00 
			pr_info("%s NIC Link is Down\n",
    7477:	e8 00 00 00 00       	callq  747c <e1000_watchdog+0x4bc>
				netdev->name);
			netif_carrier_off(netdev);
    747c:	4c 89 ef             	mov    %r13,%rdi
    747f:	e8 00 00 00 00       	callq  7484 <e1000_watchdog+0x4c4>
    7484:	48 8b 43 c8          	mov    -0x38(%rbx),%rax

			if (!test_bit(__E1000_DOWN, &adapter->flags))
    7488:	a8 04                	test   $0x4,%al
    748a:	0f 85 02 fe ff ff    	jne    7292 <e1000_watchdog+0x2d2>
 */
static inline bool queue_delayed_work(struct workqueue_struct *wq,
				      struct delayed_work *dwork,
				      unsigned long delay)
{
	return queue_delayed_work_on(WORK_CPU_UNBOUND, wq, dwork, delay);
    7490:	48 8b 35 00 00 00 00 	mov    0x0(%rip),%rsi        # 7497 <e1000_watchdog+0x4d7>
				schedule_delayed_work(&adapter->phy_info_task,
    7497:	48 8d 93 00 01 00 00 	lea    0x100(%rbx),%rdx
    749e:	b9 f4 01 00 00       	mov    $0x1f4,%ecx
    74a3:	bf 00 01 00 00       	mov    $0x100,%edi
    74a8:	e8 00 00 00 00       	callq  74ad <e1000_watchdog+0x4ed>
    74ad:	e9 e0 fd ff ff       	jmpq   7292 <e1000_watchdog+0x2d2>
    74b2:	48 8b 35 00 00 00 00 	mov    0x0(%rip),%rsi        # 74b9 <e1000_watchdog+0x4f9>
			tctl |= E1000_TCTL_EN;
			ew32(TCTL, tctl);

			netif_carrier_on(netdev);
			if (!test_bit(__E1000_DOWN, &adapter->flags))
				schedule_delayed_work(&adapter->phy_info_task,
    74b9:	48 8d 93 00 01 00 00 	lea    0x100(%rbx),%rdx
    74c0:	b9 f4 01 00 00       	mov    $0x1f4,%ecx
    74c5:	bf 00 01 00 00       	mov    $0x100,%edi
    74ca:	e8 00 00 00 00       	callq  74cf <e1000_watchdog+0x50f>
    74cf:	e9 2e fd ff ff       	jmpq   7202 <e1000_watchdog+0x242>
    74d4:	66 66 66 2e 0f 1f 84 	data32 data32 nopw %cs:0x0(%rax,%rax,1)
    74db:	00 00 00 00 00 

00000000000074e0 <e1000_pci_set_mwi>:
	}
	return E1000_SUCCESS;
}

void e1000_pci_set_mwi(struct e1000_hw *hw)
{
    74e0:	e8 00 00 00 00       	callq  74e5 <e1000_pci_set_mwi+0x5>
    74e5:	55                   	push   %rbp
    74e6:	48 89 e5             	mov    %rsp,%rbp
    74e9:	53                   	push   %rbx
	struct e1000_adapter *adapter = hw->back;
    74ea:	48 8b 5f 28          	mov    0x28(%rdi),%rbx
	int ret_val = pci_set_mwi(adapter->pdev);
    74ee:	48 8b bb b8 03 00 00 	mov    0x3b8(%rbx),%rdi
    74f5:	e8 00 00 00 00       	callq  74fa <e1000_pci_set_mwi+0x1a>

	if (ret_val)
    74fa:	85 c0                	test   %eax,%eax
    74fc:	74 09                	je     7507 <e1000_pci_set_mwi+0x27>
		e_err(probe, "Error in setting MWI\n");
    74fe:	f6 83 a0 07 00 00 02 	testb  $0x2,0x7a0(%rbx)
    7505:	75 03                	jne    750a <e1000_pci_set_mwi+0x2a>
}
    7507:	5b                   	pop    %rbx
    7508:	5d                   	pop    %rbp
    7509:	c3                   	retq   
{
	struct e1000_adapter *adapter = hw->back;
	int ret_val = pci_set_mwi(adapter->pdev);

	if (ret_val)
		e_err(probe, "Error in setting MWI\n");
    750a:	48 8b bb b0 03 00 00 	mov    0x3b0(%rbx),%rdi
    7511:	48 c7 c6 00 00 00 00 	mov    $0x0,%rsi
    7518:	31 c0                	xor    %eax,%eax
    751a:	e8 00 00 00 00       	callq  751f <e1000_pci_set_mwi+0x3f>
}
    751f:	5b                   	pop    %rbx
    7520:	5d                   	pop    %rbp
    7521:	c3                   	retq   
    7522:	66 66 66 66 66 2e 0f 	data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
    7529:	1f 84 00 00 00 00 00 

0000000000007530 <e1000_leave_82542_rst>:
	if (netif_running(netdev))
		e1000_clean_all_rx_rings(adapter);
}

static void e1000_leave_82542_rst(struct e1000_adapter *adapter)
{
    7530:	e8 00 00 00 00       	callq  7535 <e1000_leave_82542_rst+0x5>
    7535:	55                   	push   %rbp
    7536:	48 89 e5             	mov    %rsp,%rbp
    7539:	41 54                	push   %r12
    753b:	53                   	push   %rbx
    753c:	48 89 fb             	mov    %rdi,%rbx
	struct e1000_hw *hw = &adapter->hw;
	struct net_device *netdev = adapter->netdev;
    753f:	4c 8b a7 b0 03 00 00 	mov    0x3b0(%rdi),%r12
	u32 rctl;

	rctl = er32(RCTL);
    7546:	48 8b 87 c0 03 00 00 	mov    0x3c0(%rdi),%rax
{ asm volatile("mov" size " %0,%1": :reg (val), \
"m" (*(volatile type __force *)addr) barrier); }

build_mmio_read(readb, "b", unsigned char, "=q", :"memory")
build_mmio_read(readw, "w", unsigned short, "=r", :"memory")
build_mmio_read(readl, "l", unsigned int, "=r", :"memory")
    754d:	8b 80 00 01 00 00    	mov    0x100(%rax),%eax
	rctl &= ~E1000_RCTL_RST;
    7553:	83 e0 fe             	and    $0xfffffffe,%eax
	ew32(RCTL, rctl);
    7556:	48 8b 97 c0 03 00 00 	mov    0x3c0(%rdi),%rdx
build_mmio_read(__readw, "w", unsigned short, "=r", )
build_mmio_read(__readl, "l", unsigned int, "=r", )

build_mmio_write(writeb, "b", unsigned char, "q", :"memory")
build_mmio_write(writew, "w", unsigned short, "r", :"memory")
build_mmio_write(writel, "l", unsigned int, "r", :"memory")
    755d:	89 82 00 01 00 00    	mov    %eax,0x100(%rdx)
	E1000_WRITE_FLUSH();
    7563:	48 8b 87 c0 03 00 00 	mov    0x3c0(%rdi),%rax
{ asm volatile("mov" size " %0,%1": :reg (val), \
"m" (*(volatile type __force *)addr) barrier); }

build_mmio_read(readb, "b", unsigned char, "=q", :"memory")
build_mmio_read(readw, "w", unsigned short, "=r", :"memory")
build_mmio_read(readl, "l", unsigned int, "=r", :"memory")
    756a:	8b 40 08             	mov    0x8(%rax),%eax
	mdelay(5);
    756d:	bf b8 ae 47 01       	mov    $0x147aeb8,%edi
    7572:	e8 00 00 00 00       	callq  7577 <e1000_leave_82542_rst+0x47>

	if (hw->pci_cmd_word & PCI_COMMAND_INVALIDATE)
    7577:	f6 83 94 04 00 00 10 	testb  $0x10,0x494(%rbx)
    757e:	75 4e                	jne    75ce <e1000_leave_82542_rst+0x9e>
    7580:	49 8b 44 24 48       	mov    0x48(%r12),%rax
		e1000_pci_set_mwi(hw);

	if (netif_running(netdev)) {
    7585:	a8 01                	test   $0x1,%al
    7587:	75 05                	jne    758e <e1000_leave_82542_rst+0x5e>
		/* No need to loop, because 82542 supports only 1 queue */
		struct e1000_rx_ring *ring = &adapter->rx_ring[0];
		e1000_configure_rx(adapter);
		adapter->alloc_rx_buf(adapter, ring, E1000_DESC_UNUSED(ring));
	}
}
    7589:	5b                   	pop    %rbx
    758a:	41 5c                	pop    %r12
    758c:	5d                   	pop    %rbp
    758d:	c3                   	retq   
	if (hw->pci_cmd_word & PCI_COMMAND_INVALIDATE)
		e1000_pci_set_mwi(hw);

	if (netif_running(netdev)) {
		/* No need to loop, because 82542 supports only 1 queue */
		struct e1000_rx_ring *ring = &adapter->rx_ring[0];
    758e:	4c 8b a3 a8 02 00 00 	mov    0x2a8(%rbx),%r12
		e1000_configure_rx(adapter);
    7595:	48 89 df             	mov    %rbx,%rdi
    7598:	e8 63 8b ff ff       	callq  100 <e1000_configure_rx>
		adapter->alloc_rx_buf(adapter, ring, E1000_DESC_UNUSED(ring));
    759d:	31 d2                	xor    %edx,%edx
    759f:	4c 8b 83 a0 02 00 00 	mov    0x2a0(%rbx),%r8
    75a6:	41 8b 44 24 1c       	mov    0x1c(%r12),%eax
    75ab:	41 8b 4c 24 18       	mov    0x18(%r12),%ecx
    75b0:	39 c8                	cmp    %ecx,%eax
    75b2:	77 05                	ja     75b9 <e1000_leave_82542_rst+0x89>
    75b4:	41 8b 54 24 14       	mov    0x14(%r12),%edx
    75b9:	83 e8 01             	sub    $0x1,%eax
    75bc:	4c 89 e6             	mov    %r12,%rsi
    75bf:	48 89 df             	mov    %rbx,%rdi
    75c2:	29 c8                	sub    %ecx,%eax
    75c4:	01 c2                	add    %eax,%edx
    75c6:	41 ff d0             	callq  *%r8
	}
}
    75c9:	5b                   	pop    %rbx
    75ca:	41 5c                	pop    %r12
    75cc:	5d                   	pop    %rbp
    75cd:	c3                   	retq   
		e1000_clean_all_rx_rings(adapter);
}

static void e1000_leave_82542_rst(struct e1000_adapter *adapter)
{
	struct e1000_hw *hw = &adapter->hw;
    75ce:	48 8d bb c0 03 00 00 	lea    0x3c0(%rbx),%rdi
	ew32(RCTL, rctl);
	E1000_WRITE_FLUSH();
	mdelay(5);

	if (hw->pci_cmd_word & PCI_COMMAND_INVALIDATE)
		e1000_pci_set_mwi(hw);
    75d5:	e8 00 00 00 00       	callq  75da <e1000_leave_82542_rst+0xaa>
    75da:	eb a4                	jmp    7580 <e1000_leave_82542_rst+0x50>
    75dc:	0f 1f 40 00          	nopl   0x0(%rax)

00000000000075e0 <e1000_set_rx_mode>:
 * address lists or the network interface flags are updated. This routine is
 * responsible for configuring the hardware for proper unicast, multicast,
 * promiscuous mode, and all-multi behavior.
 **/
static void e1000_set_rx_mode(struct net_device *netdev)
{
    75e0:	e8 00 00 00 00       	callq  75e5 <e1000_set_rx_mode+0x5>
    75e5:	55                   	push   %rbp
	struct e1000_adapter *adapter = netdev_priv(netdev);
    75e6:	48 8d 87 40 08 00 00 	lea    0x840(%rdi),%rax
 */
static inline void *kmalloc_array(size_t n, size_t size, gfp_t flags)
{
	if (size != 0 && n > SIZE_MAX / size)
		return NULL;
	return __kmalloc(n * size, flags);
    75ed:	be 20 80 08 02       	mov    $0x2088020,%esi
 * address lists or the network interface flags are updated. This routine is
 * responsible for configuring the hardware for proper unicast, multicast,
 * promiscuous mode, and all-multi behavior.
 **/
static void e1000_set_rx_mode(struct net_device *netdev)
{
    75f2:	48 89 e5             	mov    %rsp,%rbp
    75f5:	41 57                	push   %r15
    75f7:	49 89 ff             	mov    %rdi,%r15
    75fa:	41 56                	push   %r14
    75fc:	41 55                	push   %r13
    75fe:	41 54                	push   %r12
    7600:	53                   	push   %rbx
	struct e1000_adapter *adapter = netdev_priv(netdev);
	struct e1000_hw *hw = &adapter->hw;
    7601:	48 8d 9f 00 0c 00 00 	lea    0xc00(%rdi),%rbx
    7608:	bf 00 02 00 00       	mov    $0x200,%edi
 * address lists or the network interface flags are updated. This routine is
 * responsible for configuring the hardware for proper unicast, multicast,
 * promiscuous mode, and all-multi behavior.
 **/
static void e1000_set_rx_mode(struct net_device *netdev)
{
    760d:	48 83 ec 18          	sub    $0x18,%rsp
	struct e1000_adapter *adapter = netdev_priv(netdev);
    7611:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
    7615:	e8 00 00 00 00       	callq  761a <e1000_set_rx_mode+0x3a>
	u32 hash_value;
	int i, rar_entries = E1000_RAR_ENTRIES;
	int mta_reg_count = E1000_NUM_MTA_REGISTERS;
	u32 *mcarray = kcalloc(mta_reg_count, sizeof(u32), GFP_ATOMIC);

	if (!mcarray)
    761a:	48 85 c0             	test   %rax,%rax
    761d:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
    7621:	0f 84 16 02 00 00    	je     783d <e1000_set_rx_mode+0x25d>
		return;

	/* Check for Promiscuous and All Multicast modes */

	rctl = er32(RCTL);
    7627:	49 8b 87 00 0c 00 00 	mov    0xc00(%r15),%rax
    762e:	8b 90 00 01 00 00    	mov    0x100(%rax),%edx

	if (netdev->flags & IFF_PROMISC) {
    7634:	41 8b 87 20 02 00 00 	mov    0x220(%r15),%eax
    763b:	f6 c4 01             	test   $0x1,%ah
    763e:	0f 85 08 02 00 00    	jne    784c <e1000_set_rx_mode+0x26c>
		rctl |= (E1000_RCTL_UPE | E1000_RCTL_MPE);
		rctl &= ~E1000_RCTL_VFE;
	} else {
		if (netdev->flags & IFF_ALLMULTI)
			rctl |= E1000_RCTL_MPE;
    7644:	41 89 d4             	mov    %edx,%r12d

static bool e1000_vlan_used(struct e1000_adapter *adapter)
{
	u16 vid;

	for_each_set_bit(vid, adapter->active_vlans, VLAN_N_VID)
    7647:	48 8b 7d c0          	mov    -0x40(%rbp),%rdi
	if (netdev->flags & IFF_PROMISC) {
		rctl |= (E1000_RCTL_UPE | E1000_RCTL_MPE);
		rctl &= ~E1000_RCTL_VFE;
	} else {
		if (netdev->flags & IFF_ALLMULTI)
			rctl |= E1000_RCTL_MPE;
    764b:	83 e2 ef             	and    $0xffffffef,%edx
    764e:	41 83 cc 10          	or     $0x10,%r12d
    7652:	f6 c4 02             	test   $0x2,%ah

static bool e1000_vlan_used(struct e1000_adapter *adapter)
{
	u16 vid;

	for_each_set_bit(vid, adapter->active_vlans, VLAN_N_VID)
    7655:	be 00 10 00 00       	mov    $0x1000,%esi
	if (netdev->flags & IFF_PROMISC) {
		rctl |= (E1000_RCTL_UPE | E1000_RCTL_MPE);
		rctl &= ~E1000_RCTL_VFE;
	} else {
		if (netdev->flags & IFF_ALLMULTI)
			rctl |= E1000_RCTL_MPE;
    765a:	44 0f 44 e2          	cmove  %edx,%r12d

static bool e1000_vlan_used(struct e1000_adapter *adapter)
{
	u16 vid;

	for_each_set_bit(vid, adapter->active_vlans, VLAN_N_VID)
    765e:	e8 00 00 00 00       	callq  7663 <e1000_set_rx_mode+0x83>
			rctl |= E1000_RCTL_MPE;
		else
			rctl &= ~E1000_RCTL_MPE;
		/* Enable VLAN filter if there is a VLAN */
		if (e1000_vlan_used(adapter))
			rctl |= E1000_RCTL_VFE;
    7663:	44 89 e2             	mov    %r12d,%edx
    7666:	81 ca 00 00 04 00    	or     $0x40000,%edx
    766c:	66 3d ff 0f          	cmp    $0xfff,%ax
    7670:	44 0f 46 e2          	cmovbe %edx,%r12d
	}

	if (netdev_uc_count(netdev) > rar_entries - 1) {
    7674:	41 83 bf 80 02 00 00 	cmpl   $0xe,0x280(%r15)
    767b:	0e 
    767c:	0f 8e e5 01 00 00    	jle    7867 <e1000_set_rx_mode+0x287>
		rctl |= E1000_RCTL_UPE;
    7682:	41 83 cc 08          	or     $0x8,%r12d
static void e1000_set_rx_mode(struct net_device *netdev)
{
	struct e1000_adapter *adapter = netdev_priv(netdev);
	struct e1000_hw *hw = &adapter->hw;
	struct netdev_hw_addr *ha;
	bool use_uc = false;
    7686:	45 31 ed             	xor    %r13d,%r13d
	} else if (!(netdev->flags & IFF_PROMISC)) {
		rctl &= ~E1000_RCTL_UPE;
		use_uc = true;
	}

	ew32(RCTL, rctl);
    7689:	49 8b 87 00 0c 00 00 	mov    0xc00(%r15),%rax
build_mmio_read(__readw, "w", unsigned short, "=r", )
build_mmio_read(__readl, "l", unsigned int, "=r", )

build_mmio_write(writeb, "b", unsigned char, "q", :"memory")
build_mmio_write(writew, "w", unsigned short, "r", :"memory")
build_mmio_write(writel, "l", unsigned int, "r", :"memory")
    7690:	44 89 a0 00 01 00 00 	mov    %r12d,0x100(%rax)

	/* 82542 2.0 needs to be in reset to write receive address registers */

	if (hw->mac_type == e1000_82542_rev2_0)
    7697:	41 83 bf 18 0c 00 00 	cmpl   $0x1,0xc18(%r15)
    769e:	01 
    769f:	0f 84 e2 01 00 00    	je     7887 <e1000_set_rx_mode+0x2a7>
	 *
	 * RAR 0 is used for the station MAC address
	 * if there are not 14 addresses, go ahead and clear the filters
	 */
	i = 1;
	if (use_uc)
    76a5:	45 84 ed             	test   %r13b,%r13b
	 * when possible.
	 *
	 * RAR 0 is used for the station MAC address
	 * if there are not 14 addresses, go ahead and clear the filters
	 */
	i = 1;
    76a8:	41 be 01 00 00 00    	mov    $0x1,%r14d
	if (use_uc)
    76ae:	74 36                	je     76e6 <e1000_set_rx_mode+0x106>
		netdev_for_each_uc_addr(ha, netdev) {
    76b0:	4d 8b af 70 02 00 00 	mov    0x270(%r15),%r13
    76b7:	4d 8d a7 70 02 00 00 	lea    0x270(%r15),%r12
    76be:	4d 39 e5             	cmp    %r12,%r13
    76c1:	74 23                	je     76e6 <e1000_set_rx_mode+0x106>
			if (i == rar_entries)
				break;
			e1000_rar_set(hw, ha->addr, i++);
    76c3:	41 83 c6 01          	add    $0x1,%r14d
    76c7:	49 8d 75 10          	lea    0x10(%r13),%rsi
    76cb:	48 89 df             	mov    %rbx,%rdi
    76ce:	41 8d 56 ff          	lea    -0x1(%r14),%edx
    76d2:	e8 00 00 00 00       	callq  76d7 <e1000_set_rx_mode+0xf7>
	 * RAR 0 is used for the station MAC address
	 * if there are not 14 addresses, go ahead and clear the filters
	 */
	i = 1;
	if (use_uc)
		netdev_for_each_uc_addr(ha, netdev) {
    76d7:	4d 8b 6d 00          	mov    0x0(%r13),%r13
    76db:	4d 39 e5             	cmp    %r12,%r13
    76de:	74 06                	je     76e6 <e1000_set_rx_mode+0x106>
			if (i == rar_entries)
    76e0:	41 83 fe 0f          	cmp    $0xf,%r14d
    76e4:	75 dd                	jne    76c3 <e1000_set_rx_mode+0xe3>
				break;
			e1000_rar_set(hw, ha->addr, i++);
		}

	netdev_for_each_mc_addr(ha, netdev) {
    76e6:	4d 8b af 88 02 00 00 	mov    0x288(%r15),%r13
    76ed:	49 8d 87 88 02 00 00 	lea    0x288(%r15),%rax
    76f4:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
    76f8:	49 39 c5             	cmp    %rax,%r13
    76fb:	75 22                	jne    771f <e1000_set_rx_mode+0x13f>
    76fd:	eb 56                	jmp    7755 <e1000_set_rx_mode+0x175>
			hash_reg = (hash_value >> 5) & 0x7F;
			hash_bit = hash_value & 0x1F;
			mta = (1 << hash_bit);
			mcarray[hash_reg] |= mta;
		} else {
			e1000_rar_set(hw, ha->addr, i++);
    76ff:	49 8d 75 10          	lea    0x10(%r13),%rsi
    7703:	44 89 f2             	mov    %r14d,%edx
    7706:	48 89 df             	mov    %rbx,%rdi
    7709:	45 8d 66 01          	lea    0x1(%r14),%r12d
    770d:	e8 00 00 00 00       	callq  7712 <e1000_set_rx_mode+0x132>
			if (i == rar_entries)
				break;
			e1000_rar_set(hw, ha->addr, i++);
		}

	netdev_for_each_mc_addr(ha, netdev) {
    7712:	4d 8b 6d 00          	mov    0x0(%r13),%r13
    7716:	4c 39 6d d0          	cmp    %r13,-0x30(%rbp)
			hash_reg = (hash_value >> 5) & 0x7F;
			hash_bit = hash_value & 0x1F;
			mta = (1 << hash_bit);
			mcarray[hash_reg] |= mta;
		} else {
			e1000_rar_set(hw, ha->addr, i++);
    771a:	45 89 e6             	mov    %r12d,%r14d
			if (i == rar_entries)
				break;
			e1000_rar_set(hw, ha->addr, i++);
		}

	netdev_for_each_mc_addr(ha, netdev) {
    771d:	74 36                	je     7755 <e1000_set_rx_mode+0x175>
		if (i == rar_entries) {
    771f:	41 83 fe 0f          	cmp    $0xf,%r14d
    7723:	75 da                	jne    76ff <e1000_set_rx_mode+0x11f>
			/* load any remaining addresses into the hash table */
			u32 hash_reg, hash_bit, mta;
			hash_value = e1000_hash_mc_addr(hw, ha->addr);
    7725:	49 8d 75 10          	lea    0x10(%r13),%rsi
    7729:	48 89 df             	mov    %rbx,%rdi
    772c:	e8 00 00 00 00       	callq  7731 <e1000_set_rx_mode+0x151>
			hash_reg = (hash_value >> 5) & 0x7F;
			hash_bit = hash_value & 0x1F;
			mta = (1 << hash_bit);
    7731:	bf 01 00 00 00       	mov    $0x1,%edi
    7736:	89 c1                	mov    %eax,%ecx
	netdev_for_each_mc_addr(ha, netdev) {
		if (i == rar_entries) {
			/* load any remaining addresses into the hash table */
			u32 hash_reg, hash_bit, mta;
			hash_value = e1000_hash_mc_addr(hw, ha->addr);
			hash_reg = (hash_value >> 5) & 0x7F;
    7738:	89 c2                	mov    %eax,%edx
			hash_bit = hash_value & 0x1F;
			mta = (1 << hash_bit);
    773a:	d3 e7                	shl    %cl,%edi
	netdev_for_each_mc_addr(ha, netdev) {
		if (i == rar_entries) {
			/* load any remaining addresses into the hash table */
			u32 hash_reg, hash_bit, mta;
			hash_value = e1000_hash_mc_addr(hw, ha->addr);
			hash_reg = (hash_value >> 5) & 0x7F;
    773c:	c1 ea 05             	shr    $0x5,%edx
			hash_bit = hash_value & 0x1F;
			mta = (1 << hash_bit);
    773f:	89 f8                	mov    %edi,%eax
			mcarray[hash_reg] |= mta;
    7741:	48 8b 7d c8          	mov    -0x38(%rbp),%rdi
    7745:	83 e2 7f             	and    $0x7f,%edx
    7748:	09 04 97             	or     %eax,(%rdi,%rdx,4)
			if (i == rar_entries)
				break;
			e1000_rar_set(hw, ha->addr, i++);
		}

	netdev_for_each_mc_addr(ha, netdev) {
    774b:	4d 8b 6d 00          	mov    0x0(%r13),%r13
    774f:	4c 39 6d d0          	cmp    %r13,-0x30(%rbp)
    7753:	75 ca                	jne    771f <e1000_set_rx_mode+0x13f>
		} else {
			e1000_rar_set(hw, ha->addr, i++);
		}
	}

	for (; i < rar_entries; i++) {
    7755:	41 83 fe 0f          	cmp    $0xf,%r14d
    7759:	74 7a                	je     77d5 <e1000_set_rx_mode+0x1f5>
    775b:	31 d2                	xor    %edx,%edx
		E1000_WRITE_REG_ARRAY(hw, RA, i << 1, 0);
    775d:	41 83 bf 18 0c 00 00 	cmpl   $0x3,0xc18(%r15)
    7764:	03 
    7765:	42 8d 0c f5 00 00 00 	lea    0x0(,%r14,8),%ecx
    776c:	00 
    776d:	48 63 c9             	movslq %ecx,%rcx
    7770:	48 19 c0             	sbb    %rax,%rax
    7773:	48 25 40 ac ff ff    	and    $0xffffffffffffac40,%rax
    7779:	48 8d 84 08 00 54 00 	lea    0x5400(%rax,%rcx,1),%rax
    7780:	00 
    7781:	49 03 87 00 0c 00 00 	add    0xc00(%r15),%rax
    7788:	89 10                	mov    %edx,(%rax)
		E1000_WRITE_FLUSH();
    778a:	49 8b 87 00 0c 00 00 	mov    0xc00(%r15),%rax
{ asm volatile("mov" size " %0,%1": :reg (val), \
"m" (*(volatile type __force *)addr) barrier); }

build_mmio_read(readb, "b", unsigned char, "=q", :"memory")
build_mmio_read(readw, "w", unsigned short, "=r", :"memory")
build_mmio_read(readl, "l", unsigned int, "=r", :"memory")
    7791:	8b 40 08             	mov    0x8(%rax),%eax
		E1000_WRITE_REG_ARRAY(hw, RA, (i << 1) + 1, 0);
    7794:	41 83 bf 18 0c 00 00 	cmpl   $0x3,0xc18(%r15)
    779b:	03 
    779c:	42 8d 0c f5 04 00 00 	lea    0x4(,%r14,8),%ecx
    77a3:	00 
    77a4:	48 63 c9             	movslq %ecx,%rcx
    77a7:	48 19 c0             	sbb    %rax,%rax
    77aa:	48 25 40 ac ff ff    	and    $0xffffffffffffac40,%rax
    77b0:	48 8d 84 08 00 54 00 	lea    0x5400(%rax,%rcx,1),%rax
    77b7:	00 
    77b8:	49 03 87 00 0c 00 00 	add    0xc00(%r15),%rax
build_mmio_read(__readw, "w", unsigned short, "=r", )
build_mmio_read(__readl, "l", unsigned int, "=r", )

build_mmio_write(writeb, "b", unsigned char, "q", :"memory")
build_mmio_write(writew, "w", unsigned short, "r", :"memory")
build_mmio_write(writel, "l", unsigned int, "r", :"memory")
    77bf:	89 10                	mov    %edx,(%rax)
		E1000_WRITE_FLUSH();
    77c1:	49 8b 87 00 0c 00 00 	mov    0xc00(%r15),%rax
{ asm volatile("mov" size " %0,%1": :reg (val), \
"m" (*(volatile type __force *)addr) barrier); }

build_mmio_read(readb, "b", unsigned char, "=q", :"memory")
build_mmio_read(readw, "w", unsigned short, "=r", :"memory")
build_mmio_read(readl, "l", unsigned int, "=r", :"memory")
    77c8:	8b 40 08             	mov    0x8(%rax),%eax
		} else {
			e1000_rar_set(hw, ha->addr, i++);
		}
	}

	for (; i < rar_entries; i++) {
    77cb:	41 83 c6 01          	add    $0x1,%r14d
    77cf:	41 83 fe 0f          	cmp    $0xf,%r14d
    77d3:	75 88                	jne    775d <e1000_set_rx_mode+0x17d>
    77d5:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
    77d9:	48 8d 88 fc 01 00 00 	lea    0x1fc(%rax),%rcx
		E1000_WRITE_REG_ARRAY(hw, RA, i << 1, 0);
		E1000_WRITE_FLUSH();
		E1000_WRITE_REG_ARRAY(hw, RA, (i << 1) + 1, 0);
    77e0:	b8 7f 00 00 00       	mov    $0x7f,%eax
		/* If we are on an 82544 has an errata where writing odd
		 * offsets overwrites the previous even offset, but writing
		 * backwards over the range solves the issue by always
		 * writing the odd offset first
		 */
		E1000_WRITE_REG_ARRAY(hw, MTA, i, mcarray[i]);
    77e5:	41 83 bf 18 0c 00 00 	cmpl   $0x3,0xc18(%r15)
    77ec:	03 
    77ed:	8d 34 85 00 00 00 00 	lea    0x0(,%rax,4),%esi
    77f4:	48 63 f6             	movslq %esi,%rsi
    77f7:	48 19 d2             	sbb    %rdx,%rdx
    77fa:	48 81 e2 00 b0 ff ff 	and    $0xffffffffffffb000,%rdx
    7801:	48 8d 94 32 00 52 00 	lea    0x5200(%rdx,%rsi,1),%rdx
    7808:	00 
    7809:	8b 31                	mov    (%rcx),%esi
    780b:	49 03 97 00 0c 00 00 	add    0xc00(%r15),%rdx
build_mmio_read(__readw, "w", unsigned short, "=r", )
build_mmio_read(__readl, "l", unsigned int, "=r", )

build_mmio_write(writeb, "b", unsigned char, "q", :"memory")
build_mmio_write(writew, "w", unsigned short, "r", :"memory")
build_mmio_write(writel, "l", unsigned int, "r", :"memory")
    7812:	89 32                	mov    %esi,(%rdx)
	}

	/* write the hash table completely, write from bottom to avoid
	 * both stupid write combining chipsets, and flushing each write
	 */
	for (i = mta_reg_count - 1; i >= 0 ; i--) {
    7814:	83 e8 01             	sub    $0x1,%eax
    7817:	48 83 e9 04          	sub    $0x4,%rcx
    781b:	83 f8 ff             	cmp    $0xffffffff,%eax
    781e:	75 c5                	jne    77e5 <e1000_set_rx_mode+0x205>
		 * backwards over the range solves the issue by always
		 * writing the odd offset first
		 */
		E1000_WRITE_REG_ARRAY(hw, MTA, i, mcarray[i]);
	}
	E1000_WRITE_FLUSH();
    7820:	49 8b 87 00 0c 00 00 	mov    0xc00(%r15),%rax
{ asm volatile("mov" size " %0,%1": :reg (val), \
"m" (*(volatile type __force *)addr) barrier); }

build_mmio_read(readb, "b", unsigned char, "=q", :"memory")
build_mmio_read(readw, "w", unsigned short, "=r", :"memory")
build_mmio_read(readl, "l", unsigned int, "=r", :"memory")
    7827:	8b 40 08             	mov    0x8(%rax),%eax

	if (hw->mac_type == e1000_82542_rev2_0)
    782a:	41 83 bf 18 0c 00 00 	cmpl   $0x1,0xc18(%r15)
    7831:	01 
    7832:	74 61                	je     7895 <e1000_set_rx_mode+0x2b5>
		e1000_leave_82542_rst(adapter);

	kfree(mcarray);
    7834:	48 8b 7d c8          	mov    -0x38(%rbp),%rdi
    7838:	e8 00 00 00 00       	callq  783d <e1000_set_rx_mode+0x25d>
}
    783d:	48 83 c4 18          	add    $0x18,%rsp
    7841:	5b                   	pop    %rbx
    7842:	41 5c                	pop    %r12
    7844:	41 5d                	pop    %r13
    7846:	41 5e                	pop    %r14
    7848:	41 5f                	pop    %r15
    784a:	5d                   	pop    %rbp
    784b:	c3                   	retq   

	rctl = er32(RCTL);

	if (netdev->flags & IFF_PROMISC) {
		rctl |= (E1000_RCTL_UPE | E1000_RCTL_MPE);
		rctl &= ~E1000_RCTL_VFE;
    784c:	81 e2 ff ff fb ff    	and    $0xfffbffff,%edx
    7852:	41 89 d4             	mov    %edx,%r12d
    7855:	41 83 cc 18          	or     $0x18,%r12d
		/* Enable VLAN filter if there is a VLAN */
		if (e1000_vlan_used(adapter))
			rctl |= E1000_RCTL_VFE;
	}

	if (netdev_uc_count(netdev) > rar_entries - 1) {
    7859:	41 83 bf 80 02 00 00 	cmpl   $0xe,0x280(%r15)
    7860:	0e 
    7861:	0f 8f 1b fe ff ff    	jg     7682 <e1000_set_rx_mode+0xa2>
static void e1000_set_rx_mode(struct net_device *netdev)
{
	struct e1000_adapter *adapter = netdev_priv(netdev);
	struct e1000_hw *hw = &adapter->hw;
	struct netdev_hw_addr *ha;
	bool use_uc = false;
    7867:	45 31 ed             	xor    %r13d,%r13d
			rctl |= E1000_RCTL_VFE;
	}

	if (netdev_uc_count(netdev) > rar_entries - 1) {
		rctl |= E1000_RCTL_UPE;
	} else if (!(netdev->flags & IFF_PROMISC)) {
    786a:	41 f6 87 21 02 00 00 	testb  $0x1,0x221(%r15)
    7871:	01 
    7872:	0f 85 11 fe ff ff    	jne    7689 <e1000_set_rx_mode+0xa9>
		rctl &= ~E1000_RCTL_UPE;
    7878:	41 83 e4 f7          	and    $0xfffffff7,%r12d
		use_uc = true;
    787c:	41 bd 01 00 00 00    	mov    $0x1,%r13d
    7882:	e9 02 fe ff ff       	jmpq   7689 <e1000_set_rx_mode+0xa9>
	ew32(RCTL, rctl);

	/* 82542 2.0 needs to be in reset to write receive address registers */

	if (hw->mac_type == e1000_82542_rev2_0)
		e1000_enter_82542_rst(adapter);
    7887:	48 8b 7d c0          	mov    -0x40(%rbp),%rdi
    788b:	e8 b0 b3 ff ff       	callq  2c40 <e1000_enter_82542_rst>
    7890:	e9 10 fe ff ff       	jmpq   76a5 <e1000_set_rx_mode+0xc5>
		E1000_WRITE_REG_ARRAY(hw, MTA, i, mcarray[i]);
	}
	E1000_WRITE_FLUSH();

	if (hw->mac_type == e1000_82542_rev2_0)
		e1000_leave_82542_rst(adapter);
    7895:	48 8b 7d c0          	mov    -0x40(%rbp),%rdi
    7899:	e8 92 fc ff ff       	callq  7530 <e1000_leave_82542_rst>
    789e:	66 90                	xchg   %ax,%ax
    78a0:	eb 92                	jmp    7834 <e1000_set_rx_mode+0x254>
    78a2:	66 66 66 66 66 2e 0f 	data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
    78a9:	1f 84 00 00 00 00 00 

00000000000078b0 <__e1000_shutdown>:
	e_err(probe, "Unsupported Speed/Duplex configuration\n");
	return -EINVAL;
}

static int __e1000_shutdown(struct pci_dev *pdev, bool *enable_wake)
{
    78b0:	e8 00 00 00 00       	callq  78b5 <__e1000_shutdown+0x5>
    78b5:	55                   	push   %rbp
    78b6:	48 89 e5             	mov    %rsp,%rbp
    78b9:	41 57                	push   %r15
    78bb:	49 89 f7             	mov    %rsi,%r15
    78be:	41 56                	push   %r14
    78c0:	49 89 fe             	mov    %rdi,%r14
    78c3:	41 55                	push   %r13
    78c5:	41 54                	push   %r12
    78c7:	53                   	push   %rbx
    78c8:	48 83 ec 08          	sub    $0x8,%rsp
    78cc:	4c 8b a7 38 01 00 00 	mov    0x138(%rdi),%r12
	struct net_device *netdev = pci_get_drvdata(pdev);
	struct e1000_adapter *adapter = netdev_priv(netdev);
    78d3:	49 8d 84 24 40 08 00 	lea    0x840(%r12),%rax
    78da:	00 
	u32 wufc = adapter->wol;
#ifdef CONFIG_PM
	int retval = 0;
#endif

	netif_device_detach(netdev);
    78db:	4c 89 e7             	mov    %r12,%rdi
{
	struct net_device *netdev = pci_get_drvdata(pdev);
	struct e1000_adapter *adapter = netdev_priv(netdev);
	struct e1000_hw *hw = &adapter->hw;
	u32 ctrl, ctrl_ext, rctl, status;
	u32 wufc = adapter->wol;
    78de:	45 8b ac 24 4c 0a 00 	mov    0xa4c(%r12),%r13d
    78e5:	00 
}

static int __e1000_shutdown(struct pci_dev *pdev, bool *enable_wake)
{
	struct net_device *netdev = pci_get_drvdata(pdev);
	struct e1000_adapter *adapter = netdev_priv(netdev);
    78e6:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
	u32 wufc = adapter->wol;
#ifdef CONFIG_PM
	int retval = 0;
#endif

	netif_device_detach(netdev);
    78ea:	e8 00 00 00 00       	callq  78ef <__e1000_shutdown+0x3f>
    78ef:	49 8b 44 24 48       	mov    0x48(%r12),%rax

	if (netif_running(netdev)) {
    78f4:	a8 01                	test   $0x1,%al
    78f6:	74 2e                	je     7926 <__e1000_shutdown+0x76>
    78f8:	49 8b 84 24 e8 0f 00 	mov    0xfe8(%r12),%rax
    78ff:	00 
		int count = E1000_CHECK_RESET_COUNT;

		while (test_bit(__E1000_RESETTING, &adapter->flags) && count--)
    7900:	bb 32 00 00 00       	mov    $0x32,%ebx
    7905:	a8 02                	test   $0x2,%al
    7907:	0f 85 c5 00 00 00    	jne    79d2 <__e1000_shutdown+0x122>
    790d:	49 8b 84 24 e8 0f 00 	mov    0xfe8(%r12),%rax
    7914:	00 
			usleep_range(10000, 20000);

		WARN_ON(test_bit(__E1000_RESETTING, &adapter->flags));
    7915:	a8 02                	test   $0x2,%al
    7917:	0f 85 bf 01 00 00    	jne    7adc <__e1000_shutdown+0x22c>
		e1000_down(adapter);
    791d:	48 8b 7d d0          	mov    -0x30(%rbp),%rdi
    7921:	e8 00 00 00 00       	callq  7926 <__e1000_shutdown+0x76>
	}

#ifdef CONFIG_PM
	retval = pci_save_state(pdev);
    7926:	4c 89 f7             	mov    %r14,%rdi
    7929:	e8 00 00 00 00       	callq  792e <__e1000_shutdown+0x7e>
	if (retval)
    792e:	85 c0                	test   %eax,%eax
    7930:	0f 85 84 00 00 00    	jne    79ba <__e1000_shutdown+0x10a>
		return retval;
#endif

	status = er32(STATUS);
    7936:	49 8b 84 24 00 0c 00 	mov    0xc00(%r12),%rax
    793d:	00 
    793e:	8b 50 08             	mov    0x8(%rax),%edx
	if (status & E1000_STATUS_LU)
		wufc &= ~E1000_WUFC_LNKC;
    7941:	44 89 e8             	mov    %r13d,%eax
    7944:	83 e0 fe             	and    $0xfffffffe,%eax
    7947:	83 e2 02             	and    $0x2,%edx
    794a:	44 0f 45 e8          	cmovne %eax,%r13d

	if (wufc) {
    794e:	45 85 ed             	test   %r13d,%r13d
    7951:	0f 85 9b 00 00 00    	jne    79f2 <__e1000_shutdown+0x142>
		}

		ew32(WUC, E1000_WUC_PME_EN);
		ew32(WUFC, wufc);
	} else {
		ew32(WUC, 0);
    7957:	49 8b 94 24 00 0c 00 	mov    0xc00(%r12),%rdx
    795e:	00 
build_mmio_read(__readw, "w", unsigned short, "=r", )
build_mmio_read(__readl, "l", unsigned int, "=r", )

build_mmio_write(writeb, "b", unsigned char, "q", :"memory")
build_mmio_write(writew, "w", unsigned short, "r", :"memory")
build_mmio_write(writel, "l", unsigned int, "r", :"memory")
    795f:	31 c0                	xor    %eax,%eax
    7961:	89 82 00 58 00 00    	mov    %eax,0x5800(%rdx)
		ew32(WUFC, 0);
    7967:	49 8b 94 24 00 0c 00 	mov    0xc00(%r12),%rdx
    796e:	00 
    796f:	89 82 08 58 00 00    	mov    %eax,0x5808(%rdx)

static void e1000_release_manageability(struct e1000_adapter *adapter)
{
	struct e1000_hw *hw = &adapter->hw;

	if (adapter->en_mng_pt) {
    7975:	41 8b b4 24 54 0a 00 	mov    0xa54(%r12),%esi
    797c:	00 
    797d:	85 f6                	test   %esi,%esi
    797f:	0f 85 0f 01 00 00    	jne    7a94 <__e1000_shutdown+0x1e4>
		ew32(WUFC, 0);
	}

	e1000_release_manageability(adapter);

	*enable_wake = !!wufc;
    7985:	45 85 ed             	test   %r13d,%r13d

	/* make sure adapter isn't asleep if manageability is enabled */
	if (adapter->en_mng_pt)
		*enable_wake = true;
    7988:	b8 01 00 00 00       	mov    $0x1,%eax
		ew32(WUFC, 0);
	}

	e1000_release_manageability(adapter);

	*enable_wake = !!wufc;
    798d:	0f 95 c2             	setne  %dl
    7990:	41 88 17             	mov    %dl,(%r15)

	/* make sure adapter isn't asleep if manageability is enabled */
	if (adapter->en_mng_pt)
		*enable_wake = true;
    7993:	41 8b 8c 24 54 0a 00 	mov    0xa54(%r12),%ecx
    799a:	00 
    799b:	85 c9                	test   %ecx,%ecx
    799d:	0f 44 c2             	cmove  %edx,%eax
    79a0:	41 88 07             	mov    %al,(%r15)
    79a3:	49 8b 44 24 48       	mov    0x48(%r12),%rax

	if (netif_running(netdev))
    79a8:	a8 01                	test   $0x1,%al
    79aa:	0f 85 f2 00 00 00    	jne    7aa2 <__e1000_shutdown+0x1f2>
		e1000_free_irq(adapter);

	pci_disable_device(pdev);
    79b0:	4c 89 f7             	mov    %r14,%rdi
    79b3:	e8 00 00 00 00       	callq  79b8 <__e1000_shutdown+0x108>

	return 0;
    79b8:	31 c0                	xor    %eax,%eax
}
    79ba:	48 83 c4 08          	add    $0x8,%rsp
    79be:	5b                   	pop    %rbx
    79bf:	41 5c                	pop    %r12
    79c1:	41 5d                	pop    %r13
    79c3:	41 5e                	pop    %r14
    79c5:	41 5f                	pop    %r15
    79c7:	5d                   	pop    %rbp
    79c8:	c3                   	retq   
	netif_device_detach(netdev);

	if (netif_running(netdev)) {
		int count = E1000_CHECK_RESET_COUNT;

		while (test_bit(__E1000_RESETTING, &adapter->flags) && count--)
    79c9:	83 eb 01             	sub    $0x1,%ebx
    79cc:	0f 84 3b ff ff ff    	je     790d <__e1000_shutdown+0x5d>
			usleep_range(10000, 20000);
    79d2:	be 20 4e 00 00       	mov    $0x4e20,%esi
    79d7:	bf 10 27 00 00       	mov    $0x2710,%edi
    79dc:	e8 00 00 00 00       	callq  79e1 <__e1000_shutdown+0x131>
    79e1:	49 8b 84 24 e8 0f 00 	mov    0xfe8(%r12),%rax
    79e8:	00 
	netif_device_detach(netdev);

	if (netif_running(netdev)) {
		int count = E1000_CHECK_RESET_COUNT;

		while (test_bit(__E1000_RESETTING, &adapter->flags) && count--)
    79e9:	a8 02                	test   $0x2,%al
    79eb:	75 dc                	jne    79c9 <__e1000_shutdown+0x119>
    79ed:	e9 1b ff ff ff       	jmpq   790d <__e1000_shutdown+0x5d>
	status = er32(STATUS);
	if (status & E1000_STATUS_LU)
		wufc &= ~E1000_WUFC_LNKC;

	if (wufc) {
		e1000_setup_rctl(adapter);
    79f2:	48 8b 7d d0          	mov    -0x30(%rbp),%rdi
    79f6:	e8 35 86 ff ff       	callq  30 <e1000_setup_rctl>
		e1000_set_rx_mode(netdev);
    79fb:	4c 89 e7             	mov    %r12,%rdi
    79fe:	e8 dd fb ff ff       	callq  75e0 <e1000_set_rx_mode>

		rctl = er32(RCTL);
    7a03:	49 8b 84 24 00 0c 00 	mov    0xc00(%r12),%rax
    7a0a:	00 
{ asm volatile("mov" size " %0,%1": :reg (val), \
"m" (*(volatile type __force *)addr) barrier); }

build_mmio_read(readb, "b", unsigned char, "=q", :"memory")
build_mmio_read(readw, "w", unsigned short, "=r", :"memory")
build_mmio_read(readl, "l", unsigned int, "=r", :"memory")
    7a0b:	8b 80 00 01 00 00    	mov    0x100(%rax),%eax

		/* turn on all-multi mode if wake on multicast is enabled */
		if (wufc & E1000_WUFC_MC)
			rctl |= E1000_RCTL_MPE;
    7a11:	89 c2                	mov    %eax,%edx
    7a13:	83 ca 10             	or     $0x10,%edx
    7a16:	41 f6 c5 08          	test   $0x8,%r13b
    7a1a:	0f 45 c2             	cmovne %edx,%eax

		/* enable receives in the hardware */
		ew32(RCTL, rctl | E1000_RCTL_EN);
    7a1d:	49 8b 94 24 00 0c 00 	mov    0xc00(%r12),%rdx
    7a24:	00 
    7a25:	83 c8 02             	or     $0x2,%eax
build_mmio_read(__readw, "w", unsigned short, "=r", )
build_mmio_read(__readl, "l", unsigned int, "=r", )

build_mmio_write(writeb, "b", unsigned char, "q", :"memory")
build_mmio_write(writew, "w", unsigned short, "r", :"memory")
build_mmio_write(writel, "l", unsigned int, "r", :"memory")
    7a28:	89 82 00 01 00 00    	mov    %eax,0x100(%rdx)

		if (hw->mac_type >= e1000_82540) {
    7a2e:	41 83 bc 24 18 0c 00 	cmpl   $0x4,0xc18(%r12)
    7a35:	00 04 
    7a37:	76 19                	jbe    7a52 <__e1000_shutdown+0x1a2>
			ctrl = er32(CTRL);
    7a39:	49 8b 84 24 00 0c 00 	mov    0xc00(%r12),%rax
    7a40:	00 
{ asm volatile("mov" size " %0,%1": :reg (val), \
"m" (*(volatile type __force *)addr) barrier); }

build_mmio_read(readb, "b", unsigned char, "=q", :"memory")
build_mmio_read(readw, "w", unsigned short, "=r", :"memory")
build_mmio_read(readl, "l", unsigned int, "=r", :"memory")
    7a41:	8b 00                	mov    (%rax),%eax
			/* advertise wake from D3Cold */
			#define E1000_CTRL_ADVD3WUC 0x00100000
			/* phy power management enable */
			#define E1000_CTRL_EN_PHY_PWR_MGMT 0x00200000
			ctrl |= E1000_CTRL_ADVD3WUC |
    7a43:	0d 00 00 30 00       	or     $0x300000,%eax
				E1000_CTRL_EN_PHY_PWR_MGMT;
			ew32(CTRL, ctrl);
    7a48:	49 8b 94 24 00 0c 00 	mov    0xc00(%r12),%rdx
    7a4f:	00 
build_mmio_read(__readw, "w", unsigned short, "=r", )
build_mmio_read(__readl, "l", unsigned int, "=r", )

build_mmio_write(writeb, "b", unsigned char, "q", :"memory")
build_mmio_write(writew, "w", unsigned short, "r", :"memory")
build_mmio_write(writel, "l", unsigned int, "r", :"memory")
    7a50:	89 02                	mov    %eax,(%rdx)
		}

		if (hw->media_type == e1000_media_type_fiber ||
    7a52:	41 8b 84 24 24 0c 00 	mov    0xc24(%r12),%eax
    7a59:	00 
    7a5a:	83 e8 01             	sub    $0x1,%eax
    7a5d:	83 f8 01             	cmp    $0x1,%eax
    7a60:	76 60                	jbe    7ac2 <__e1000_shutdown+0x212>
			ctrl_ext = er32(CTRL_EXT);
			ctrl_ext |= E1000_CTRL_EXT_SDP7_DATA;
			ew32(CTRL_EXT, ctrl_ext);
		}

		ew32(WUC, E1000_WUC_PME_EN);
    7a62:	49 8b 94 24 00 0c 00 	mov    0xc00(%r12),%rdx
    7a69:	00 
    7a6a:	b8 02 00 00 00       	mov    $0x2,%eax
    7a6f:	89 82 00 58 00 00    	mov    %eax,0x5800(%rdx)
		ew32(WUFC, wufc);
    7a75:	49 8b 84 24 00 0c 00 	mov    0xc00(%r12),%rax
    7a7c:	00 
    7a7d:	44 89 a8 08 58 00 00 	mov    %r13d,0x5808(%rax)

static void e1000_release_manageability(struct e1000_adapter *adapter)
{
	struct e1000_hw *hw = &adapter->hw;

	if (adapter->en_mng_pt) {
    7a84:	41 8b b4 24 54 0a 00 	mov    0xa54(%r12),%esi
    7a8b:	00 
    7a8c:	85 f6                	test   %esi,%esi
    7a8e:	0f 84 f1 fe ff ff    	je     7985 <__e1000_shutdown+0xd5>
    7a94:	48 8b 7d d0          	mov    -0x30(%rbp),%rdi
    7a98:	e8 43 93 ff ff       	callq  de0 <e1000_release_manageability.part.32>
    7a9d:	e9 e3 fe ff ff       	jmpq   7985 <__e1000_shutdown+0xd5>

static void e1000_free_irq(struct e1000_adapter *adapter)
{
	struct net_device *netdev = adapter->netdev;

	free_irq(adapter->pdev->irq, netdev);
    7aa2:	49 8b 84 24 f8 0b 00 	mov    0xbf8(%r12),%rax
    7aa9:	00 
    7aaa:	49 8b b4 24 f0 0b 00 	mov    0xbf0(%r12),%rsi
    7ab1:	00 
    7ab2:	8b b8 74 03 00 00    	mov    0x374(%rax),%edi
    7ab8:	e8 00 00 00 00       	callq  7abd <__e1000_shutdown+0x20d>
    7abd:	e9 ee fe ff ff       	jmpq   79b0 <__e1000_shutdown+0x100>
		}

		if (hw->media_type == e1000_media_type_fiber ||
		    hw->media_type == e1000_media_type_internal_serdes) {
			/* keep the laser running in D3 */
			ctrl_ext = er32(CTRL_EXT);
    7ac2:	49 8b 84 24 00 0c 00 	mov    0xc00(%r12),%rax
    7ac9:	00 
{ asm volatile("mov" size " %0,%1": :reg (val), \
"m" (*(volatile type __force *)addr) barrier); }

build_mmio_read(readb, "b", unsigned char, "=q", :"memory")
build_mmio_read(readw, "w", unsigned short, "=r", :"memory")
build_mmio_read(readl, "l", unsigned int, "=r", :"memory")
    7aca:	8b 40 18             	mov    0x18(%rax),%eax
			ctrl_ext |= E1000_CTRL_EXT_SDP7_DATA;
    7acd:	0c 80                	or     $0x80,%al
			ew32(CTRL_EXT, ctrl_ext);
    7acf:	49 8b 94 24 00 0c 00 	mov    0xc00(%r12),%rdx
    7ad6:	00 
build_mmio_read(__readw, "w", unsigned short, "=r", )
build_mmio_read(__readl, "l", unsigned int, "=r", )

build_mmio_write(writeb, "b", unsigned char, "q", :"memory")
build_mmio_write(writew, "w", unsigned short, "r", :"memory")
build_mmio_write(writel, "l", unsigned int, "r", :"memory")
    7ad7:	89 42 18             	mov    %eax,0x18(%rdx)
    7ada:	eb 86                	jmp    7a62 <__e1000_shutdown+0x1b2>
		int count = E1000_CHECK_RESET_COUNT;

		while (test_bit(__E1000_RESETTING, &adapter->flags) && count--)
			usleep_range(10000, 20000);

		WARN_ON(test_bit(__E1000_RESETTING, &adapter->flags));
    7adc:	be 23 14 00 00       	mov    $0x1423,%esi
    7ae1:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
    7ae8:	e8 00 00 00 00       	callq  7aed <__e1000_shutdown+0x23d>
    7aed:	e9 2b fe ff ff       	jmpq   791d <__e1000_shutdown+0x6d>
    7af2:	66 66 66 66 66 2e 0f 	data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
    7af9:	1f 84 00 00 00 00 00 

0000000000007b00 <e1000_shutdown>:
	return 0;
}
#endif

static void e1000_shutdown(struct pci_dev *pdev)
{
    7b00:	e8 00 00 00 00       	callq  7b05 <e1000_shutdown+0x5>
    7b05:	55                   	push   %rbp
    7b06:	48 89 e5             	mov    %rsp,%rbp
    7b09:	53                   	push   %rbx
    7b0a:	48 89 fb             	mov    %rdi,%rbx
	bool wake;

	__e1000_shutdown(pdev, &wake);
    7b0d:	48 8d 75 f7          	lea    -0x9(%rbp),%rsi
	return 0;
}
#endif

static void e1000_shutdown(struct pci_dev *pdev)
{
    7b11:	48 83 ec 08          	sub    $0x8,%rsp
	bool wake;

	__e1000_shutdown(pdev, &wake);
    7b15:	e8 96 fd ff ff       	callq  78b0 <__e1000_shutdown>

	if (system_state == SYSTEM_POWER_OFF) {
    7b1a:	83 3d 00 00 00 00 03 	cmpl   $0x3,0x0(%rip)        # 7b21 <e1000_shutdown+0x21>
    7b21:	74 07                	je     7b2a <e1000_shutdown+0x2a>
		pci_wake_from_d3(pdev, wake);
		pci_set_power_state(pdev, PCI_D3hot);
	}
}
    7b23:	48 83 c4 08          	add    $0x8,%rsp
    7b27:	5b                   	pop    %rbx
    7b28:	5d                   	pop    %rbp
    7b29:	c3                   	retq   
	bool wake;

	__e1000_shutdown(pdev, &wake);

	if (system_state == SYSTEM_POWER_OFF) {
		pci_wake_from_d3(pdev, wake);
    7b2a:	0f b6 75 f7          	movzbl -0x9(%rbp),%esi
    7b2e:	48 89 df             	mov    %rbx,%rdi
    7b31:	e8 00 00 00 00       	callq  7b36 <e1000_shutdown+0x36>
		pci_set_power_state(pdev, PCI_D3hot);
    7b36:	48 89 df             	mov    %rbx,%rdi
    7b39:	be 03 00 00 00       	mov    $0x3,%esi
    7b3e:	e8 00 00 00 00       	callq  7b43 <e1000_shutdown+0x43>
	}
}
    7b43:	48 83 c4 08          	add    $0x8,%rsp
    7b47:	5b                   	pop    %rbx
    7b48:	5d                   	pop    %rbp
    7b49:	c3                   	retq   
    7b4a:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)

0000000000007b50 <e1000_suspend>:
	return 0;
}

#ifdef CONFIG_PM
static int e1000_suspend(struct pci_dev *pdev, pm_message_t state)
{
    7b50:	e8 00 00 00 00       	callq  7b55 <e1000_suspend+0x5>
    7b55:	55                   	push   %rbp
    7b56:	48 89 e5             	mov    %rsp,%rbp
    7b59:	41 54                	push   %r12
    7b5b:	49 89 fc             	mov    %rdi,%r12
	int retval;
	bool wake;

	retval = __e1000_shutdown(pdev, &wake);
    7b5e:	48 8d 75 ef          	lea    -0x11(%rbp),%rsi
	return 0;
}

#ifdef CONFIG_PM
static int e1000_suspend(struct pci_dev *pdev, pm_message_t state)
{
    7b62:	53                   	push   %rbx
    7b63:	48 83 ec 08          	sub    $0x8,%rsp
	int retval;
	bool wake;

	retval = __e1000_shutdown(pdev, &wake);
    7b67:	e8 44 fd ff ff       	callq  78b0 <__e1000_shutdown>
	if (retval)
    7b6c:	85 c0                	test   %eax,%eax
static int e1000_suspend(struct pci_dev *pdev, pm_message_t state)
{
	int retval;
	bool wake;

	retval = __e1000_shutdown(pdev, &wake);
    7b6e:	89 c3                	mov    %eax,%ebx
	if (retval)
    7b70:	75 1d                	jne    7b8f <e1000_suspend+0x3f>
		return retval;

	if (wake) {
    7b72:	80 7d ef 00          	cmpb   $0x0,-0x11(%rbp)
    7b76:	75 22                	jne    7b9a <e1000_suspend+0x4a>
		pci_prepare_to_sleep(pdev);
	} else {
		pci_wake_from_d3(pdev, false);
    7b78:	31 f6                	xor    %esi,%esi
    7b7a:	4c 89 e7             	mov    %r12,%rdi
    7b7d:	e8 00 00 00 00       	callq  7b82 <e1000_suspend+0x32>
		pci_set_power_state(pdev, PCI_D3hot);
    7b82:	be 03 00 00 00       	mov    $0x3,%esi
    7b87:	4c 89 e7             	mov    %r12,%rdi
    7b8a:	e8 00 00 00 00       	callq  7b8f <e1000_suspend+0x3f>
	}

	return 0;
}
    7b8f:	48 83 c4 08          	add    $0x8,%rsp
    7b93:	89 d8                	mov    %ebx,%eax
    7b95:	5b                   	pop    %rbx
    7b96:	41 5c                	pop    %r12
    7b98:	5d                   	pop    %rbp
    7b99:	c3                   	retq   
	retval = __e1000_shutdown(pdev, &wake);
	if (retval)
		return retval;

	if (wake) {
		pci_prepare_to_sleep(pdev);
    7b9a:	4c 89 e7             	mov    %r12,%rdi
    7b9d:	e8 00 00 00 00       	callq  7ba2 <e1000_suspend+0x52>
		pci_wake_from_d3(pdev, false);
		pci_set_power_state(pdev, PCI_D3hot);
	}

	return 0;
}
    7ba2:	48 83 c4 08          	add    $0x8,%rsp
    7ba6:	89 d8                	mov    %ebx,%eax
    7ba8:	5b                   	pop    %rbx
    7ba9:	41 5c                	pop    %r12
    7bab:	5d                   	pop    %rbp
    7bac:	c3                   	retq   
    7bad:	0f 1f 00             	nopl   (%rax)

0000000000007bb0 <e1000_configure>:
/**
 * e1000_configure - configure the hardware for RX and TX
 * @adapter = private board structure
 **/
static void e1000_configure(struct e1000_adapter *adapter)
{
    7bb0:	e8 00 00 00 00       	callq  7bb5 <e1000_configure+0x5>
    7bb5:	55                   	push   %rbp
    7bb6:	48 89 e5             	mov    %rsp,%rbp
    7bb9:	41 54                	push   %r12
    7bbb:	53                   	push   %rbx
    7bbc:	48 89 fb             	mov    %rdi,%rbx
	struct net_device *netdev = adapter->netdev;
	int i;

	e1000_set_rx_mode(netdev);
    7bbf:	48 8b bf b0 03 00 00 	mov    0x3b0(%rdi),%rdi
    7bc6:	e8 15 fa ff ff       	callq  75e0 <e1000_set_rx_mode>

static bool e1000_vlan_used(struct e1000_adapter *adapter)
{
	u16 vid;

	for_each_set_bit(vid, adapter->active_vlans, VLAN_N_VID)
    7bcb:	be 00 10 00 00       	mov    $0x1000,%esi
    7bd0:	48 89 df             	mov    %rbx,%rdi
    7bd3:	e8 00 00 00 00       	callq  7bd8 <e1000_configure+0x28>
    7bd8:	66 3d ff 0f          	cmp    $0xfff,%ax
    7bdc:	77 56                	ja     7c34 <e1000_configure+0x84>
	u16 vid;

	if (!e1000_vlan_used(adapter))
		return;

	e1000_vlan_filter_on_off(adapter, true);
    7bde:	be 01 00 00 00       	mov    $0x1,%esi
    7be3:	48 89 df             	mov    %rbx,%rdi
    7be6:	e8 85 8f ff ff       	callq  b70 <e1000_vlan_filter_on_off>
	for_each_set_bit(vid, adapter->active_vlans, VLAN_N_VID)
    7beb:	be 00 10 00 00       	mov    $0x1000,%esi
    7bf0:	48 89 df             	mov    %rbx,%rdi
    7bf3:	e8 00 00 00 00       	callq  7bf8 <e1000_configure+0x48>
    7bf8:	66 3d ff 0f          	cmp    $0xfff,%ax
    7bfc:	44 0f b7 e0          	movzwl %ax,%r12d
    7c00:	77 32                	ja     7c34 <e1000_configure+0x84>
		e1000_vlan_rx_add_vid(adapter->netdev, htons(ETH_P_8021Q), vid);
    7c02:	48 8b bb b0 03 00 00 	mov    0x3b0(%rbx),%rdi
    7c09:	44 89 e2             	mov    %r12d,%edx
    7c0c:	be 81 00 00 00       	mov    $0x81,%esi

	if (!e1000_vlan_used(adapter))
		return;

	e1000_vlan_filter_on_off(adapter, true);
	for_each_set_bit(vid, adapter->active_vlans, VLAN_N_VID)
    7c11:	41 83 c4 01          	add    $0x1,%r12d
		e1000_vlan_rx_add_vid(adapter->netdev, htons(ETH_P_8021Q), vid);
    7c15:	e8 46 90 ff ff       	callq  c60 <e1000_vlan_rx_add_vid>

	if (!e1000_vlan_used(adapter))
		return;

	e1000_vlan_filter_on_off(adapter, true);
	for_each_set_bit(vid, adapter->active_vlans, VLAN_N_VID)
    7c1a:	49 63 d4             	movslq %r12d,%rdx
    7c1d:	be 00 10 00 00       	mov    $0x1000,%esi
    7c22:	48 89 df             	mov    %rbx,%rdi
    7c25:	e8 00 00 00 00       	callq  7c2a <e1000_configure+0x7a>
    7c2a:	66 3d ff 0f          	cmp    $0xfff,%ax
    7c2e:	44 0f b7 e0          	movzwl %ax,%r12d
    7c32:	76 ce                	jbe    7c02 <e1000_configure+0x52>

static void e1000_init_manageability(struct e1000_adapter *adapter)
{
	struct e1000_hw *hw = &adapter->hw;

	if (adapter->en_mng_pt) {
    7c34:	8b b3 14 02 00 00    	mov    0x214(%rbx),%esi
    7c3a:	85 f6                	test   %esi,%esi
    7c3c:	0f 85 7c 02 00 00    	jne    7ebe <e1000_configure+0x30e>
	/* Setup the HW Tx Head and Tail descriptor pointers */

	switch (adapter->num_tx_queues) {
	case 1:
	default:
		tdba = adapter->tx_ring[0].dma;
    7c42:	48 8b 83 40 02 00 00 	mov    0x240(%rbx),%rax
 * Configure the Tx unit of the MAC after a reset.
 **/
static void e1000_configure_tx(struct e1000_adapter *adapter)
{
	u64 tdba;
	struct e1000_hw *hw = &adapter->hw;
    7c49:	48 8d bb c0 03 00 00 	lea    0x3c0(%rbx),%rdi
	/* Setup the HW Tx Head and Tail descriptor pointers */

	switch (adapter->num_tx_queues) {
	case 1:
	default:
		tdba = adapter->tx_ring[0].dma;
    7c50:	48 8b 48 08          	mov    0x8(%rax),%rcx
		tdlen = adapter->tx_ring[0].count *
    7c54:	8b 40 14             	mov    0x14(%rax),%eax
    7c57:	c1 e0 04             	shl    $0x4,%eax
			sizeof(struct e1000_tx_desc);
		ew32(TDLEN, tdlen);
    7c5a:	83 bb d8 03 00 00 03 	cmpl   $0x3,0x3d8(%rbx)
    7c61:	48 19 d2             	sbb    %rdx,%rdx
    7c64:	48 81 e2 20 cc ff ff 	and    $0xffffffffffffcc20,%rdx
    7c6b:	48 81 c2 08 38 00 00 	add    $0x3808,%rdx
    7c72:	48 03 93 c0 03 00 00 	add    0x3c0(%rbx),%rdx
    7c79:	89 02                	mov    %eax,(%rdx)
		ew32(TDBAH, (tdba >> 32));
    7c7b:	83 bb d8 03 00 00 03 	cmpl   $0x3,0x3d8(%rbx)
    7c82:	48 89 ca             	mov    %rcx,%rdx
    7c85:	48 19 c0             	sbb    %rax,%rax
    7c88:	48 c1 ea 20          	shr    $0x20,%rdx
    7c8c:	48 25 20 cc ff ff    	and    $0xffffffffffffcc20,%rax
    7c92:	48 05 04 38 00 00    	add    $0x3804,%rax
    7c98:	48 03 83 c0 03 00 00 	add    0x3c0(%rbx),%rax
    7c9f:	89 10                	mov    %edx,(%rax)
		ew32(TDBAL, (tdba & 0x00000000ffffffffULL));
    7ca1:	83 bb d8 03 00 00 03 	cmpl   $0x3,0x3d8(%rbx)
    7ca8:	48 19 c0             	sbb    %rax,%rax
    7cab:	48 25 20 cc ff ff    	and    $0xffffffffffffcc20,%rax
    7cb1:	48 05 00 38 00 00    	add    $0x3800,%rax
    7cb7:	48 03 83 c0 03 00 00 	add    0x3c0(%rbx),%rax
    7cbe:	89 08                	mov    %ecx,(%rax)
		ew32(TDT, 0);
    7cc0:	83 bb d8 03 00 00 03 	cmpl   $0x3,0x3d8(%rbx)
    7cc7:	48 19 c0             	sbb    %rax,%rax
    7cca:	31 d2                	xor    %edx,%edx
    7ccc:	48 25 20 cc ff ff    	and    $0xffffffffffffcc20,%rax
    7cd2:	48 05 18 38 00 00    	add    $0x3818,%rax
    7cd8:	48 03 83 c0 03 00 00 	add    0x3c0(%rbx),%rax
    7cdf:	89 10                	mov    %edx,(%rax)
		ew32(TDH, 0);
    7ce1:	83 bb d8 03 00 00 03 	cmpl   $0x3,0x3d8(%rbx)
    7ce8:	48 19 c0             	sbb    %rax,%rax
    7ceb:	48 25 20 cc ff ff    	and    $0xffffffffffffcc20,%rax
    7cf1:	48 05 10 38 00 00    	add    $0x3810,%rax
    7cf7:	48 03 83 c0 03 00 00 	add    0x3c0(%rbx),%rax
    7cfe:	89 10                	mov    %edx,(%rax)
		adapter->tx_ring[0].tdh = ((hw->mac_type >= e1000_82543) ?
    7d00:	83 bb d8 03 00 00 03 	cmpl   $0x3,0x3d8(%rbx)
    7d07:	48 8b 93 40 02 00 00 	mov    0x240(%rbx),%rdx
    7d0e:	19 c0                	sbb    %eax,%eax
    7d10:	66 25 20 cc          	and    $0xcc20,%ax
    7d14:	66 05 10 38          	add    $0x3810,%ax
    7d18:	66 89 42 28          	mov    %ax,0x28(%rdx)
					   E1000_TDH : E1000_82542_TDH);
		adapter->tx_ring[0].tdt = ((hw->mac_type >= e1000_82543) ?
    7d1c:	83 bb d8 03 00 00 03 	cmpl   $0x3,0x3d8(%rbx)
    7d23:	48 8b 93 40 02 00 00 	mov    0x240(%rbx),%rdx
    7d2a:	19 c0                	sbb    %eax,%eax
    7d2c:	66 25 20 cc          	and    $0xcc20,%ax
    7d30:	66 05 18 38          	add    $0x3818,%ax
    7d34:	66 89 42 2a          	mov    %ax,0x2a(%rdx)
					   E1000_TDT : E1000_82542_TDT);
		break;
	}

	/* Set the default values for the Tx Inter Packet Gap timer */
	if ((hw->media_type == e1000_media_type_fiber ||
    7d38:	8b 83 e4 03 00 00    	mov    0x3e4(%rbx),%eax
    7d3e:	83 e8 01             	sub    $0x1,%eax
	     hw->media_type == e1000_media_type_internal_serdes))
		tipg = DEFAULT_82543_TIPG_IPGT_FIBER;
    7d41:	83 f8 02             	cmp    $0x2,%eax
	else
		tipg = DEFAULT_82543_TIPG_IPGT_COPPER;

	switch (hw->mac_type) {
    7d44:	8b 83 d8 03 00 00    	mov    0x3d8(%rbx),%eax
	}

	/* Set the default values for the Tx Inter Packet Gap timer */
	if ((hw->media_type == e1000_media_type_fiber ||
	     hw->media_type == e1000_media_type_internal_serdes))
		tipg = DEFAULT_82543_TIPG_IPGT_FIBER;
    7d4a:	19 d2                	sbb    %edx,%edx
    7d4c:	f7 d2                	not    %edx
	else
		tipg = DEFAULT_82543_TIPG_IPGT_COPPER;

	switch (hw->mac_type) {
    7d4e:	8d 48 ff             	lea    -0x1(%rax),%ecx
	}

	/* Set the default values for the Tx Inter Packet Gap timer */
	if ((hw->media_type == e1000_media_type_fiber ||
	     hw->media_type == e1000_media_type_internal_serdes))
		tipg = DEFAULT_82543_TIPG_IPGT_FIBER;
    7d51:	83 c2 09             	add    $0x9,%edx
	else
		tipg = DEFAULT_82543_TIPG_IPGT_COPPER;

	switch (hw->mac_type) {
    7d54:	b8 0a 08 a0 00       	mov    $0xa0080a,%eax
    7d59:	81 ca 00 20 60 00    	or     $0x602000,%edx
    7d5f:	83 f9 01             	cmp    $0x1,%ecx
    7d62:	0f 47 c2             	cmova  %edx,%eax
		ipgr2 = DEFAULT_82543_TIPG_IPGR2;
		break;
	}
	tipg |= ipgr1 << E1000_TIPG_IPGR1_SHIFT;
	tipg |= ipgr2 << E1000_TIPG_IPGR2_SHIFT;
	ew32(TIPG, tipg);
    7d65:	48 8b 93 c0 03 00 00 	mov    0x3c0(%rbx),%rdx
    7d6c:	89 82 10 04 00 00    	mov    %eax,0x410(%rdx)

	/* Set the Tx Interrupt Delay register */

	ew32(TIDV, adapter->tx_int_delay);
    7d72:	83 bb d8 03 00 00 03 	cmpl   $0x3,0x3d8(%rbx)
    7d79:	8b 93 50 02 00 00    	mov    0x250(%rbx),%edx
    7d7f:	48 19 c0             	sbb    %rax,%rax
    7d82:	48 25 20 cc ff ff    	and    $0xffffffffffffcc20,%rax
    7d88:	48 05 20 38 00 00    	add    $0x3820,%rax
    7d8e:	48 03 83 c0 03 00 00 	add    0x3c0(%rbx),%rax
    7d95:	89 10                	mov    %edx,(%rax)
	if (hw->mac_type >= e1000_82540)
    7d97:	83 bb d8 03 00 00 04 	cmpl   $0x4,0x3d8(%rbx)
    7d9e:	76 13                	jbe    7db3 <e1000_configure+0x203>
		ew32(TADV, adapter->tx_abs_int_delay);
    7da0:	48 8b 93 c0 03 00 00 	mov    0x3c0(%rbx),%rdx
    7da7:	8b 83 54 02 00 00    	mov    0x254(%rbx),%eax
    7dad:	89 82 2c 38 00 00    	mov    %eax,0x382c(%rdx)

	/* Program the Transmit Control Register */

	tctl = er32(TCTL);
    7db3:	48 8b 83 c0 03 00 00 	mov    0x3c0(%rbx),%rax
{ asm volatile("mov" size " %0,%1": :reg (val), \
"m" (*(volatile type __force *)addr) barrier); }

build_mmio_read(readb, "b", unsigned char, "=q", :"memory")
build_mmio_read(readw, "w", unsigned short, "=r", :"memory")
build_mmio_read(readl, "l", unsigned int, "=r", :"memory")
    7dba:	44 8b a0 00 04 00 00 	mov    0x400(%rax),%r12d
	tctl &= ~E1000_TCTL_CT;
	tctl |= E1000_TCTL_PSP | E1000_TCTL_RTLC |
		(E1000_COLLISION_THRESHOLD << E1000_CT_SHIFT);

	e1000_config_collision_dist(hw);
    7dc1:	e8 00 00 00 00       	callq  7dc6 <e1000_configure+0x216>

	/* Setup Transmit Descriptor Settings for eop descriptor */
	adapter->txd_cmd = E1000_TXD_CMD_EOP | E1000_TXD_CMD_IFCS;

	/* only set IDE if we are delaying interrupts using the timers */
	if (adapter->tx_int_delay)
    7dc6:	8b 8b 50 02 00 00    	mov    0x250(%rbx),%ecx
		ew32(TADV, adapter->tx_abs_int_delay);

	/* Program the Transmit Control Register */

	tctl = er32(TCTL);
	tctl &= ~E1000_TCTL_CT;
    7dcc:	41 81 e4 0f f0 ff ff 	and    $0xfffff00f,%r12d
		(E1000_COLLISION_THRESHOLD << E1000_CT_SHIFT);

	e1000_config_collision_dist(hw);

	/* Setup Transmit Descriptor Settings for eop descriptor */
	adapter->txd_cmd = E1000_TXD_CMD_EOP | E1000_TXD_CMD_IFCS;
    7dd3:	c7 83 4c 02 00 00 00 	movl   $0x3000000,0x24c(%rbx)
    7dda:	00 00 03 

	/* Program the Transmit Control Register */

	tctl = er32(TCTL);
	tctl &= ~E1000_TCTL_CT;
	tctl |= E1000_TCTL_PSP | E1000_TCTL_RTLC |
    7ddd:	41 81 cc f8 00 00 01 	or     $0x10000f8,%r12d

	/* Setup Transmit Descriptor Settings for eop descriptor */
	adapter->txd_cmd = E1000_TXD_CMD_EOP | E1000_TXD_CMD_IFCS;

	/* only set IDE if we are delaying interrupts using the timers */
	if (adapter->tx_int_delay)
    7de4:	ba 00 00 00 03       	mov    $0x3000000,%edx
    7de9:	85 c9                	test   %ecx,%ecx
    7deb:	74 0f                	je     7dfc <e1000_configure+0x24c>
		adapter->txd_cmd |= E1000_TXD_CMD_IDE;
    7ded:	c7 83 4c 02 00 00 00 	movl   $0x83000000,0x24c(%rbx)
    7df4:	00 00 83 
    7df7:	ba 00 00 00 83       	mov    $0x83000000,%edx

	if (hw->mac_type < e1000_82543)
    7dfc:	8b 83 d8 03 00 00    	mov    0x3d8(%rbx),%eax
    7e02:	83 f8 02             	cmp    $0x2,%eax
    7e05:	0f 87 85 00 00 00    	ja     7e90 <e1000_configure+0x2e0>
		adapter->txd_cmd |= E1000_TXD_CMD_RPS;
    7e0b:	81 ca 00 00 00 10    	or     $0x10000000,%edx
    7e11:	89 93 4c 02 00 00    	mov    %edx,0x24c(%rbx)
	 */
	if (hw->mac_type == e1000_82544 &&
	    hw->bus_type == e1000_bus_type_pcix)
		adapter->pcix_82544 = true;

	ew32(TCTL, tctl);
    7e17:	48 8b 83 c0 03 00 00 	mov    0x3c0(%rbx),%rax
build_mmio_read(__readw, "w", unsigned short, "=r", )
build_mmio_read(__readl, "l", unsigned int, "=r", )

build_mmio_write(writeb, "b", unsigned char, "q", :"memory")
build_mmio_write(writew, "w", unsigned short, "r", :"memory")
build_mmio_write(writel, "l", unsigned int, "r", :"memory")
    7e1e:	44 89 a0 00 04 00 00 	mov    %r12d,0x400(%rax)

	e1000_restore_vlan(adapter);
	e1000_init_manageability(adapter);

	e1000_configure_tx(adapter);
	e1000_setup_rctl(adapter);
    7e25:	48 89 df             	mov    %rbx,%rdi
	e1000_configure_rx(adapter);
	/* call E1000_DESC_UNUSED which always leaves
	 * at least 1 descriptor unused to make sure
	 * next_to_use != next_to_clean
	 */
	for (i = 0; i < adapter->num_rx_queues; i++) {
    7e28:	45 31 e4             	xor    %r12d,%r12d

	e1000_restore_vlan(adapter);
	e1000_init_manageability(adapter);

	e1000_configure_tx(adapter);
	e1000_setup_rctl(adapter);
    7e2b:	e8 00 82 ff ff       	callq  30 <e1000_setup_rctl>
	e1000_configure_rx(adapter);
    7e30:	48 89 df             	mov    %rbx,%rdi
    7e33:	e8 c8 82 ff ff       	callq  100 <e1000_configure_rx>
	/* call E1000_DESC_UNUSED which always leaves
	 * at least 1 descriptor unused to make sure
	 * next_to_use != next_to_clean
	 */
	for (i = 0; i < adapter->num_rx_queues; i++) {
    7e38:	8b 83 7c 03 00 00    	mov    0x37c(%rbx),%eax
    7e3e:	85 c0                	test   %eax,%eax
    7e40:	7e 49                	jle    7e8b <e1000_configure+0x2db>
		struct e1000_rx_ring *ring = &adapter->rx_ring[i];
    7e42:	49 63 f4             	movslq %r12d,%rsi
		adapter->alloc_rx_buf(adapter, ring,
				      E1000_DESC_UNUSED(ring));
    7e45:	31 d2                	xor    %edx,%edx
	 * at least 1 descriptor unused to make sure
	 * next_to_use != next_to_clean
	 */
	for (i = 0; i < adapter->num_rx_queues; i++) {
		struct e1000_rx_ring *ring = &adapter->rx_ring[i];
		adapter->alloc_rx_buf(adapter, ring,
    7e47:	4c 8b 83 a0 02 00 00 	mov    0x2a0(%rbx),%r8
	/* call E1000_DESC_UNUSED which always leaves
	 * at least 1 descriptor unused to make sure
	 * next_to_use != next_to_clean
	 */
	for (i = 0; i < adapter->num_rx_queues; i++) {
		struct e1000_rx_ring *ring = &adapter->rx_ring[i];
    7e4e:	48 8d 04 f5 00 00 00 	lea    0x0(,%rsi,8),%rax
    7e55:	00 
    7e56:	48 c1 e6 06          	shl    $0x6,%rsi
    7e5a:	48 29 c6             	sub    %rax,%rsi
    7e5d:	48 03 b3 a8 02 00 00 	add    0x2a8(%rbx),%rsi
		adapter->alloc_rx_buf(adapter, ring,
				      E1000_DESC_UNUSED(ring));
    7e64:	8b 46 1c             	mov    0x1c(%rsi),%eax
    7e67:	8b 4e 18             	mov    0x18(%rsi),%ecx
    7e6a:	39 c8                	cmp    %ecx,%eax
    7e6c:	77 03                	ja     7e71 <e1000_configure+0x2c1>
    7e6e:	8b 56 14             	mov    0x14(%rsi),%edx
    7e71:	83 e8 01             	sub    $0x1,%eax
	 * at least 1 descriptor unused to make sure
	 * next_to_use != next_to_clean
	 */
	for (i = 0; i < adapter->num_rx_queues; i++) {
		struct e1000_rx_ring *ring = &adapter->rx_ring[i];
		adapter->alloc_rx_buf(adapter, ring,
    7e74:	48 89 df             	mov    %rbx,%rdi
	e1000_configure_rx(adapter);
	/* call E1000_DESC_UNUSED which always leaves
	 * at least 1 descriptor unused to make sure
	 * next_to_use != next_to_clean
	 */
	for (i = 0; i < adapter->num_rx_queues; i++) {
    7e77:	41 83 c4 01          	add    $0x1,%r12d
		struct e1000_rx_ring *ring = &adapter->rx_ring[i];
		adapter->alloc_rx_buf(adapter, ring,
				      E1000_DESC_UNUSED(ring));
    7e7b:	29 c8                	sub    %ecx,%eax
    7e7d:	01 c2                	add    %eax,%edx
	 * at least 1 descriptor unused to make sure
	 * next_to_use != next_to_clean
	 */
	for (i = 0; i < adapter->num_rx_queues; i++) {
		struct e1000_rx_ring *ring = &adapter->rx_ring[i];
		adapter->alloc_rx_buf(adapter, ring,
    7e7f:	41 ff d0             	callq  *%r8
	e1000_configure_rx(adapter);
	/* call E1000_DESC_UNUSED which always leaves
	 * at least 1 descriptor unused to make sure
	 * next_to_use != next_to_clean
	 */
	for (i = 0; i < adapter->num_rx_queues; i++) {
    7e82:	44 39 a3 7c 03 00 00 	cmp    %r12d,0x37c(%rbx)
    7e89:	7f b7                	jg     7e42 <e1000_configure+0x292>
		struct e1000_rx_ring *ring = &adapter->rx_ring[i];
		adapter->alloc_rx_buf(adapter, ring,
				      E1000_DESC_UNUSED(ring));
	}
}
    7e8b:	5b                   	pop    %rbx
    7e8c:	41 5c                	pop    %r12
    7e8e:	5d                   	pop    %rbp
    7e8f:	c3                   	retq   
		adapter->txd_cmd |= E1000_TXD_CMD_IDE;

	if (hw->mac_type < e1000_82543)
		adapter->txd_cmd |= E1000_TXD_CMD_RPS;
	else
		adapter->txd_cmd |= E1000_TXD_CMD_RS;
    7e90:	81 ca 00 00 00 08    	or     $0x8000000,%edx

	/* Cache if we're 82544 running in PCI-X because we'll
	 * need this to apply a workaround later in the send path.
	 */
	if (hw->mac_type == e1000_82544 &&
    7e96:	83 f8 04             	cmp    $0x4,%eax
		adapter->txd_cmd |= E1000_TXD_CMD_IDE;

	if (hw->mac_type < e1000_82543)
		adapter->txd_cmd |= E1000_TXD_CMD_RPS;
	else
		adapter->txd_cmd |= E1000_TXD_CMD_RS;
    7e99:	89 93 4c 02 00 00    	mov    %edx,0x24c(%rbx)

	/* Cache if we're 82544 running in PCI-X because we'll
	 * need this to apply a workaround later in the send path.
	 */
	if (hw->mac_type == e1000_82544 &&
    7e9f:	0f 85 72 ff ff ff    	jne    7e17 <e1000_configure+0x267>
    7ea5:	83 bb 0c 04 00 00 02 	cmpl   $0x2,0x40c(%rbx)
    7eac:	0f 85 65 ff ff ff    	jne    7e17 <e1000_configure+0x267>
	    hw->bus_type == e1000_bus_type_pcix)
		adapter->pcix_82544 = true;
    7eb2:	c6 83 90 02 00 00 01 	movb   $0x1,0x290(%rbx)
    7eb9:	e9 59 ff ff ff       	jmpq   7e17 <e1000_configure+0x267>
    7ebe:	48 89 df             	mov    %rbx,%rdi
    7ec1:	e8 ea 8e ff ff       	callq  db0 <e1000_init_manageability.part.31>
    7ec6:	e9 77 fd ff ff       	jmpq   7c42 <e1000_configure+0x92>
    7ecb:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)

0000000000007ed0 <e1000_open>:
 * for transmit and receive operations are allocated, the interrupt
 * handler is registered with the OS, the watchdog task is started,
 * and the stack is notified that the interface is ready.
 **/
static int e1000_open(struct net_device *netdev)
{
    7ed0:	e8 00 00 00 00       	callq  7ed5 <e1000_open+0x5>
    7ed5:	55                   	push   %rbp
	struct e1000_adapter *adapter = netdev_priv(netdev);
	struct e1000_hw *hw = &adapter->hw;
	int err;

	printk("xiehuan e1000 is open%s,%d\n",__func__,__LINE__);
    7ed6:	31 c0                	xor    %eax,%eax
    7ed8:	ba 77 05 00 00       	mov    $0x577,%edx
    7edd:	48 c7 c6 00 00 00 00 	mov    $0x0,%rsi
 * for transmit and receive operations are allocated, the interrupt
 * handler is registered with the OS, the watchdog task is started,
 * and the stack is notified that the interface is ready.
 **/
static int e1000_open(struct net_device *netdev)
{
    7ee4:	48 89 e5             	mov    %rsp,%rbp
    7ee7:	41 55                	push   %r13
    7ee9:	41 54                	push   %r12
	struct e1000_adapter *adapter = netdev_priv(netdev);
    7eeb:	4c 8d a7 40 08 00 00 	lea    0x840(%rdi),%r12
 * for transmit and receive operations are allocated, the interrupt
 * handler is registered with the OS, the watchdog task is started,
 * and the stack is notified that the interface is ready.
 **/
static int e1000_open(struct net_device *netdev)
{
    7ef2:	53                   	push   %rbx
    7ef3:	48 89 fb             	mov    %rdi,%rbx
	struct e1000_adapter *adapter = netdev_priv(netdev);
	struct e1000_hw *hw = &adapter->hw;
	int err;

	printk("xiehuan e1000 is open%s,%d\n",__func__,__LINE__);
    7ef6:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
    7efd:	e8 00 00 00 00       	callq  7f02 <e1000_open+0x32>
    7f02:	48 8b 83 e8 0f 00 00 	mov    0xfe8(%rbx),%rax
	/* disallow open during test */
	if (test_bit(__E1000_TESTING, &adapter->flags))
    7f09:	a8 01                	test   $0x1,%al
    7f0b:	0f 85 fe 00 00 00    	jne    800f <e1000_open+0x13f>
		return -EBUSY;

	netif_carrier_off(netdev);
    7f11:	48 89 df             	mov    %rbx,%rdi
    7f14:	e8 00 00 00 00       	callq  7f19 <e1000_open+0x49>

	/* allocate transmit descriptors */
	err = e1000_setup_all_tx_resources(adapter);
    7f19:	4c 89 e7             	mov    %r12,%rdi
    7f1c:	e8 00 00 00 00       	callq  7f21 <e1000_open+0x51>
	if (err)
    7f21:	85 c0                	test   %eax,%eax
		return -EBUSY;

	netif_carrier_off(netdev);

	/* allocate transmit descriptors */
	err = e1000_setup_all_tx_resources(adapter);
    7f23:	41 89 c5             	mov    %eax,%r13d
	if (err)
    7f26:	74 12                	je     7f3a <e1000_open+0x6a>
	e1000_power_down_phy(adapter);
	e1000_free_all_rx_resources(adapter);
err_setup_rx:
	e1000_free_all_tx_resources(adapter);
err_setup_tx:
	e1000_reset(adapter);
    7f28:	4c 89 e7             	mov    %r12,%rdi
    7f2b:	e8 00 00 00 00       	callq  7f30 <e1000_open+0x60>

	return err;
    7f30:	44 89 e8             	mov    %r13d,%eax
}
    7f33:	5b                   	pop    %rbx
    7f34:	41 5c                	pop    %r12
    7f36:	41 5d                	pop    %r13
    7f38:	5d                   	pop    %rbp
    7f39:	c3                   	retq   
	err = e1000_setup_all_tx_resources(adapter);
	if (err)
		goto err_setup_tx;

	/* allocate receive descriptors */
	err = e1000_setup_all_rx_resources(adapter);
    7f3a:	4c 89 e7             	mov    %r12,%rdi
    7f3d:	e8 00 00 00 00       	callq  7f42 <e1000_open+0x72>
	if (err)
    7f42:	85 c0                	test   %eax,%eax
	err = e1000_setup_all_tx_resources(adapter);
	if (err)
		goto err_setup_tx;

	/* allocate receive descriptors */
	err = e1000_setup_all_rx_resources(adapter);
    7f44:	41 89 c5             	mov    %eax,%r13d
	if (err)
    7f47:	75 48                	jne    7f91 <e1000_open+0xc1>
		goto err_setup_rx;

	e1000_power_up_phy(adapter);
    7f49:	4c 89 e7             	mov    %r12,%rdi
    7f4c:	e8 00 00 00 00       	callq  7f51 <e1000_open+0x81>

	adapter->mng_vlan_id = E1000_MNG_VLAN_NONE;
	if ((hw->mng_cookie.status &
    7f51:	f6 83 c4 0c 00 00 02 	testb  $0x2,0xcc4(%rbx)
	if (err)
		goto err_setup_rx;

	e1000_power_up_phy(adapter);

	adapter->mng_vlan_id = E1000_MNG_VLAN_NONE;
    7f58:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
    7f5d:	66 89 83 40 0a 00 00 	mov    %ax,0xa40(%rbx)
	if ((hw->mng_cookie.status &
    7f64:	0f 85 98 00 00 00    	jne    8002 <e1000_open+0x132>
	/* before we allocate an interrupt, we must be ready to handle it.
	 * Setting DEBUG_SHIRQ in the kernel makes it fire an interrupt
	 * as soon as we call pci_request_irq, so we have to setup our
	 * clean_rx handler before we do so.
	 */
	e1000_configure(adapter);
    7f6a:	4c 89 e7             	mov    %r12,%rdi
    7f6d:	e8 3e fc ff ff       	callq  7bb0 <e1000_configure>

	err = e1000_request_irq(adapter);
    7f72:	4c 89 e7             	mov    %r12,%rdi
    7f75:	e8 c6 86 ff ff       	callq  640 <e1000_request_irq>
	if (err)
    7f7a:	85 c0                	test   %eax,%eax
	 * as soon as we call pci_request_irq, so we have to setup our
	 * clean_rx handler before we do so.
	 */
	e1000_configure(adapter);

	err = e1000_request_irq(adapter);
    7f7c:	41 89 c5             	mov    %eax,%r13d
	if (err)
    7f7f:	74 1a                	je     7f9b <e1000_open+0xcb>
	ew32(ICS, E1000_ICS_LSC);

	return E1000_SUCCESS;

err_req_irq:
	e1000_power_down_phy(adapter);
    7f81:	4c 89 e7             	mov    %r12,%rdi
    7f84:	e8 97 8d ff ff       	callq  d20 <e1000_power_down_phy>
	e1000_free_all_rx_resources(adapter);
    7f89:	4c 89 e7             	mov    %r12,%rdi
    7f8c:	e8 00 00 00 00       	callq  7f91 <e1000_open+0xc1>
err_setup_rx:
	e1000_free_all_tx_resources(adapter);
    7f91:	4c 89 e7             	mov    %r12,%rdi
    7f94:	e8 00 00 00 00       	callq  7f99 <e1000_open+0xc9>
    7f99:	eb 8d                	jmp    7f28 <e1000_open+0x58>
 */
static __always_inline void
clear_bit(long nr, volatile unsigned long *addr)
{
	if (IS_IMMEDIATE(nr)) {
		asm volatile(LOCK_PREFIX "andb %1,%0"
    7f9b:	f0 80 a3 e8 0f 00 00 	lock andb $0xfb,0xfe8(%rbx)
    7fa2:	fb 
}

static __always_inline int constant_test_bit(long nr, const volatile unsigned long *addr)
{
	return ((1UL << (nr & (BITS_PER_LONG-1))) &
		(addr[nr >> _BITOPS_LONG_SHIFT])) != 0;
    7fa3:	48 8b 83 00 0b 00 00 	mov    0xb00(%rbx),%rax
 * Resume NAPI from being scheduled on this context.
 * Must be paired with napi_disable.
 */
static inline void napi_enable(struct napi_struct *n)
{
	BUG_ON(!test_bit(NAPI_STATE_SCHED, &n->state));
    7faa:	a8 01                	test   $0x1,%al
    7fac:	74 6b                	je     8019 <e1000_open+0x149>
 */
static __always_inline void
clear_bit(long nr, volatile unsigned long *addr)
{
	if (IS_IMMEDIATE(nr)) {
		asm volatile(LOCK_PREFIX "andb %1,%0"
    7fae:	f0 80 a3 00 0b 00 00 	lock andb $0xfe,0xb00(%rbx)
    7fb5:	fe 
    7fb6:	f0 80 a3 00 0b 00 00 	lock andb $0xfb,0xb00(%rbx)
    7fbd:	fb 
    7fbe:	b8 9d 00 00 00       	mov    $0x9d,%eax
 **/
static void e1000_irq_enable(struct e1000_adapter *adapter)
{
	struct e1000_hw *hw = &adapter->hw;

	ew32(IMS, IMS_ENABLE_MASK);
    7fc3:	48 8b 93 00 0c 00 00 	mov    0xc00(%rbx),%rdx
    7fca:	89 82 d0 00 00 00    	mov    %eax,0xd0(%rdx)
	E1000_WRITE_FLUSH();
    7fd0:	48 8b 83 00 0c 00 00 	mov    0xc00(%rbx),%rax
{ asm volatile("mov" size " %0,%1": :reg (val), \
"m" (*(volatile type __force *)addr) barrier); }

build_mmio_read(readb, "b", unsigned char, "=q", :"memory")
build_mmio_read(readw, "w", unsigned short, "=r", :"memory")
build_mmio_read(readl, "l", unsigned int, "=r", :"memory")
    7fd7:	8b 40 08             	mov    0x8(%rax),%eax
			: CONST_MASK_ADDR(nr, addr)
    7fda:	48 8b 83 c0 03 00 00 	mov    0x3c0(%rbx),%rax
 */
static __always_inline void
clear_bit(long nr, volatile unsigned long *addr)
{
	if (IS_IMMEDIATE(nr)) {
		asm volatile(LOCK_PREFIX "andb %1,%0"
    7fe1:	f0 80 a0 98 00 00 00 	lock andb $0xfe,0x98(%rax)
    7fe8:	fe 
build_mmio_read(__readw, "w", unsigned short, "=r", )
build_mmio_read(__readl, "l", unsigned int, "=r", )

build_mmio_write(writeb, "b", unsigned char, "q", :"memory")
build_mmio_write(writew, "w", unsigned short, "r", :"memory")
build_mmio_write(writel, "l", unsigned int, "r", :"memory")
    7fe9:	b8 04 00 00 00       	mov    $0x4,%eax
	e1000_irq_enable(adapter);

	netif_start_queue(netdev);

	/* fire a link status change interrupt to start the watchdog */
	ew32(ICS, E1000_ICS_LSC);
    7fee:	48 8b 93 00 0c 00 00 	mov    0xc00(%rbx),%rdx
    7ff5:	89 82 c8 00 00 00    	mov    %eax,0xc8(%rdx)

	return E1000_SUCCESS;
    7ffb:	30 c0                	xor    %al,%al
    7ffd:	e9 31 ff ff ff       	jmpq   7f33 <e1000_open+0x63>
	e1000_power_up_phy(adapter);

	adapter->mng_vlan_id = E1000_MNG_VLAN_NONE;
	if ((hw->mng_cookie.status &
			  E1000_MNG_DHCP_COOKIE_STATUS_VLAN_SUPPORT)) {
		e1000_update_mng_vlan(adapter);
    8002:	4c 89 e7             	mov    %r12,%rdi
    8005:	e8 a6 8a ff ff       	callq  ab0 <e1000_update_mng_vlan>
    800a:	e9 5b ff ff ff       	jmpq   7f6a <e1000_open+0x9a>
	int err;

	printk("xiehuan e1000 is open%s,%d\n",__func__,__LINE__);
	/* disallow open during test */
	if (test_bit(__E1000_TESTING, &adapter->flags))
		return -EBUSY;
    800f:	b8 f0 ff ff ff       	mov    $0xfffffff0,%eax
    8014:	e9 1a ff ff ff       	jmpq   7f33 <e1000_open+0x63>
    8019:	e8 00 00 00 00       	callq  801e <e1000_open+0x14e>
    801e:	66 90                	xchg   %ax,%ax

0000000000008020 <e1000_up>:
				      E1000_DESC_UNUSED(ring));
	}
}

int e1000_up(struct e1000_adapter *adapter)
{
    8020:	e8 00 00 00 00       	callq  8025 <e1000_up+0x5>
    8025:	55                   	push   %rbp
    8026:	48 89 e5             	mov    %rsp,%rbp
    8029:	53                   	push   %rbx
    802a:	48 89 fb             	mov    %rdi,%rbx
	struct e1000_hw *hw = &adapter->hw;

	/* hardware has been reset, we need to reload some things */
	e1000_configure(adapter);
    802d:	e8 7e fb ff ff       	callq  7bb0 <e1000_configure>
    8032:	f0 80 a3 a8 07 00 00 	lock andb $0xfb,0x7a8(%rbx)
    8039:	fb 
}

static __always_inline int constant_test_bit(long nr, const volatile unsigned long *addr)
{
	return ((1UL << (nr & (BITS_PER_LONG-1))) &
		(addr[nr >> _BITOPS_LONG_SHIFT])) != 0;
    803a:	48 8b 83 c0 02 00 00 	mov    0x2c0(%rbx),%rax
    8041:	a8 01                	test   $0x1,%al
    8043:	74 56                	je     809b <e1000_up+0x7b>
 */
static __always_inline void
clear_bit(long nr, volatile unsigned long *addr)
{
	if (IS_IMMEDIATE(nr)) {
		asm volatile(LOCK_PREFIX "andb %1,%0"
    8045:	f0 80 a3 c0 02 00 00 	lock andb $0xfe,0x2c0(%rbx)
    804c:	fe 
    804d:	f0 80 a3 c0 02 00 00 	lock andb $0xfb,0x2c0(%rbx)
    8054:	fb 
    8055:	b8 9d 00 00 00       	mov    $0x9d,%eax
 **/
static void e1000_irq_enable(struct e1000_adapter *adapter)
{
	struct e1000_hw *hw = &adapter->hw;

	ew32(IMS, IMS_ENABLE_MASK);
    805a:	48 8b 93 c0 03 00 00 	mov    0x3c0(%rbx),%rdx
    8061:	89 82 d0 00 00 00    	mov    %eax,0xd0(%rdx)
	E1000_WRITE_FLUSH();
    8067:	48 8b 83 c0 03 00 00 	mov    0x3c0(%rbx),%rax
{ asm volatile("mov" size " %0,%1": :reg (val), \
"m" (*(volatile type __force *)addr) barrier); }

build_mmio_read(readb, "b", unsigned char, "=q", :"memory")
build_mmio_read(readw, "w", unsigned short, "=r", :"memory")
build_mmio_read(readl, "l", unsigned int, "=r", :"memory")
    806e:	8b 40 08             	mov    0x8(%rax),%eax
 *	@dev: network device
 *
 *	Allow upper layers to call the device hard_start_xmit routine.
 *	Used for flow control when transmit resources are available.
 */
static inline void netif_wake_queue(struct net_device *dev)
    8071:	48 8b 83 b0 03 00 00 	mov    0x3b0(%rbx),%rax
{
	netif_tx_wake_queue(netdev_get_tx_queue(dev, 0));
    8078:	48 8b b8 c0 03 00 00 	mov    0x3c0(%rax),%rdi
    807f:	e8 00 00 00 00       	callq  8084 <e1000_up+0x64>
	e1000_irq_enable(adapter);

	netif_wake_queue(adapter->netdev);

	/* fire a link change interrupt to start the watchdog */
	ew32(ICS, E1000_ICS_LSC);
    8084:	48 8b 93 c0 03 00 00 	mov    0x3c0(%rbx),%rdx
build_mmio_read(__readw, "w", unsigned short, "=r", )
build_mmio_read(__readl, "l", unsigned int, "=r", )

build_mmio_write(writeb, "b", unsigned char, "q", :"memory")
build_mmio_write(writew, "w", unsigned short, "r", :"memory")
build_mmio_write(writel, "l", unsigned int, "r", :"memory")
    808b:	b8 04 00 00 00       	mov    $0x4,%eax
    8090:	89 82 c8 00 00 00    	mov    %eax,0xc8(%rdx)
	return 0;
}
    8096:	5b                   	pop    %rbx
    8097:	30 c0                	xor    %al,%al
    8099:	5d                   	pop    %rbp
    809a:	c3                   	retq   
    809b:	e8 00 00 00 00       	callq  80a0 <e1000_io_resume>

00000000000080a0 <e1000_io_resume>:
 * This callback is called when the error recovery driver tells us that
 * its OK to resume normal operation. Implementation resembles the
 * second-half of the e1000_resume routine.
 */
static void e1000_io_resume(struct pci_dev *pdev)
{
    80a0:	e8 00 00 00 00       	callq  80a5 <e1000_io_resume+0x5>
    80a5:	55                   	push   %rbp
    80a6:	48 89 e5             	mov    %rsp,%rbp
    80a9:	41 54                	push   %r12
    80ab:	53                   	push   %rbx
    80ac:	48 8b 9f 38 01 00 00 	mov    0x138(%rdi),%rbx

static void e1000_init_manageability(struct e1000_adapter *adapter)
{
	struct e1000_hw *hw = &adapter->hw;

	if (adapter->en_mng_pt) {
    80b3:	8b 83 54 0a 00 00    	mov    0xa54(%rbx),%eax
 * second-half of the e1000_resume routine.
 */
static void e1000_io_resume(struct pci_dev *pdev)
{
	struct net_device *netdev = pci_get_drvdata(pdev);
	struct e1000_adapter *adapter = netdev_priv(netdev);
    80b9:	4c 8d a3 40 08 00 00 	lea    0x840(%rbx),%r12

static void e1000_init_manageability(struct e1000_adapter *adapter)
{
	struct e1000_hw *hw = &adapter->hw;

	if (adapter->en_mng_pt) {
    80c0:	85 c0                	test   %eax,%eax
    80c2:	75 21                	jne    80e5 <e1000_io_resume+0x45>
}

static __always_inline int constant_test_bit(long nr, const volatile unsigned long *addr)
{
	return ((1UL << (nr & (BITS_PER_LONG-1))) &
		(addr[nr >> _BITOPS_LONG_SHIFT])) != 0;
    80c4:	48 8b 43 48          	mov    0x48(%rbx),%rax
	struct net_device *netdev = pci_get_drvdata(pdev);
	struct e1000_adapter *adapter = netdev_priv(netdev);

	e1000_init_manageability(adapter);

	if (netif_running(netdev)) {
    80c8:	a8 01                	test   $0x1,%al
    80ca:	74 0c                	je     80d8 <e1000_io_resume+0x38>
		if (e1000_up(adapter)) {
    80cc:	4c 89 e7             	mov    %r12,%rdi
    80cf:	e8 00 00 00 00       	callq  80d4 <e1000_io_resume+0x34>
    80d4:	85 c0                	test   %eax,%eax
    80d6:	75 17                	jne    80ef <e1000_io_resume+0x4f>
			pr_info("can't bring device back up after reset\n");
			return;
		}
	}

	netif_device_attach(netdev);
    80d8:	48 89 df             	mov    %rbx,%rdi
    80db:	e8 00 00 00 00       	callq  80e0 <e1000_io_resume+0x40>
}
    80e0:	5b                   	pop    %rbx
    80e1:	41 5c                	pop    %r12
    80e3:	5d                   	pop    %rbp
    80e4:	c3                   	retq   
    80e5:	4c 89 e7             	mov    %r12,%rdi
    80e8:	e8 c3 8c ff ff       	callq  db0 <e1000_init_manageability.part.31>
    80ed:	eb d5                	jmp    80c4 <e1000_io_resume+0x24>

	e1000_init_manageability(adapter);

	if (netif_running(netdev)) {
		if (e1000_up(adapter)) {
			pr_info("can't bring device back up after reset\n");
    80ef:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
    80f6:	31 c0                	xor    %eax,%eax
    80f8:	e8 00 00 00 00       	callq  80fd <e1000_io_resume+0x5d>
			return;
    80fd:	eb e1                	jmp    80e0 <e1000_io_resume+0x40>
    80ff:	90                   	nop

0000000000008100 <e1000_resume>:

	return 0;
}

static int e1000_resume(struct pci_dev *pdev)
{
    8100:	e8 00 00 00 00       	callq  8105 <e1000_resume+0x5>
    8105:	55                   	push   %rbp
	struct net_device *netdev = pci_get_drvdata(pdev);
	struct e1000_adapter *adapter = netdev_priv(netdev);
	struct e1000_hw *hw = &adapter->hw;
	u32 err;

	pci_set_power_state(pdev, PCI_D0);
    8106:	31 f6                	xor    %esi,%esi

	return 0;
}

static int e1000_resume(struct pci_dev *pdev)
{
    8108:	48 89 e5             	mov    %rsp,%rbp
    810b:	41 56                	push   %r14
    810d:	41 55                	push   %r13
    810f:	41 54                	push   %r12
    8111:	53                   	push   %rbx
    8112:	48 89 fb             	mov    %rdi,%rbx
    8115:	4c 8b a7 38 01 00 00 	mov    0x138(%rdi),%r12
	struct net_device *netdev = pci_get_drvdata(pdev);
	struct e1000_adapter *adapter = netdev_priv(netdev);
	struct e1000_hw *hw = &adapter->hw;
	u32 err;

	pci_set_power_state(pdev, PCI_D0);
    811c:	e8 00 00 00 00       	callq  8121 <e1000_resume+0x21>
	pci_restore_state(pdev);
    8121:	48 89 df             	mov    %rbx,%rdi
}

static int e1000_resume(struct pci_dev *pdev)
{
	struct net_device *netdev = pci_get_drvdata(pdev);
	struct e1000_adapter *adapter = netdev_priv(netdev);
    8124:	4d 8d ac 24 40 08 00 	lea    0x840(%r12),%r13
    812b:	00 
	struct e1000_hw *hw = &adapter->hw;
	u32 err;

	pci_set_power_state(pdev, PCI_D0);
	pci_restore_state(pdev);
    812c:	e8 00 00 00 00       	callq  8131 <e1000_resume+0x31>
	pci_save_state(pdev);
    8131:	48 89 df             	mov    %rbx,%rdi
    8134:	e8 00 00 00 00       	callq  8139 <e1000_resume+0x39>

	if (adapter->need_ioport)
    8139:	41 8b 94 24 f8 0f 00 	mov    0xff8(%r12),%edx
    8140:	00 
		err = pci_enable_device(pdev);
    8141:	48 89 df             	mov    %rbx,%rdi

	pci_set_power_state(pdev, PCI_D0);
	pci_restore_state(pdev);
	pci_save_state(pdev);

	if (adapter->need_ioport)
    8144:	85 d2                	test   %edx,%edx
    8146:	0f 84 8f 00 00 00    	je     81db <e1000_resume+0xdb>
		err = pci_enable_device(pdev);
    814c:	e8 00 00 00 00       	callq  8151 <e1000_resume+0x51>
    8151:	41 89 c6             	mov    %eax,%r14d
	else
		err = pci_enable_device_mem(pdev);
	if (err) {
    8154:	45 85 f6             	test   %r14d,%r14d
    8157:	0f 85 af 00 00 00    	jne    820c <e1000_resume+0x10c>
		pr_err("Cannot enable PCI device from suspend\n");
		return err;
	}
	pci_set_master(pdev);
    815d:	48 89 df             	mov    %rbx,%rdi
    8160:	e8 00 00 00 00       	callq  8165 <e1000_resume+0x65>
void pci_pme_wakeup_bus(struct pci_bus *bus);

static inline int pci_enable_wake(struct pci_dev *dev, pci_power_t state,
				  bool enable)
{
	return __pci_enable_wake(dev, state, false, enable);
    8165:	31 c9                	xor    %ecx,%ecx
    8167:	31 d2                	xor    %edx,%edx
    8169:	be 03 00 00 00       	mov    $0x3,%esi
    816e:	48 89 df             	mov    %rbx,%rdi
    8171:	e8 00 00 00 00       	callq  8176 <e1000_resume+0x76>
    8176:	31 c9                	xor    %ecx,%ecx
    8178:	31 d2                	xor    %edx,%edx
    817a:	be 04 00 00 00       	mov    $0x4,%esi
    817f:	48 89 df             	mov    %rbx,%rdi
    8182:	e8 00 00 00 00       	callq  8187 <e1000_resume+0x87>
    8187:	49 8b 44 24 48       	mov    0x48(%r12),%rax

	pci_enable_wake(pdev, PCI_D3hot, 0);
	pci_enable_wake(pdev, PCI_D3cold, 0);

	if (netif_running(netdev)) {
    818c:	a8 01                	test   $0x1,%al
    818e:	75 58                	jne    81e8 <e1000_resume+0xe8>
		err = e1000_request_irq(adapter);
		if (err)
			return err;
	}

	e1000_power_up_phy(adapter);
    8190:	4c 89 ef             	mov    %r13,%rdi
    8193:	e8 00 00 00 00       	callq  8198 <e1000_resume+0x98>
	e1000_reset(adapter);
    8198:	4c 89 ef             	mov    %r13,%rdi
    819b:	e8 00 00 00 00       	callq  81a0 <e1000_resume+0xa0>
	ew32(WUS, ~0);
    81a0:	49 8b 94 24 00 0c 00 	mov    0xc00(%r12),%rdx
    81a7:	00 
    81a8:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
    81ad:	89 82 10 58 00 00    	mov    %eax,0x5810(%rdx)

static void e1000_init_manageability(struct e1000_adapter *adapter)
{
	struct e1000_hw *hw = &adapter->hw;

	if (adapter->en_mng_pt) {
    81b3:	41 8b 84 24 54 0a 00 	mov    0xa54(%r12),%eax
    81ba:	00 
    81bb:	85 c0                	test   %eax,%eax
    81bd:	75 43                	jne    8202 <e1000_resume+0x102>
    81bf:	49 8b 44 24 48       	mov    0x48(%r12),%rax
	e1000_reset(adapter);
	ew32(WUS, ~0);

	e1000_init_manageability(adapter);

	if (netif_running(netdev))
    81c4:	a8 01                	test   $0x1,%al
    81c6:	75 2e                	jne    81f6 <e1000_resume+0xf6>
		e1000_up(adapter);

	netif_device_attach(netdev);
    81c8:	4c 89 e7             	mov    %r12,%rdi
    81cb:	e8 00 00 00 00       	callq  81d0 <e1000_resume+0xd0>

	return 0;
    81d0:	31 c0                	xor    %eax,%eax
}
    81d2:	5b                   	pop    %rbx
    81d3:	41 5c                	pop    %r12
    81d5:	41 5d                	pop    %r13
    81d7:	41 5e                	pop    %r14
    81d9:	5d                   	pop    %rbp
    81da:	c3                   	retq   
	pci_save_state(pdev);

	if (adapter->need_ioport)
		err = pci_enable_device(pdev);
	else
		err = pci_enable_device_mem(pdev);
    81db:	e8 00 00 00 00       	callq  81e0 <e1000_resume+0xe0>
    81e0:	41 89 c6             	mov    %eax,%r14d
    81e3:	e9 6c ff ff ff       	jmpq   8154 <e1000_resume+0x54>

	pci_enable_wake(pdev, PCI_D3hot, 0);
	pci_enable_wake(pdev, PCI_D3cold, 0);

	if (netif_running(netdev)) {
		err = e1000_request_irq(adapter);
    81e8:	4c 89 ef             	mov    %r13,%rdi
    81eb:	e8 50 84 ff ff       	callq  640 <e1000_request_irq>
		if (err)
    81f0:	85 c0                	test   %eax,%eax
    81f2:	74 9c                	je     8190 <e1000_resume+0x90>
    81f4:	eb dc                	jmp    81d2 <e1000_resume+0xd2>
	ew32(WUS, ~0);

	e1000_init_manageability(adapter);

	if (netif_running(netdev))
		e1000_up(adapter);
    81f6:	4c 89 ef             	mov    %r13,%rdi
    81f9:	e8 00 00 00 00       	callq  81fe <e1000_resume+0xfe>
    81fe:	66 90                	xchg   %ax,%ax
    8200:	eb c6                	jmp    81c8 <e1000_resume+0xc8>
    8202:	4c 89 ef             	mov    %r13,%rdi
    8205:	e8 a6 8b ff ff       	callq  db0 <e1000_init_manageability.part.31>
    820a:	eb b3                	jmp    81bf <e1000_resume+0xbf>
	if (adapter->need_ioport)
		err = pci_enable_device(pdev);
	else
		err = pci_enable_device_mem(pdev);
	if (err) {
		pr_err("Cannot enable PCI device from suspend\n");
    820c:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
    8213:	31 c0                	xor    %eax,%eax
    8215:	e8 00 00 00 00       	callq  821a <e1000_resume+0x11a>
		return err;
    821a:	44 89 f0             	mov    %r14d,%eax
    821d:	eb b3                	jmp    81d2 <e1000_resume+0xd2>
    821f:	90                   	nop

0000000000008220 <e1000_change_mtu>:
 * @new_mtu: new value for maximum frame size
 *
 * Returns 0 on success, negative on failure
 **/
static int e1000_change_mtu(struct net_device *netdev, int new_mtu)
{
    8220:	e8 00 00 00 00       	callq  8225 <e1000_change_mtu+0x5>
    8225:	55                   	push   %rbp
	struct e1000_adapter *adapter = netdev_priv(netdev);
	struct e1000_hw *hw = &adapter->hw;
	int max_frame = new_mtu + ENET_HEADER_SIZE + ETHERNET_FCS_SIZE;

	if ((max_frame < MINIMUM_ETHERNET_FRAME_SIZE) ||
    8226:	8d 46 d2             	lea    -0x2e(%rsi),%eax
 * @new_mtu: new value for maximum frame size
 *
 * Returns 0 on success, negative on failure
 **/
static int e1000_change_mtu(struct net_device *netdev, int new_mtu)
{
    8229:	48 89 e5             	mov    %rsp,%rbp
    822c:	41 57                	push   %r15
	struct e1000_adapter *adapter = netdev_priv(netdev);
	struct e1000_hw *hw = &adapter->hw;
	int max_frame = new_mtu + ENET_HEADER_SIZE + ETHERNET_FCS_SIZE;

	if ((max_frame < MINIMUM_ETHERNET_FRAME_SIZE) ||
    822e:	3d c0 3e 00 00       	cmp    $0x3ec0,%eax
 * @new_mtu: new value for maximum frame size
 *
 * Returns 0 on success, negative on failure
 **/
static int e1000_change_mtu(struct net_device *netdev, int new_mtu)
{
    8233:	41 56                	push   %r14
    8235:	41 55                	push   %r13
	struct e1000_adapter *adapter = netdev_priv(netdev);
	struct e1000_hw *hw = &adapter->hw;
	int max_frame = new_mtu + ENET_HEADER_SIZE + ETHERNET_FCS_SIZE;
    8237:	44 8d 6e 12          	lea    0x12(%rsi),%r13d
 * @new_mtu: new value for maximum frame size
 *
 * Returns 0 on success, negative on failure
 **/
static int e1000_change_mtu(struct net_device *netdev, int new_mtu)
{
    823b:	41 54                	push   %r12
    823d:	49 89 fc             	mov    %rdi,%r12
    8240:	53                   	push   %rbx
    8241:	89 f3                	mov    %esi,%ebx
	struct e1000_adapter *adapter = netdev_priv(netdev);
	struct e1000_hw *hw = &adapter->hw;
	int max_frame = new_mtu + ENET_HEADER_SIZE + ETHERNET_FCS_SIZE;

	if ((max_frame < MINIMUM_ETHERNET_FRAME_SIZE) ||
    8243:	76 1b                	jbe    8260 <e1000_change_mtu+0x40>
	    (max_frame > MAX_JUMBO_FRAME_SIZE)) {
		e_err(probe, "Invalid MTU setting\n");
    8245:	f6 87 e0 0f 00 00 02 	testb  $0x2,0xfe0(%rdi)
		return -EINVAL;
    824c:	bb ea ff ff ff       	mov    $0xffffffea,%ebx
	struct e1000_hw *hw = &adapter->hw;
	int max_frame = new_mtu + ENET_HEADER_SIZE + ETHERNET_FCS_SIZE;

	if ((max_frame < MINIMUM_ETHERNET_FRAME_SIZE) ||
	    (max_frame > MAX_JUMBO_FRAME_SIZE)) {
		e_err(probe, "Invalid MTU setting\n");
    8251:	75 4f                	jne    82a2 <e1000_change_mtu+0x82>
		e1000_reset(adapter);

	clear_bit(__E1000_RESETTING, &adapter->flags);

	return 0;
}
    8253:	89 d8                	mov    %ebx,%eax
    8255:	5b                   	pop    %rbx
    8256:	41 5c                	pop    %r12
    8258:	41 5d                	pop    %r13
    825a:	41 5e                	pop    %r14
    825c:	41 5f                	pop    %r15
    825e:	5d                   	pop    %rbp
    825f:	c3                   	retq   
		e_err(probe, "Invalid MTU setting\n");
		return -EINVAL;
	}

	/* Adapter-specific max frame size limits. */
	switch (hw->mac_type) {
    8260:	83 bf 18 0c 00 00 02 	cmpl   $0x2,0xc18(%rdi)
    8267:	77 5b                	ja     82c4 <e1000_change_mtu+0xa4>
	case e1000_undefined ... e1000_82542_rev2_1:
		if (max_frame > (ETH_FRAME_LEN + ETH_FCS_LEN)) {
    8269:	41 81 fd ee 05 00 00 	cmp    $0x5ee,%r13d
    8270:	7e 52                	jle    82c4 <e1000_change_mtu+0xa4>
			e_err(probe, "Jumbo Frames not supported.\n");
    8272:	f6 87 e0 0f 00 00 02 	testb  $0x2,0xfe0(%rdi)
	int max_frame = new_mtu + ENET_HEADER_SIZE + ETHERNET_FCS_SIZE;

	if ((max_frame < MINIMUM_ETHERNET_FRAME_SIZE) ||
	    (max_frame > MAX_JUMBO_FRAME_SIZE)) {
		e_err(probe, "Invalid MTU setting\n");
		return -EINVAL;
    8279:	bb ea ff ff ff       	mov    $0xffffffea,%ebx

	/* Adapter-specific max frame size limits. */
	switch (hw->mac_type) {
	case e1000_undefined ... e1000_82542_rev2_1:
		if (max_frame > (ETH_FRAME_LEN + ETH_FCS_LEN)) {
			e_err(probe, "Jumbo Frames not supported.\n");
    827e:	74 d3                	je     8253 <e1000_change_mtu+0x33>
    8280:	48 8b bf f0 0b 00 00 	mov    0xbf0(%rdi),%rdi
    8287:	31 c0                	xor    %eax,%eax
    8289:	48 c7 c6 00 00 00 00 	mov    $0x0,%rsi
    8290:	e8 00 00 00 00       	callq  8295 <e1000_change_mtu+0x75>
		e1000_reset(adapter);

	clear_bit(__E1000_RESETTING, &adapter->flags);

	return 0;
}
    8295:	89 d8                	mov    %ebx,%eax
    8297:	5b                   	pop    %rbx
    8298:	41 5c                	pop    %r12
    829a:	41 5d                	pop    %r13
    829c:	41 5e                	pop    %r14
    829e:	41 5f                	pop    %r15
    82a0:	5d                   	pop    %rbp
    82a1:	c3                   	retq   
	struct e1000_hw *hw = &adapter->hw;
	int max_frame = new_mtu + ENET_HEADER_SIZE + ETHERNET_FCS_SIZE;

	if ((max_frame < MINIMUM_ETHERNET_FRAME_SIZE) ||
	    (max_frame > MAX_JUMBO_FRAME_SIZE)) {
		e_err(probe, "Invalid MTU setting\n");
    82a2:	48 8b bf f0 0b 00 00 	mov    0xbf0(%rdi),%rdi
    82a9:	31 c0                	xor    %eax,%eax
    82ab:	48 c7 c6 00 00 00 00 	mov    $0x0,%rsi
    82b2:	e8 00 00 00 00       	callq  82b7 <e1000_change_mtu+0x97>
		e1000_reset(adapter);

	clear_bit(__E1000_RESETTING, &adapter->flags);

	return 0;
}
    82b7:	89 d8                	mov    %ebx,%eax
    82b9:	5b                   	pop    %rbx
    82ba:	41 5c                	pop    %r12
    82bc:	41 5d                	pop    %r13
    82be:	41 5e                	pop    %r14
    82c0:	41 5f                	pop    %r15
    82c2:	5d                   	pop    %rbp
    82c3:	c3                   	retq   
    82c4:	4d 8d b4 24 e8 0f 00 	lea    0xfe8(%r12),%r14
    82cb:	00 
 * This operation is atomic and cannot be reordered.
 * It also implies a memory barrier.
 */
static inline int test_and_set_bit(long nr, volatile unsigned long *addr)
{
	GEN_BINARY_RMWcc(LOCK_PREFIX "bts", *addr, "Ir", nr, "%0", "c");
    82cc:	f0 41 0f ba 2e 01    	lock btsl $0x1,(%r14)
    82d2:	0f 82 b2 00 00 00    	jb     838a <e1000_change_mtu+0x16a>
 *
 * Returns 0 on success, negative on failure
 **/
static int e1000_change_mtu(struct net_device *netdev, int new_mtu)
{
	struct e1000_adapter *adapter = netdev_priv(netdev);
    82d8:	4d 8d bc 24 40 08 00 	lea    0x840(%r12),%r15
    82df:	00 
}

static __always_inline int constant_test_bit(long nr, const volatile unsigned long *addr)
{
	return ((1UL << (nr & (BITS_PER_LONG-1))) &
		(addr[nr >> _BITOPS_LONG_SHIFT])) != 0;
    82e0:	49 8b 44 24 48       	mov    0x48(%r12),%rax
	}

	while (test_and_set_bit(__E1000_RESETTING, &adapter->flags))
		msleep(1);
	/* e1000_down has a dependency on max_frame_size */
	hw->max_frame_size = max_frame;
    82e5:	45 89 ac 24 98 0c 00 	mov    %r13d,0xc98(%r12)
    82ec:	00 
	if (netif_running(netdev)) {
    82ed:	a8 01                	test   $0x1,%al
    82ef:	74 14                	je     8305 <e1000_change_mtu+0xe5>
		/* prevent buffers from being reallocated */
		adapter->alloc_rx_buf = e1000_alloc_dummy_rx_buffers;
    82f1:	49 c7 84 24 e0 0a 00 	movq   $0x0,0xae0(%r12)
    82f8:	00 00 00 00 00 
		e1000_down(adapter);
    82fd:	4c 89 ff             	mov    %r15,%rdi
    8300:	e8 00 00 00 00       	callq  8305 <e1000_change_mtu+0xe5>
	 * however with the new *_jumbo_rx* routines, jumbo receives will use
	 * fragmented skbs
	 */

	if (max_frame <= E1000_RXBUFFER_2048)
		adapter->rx_buffer_len = E1000_RXBUFFER_2048;
    8305:	41 81 fd 00 08 00 00 	cmp    $0x800,%r13d
    830c:	b8 00 08 00 00       	mov    $0x800,%eax
    8311:	ba 00 10 00 00       	mov    $0x1000,%edx
    8316:	0f 4f c2             	cmovg  %edx,%eax
#elif (PAGE_SIZE >= E1000_RXBUFFER_4096)
		adapter->rx_buffer_len = PAGE_SIZE;
#endif

	/* adjust allocation if LPE protects us, and we aren't using SBP */
	if (!hw->tbi_compatibility_on &&
    8319:	41 80 bc 24 0f 0d 00 	cmpb   $0x0,0xd0f(%r12)
    8320:	00 00 
	 * however with the new *_jumbo_rx* routines, jumbo receives will use
	 * fragmented skbs
	 */

	if (max_frame <= E1000_RXBUFFER_2048)
		adapter->rx_buffer_len = E1000_RXBUFFER_2048;
    8322:	41 89 84 24 48 0a 00 	mov    %eax,0xa48(%r12)
    8329:	00 
#elif (PAGE_SIZE >= E1000_RXBUFFER_4096)
		adapter->rx_buffer_len = PAGE_SIZE;
#endif

	/* adjust allocation if LPE protects us, and we aren't using SBP */
	if (!hw->tbi_compatibility_on &&
    832a:	75 1e                	jne    834a <e1000_change_mtu+0x12a>
    832c:	41 81 fd f2 05 00 00 	cmp    $0x5f2,%r13d
    8333:	74 09                	je     833e <e1000_change_mtu+0x11e>
    8335:	41 81 fd ee 05 00 00 	cmp    $0x5ee,%r13d
    833c:	75 0c                	jne    834a <e1000_change_mtu+0x12a>
	    ((max_frame == (ETH_FRAME_LEN + ETH_FCS_LEN)) ||
	     (max_frame == MAXIMUM_ETHERNET_VLAN_SIZE)))
		adapter->rx_buffer_len = MAXIMUM_ETHERNET_VLAN_SIZE;
    833e:	41 c7 84 24 48 0a 00 	movl   $0x5f2,0xa48(%r12)
    8345:	00 f2 05 00 00 

	pr_info("%s changing MTU from %d to %d\n",
    834a:	41 8b 94 24 30 02 00 	mov    0x230(%r12),%edx
    8351:	00 
    8352:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
    8359:	31 c0                	xor    %eax,%eax
    835b:	89 d9                	mov    %ebx,%ecx
    835d:	4c 89 e6             	mov    %r12,%rsi
    8360:	e8 00 00 00 00       	callq  8365 <e1000_change_mtu+0x145>
    8365:	49 8b 44 24 48       	mov    0x48(%r12),%rax
		netdev->name, netdev->mtu, new_mtu);
	netdev->mtu = new_mtu;
    836a:	41 89 9c 24 30 02 00 	mov    %ebx,0x230(%r12)
    8371:	00 

	if (netif_running(netdev))
		e1000_up(adapter);
    8372:	4c 89 ff             	mov    %r15,%rdi

	pr_info("%s changing MTU from %d to %d\n",
		netdev->name, netdev->mtu, new_mtu);
	netdev->mtu = new_mtu;

	if (netif_running(netdev))
    8375:	a8 01                	test   $0x1,%al
    8377:	74 20                	je     8399 <e1000_change_mtu+0x179>
		e1000_up(adapter);
    8379:	e8 00 00 00 00       	callq  837e <e1000_change_mtu+0x15e>
 */
static __always_inline void
clear_bit(long nr, volatile unsigned long *addr)
{
	if (IS_IMMEDIATE(nr)) {
		asm volatile(LOCK_PREFIX "andb %1,%0"
    837e:	f0 41 80 26 fd       	lock andb $0xfd,(%r14)
	else
		e1000_reset(adapter);

	clear_bit(__E1000_RESETTING, &adapter->flags);

	return 0;
    8383:	31 db                	xor    %ebx,%ebx
    8385:	e9 c9 fe ff ff       	jmpq   8253 <e1000_change_mtu+0x33>
		/* Capable of supporting up to MAX_JUMBO_FRAME_SIZE limit. */
		break;
	}

	while (test_and_set_bit(__E1000_RESETTING, &adapter->flags))
		msleep(1);
    838a:	bf 01 00 00 00       	mov    $0x1,%edi
    838f:	e8 00 00 00 00       	callq  8394 <e1000_change_mtu+0x174>
    8394:	e9 33 ff ff ff       	jmpq   82cc <e1000_change_mtu+0xac>
	netdev->mtu = new_mtu;

	if (netif_running(netdev))
		e1000_up(adapter);
	else
		e1000_reset(adapter);
    8399:	e8 00 00 00 00       	callq  839e <e1000_change_mtu+0x17e>
    839e:	66 90                	xchg   %ax,%ax
    83a0:	eb dc                	jmp    837e <e1000_change_mtu+0x15e>
    83a2:	66 66 66 66 66 2e 0f 	data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
    83a9:	1f 84 00 00 00 00 00 

00000000000083b0 <e1000_reinit_locked>:
	e1000_clean_all_tx_rings(adapter);
	e1000_clean_all_rx_rings(adapter);
}

void e1000_reinit_locked(struct e1000_adapter *adapter)
{
    83b0:	e8 00 00 00 00       	callq  83b5 <e1000_reinit_locked+0x5>
    83b5:	55                   	push   %rbp
 * We mask the PREEMPT_NEED_RESCHED bit so as not to confuse all current users
 * that think a non-zero value indicates we cannot preempt.
 */
static __always_inline int preempt_count(void)
{
	return raw_cpu_read_4(__preempt_count) & ~PREEMPT_NEED_RESCHED;
    83b6:	65 8b 05 00 00 00 00 	mov    %gs:0x0(%rip),%eax        # 83bd <e1000_reinit_locked+0xd>
    83bd:	48 89 e5             	mov    %rsp,%rbp
    83c0:	41 54                	push   %r12
	WARN_ON(in_interrupt());
    83c2:	a9 00 ff 1f 00       	test   $0x1fff00,%eax
	e1000_clean_all_tx_rings(adapter);
	e1000_clean_all_rx_rings(adapter);
}

void e1000_reinit_locked(struct e1000_adapter *adapter)
{
    83c7:	53                   	push   %rbx
    83c8:	48 89 fb             	mov    %rdi,%rbx
	WARN_ON(in_interrupt());
    83cb:	75 39                	jne    8406 <e1000_reinit_locked+0x56>
    83cd:	4c 8d a3 a8 07 00 00 	lea    0x7a8(%rbx),%r12
 * This operation is atomic and cannot be reordered.
 * It also implies a memory barrier.
 */
static inline int test_and_set_bit(long nr, volatile unsigned long *addr)
{
	GEN_BINARY_RMWcc(LOCK_PREFIX "bts", *addr, "Ir", nr, "%0", "c");
    83d4:	f0 41 0f ba 2c 24 01 	lock btsl $0x1,(%r12)
    83db:	72 1d                	jb     83fa <e1000_reinit_locked+0x4a>
	while (test_and_set_bit(__E1000_RESETTING, &adapter->flags))
		msleep(1);
	e1000_down(adapter);
    83dd:	48 89 df             	mov    %rbx,%rdi
    83e0:	e8 00 00 00 00       	callq  83e5 <e1000_reinit_locked+0x35>
	e1000_up(adapter);
    83e5:	48 89 df             	mov    %rbx,%rdi
    83e8:	e8 00 00 00 00       	callq  83ed <e1000_reinit_locked+0x3d>
 */
static __always_inline void
clear_bit(long nr, volatile unsigned long *addr)
{
	if (IS_IMMEDIATE(nr)) {
		asm volatile(LOCK_PREFIX "andb %1,%0"
    83ed:	f0 80 a3 a8 07 00 00 	lock andb $0xfd,0x7a8(%rbx)
    83f4:	fd 
	clear_bit(__E1000_RESETTING, &adapter->flags);
}
    83f5:	5b                   	pop    %rbx
    83f6:	41 5c                	pop    %r12
    83f8:	5d                   	pop    %rbp
    83f9:	c3                   	retq   

void e1000_reinit_locked(struct e1000_adapter *adapter)
{
	WARN_ON(in_interrupt());
	while (test_and_set_bit(__E1000_RESETTING, &adapter->flags))
		msleep(1);
    83fa:	bf 01 00 00 00       	mov    $0x1,%edi
    83ff:	e8 00 00 00 00       	callq  8404 <e1000_reinit_locked+0x54>
    8404:	eb ce                	jmp    83d4 <e1000_reinit_locked+0x24>
	e1000_clean_all_rx_rings(adapter);
}

void e1000_reinit_locked(struct e1000_adapter *adapter)
{
	WARN_ON(in_interrupt());
    8406:	be 34 02 00 00       	mov    $0x234,%esi
    840b:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
    8412:	e8 00 00 00 00       	callq  8417 <e1000_reinit_locked+0x67>
    8417:	eb b4                	jmp    83cd <e1000_reinit_locked+0x1d>
    8419:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)

0000000000008420 <e1000_reset_task>:
	adapter->tx_timeout_count++;
	schedule_work(&adapter->reset_task);
}

static void e1000_reset_task(struct work_struct *work)
{
    8420:	e8 00 00 00 00       	callq  8425 <e1000_reset_task+0x5>
    8425:	55                   	push   %rbp
    8426:	48 89 e5             	mov    %rsp,%rbp
    8429:	53                   	push   %rbx
	struct e1000_adapter *adapter =
		container_of(work, struct e1000_adapter, reset_task);

	e_err(drv, "Reset adapter\n");
    842a:	f6 47 e0 01          	testb  $0x1,-0x20(%rdi)
	schedule_work(&adapter->reset_task);
}

static void e1000_reset_task(struct work_struct *work)
{
	struct e1000_adapter *adapter =
    842e:	48 8d 9f 40 f8 ff ff 	lea    -0x7c0(%rdi),%rbx
		container_of(work, struct e1000_adapter, reset_task);

	e_err(drv, "Reset adapter\n");
    8435:	74 15                	je     844c <e1000_reset_task+0x2c>
    8437:	48 8b bf f0 fb ff ff 	mov    -0x410(%rdi),%rdi
    843e:	48 c7 c6 00 00 00 00 	mov    $0x0,%rsi
    8445:	31 c0                	xor    %eax,%eax
    8447:	e8 00 00 00 00       	callq  844c <e1000_reset_task+0x2c>
	e1000_reinit_locked(adapter);
    844c:	48 89 df             	mov    %rbx,%rdi
    844f:	e8 00 00 00 00       	callq  8454 <e1000_reset_task+0x34>
}
    8454:	5b                   	pop    %rbx
    8455:	5d                   	pop    %rbp
    8456:	c3                   	retq   
    8457:	66 0f 1f 84 00 00 00 	nopw   0x0(%rax,%rax,1)
    845e:	00 00 

0000000000008460 <e1000_set_features>:
	return features;
}

static int e1000_set_features(struct net_device *netdev,
	netdev_features_t features)
{
    8460:	e8 00 00 00 00       	callq  8465 <e1000_set_features+0x5>
    8465:	55                   	push   %rbp
    8466:	48 89 e5             	mov    %rsp,%rbp
    8469:	41 55                	push   %r13
	struct e1000_adapter *adapter = netdev_priv(netdev);
    846b:	4c 8d af 40 08 00 00 	lea    0x840(%rdi),%r13
	return features;
}

static int e1000_set_features(struct net_device *netdev,
	netdev_features_t features)
{
    8472:	41 54                	push   %r12
	struct e1000_adapter *adapter = netdev_priv(netdev);
	netdev_features_t changed = features ^ netdev->features;
    8474:	49 89 f4             	mov    %rsi,%r12
	return features;
}

static int e1000_set_features(struct net_device *netdev,
	netdev_features_t features)
{
    8477:	53                   	push   %rbx
    8478:	48 89 fb             	mov    %rdi,%rbx
    847b:	48 83 ec 08          	sub    $0x8,%rsp
	struct e1000_adapter *adapter = netdev_priv(netdev);
	netdev_features_t changed = features ^ netdev->features;
    847f:	4c 33 a7 f0 00 00 00 	xor    0xf0(%rdi),%r12

	if (changed & NETIF_F_HW_VLAN_CTAG_RX)
    8486:	41 f7 c4 00 01 00 00 	test   $0x100,%r12d
    848d:	75 53                	jne    84e2 <e1000_set_features+0x82>
		e1000_vlan_mode(netdev, features);

	if (!(changed & (NETIF_F_RXCSUM | NETIF_F_RXALL)))
    848f:	48 b8 00 00 00 00 44 	movabs $0x4400000000,%rax
    8496:	00 00 00 
    8499:	49 85 c4             	test   %rax,%r12
    849c:	74 25                	je     84c3 <e1000_set_features+0x63>
}

static __always_inline int constant_test_bit(long nr, const volatile unsigned long *addr)
{
	return ((1UL << (nr & (BITS_PER_LONG-1))) &
		(addr[nr >> _BITOPS_LONG_SHIFT])) != 0;
    849e:	48 8b 43 48          	mov    0x48(%rbx),%rax
		return 0;

	netdev->features = features;
    84a2:	48 89 b3 f0 00 00 00 	mov    %rsi,0xf0(%rbx)
	adapter->rx_csum = !!(features & NETIF_F_RXCSUM);
    84a9:	48 c1 ee 22          	shr    $0x22,%rsi
    84ad:	83 e6 01             	and    $0x1,%esi

	if (netif_running(netdev))
		e1000_reinit_locked(adapter);
    84b0:	4c 89 ef             	mov    %r13,%rdi

	if (!(changed & (NETIF_F_RXCSUM | NETIF_F_RXALL)))
		return 0;

	netdev->features = features;
	adapter->rx_csum = !!(features & NETIF_F_RXCSUM);
    84b3:	40 88 b3 dc 0b 00 00 	mov    %sil,0xbdc(%rbx)

	if (netif_running(netdev))
    84ba:	a8 01                	test   $0x1,%al
    84bc:	75 12                	jne    84d0 <e1000_set_features+0x70>
		e1000_reinit_locked(adapter);
	else
		e1000_reset(adapter);
    84be:	e8 00 00 00 00       	callq  84c3 <e1000_set_features+0x63>

	return 0;
}
    84c3:	48 83 c4 08          	add    $0x8,%rsp
    84c7:	31 c0                	xor    %eax,%eax
    84c9:	5b                   	pop    %rbx
    84ca:	41 5c                	pop    %r12
    84cc:	41 5d                	pop    %r13
    84ce:	5d                   	pop    %rbp
    84cf:	c3                   	retq   

	netdev->features = features;
	adapter->rx_csum = !!(features & NETIF_F_RXCSUM);

	if (netif_running(netdev))
		e1000_reinit_locked(adapter);
    84d0:	e8 00 00 00 00       	callq  84d5 <e1000_set_features+0x75>
	else
		e1000_reset(adapter);

	return 0;
}
    84d5:	48 83 c4 08          	add    $0x8,%rsp
    84d9:	31 c0                	xor    %eax,%eax
    84db:	5b                   	pop    %rbx
    84dc:	41 5c                	pop    %r12
    84de:	41 5d                	pop    %r13
    84e0:	5d                   	pop    %rbp
    84e1:	c3                   	retq   
    84e2:	48 8b 87 e8 0f 00 00 	mov    0xfe8(%rdi),%rax
static void e1000_vlan_mode(struct net_device *netdev,
			    netdev_features_t features)
{
	struct e1000_adapter *adapter = netdev_priv(netdev);

	if (!test_bit(__E1000_DOWN, &adapter->flags))
    84e9:	a8 04                	test   $0x4,%al
    84eb:	74 58                	je     8545 <e1000_set_features+0xe5>
			      netdev_features_t features)
{
	struct e1000_hw *hw = &adapter->hw;
	u32 ctrl;

	ctrl = er32(CTRL);
    84ed:	48 8b 83 00 0c 00 00 	mov    0xc00(%rbx),%rax
{ asm volatile("mov" size " %0,%1": :reg (val), \
"m" (*(volatile type __force *)addr) barrier); }

build_mmio_read(readb, "b", unsigned char, "=q", :"memory")
build_mmio_read(readw, "w", unsigned short, "=r", :"memory")
build_mmio_read(readl, "l", unsigned int, "=r", :"memory")
    84f4:	8b 10                	mov    (%rax),%edx
	if (features & NETIF_F_HW_VLAN_CTAG_RX) {
		/* enable VLAN tag insert/strip */
		ctrl |= E1000_CTRL_VME;
    84f6:	89 d0                	mov    %edx,%eax
    84f8:	81 e2 ff ff ff bf    	and    $0xbfffffff,%edx
    84fe:	0d 00 00 00 40       	or     $0x40000000,%eax
    8503:	f7 c6 00 01 00 00    	test   $0x100,%esi
    8509:	0f 44 c2             	cmove  %edx,%eax
	} else {
		/* disable VLAN tag insert/strip */
		ctrl &= ~E1000_CTRL_VME;
	}
	ew32(CTRL, ctrl);
    850c:	48 8b 93 00 0c 00 00 	mov    0xc00(%rbx),%rdx
build_mmio_read(__readw, "w", unsigned short, "=r", )
build_mmio_read(__readl, "l", unsigned int, "=r", )

build_mmio_write(writeb, "b", unsigned char, "q", :"memory")
build_mmio_write(writew, "w", unsigned short, "r", :"memory")
build_mmio_write(writel, "l", unsigned int, "r", :"memory")
    8513:	89 02                	mov    %eax,(%rdx)
    8515:	48 8b 83 e8 0f 00 00 	mov    0xfe8(%rbx),%rax
	if (!test_bit(__E1000_DOWN, &adapter->flags))
		e1000_irq_disable(adapter);

	__e1000_vlan_mode(adapter, features);

	if (!test_bit(__E1000_DOWN, &adapter->flags))
    851c:	a8 04                	test   $0x4,%al
    851e:	0f 85 6b ff ff ff    	jne    848f <e1000_set_features+0x2f>
 **/
static void e1000_irq_enable(struct e1000_adapter *adapter)
{
	struct e1000_hw *hw = &adapter->hw;

	ew32(IMS, IMS_ENABLE_MASK);
    8524:	48 8b 93 00 0c 00 00 	mov    0xc00(%rbx),%rdx
    852b:	b8 9d 00 00 00       	mov    $0x9d,%eax
    8530:	89 82 d0 00 00 00    	mov    %eax,0xd0(%rdx)
	E1000_WRITE_FLUSH();
    8536:	48 8b 83 00 0c 00 00 	mov    0xc00(%rbx),%rax
{ asm volatile("mov" size " %0,%1": :reg (val), \
"m" (*(volatile type __force *)addr) barrier); }

build_mmio_read(readb, "b", unsigned char, "=q", :"memory")
build_mmio_read(readw, "w", unsigned short, "=r", :"memory")
build_mmio_read(readl, "l", unsigned int, "=r", :"memory")
    853d:	8b 40 08             	mov    0x8(%rax),%eax
    8540:	e9 4a ff ff ff       	jmpq   848f <e1000_set_features+0x2f>
			    netdev_features_t features)
{
	struct e1000_adapter *adapter = netdev_priv(netdev);

	if (!test_bit(__E1000_DOWN, &adapter->flags))
		e1000_irq_disable(adapter);
    8545:	4c 89 ef             	mov    %r13,%rdi
    8548:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
    854c:	e8 cf 83 ff ff       	callq  920 <e1000_irq_disable>
    8551:	48 8b 75 e0          	mov    -0x20(%rbp),%rsi
    8555:	eb 96                	jmp    84ed <e1000_set_features+0x8d>
    8557:	66 0f 1f 84 00 00 00 	nopw   0x0(%rax,%rax,1)
    855e:	00 00 

0000000000008560 <e1000_set_mac>:
 * @p: pointer to an address structure
 *
 * Returns 0 on success, negative on failure
 **/
static int e1000_set_mac(struct net_device *netdev, void *p)
{
    8560:	e8 00 00 00 00       	callq  8565 <e1000_set_mac+0x5>
    8565:	55                   	push   %rbp
	struct e1000_adapter *adapter = netdev_priv(netdev);
	struct e1000_hw *hw = &adapter->hw;
	struct sockaddr *addr = p;

	if (!is_valid_ether_addr(addr->sa_data))
		return -EADDRNOTAVAIL;
    8566:	b8 9d ff ff ff       	mov    $0xffffff9d,%eax
 * @p: pointer to an address structure
 *
 * Returns 0 on success, negative on failure
 **/
static int e1000_set_mac(struct net_device *netdev, void *p)
{
    856b:	48 89 e5             	mov    %rsp,%rbp
    856e:	41 56                	push   %r14
    8570:	41 55                	push   %r13
	struct e1000_adapter *adapter = netdev_priv(netdev);
	struct e1000_hw *hw = &adapter->hw;
    8572:	4c 8d af 40 08 00 00 	lea    0x840(%rdi),%r13
 * @p: pointer to an address structure
 *
 * Returns 0 on success, negative on failure
 **/
static int e1000_set_mac(struct net_device *netdev, void *p)
{
    8579:	41 54                	push   %r12
	struct e1000_adapter *adapter = netdev_priv(netdev);
	struct e1000_hw *hw = &adapter->hw;
    857b:	4c 8d a7 00 0c 00 00 	lea    0xc00(%rdi),%r12
 * @p: pointer to an address structure
 *
 * Returns 0 on success, negative on failure
 **/
static int e1000_set_mac(struct net_device *netdev, void *p)
{
    8582:	53                   	push   %rbx
    8583:	48 89 fb             	mov    %rdi,%rbx
    8586:	48 83 ec 08          	sub    $0x8,%rsp
 * By definition the broadcast address is also a multicast address.
 */
static inline bool is_multicast_ether_addr(const u8 *addr)
{
#if defined(CONFIG_HAVE_EFFICIENT_UNALIGNED_ACCESS)
	u32 a = *(const u32 *)addr;
    858a:	8b 56 02             	mov    0x2(%rsi),%edx
 */
static inline bool is_valid_ether_addr(const u8 *addr)
{
	/* FF:FF:FF:FF:FF:FF is a multicast address so we don't need to
	 * explicitly check for it here. */
	return !is_multicast_ether_addr(addr) && !is_zero_ether_addr(addr);
    858d:	f6 c2 01             	test   $0x1,%dl
    8590:	75 6c                	jne    85fe <e1000_set_mac+0x9e>
 * Please note: addr must be aligned to u16.
 */
static inline bool is_zero_ether_addr(const u8 *addr)
{
#if defined(CONFIG_HAVE_EFFICIENT_UNALIGNED_ACCESS)
	return ((*(const u32 *)addr) | (*(const u16 *)(addr + 4))) == 0;
    8592:	0f b7 4e 06          	movzwl 0x6(%rsi),%ecx
 */
static inline bool is_valid_ether_addr(const u8 *addr)
{
	/* FF:FF:FF:FF:FF:FF is a multicast address so we don't need to
	 * explicitly check for it here. */
	return !is_multicast_ether_addr(addr) && !is_zero_ether_addr(addr);
    8596:	09 d1                	or     %edx,%ecx
    8598:	74 64                	je     85fe <e1000_set_mac+0x9e>
	if (!is_valid_ether_addr(addr->sa_data))
		return -EADDRNOTAVAIL;

	/* 82542 2.0 needs to be in reset to write receive address registers */

	if (hw->mac_type == e1000_82542_rev2_0)
    859a:	83 bf 18 0c 00 00 01 	cmpl   $0x1,0xc18(%rdi)
    85a1:	75 10                	jne    85b3 <e1000_set_mac+0x53>
		e1000_enter_82542_rst(adapter);
    85a3:	4c 89 ef             	mov    %r13,%rdi
    85a6:	48 89 75 d8          	mov    %rsi,-0x28(%rbp)
    85aa:	e8 91 a6 ff ff       	callq  2c40 <e1000_enter_82542_rst>
    85af:	48 8b 75 d8          	mov    -0x28(%rbp),%rsi

	memcpy(netdev->dev_addr, addr->sa_data, netdev->addr_len);
    85b3:	0f b6 93 5d 02 00 00 	movzbl 0x25d(%rbx),%edx
    85ba:	4c 8d 76 02          	lea    0x2(%rsi),%r14
    85be:	48 8b bb 20 03 00 00 	mov    0x320(%rbx),%rdi
    85c5:	4c 89 f6             	mov    %r14,%rsi
    85c8:	e8 00 00 00 00       	callq  85cd <e1000_set_mac+0x6d>
	memcpy(hw->mac_addr, addr->sa_data, netdev->addr_len);
    85cd:	0f b6 93 5d 02 00 00 	movzbl 0x25d(%rbx),%edx
    85d4:	48 8d 8b f4 0c 00 00 	lea    0xcf4(%rbx),%rcx
    85db:	4c 89 f6             	mov    %r14,%rsi
    85de:	48 89 cf             	mov    %rcx,%rdi
    85e1:	e8 00 00 00 00       	callq  85e6 <e1000_set_mac+0x86>

	e1000_rar_set(hw, hw->mac_addr, 0);
    85e6:	31 d2                	xor    %edx,%edx
    85e8:	48 89 c6             	mov    %rax,%rsi
    85eb:	4c 89 e7             	mov    %r12,%rdi
    85ee:	e8 00 00 00 00       	callq  85f3 <e1000_set_mac+0x93>

	if (hw->mac_type == e1000_82542_rev2_0)
		e1000_leave_82542_rst(adapter);

	return 0;
    85f3:	31 c0                	xor    %eax,%eax
	memcpy(netdev->dev_addr, addr->sa_data, netdev->addr_len);
	memcpy(hw->mac_addr, addr->sa_data, netdev->addr_len);

	e1000_rar_set(hw, hw->mac_addr, 0);

	if (hw->mac_type == e1000_82542_rev2_0)
    85f5:	83 bb 18 0c 00 00 01 	cmpl   $0x1,0xc18(%rbx)
    85fc:	74 0d                	je     860b <e1000_set_mac+0xab>
		e1000_leave_82542_rst(adapter);

	return 0;
}
    85fe:	48 83 c4 08          	add    $0x8,%rsp
    8602:	5b                   	pop    %rbx
    8603:	41 5c                	pop    %r12
    8605:	41 5d                	pop    %r13
    8607:	41 5e                	pop    %r14
    8609:	5d                   	pop    %rbp
    860a:	c3                   	retq   
	memcpy(hw->mac_addr, addr->sa_data, netdev->addr_len);

	e1000_rar_set(hw, hw->mac_addr, 0);

	if (hw->mac_type == e1000_82542_rev2_0)
		e1000_leave_82542_rst(adapter);
    860b:	4c 89 ef             	mov    %r13,%rdi
    860e:	89 45 d8             	mov    %eax,-0x28(%rbp)
    8611:	e8 1a ef ff ff       	callq  7530 <e1000_leave_82542_rst>
    8616:	8b 45 d8             	mov    -0x28(%rbp),%eax

	return 0;
}
    8619:	48 83 c4 08          	add    $0x8,%rsp
    861d:	5b                   	pop    %rbx
    861e:	41 5c                	pop    %r12
    8620:	41 5d                	pop    %r13
    8622:	41 5e                	pop    %r14
    8624:	5d                   	pop    %rbp
    8625:	c3                   	retq   
    8626:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    862d:	00 00 00 

0000000000008630 <e1000_pci_clear_mwi>:
	if (ret_val)
		e_err(probe, "Error in setting MWI\n");
}

void e1000_pci_clear_mwi(struct e1000_hw *hw)
{
    8630:	e8 00 00 00 00       	callq  8635 <e1000_pci_clear_mwi+0x5>
    8635:	55                   	push   %rbp
	struct e1000_adapter *adapter = hw->back;

	pci_clear_mwi(adapter->pdev);
    8636:	48 8b 47 28          	mov    0x28(%rdi),%rax
	if (ret_val)
		e_err(probe, "Error in setting MWI\n");
}

void e1000_pci_clear_mwi(struct e1000_hw *hw)
{
    863a:	48 89 e5             	mov    %rsp,%rbp
	struct e1000_adapter *adapter = hw->back;

	pci_clear_mwi(adapter->pdev);
    863d:	48 8b b8 b8 03 00 00 	mov    0x3b8(%rax),%rdi
    8644:	e8 00 00 00 00       	callq  8649 <e1000_pci_clear_mwi+0x19>
}
    8649:	5d                   	pop    %rbp
    864a:	c3                   	retq   
    864b:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)

0000000000008650 <e1000_pcix_get_mmrbc>:

int e1000_pcix_get_mmrbc(struct e1000_hw *hw)
{
    8650:	e8 00 00 00 00       	callq  8655 <e1000_pcix_get_mmrbc+0x5>
    8655:	55                   	push   %rbp
	struct e1000_adapter *adapter = hw->back;
	return pcix_get_mmrbc(adapter->pdev);
    8656:	48 8b 47 28          	mov    0x28(%rdi),%rax

	pci_clear_mwi(adapter->pdev);
}

int e1000_pcix_get_mmrbc(struct e1000_hw *hw)
{
    865a:	48 89 e5             	mov    %rsp,%rbp
	struct e1000_adapter *adapter = hw->back;
	return pcix_get_mmrbc(adapter->pdev);
    865d:	48 8b b8 b8 03 00 00 	mov    0x3b8(%rax),%rdi
    8664:	e8 00 00 00 00       	callq  8669 <e1000_pcix_get_mmrbc+0x19>
}
    8669:	5d                   	pop    %rbp
    866a:	c3                   	retq   
    866b:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)

0000000000008670 <e1000_pcix_set_mmrbc>:

void e1000_pcix_set_mmrbc(struct e1000_hw *hw, int mmrbc)
{
    8670:	e8 00 00 00 00       	callq  8675 <e1000_pcix_set_mmrbc+0x5>
    8675:	55                   	push   %rbp
	struct e1000_adapter *adapter = hw->back;
	pcix_set_mmrbc(adapter->pdev, mmrbc);
    8676:	48 8b 47 28          	mov    0x28(%rdi),%rax
	struct e1000_adapter *adapter = hw->back;
	return pcix_get_mmrbc(adapter->pdev);
}

void e1000_pcix_set_mmrbc(struct e1000_hw *hw, int mmrbc)
{
    867a:	48 89 e5             	mov    %rsp,%rbp
	struct e1000_adapter *adapter = hw->back;
	pcix_set_mmrbc(adapter->pdev, mmrbc);
    867d:	48 8b b8 b8 03 00 00 	mov    0x3b8(%rax),%rdi
    8684:	e8 00 00 00 00       	callq  8689 <e1000_pcix_set_mmrbc+0x19>
}
    8689:	5d                   	pop    %rbp
    868a:	c3                   	retq   
    868b:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)

0000000000008690 <e1000_io_write>:

void e1000_io_write(struct e1000_hw *hw, unsigned long port, u32 value)
{
    8690:	e8 00 00 00 00       	callq  8695 <e1000_io_write+0x5>
    8695:	55                   	push   %rbp
    8696:	89 d0                	mov    %edx,%eax
		     : "+D"(addr), "+c"(count) : "d"(port));		\
}

BUILDIO(b, b, char)
BUILDIO(w, w, short)
BUILDIO(l, , int)
    8698:	89 f2                	mov    %esi,%edx
    869a:	48 89 e5             	mov    %rsp,%rbp
    869d:	ef                   	out    %eax,(%dx)
	outl(value, port);
}
    869e:	5d                   	pop    %rbp
    869f:	c3                   	retq   

00000000000086a0 <e1000_set_spd_dplx>:
	for_each_set_bit(vid, adapter->active_vlans, VLAN_N_VID)
		e1000_vlan_rx_add_vid(adapter->netdev, htons(ETH_P_8021Q), vid);
}

int e1000_set_spd_dplx(struct e1000_adapter *adapter, u32 spd, u8 dplx)
{
    86a0:	e8 00 00 00 00       	callq  86a5 <e1000_set_spd_dplx+0x5>
    86a5:	55                   	push   %rbp
	hw->autoneg = 0;

	/* Make sure dplx is at most 1 bit and lsb of speed is not set
	 * for the switch() below to work
	 */
	if ((spd & 1) || (dplx & ~1))
    86a6:	40 f6 c6 01          	test   $0x1,%sil
	for_each_set_bit(vid, adapter->active_vlans, VLAN_N_VID)
		e1000_vlan_rx_add_vid(adapter->netdev, htons(ETH_P_8021Q), vid);
}

int e1000_set_spd_dplx(struct e1000_adapter *adapter, u32 spd, u8 dplx)
{
    86aa:	48 89 e5             	mov    %rsp,%rbp
    86ad:	53                   	push   %rbx
	struct e1000_hw *hw = &adapter->hw;

	hw->autoneg = 0;
    86ae:	c6 87 af 04 00 00 00 	movb   $0x0,0x4af(%rdi)

	/* Make sure dplx is at most 1 bit and lsb of speed is not set
	 * for the switch() below to work
	 */
	if ((spd & 1) || (dplx & ~1))
    86b5:	75 0a                	jne    86c1 <e1000_set_spd_dplx+0x21>
    86b7:	0f b6 c2             	movzbl %dl,%eax
    86ba:	89 c3                	mov    %eax,%ebx
    86bc:	83 e3 fe             	and    $0xfffffffe,%ebx
    86bf:	74 13                	je     86d4 <e1000_set_spd_dplx+0x34>
	hw->mdix = AUTO_ALL_MODES;

	return 0;

err_inval:
	e_err(probe, "Unsupported Speed/Duplex configuration\n");
    86c1:	f6 87 a0 07 00 00 02 	testb  $0x2,0x7a0(%rdi)
	return -EINVAL;
    86c8:	bb ea ff ff ff       	mov    $0xffffffea,%ebx
	hw->mdix = AUTO_ALL_MODES;

	return 0;

err_inval:
	e_err(probe, "Unsupported Speed/Duplex configuration\n");
    86cd:	75 2c                	jne    86fb <e1000_set_spd_dplx+0x5b>
	return -EINVAL;
}
    86cf:	89 d8                	mov    %ebx,%eax
    86d1:	5b                   	pop    %rbx
    86d2:	5d                   	pop    %rbp
    86d3:	c3                   	retq   
	 */
	if ((spd & 1) || (dplx & ~1))
		goto err_inval;

	/* Fiber NICs only allow 1000 gbps Full duplex */
	if ((hw->media_type == e1000_media_type_fiber) &&
    86d4:	83 bf e4 03 00 00 01 	cmpl   $0x1,0x3e4(%rdi)
    86db:	74 38                	je     8715 <e1000_set_spd_dplx+0x75>
	    spd != SPEED_1000 &&
	    dplx != DUPLEX_FULL)
		goto err_inval;

	switch (spd + dplx) {
    86dd:	01 c6                	add    %eax,%esi
    86df:	83 fe 64             	cmp    $0x64,%esi
    86e2:	74 6d                	je     8751 <e1000_set_spd_dplx+0xb1>
    86e4:	77 3e                	ja     8724 <e1000_set_spd_dplx+0x84>
    86e6:	83 fe 0a             	cmp    $0xa,%esi
    86e9:	74 78                	je     8763 <e1000_set_spd_dplx+0xc3>
    86eb:	83 fe 0b             	cmp    $0xb,%esi
    86ee:	66 90                	xchg   %ax,%ax
    86f0:	75 cf                	jne    86c1 <e1000_set_spd_dplx+0x21>
	case SPEED_10 + DUPLEX_HALF:
		hw->forced_speed_duplex = e1000_10_half;
		break;
	case SPEED_10 + DUPLEX_FULL:
		hw->forced_speed_duplex = e1000_10_full;
    86f2:	c6 87 b1 04 00 00 01 	movb   $0x1,0x4b1(%rdi)
		break;
    86f9:	eb 4a                	jmp    8745 <e1000_set_spd_dplx+0xa5>
	hw->mdix = AUTO_ALL_MODES;

	return 0;

err_inval:
	e_err(probe, "Unsupported Speed/Duplex configuration\n");
    86fb:	48 8b bf b0 03 00 00 	mov    0x3b0(%rdi),%rdi
    8702:	31 c0                	xor    %eax,%eax
    8704:	48 c7 c6 00 00 00 00 	mov    $0x0,%rsi
    870b:	e8 00 00 00 00       	callq  8710 <e1000_set_spd_dplx+0x70>
	return -EINVAL;
}
    8710:	89 d8                	mov    %ebx,%eax
    8712:	5b                   	pop    %rbx
    8713:	5d                   	pop    %rbp
    8714:	c3                   	retq   
	if ((spd & 1) || (dplx & ~1))
		goto err_inval;

	/* Fiber NICs only allow 1000 gbps Full duplex */
	if ((hw->media_type == e1000_media_type_fiber) &&
	    spd != SPEED_1000 &&
    8715:	81 fe e8 03 00 00    	cmp    $0x3e8,%esi
    871b:	74 c0                	je     86dd <e1000_set_spd_dplx+0x3d>
    871d:	80 fa 01             	cmp    $0x1,%dl
    8720:	75 9f                	jne    86c1 <e1000_set_spd_dplx+0x21>
    8722:	eb b9                	jmp    86dd <e1000_set_spd_dplx+0x3d>
	    dplx != DUPLEX_FULL)
		goto err_inval;

	switch (spd + dplx) {
    8724:	83 fe 65             	cmp    $0x65,%esi
    8727:	74 31                	je     875a <e1000_set_spd_dplx+0xba>
    8729:	81 fe e9 03 00 00    	cmp    $0x3e9,%esi
    872f:	90                   	nop
    8730:	75 8f                	jne    86c1 <e1000_set_spd_dplx+0x21>
	case SPEED_100 + DUPLEX_FULL:
		hw->forced_speed_duplex = e1000_100_full;
		break;
	case SPEED_1000 + DUPLEX_FULL:
		hw->autoneg = 1;
		hw->autoneg_advertised = ADVERTISE_1000_FULL;
    8732:	b8 20 00 00 00       	mov    $0x20,%eax
		break;
	case SPEED_100 + DUPLEX_FULL:
		hw->forced_speed_duplex = e1000_100_full;
		break;
	case SPEED_1000 + DUPLEX_FULL:
		hw->autoneg = 1;
    8737:	c6 87 af 04 00 00 01 	movb   $0x1,0x4af(%rdi)
		hw->autoneg_advertised = ADVERTISE_1000_FULL;
    873e:	66 89 87 92 04 00 00 	mov    %ax,0x492(%rdi)
	default:
		goto err_inval;
	}

	/* clear MDI, MDI(-X) override is only allowed when autoneg enabled */
	hw->mdix = AUTO_ALL_MODES;
    8745:	c6 87 b0 04 00 00 00 	movb   $0x0,0x4b0(%rdi)
	return 0;

err_inval:
	e_err(probe, "Unsupported Speed/Duplex configuration\n");
	return -EINVAL;
}
    874c:	89 d8                	mov    %ebx,%eax
    874e:	5b                   	pop    %rbx
    874f:	5d                   	pop    %rbp
    8750:	c3                   	retq   
		break;
	case SPEED_10 + DUPLEX_FULL:
		hw->forced_speed_duplex = e1000_10_full;
		break;
	case SPEED_100 + DUPLEX_HALF:
		hw->forced_speed_duplex = e1000_100_half;
    8751:	c6 87 b1 04 00 00 02 	movb   $0x2,0x4b1(%rdi)
		break;
    8758:	eb eb                	jmp    8745 <e1000_set_spd_dplx+0xa5>
	case SPEED_100 + DUPLEX_FULL:
		hw->forced_speed_duplex = e1000_100_full;
    875a:	c6 87 b1 04 00 00 03 	movb   $0x3,0x4b1(%rdi)
		break;
    8761:	eb e2                	jmp    8745 <e1000_set_spd_dplx+0xa5>
	    dplx != DUPLEX_FULL)
		goto err_inval;

	switch (spd + dplx) {
	case SPEED_10 + DUPLEX_HALF:
		hw->forced_speed_duplex = e1000_10_half;
    8763:	c6 87 b1 04 00 00 00 	movb   $0x0,0x4b1(%rdi)
		break;
    876a:	eb d9                	jmp    8745 <e1000_set_spd_dplx+0xa5>
    876c:	0f 1f 40 00          	nopl   0x0(%rax)

0000000000008770 <e1000_ioctl>:
 * @netdev:
 * @ifreq:
 * @cmd:
 **/
static int e1000_ioctl(struct net_device *netdev, struct ifreq *ifr, int cmd)
{
    8770:	e8 00 00 00 00       	callq  8775 <e1000_ioctl+0x5>
    8775:	55                   	push   %rbp
	switch (cmd) {
    8776:	8d 82 b9 76 ff ff    	lea    -0x8947(%rdx),%eax
 * @netdev:
 * @ifreq:
 * @cmd:
 **/
static int e1000_ioctl(struct net_device *netdev, struct ifreq *ifr, int cmd)
{
    877c:	48 89 e5             	mov    %rsp,%rbp
    877f:	41 57                	push   %r15
    8781:	41 56                	push   %r14
    8783:	41 55                	push   %r13
    8785:	41 54                	push   %r12
	case SIOCGMIIPHY:
	case SIOCGMIIREG:
	case SIOCSMIIREG:
		return e1000_mii_ioctl(netdev, ifr, cmd);
	default:
		return -EOPNOTSUPP;
    8787:	41 bc a1 ff ff ff    	mov    $0xffffffa1,%r12d
 * @netdev:
 * @ifreq:
 * @cmd:
 **/
static int e1000_ioctl(struct net_device *netdev, struct ifreq *ifr, int cmd)
{
    878d:	53                   	push   %rbx
    878e:	48 83 ec 20          	sub    $0x20,%rsp
	switch (cmd) {
    8792:	83 f8 02             	cmp    $0x2,%eax
    8795:	0f 87 c9 00 00 00    	ja     8864 <e1000_ioctl+0xf4>
	struct mii_ioctl_data *data = if_mii(ifr);
	int retval;
	u16 mii_reg;
	unsigned long flags;

	if (hw->media_type != e1000_media_type_copper)
    879b:	8b 8f 24 0c 00 00    	mov    0xc24(%rdi),%ecx
    87a1:	48 89 fb             	mov    %rdi,%rbx
 **/
static int e1000_mii_ioctl(struct net_device *netdev, struct ifreq *ifr,
			   int cmd)
{
	struct e1000_adapter *adapter = netdev_priv(netdev);
	struct e1000_hw *hw = &adapter->hw;
    87a4:	4c 8d bf 40 08 00 00 	lea    0x840(%rdi),%r15
    87ab:	4c 8d af 00 0c 00 00 	lea    0xc00(%rdi),%r13
	struct mii_ioctl_data *data = if_mii(ifr);
	int retval;
	u16 mii_reg;
	unsigned long flags;

	if (hw->media_type != e1000_media_type_copper)
    87b2:	85 c9                	test   %ecx,%ecx
    87b4:	0f 85 aa 00 00 00    	jne    8864 <e1000_ioctl+0xf4>
		return -EOPNOTSUPP;

	switch (cmd) {
    87ba:	81 fa 48 89 00 00    	cmp    $0x8948,%edx
    87c0:	49 89 f6             	mov    %rsi,%r14
    87c3:	0f 84 bc 00 00 00    	je     8885 <e1000_ioctl+0x115>
    87c9:	81 fa 49 89 00 00    	cmp    $0x8949,%edx
    87cf:	0f 85 a1 00 00 00    	jne    8876 <e1000_ioctl+0x106>
			return -EIO;
		}
		spin_unlock_irqrestore(&adapter->stats_lock, flags);
		break;
	case SIOCSMIIREG:
		if (data->reg_num & ~(0x1F))
    87d5:	0f b7 46 12          	movzwl 0x12(%rsi),%eax
			return -EFAULT;
    87d9:	41 bc f2 ff ff ff    	mov    $0xfffffff2,%r12d
			return -EIO;
		}
		spin_unlock_irqrestore(&adapter->stats_lock, flags);
		break;
	case SIOCSMIIREG:
		if (data->reg_num & ~(0x1F))
    87df:	a9 e0 ff 00 00       	test   $0xffe0,%eax
    87e4:	75 7e                	jne    8864 <e1000_ioctl+0xf4>
			return -EFAULT;
		mii_reg = data->val_in;
    87e6:	0f b7 46 14          	movzwl 0x14(%rsi),%eax
		spin_lock_irqsave(&adapter->stats_lock, flags);
    87ea:	4c 8d 8f 5c 0a 00 00 	lea    0xa5c(%rdi),%r9
    87f1:	4c 89 cf             	mov    %r9,%rdi
    87f4:	4c 89 4d d0          	mov    %r9,-0x30(%rbp)
		spin_unlock_irqrestore(&adapter->stats_lock, flags);
		break;
	case SIOCSMIIREG:
		if (data->reg_num & ~(0x1F))
			return -EFAULT;
		mii_reg = data->val_in;
    87f8:	41 89 c4             	mov    %eax,%r12d
    87fb:	66 89 45 b8          	mov    %ax,-0x48(%rbp)
		spin_lock_irqsave(&adapter->stats_lock, flags);
    87ff:	e8 00 00 00 00       	callq  8804 <e1000_ioctl+0x94>
		if (e1000_write_phy_reg(hw, data->reg_num,
    8804:	41 0f b7 76 12       	movzwl 0x12(%r14),%esi
    8809:	41 0f b7 d4          	movzwl %r12w,%edx
    880d:	4c 89 ef             	mov    %r13,%rdi
		break;
	case SIOCSMIIREG:
		if (data->reg_num & ~(0x1F))
			return -EFAULT;
		mii_reg = data->val_in;
		spin_lock_irqsave(&adapter->stats_lock, flags);
    8810:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
		if (e1000_write_phy_reg(hw, data->reg_num,
    8814:	e8 00 00 00 00       	callq  8819 <e1000_ioctl+0xa9>
    8819:	4c 8b 4d d0          	mov    -0x30(%rbp),%r9
    881d:	85 c0                	test   %eax,%eax
    881f:	41 89 c4             	mov    %eax,%r12d
    8822:	48 8b 75 c8          	mov    -0x38(%rbp),%rsi
    8826:	4c 89 cf             	mov    %r9,%rdi
    8829:	0f 85 0d 01 00 00    	jne    893c <e1000_ioctl+0x1cc>
    882f:	e8 00 00 00 00       	callq  8834 <e1000_ioctl+0xc4>
					mii_reg)) {
			spin_unlock_irqrestore(&adapter->stats_lock, flags);
			return -EIO;
		}
		spin_unlock_irqrestore(&adapter->stats_lock, flags);
		if (hw->media_type == e1000_media_type_copper) {
    8834:	8b 93 24 0c 00 00    	mov    0xc24(%rbx),%edx
    883a:	85 d2                	test   %edx,%edx
    883c:	0f 85 81 00 00 00    	jne    88c3 <e1000_ioctl+0x153>
			switch (data->reg_num) {
    8842:	41 0f b7 46 12       	movzwl 0x12(%r14),%eax
    8847:	66 83 f8 10          	cmp    $0x10,%ax
    884b:	0f 84 d0 00 00 00    	je     8921 <e1000_ioctl+0x1b1>
    8851:	66 83 f8 14          	cmp    $0x14,%ax
    8855:	0f 84 c6 00 00 00    	je     8921 <e1000_ioctl+0x1b1>
    885b:	66 85 c0             	test   %ax,%ax
    885e:	0f 84 96 00 00 00    	je     88fa <e1000_ioctl+0x18a>
	case SIOCSMIIREG:
		return e1000_mii_ioctl(netdev, ifr, cmd);
	default:
		return -EOPNOTSUPP;
	}
}
    8864:	48 83 c4 20          	add    $0x20,%rsp
    8868:	44 89 e0             	mov    %r12d,%eax
    886b:	5b                   	pop    %rbx
    886c:	41 5c                	pop    %r12
    886e:	41 5d                	pop    %r13
    8870:	41 5e                	pop    %r14
    8872:	41 5f                	pop    %r15
    8874:	5d                   	pop    %rbp
    8875:	c3                   	retq   
	if (hw->media_type != e1000_media_type_copper)
		return -EOPNOTSUPP;

	switch (cmd) {
	case SIOCGMIIPHY:
		data->phy_id = hw->phy_addr;
    8876:	8b 87 88 0c 00 00    	mov    0xc88(%rdi),%eax
		}
		break;
	default:
		return -EOPNOTSUPP;
	}
	return E1000_SUCCESS;
    887c:	45 31 e4             	xor    %r12d,%r12d
	if (hw->media_type != e1000_media_type_copper)
		return -EOPNOTSUPP;

	switch (cmd) {
	case SIOCGMIIPHY:
		data->phy_id = hw->phy_addr;
    887f:	66 89 46 10          	mov    %ax,0x10(%rsi)
    8883:	eb df                	jmp    8864 <e1000_ioctl+0xf4>
		break;
	case SIOCGMIIREG:
		spin_lock_irqsave(&adapter->stats_lock, flags);
    8885:	48 81 c3 5c 0a 00 00 	add    $0xa5c,%rbx
    888c:	48 89 df             	mov    %rbx,%rdi
    888f:	e8 00 00 00 00       	callq  8894 <e1000_ioctl+0x124>
		if (e1000_read_phy_reg(hw, data->reg_num & 0x1F,
    8894:	41 0f b7 76 12       	movzwl 0x12(%r14),%esi
				   &data->val_out)) {
    8899:	49 8d 56 16          	lea    0x16(%r14),%rdx
	case SIOCGMIIPHY:
		data->phy_id = hw->phy_addr;
		break;
	case SIOCGMIIREG:
		spin_lock_irqsave(&adapter->stats_lock, flags);
		if (e1000_read_phy_reg(hw, data->reg_num & 0x1F,
    889d:	4c 89 ef             	mov    %r13,%rdi
	switch (cmd) {
	case SIOCGMIIPHY:
		data->phy_id = hw->phy_addr;
		break;
	case SIOCGMIIREG:
		spin_lock_irqsave(&adapter->stats_lock, flags);
    88a0:	49 89 c7             	mov    %rax,%r15
		if (e1000_read_phy_reg(hw, data->reg_num & 0x1F,
    88a3:	83 e6 1f             	and    $0x1f,%esi
    88a6:	e8 00 00 00 00       	callq  88ab <e1000_ioctl+0x13b>
    88ab:	85 c0                	test   %eax,%eax
    88ad:	41 89 c4             	mov    %eax,%r12d
    88b0:	4c 89 fe             	mov    %r15,%rsi
    88b3:	48 89 df             	mov    %rbx,%rdi
    88b6:	0f 85 80 00 00 00    	jne    893c <e1000_ioctl+0x1cc>
    88bc:	e8 00 00 00 00       	callq  88c1 <e1000_ioctl+0x151>
    88c1:	eb a1                	jmp    8864 <e1000_ioctl+0xf4>
				if (e1000_phy_reset(hw))
					return -EIO;
				break;
			}
		} else {
			switch (data->reg_num) {
    88c3:	66 41 83 7e 12 00    	cmpw   $0x0,0x12(%r14)
    88c9:	75 99                	jne    8864 <e1000_ioctl+0xf4>
			case PHY_CTRL:
				if (mii_reg & MII_CR_POWER_DOWN)
    88cb:	66 f7 45 b8 00 08    	testw  $0x800,-0x48(%rbp)
    88d1:	75 91                	jne    8864 <e1000_ioctl+0xf4>
					break;
				if (netif_running(adapter->netdev))
    88d3:	48 8b 83 f0 0b 00 00 	mov    0xbf0(%rbx),%rax
					e1000_reinit_locked(adapter);
    88da:	4c 89 ff             	mov    %r15,%rdi
    88dd:	48 8b 40 48          	mov    0x48(%rax),%rax
		} else {
			switch (data->reg_num) {
			case PHY_CTRL:
				if (mii_reg & MII_CR_POWER_DOWN)
					break;
				if (netif_running(adapter->netdev))
    88e1:	a8 01                	test   $0x1,%al
    88e3:	74 0a                	je     88ef <e1000_ioctl+0x17f>
					e1000_reinit_locked(adapter);
    88e5:	e8 00 00 00 00       	callq  88ea <e1000_ioctl+0x17a>
    88ea:	e9 75 ff ff ff       	jmpq   8864 <e1000_ioctl+0xf4>
    88ef:	90                   	nop
				else
					e1000_reset(adapter);
    88f0:	e8 00 00 00 00       	callq  88f5 <e1000_ioctl+0x185>
    88f5:	e9 6a ff ff ff       	jmpq   8864 <e1000_ioctl+0xf4>
		}
		spin_unlock_irqrestore(&adapter->stats_lock, flags);
		if (hw->media_type == e1000_media_type_copper) {
			switch (data->reg_num) {
			case PHY_CTRL:
				if (mii_reg & MII_CR_POWER_DOWN)
    88fa:	0f b7 45 b8          	movzwl -0x48(%rbp),%eax
    88fe:	f6 c4 08             	test   $0x8,%ah
    8901:	0f 85 5d ff ff ff    	jne    8864 <e1000_ioctl+0xf4>
					break;
				if (mii_reg & MII_CR_AUTO_NEG_EN) {
    8907:	f6 c4 10             	test   $0x10,%ah
    890a:	74 40                	je     894c <e1000_ioctl+0x1dc>
					hw->autoneg = 1;
					hw->autoneg_advertised = 0x2F;
    890c:	b8 2f 00 00 00       	mov    $0x2f,%eax
			switch (data->reg_num) {
			case PHY_CTRL:
				if (mii_reg & MII_CR_POWER_DOWN)
					break;
				if (mii_reg & MII_CR_AUTO_NEG_EN) {
					hw->autoneg = 1;
    8911:	c6 83 ef 0c 00 00 01 	movb   $0x1,0xcef(%rbx)
					hw->autoneg_advertised = 0x2F;
    8918:	66 89 83 d2 0c 00 00 	mov    %ax,0xcd2(%rbx)
    891f:	eb b2                	jmp    88d3 <e1000_ioctl+0x163>
				else
					e1000_reset(adapter);
				break;
			case M88E1000_PHY_SPEC_CTRL:
			case M88E1000_EXT_PHY_SPEC_CTRL:
				if (e1000_phy_reset(hw))
    8921:	4c 89 ef             	mov    %r13,%rdi
    8924:	e8 00 00 00 00       	callq  8929 <e1000_ioctl+0x1b9>
    8929:	41 89 c4             	mov    %eax,%r12d
					return -EIO;
    892c:	85 c0                	test   %eax,%eax
    892e:	b8 fb ff ff ff       	mov    $0xfffffffb,%eax
    8933:	44 0f 45 e0          	cmovne %eax,%r12d
    8937:	e9 28 ff ff ff       	jmpq   8864 <e1000_ioctl+0xf4>
    893c:	e8 00 00 00 00       	callq  8941 <e1000_ioctl+0x1d1>
		mii_reg = data->val_in;
		spin_lock_irqsave(&adapter->stats_lock, flags);
		if (e1000_write_phy_reg(hw, data->reg_num,
					mii_reg)) {
			spin_unlock_irqrestore(&adapter->stats_lock, flags);
			return -EIO;
    8941:	41 bc fb ff ff ff    	mov    $0xfffffffb,%r12d
    8947:	e9 18 ff ff ff       	jmpq   8864 <e1000_ioctl+0xf4>
				if (mii_reg & MII_CR_AUTO_NEG_EN) {
					hw->autoneg = 1;
					hw->autoneg_advertised = 0x2F;
				} else {
					u32 speed;
					if (mii_reg & 0x40)
    894c:	f6 45 b8 40          	testb  $0x40,-0x48(%rbp)
						speed = SPEED_1000;
    8950:	be e8 03 00 00       	mov    $0x3e8,%esi
				if (mii_reg & MII_CR_AUTO_NEG_EN) {
					hw->autoneg = 1;
					hw->autoneg_advertised = 0x2F;
				} else {
					u32 speed;
					if (mii_reg & 0x40)
    8955:	75 14                	jne    896b <e1000_ioctl+0x1fb>
						speed = SPEED_1000;
					else if (mii_reg & 0x2000)
    8957:	0f b7 45 b8          	movzwl -0x48(%rbp),%eax
    895b:	66 25 00 20          	and    $0x2000,%ax
						speed = SPEED_100;
    895f:	66 83 f8 01          	cmp    $0x1,%ax
    8963:	19 f6                	sbb    %esi,%esi
    8965:	83 e6 a6             	and    $0xffffffa6,%esi
    8968:	83 c6 64             	add    $0x64,%esi
					else
						speed = SPEED_10;
					retval = e1000_set_spd_dplx(
    896b:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
    896f:	4c 89 ff             	mov    %r15,%rdi
    8972:	0f b6 d4             	movzbl %ah,%edx
    8975:	83 e2 01             	and    $0x1,%edx
    8978:	e8 00 00 00 00       	callq  897d <e1000_ioctl+0x20d>
						adapter, speed,
						((mii_reg & 0x100)
						 ? DUPLEX_FULL :
						 DUPLEX_HALF));
					if (retval)
    897d:	85 c0                	test   %eax,%eax
    897f:	0f 84 4e ff ff ff    	je     88d3 <e1000_ioctl+0x163>
    8985:	41 89 c4             	mov    %eax,%r12d
{
	switch (cmd) {
	case SIOCGMIIPHY:
	case SIOCGMIIREG:
	case SIOCSMIIREG:
		return e1000_mii_ioctl(netdev, ifr, cmd);
    8988:	e9 d7 fe ff ff       	jmpq   8864 <e1000_ioctl+0xf4>
    898d:	0f 1f 00             	nopl   (%rax)

0000000000008990 <e1000_shift_out_mdi_bits>:
 * @count: Number of bits to shift out
 *
 * Bits are shifted out in MSB to LSB order.
 */
static void e1000_shift_out_mdi_bits(struct e1000_hw *hw, u32 data, u16 count)
{
    8990:	e8 00 00 00 00       	callq  8995 <e1000_shift_out_mdi_bits+0x5>
    8995:	55                   	push   %rbp
	/* We need to shift "count" number of bits out to the PHY. So, the value
	 * in the "data" parameter will be shifted out to the PHY one bit at a
	 * time. In order to do this, "data" must be broken down into bits.
	 */
	mask = 0x01;
	mask <<= (count - 1);
    8996:	8d 4a ff             	lea    -0x1(%rdx),%ecx
 * @count: Number of bits to shift out
 *
 * Bits are shifted out in MSB to LSB order.
 */
static void e1000_shift_out_mdi_bits(struct e1000_hw *hw, u32 data, u16 count)
{
    8999:	48 89 e5             	mov    %rsp,%rbp
    899c:	41 56                	push   %r14
    899e:	41 89 f6             	mov    %esi,%r14d
    89a1:	41 55                	push   %r13
	/* We need to shift "count" number of bits out to the PHY. So, the value
	 * in the "data" parameter will be shifted out to the PHY one bit at a
	 * time. In order to do this, "data" must be broken down into bits.
	 */
	mask = 0x01;
	mask <<= (count - 1);
    89a3:	41 bd 01 00 00 00    	mov    $0x1,%r13d
    89a9:	41 d3 e5             	shl    %cl,%r13d
 * @count: Number of bits to shift out
 *
 * Bits are shifted out in MSB to LSB order.
 */
static void e1000_shift_out_mdi_bits(struct e1000_hw *hw, u32 data, u16 count)
{
    89ac:	41 54                	push   %r12
    89ae:	49 89 fc             	mov    %rdi,%r12
    89b1:	53                   	push   %rbx
	 * time. In order to do this, "data" must be broken down into bits.
	 */
	mask = 0x01;
	mask <<= (count - 1);

	ctrl = er32(CTRL);
    89b2:	48 8b 07             	mov    (%rdi),%rax
{ asm volatile("mov" size " %0,%1": :reg (val), \
"m" (*(volatile type __force *)addr) barrier); }

build_mmio_read(readb, "b", unsigned char, "=q", :"memory")
build_mmio_read(readw, "w", unsigned short, "=r", :"memory")
build_mmio_read(readl, "l", unsigned int, "=r", :"memory")
    89b5:	8b 18                	mov    (%rax),%ebx

	/* Set MDIO_DIR and MDC_DIR direction bits to be used as output pins. */
	ctrl |= (E1000_CTRL_MDIO_DIR | E1000_CTRL_MDC_DIR);
    89b7:	81 cb 00 00 00 03    	or     $0x3000000,%ebx

	while (mask) {
    89bd:	45 85 ed             	test   %r13d,%r13d
    89c0:	74 6b                	je     8a2d <e1000_shift_out_mdi_bits+0x9d>
		 * "1" and then raising and lowering the Management Data Clock.
		 * A "0" is shifted out to the PHY by setting the MDIO bit to
		 * "0" and then raising and lowering the clock.
		 */
		if (data & mask)
			ctrl |= E1000_CTRL_MDIO;
    89c2:	89 d8                	mov    %ebx,%eax
    89c4:	81 e3 ff ff ef ff    	and    $0xffefffff,%ebx
    89ca:	0d 00 00 10 00       	or     $0x100000,%eax
    89cf:	45 85 f5             	test   %r14d,%r13d
    89d2:	0f 45 d8             	cmovne %eax,%ebx
		else
			ctrl &= ~E1000_CTRL_MDIO;

		ew32(CTRL, ctrl);
    89d5:	49 8b 04 24          	mov    (%r12),%rax
build_mmio_read(__readw, "w", unsigned short, "=r", )
build_mmio_read(__readl, "l", unsigned int, "=r", )

build_mmio_write(writeb, "b", unsigned char, "q", :"memory")
build_mmio_write(writew, "w", unsigned short, "r", :"memory")
build_mmio_write(writel, "l", unsigned int, "r", :"memory")
    89d9:	89 18                	mov    %ebx,(%rax)
		E1000_WRITE_FLUSH();
    89db:	49 8b 04 24          	mov    (%r12),%rax
{ asm volatile("mov" size " %0,%1": :reg (val), \
"m" (*(volatile type __force *)addr) barrier); }

build_mmio_read(readb, "b", unsigned char, "=q", :"memory")
build_mmio_read(readw, "w", unsigned short, "=r", :"memory")
build_mmio_read(readl, "l", unsigned int, "=r", :"memory")
    89df:	8b 40 08             	mov    0x8(%rax),%eax

		udelay(10);
    89e2:	bf c6 a7 00 00       	mov    $0xa7c6,%edi
    89e7:	e8 00 00 00 00       	callq  89ec <e1000_shift_out_mdi_bits+0x5c>
static void e1000_raise_mdi_clk(struct e1000_hw *hw, u32 *ctrl)
{
	/* Raise the clock input to the Management Data Clock (by setting the
	 * MDC bit), and then delay 10 microseconds.
	 */
	ew32(CTRL, (*ctrl | E1000_CTRL_MDC));
    89ec:	89 d8                	mov    %ebx,%eax
    89ee:	49 8b 14 24          	mov    (%r12),%rdx
    89f2:	0d 00 00 20 00       	or     $0x200000,%eax
build_mmio_read(__readw, "w", unsigned short, "=r", )
build_mmio_read(__readl, "l", unsigned int, "=r", )

build_mmio_write(writeb, "b", unsigned char, "q", :"memory")
build_mmio_write(writew, "w", unsigned short, "r", :"memory")
build_mmio_write(writel, "l", unsigned int, "r", :"memory")
    89f7:	89 02                	mov    %eax,(%rdx)
	E1000_WRITE_FLUSH();
    89f9:	49 8b 04 24          	mov    (%r12),%rax
{ asm volatile("mov" size " %0,%1": :reg (val), \
"m" (*(volatile type __force *)addr) barrier); }

build_mmio_read(readb, "b", unsigned char, "=q", :"memory")
build_mmio_read(readw, "w", unsigned short, "=r", :"memory")
build_mmio_read(readl, "l", unsigned int, "=r", :"memory")
    89fd:	8b 40 08             	mov    0x8(%rax),%eax
	udelay(10);
    8a00:	bf c6 a7 00 00       	mov    $0xa7c6,%edi
    8a05:	e8 00 00 00 00       	callq  8a0a <e1000_shift_out_mdi_bits+0x7a>
static void e1000_lower_mdi_clk(struct e1000_hw *hw, u32 *ctrl)
{
	/* Lower the clock input to the Management Data Clock (by clearing the
	 * MDC bit), and then delay 10 microseconds.
	 */
	ew32(CTRL, (*ctrl & ~E1000_CTRL_MDC));
    8a0a:	89 d8                	mov    %ebx,%eax
    8a0c:	49 8b 14 24          	mov    (%r12),%rdx
    8a10:	25 ff ff df ff       	and    $0xffdfffff,%eax
build_mmio_read(__readw, "w", unsigned short, "=r", )
build_mmio_read(__readl, "l", unsigned int, "=r", )

build_mmio_write(writeb, "b", unsigned char, "q", :"memory")
build_mmio_write(writew, "w", unsigned short, "r", :"memory")
build_mmio_write(writel, "l", unsigned int, "r", :"memory")
    8a15:	89 02                	mov    %eax,(%rdx)
	E1000_WRITE_FLUSH();
    8a17:	49 8b 04 24          	mov    (%r12),%rax
{ asm volatile("mov" size " %0,%1": :reg (val), \
"m" (*(volatile type __force *)addr) barrier); }

build_mmio_read(readb, "b", unsigned char, "=q", :"memory")
build_mmio_read(readw, "w", unsigned short, "=r", :"memory")
build_mmio_read(readl, "l", unsigned int, "=r", :"memory")
    8a1b:	8b 40 08             	mov    0x8(%rax),%eax
	udelay(10);
    8a1e:	bf c6 a7 00 00       	mov    $0xa7c6,%edi
    8a23:	e8 00 00 00 00       	callq  8a28 <e1000_shift_out_mdi_bits+0x98>
	ctrl = er32(CTRL);

	/* Set MDIO_DIR and MDC_DIR direction bits to be used as output pins. */
	ctrl |= (E1000_CTRL_MDIO_DIR | E1000_CTRL_MDC_DIR);

	while (mask) {
    8a28:	41 d1 ed             	shr    %r13d
    8a2b:	75 95                	jne    89c2 <e1000_shift_out_mdi_bits+0x32>
		e1000_raise_mdi_clk(hw, &ctrl);
		e1000_lower_mdi_clk(hw, &ctrl);

		mask = mask >> 1;
	}
}
    8a2d:	5b                   	pop    %rbx
    8a2e:	41 5c                	pop    %r12
    8a30:	41 5d                	pop    %r13
    8a32:	41 5e                	pop    %r14
    8a34:	5d                   	pop    %rbp
    8a35:	c3                   	retq   
    8a36:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    8a3d:	00 00 00 

0000000000008a40 <e1000_write_phy_reg_ex>:
	return ret_val;
}

static s32 e1000_write_phy_reg_ex(struct e1000_hw *hw, u32 reg_addr,
				  u16 phy_data)
{
    8a40:	e8 00 00 00 00       	callq  8a45 <e1000_write_phy_reg_ex+0x5>
    8a45:	55                   	push   %rbp
    8a46:	48 89 e5             	mov    %rsp,%rbp
    8a49:	41 55                	push   %r13
    8a4b:	41 89 d5             	mov    %edx,%r13d
    8a4e:	41 54                	push   %r12
    8a50:	49 89 fc             	mov    %rdi,%r12
    8a53:	53                   	push   %rbx
	u32 i;
	u32 mdic = 0;
	const u32 phy_addr = (hw->mac_type == e1000_ce4100) ? hw->phy_addr : 1;
    8a54:	8b 47 18             	mov    0x18(%rdi),%eax
	return ret_val;
}

static s32 e1000_write_phy_reg_ex(struct e1000_hw *hw, u32 reg_addr,
				  u16 phy_data)
{
    8a57:	89 f3                	mov    %esi,%ebx
	u32 i;
	u32 mdic = 0;
	const u32 phy_addr = (hw->mac_type == e1000_ce4100) ? hw->phy_addr : 1;
    8a59:	83 f8 09             	cmp    $0x9,%eax
    8a5c:	74 70                	je     8ace <e1000_write_phy_reg_ex+0x8e>

	if (reg_addr > MAX_PHY_REG_ADDRESS) {
    8a5e:	83 fe 1f             	cmp    $0x1f,%esi
    8a61:	76 19                	jbe    8a7c <e1000_write_phy_reg_ex+0x3c>
		e_dbg("PHY Address %d is out of range\n", reg_addr);
    8a63:	f6 05 00 00 00 00 04 	testb  $0x4,0x0(%rip)        # 8a6a <e1000_write_phy_reg_ex+0x2a>
    8a6a:	0f 85 28 01 00 00    	jne    8b98 <e1000_write_phy_reg_ex+0x158>
		return -E1000_ERR_PARAM;
    8a70:	b8 fc ff ff ff       	mov    $0xfffffffc,%eax

		e1000_shift_out_mdi_bits(hw, mdic, 32);
	}

	return E1000_SUCCESS;
}
    8a75:	5b                   	pop    %rbx
    8a76:	41 5c                	pop    %r12
    8a78:	41 5d                	pop    %r13
    8a7a:	5d                   	pop    %rbp
    8a7b:	c3                   	retq   
	if (reg_addr > MAX_PHY_REG_ADDRESS) {
		e_dbg("PHY Address %d is out of range\n", reg_addr);
		return -E1000_ERR_PARAM;
	}

	if (hw->mac_type > e1000_82543) {
    8a7c:	83 f8 03             	cmp    $0x3,%eax
    8a7f:	0f 86 98 00 00 00    	jbe    8b1d <e1000_write_phy_reg_ex+0xdd>
			if (mdic & INTEL_CE_GBE_MDIC_GO) {
				e_dbg("MDI Write did not complete\n");
				return -E1000_ERR_PHY;
			}
		} else {
			mdic = (((u32) phy_data) |
    8a85:	44 0f b7 ea          	movzwl %dx,%r13d
				(reg_addr << E1000_MDIC_REG_SHIFT) |
    8a89:	c1 e3 10             	shl    $0x10,%ebx
				(phy_addr << E1000_MDIC_PHY_SHIFT) |
				(E1000_MDIC_OP_WRITE));

			ew32(MDIC, mdic);
    8a8c:	48 8b 07             	mov    (%rdi),%rax
				e_dbg("MDI Write did not complete\n");
				return -E1000_ERR_PHY;
			}
		} else {
			mdic = (((u32) phy_data) |
				(reg_addr << E1000_MDIC_REG_SHIFT) |
    8a8f:	41 81 cd 00 00 20 04 	or     $0x4200000,%r13d
			if (mdic & INTEL_CE_GBE_MDIC_GO) {
				e_dbg("MDI Write did not complete\n");
				return -E1000_ERR_PHY;
			}
		} else {
			mdic = (((u32) phy_data) |
    8a96:	41 09 dd             	or     %ebx,%r13d
build_mmio_read(__readw, "w", unsigned short, "=r", )
build_mmio_read(__readl, "l", unsigned int, "=r", )

build_mmio_write(writeb, "b", unsigned char, "q", :"memory")
build_mmio_write(writew, "w", unsigned short, "r", :"memory")
build_mmio_write(writel, "l", unsigned int, "r", :"memory")
    8a99:	44 89 68 20          	mov    %r13d,0x20(%rax)
    8a9d:	bb 81 02 00 00       	mov    $0x281,%ebx
    8aa2:	eb 09                	jmp    8aad <e1000_write_phy_reg_ex+0x6d>
			ew32(MDIC, mdic);

			/* Poll the ready bit to see if the MDI read
			 * completed
			 */
			for (i = 0; i < 641; i++) {
    8aa4:	83 eb 01             	sub    $0x1,%ebx
    8aa7:	0f 84 a5 00 00 00    	je     8b52 <e1000_write_phy_reg_ex+0x112>
				udelay(5);
    8aad:	bf e3 53 00 00       	mov    $0x53e3,%edi
    8ab2:	e8 00 00 00 00       	callq  8ab7 <e1000_write_phy_reg_ex+0x77>
				mdic = er32(MDIC);
    8ab7:	49 8b 04 24          	mov    (%r12),%rax
{ asm volatile("mov" size " %0,%1": :reg (val), \
"m" (*(volatile type __force *)addr) barrier); }

build_mmio_read(readb, "b", unsigned char, "=q", :"memory")
build_mmio_read(readw, "w", unsigned short, "=r", :"memory")
build_mmio_read(readl, "l", unsigned int, "=r", :"memory")
    8abb:	8b 40 20             	mov    0x20(%rax),%eax
				if (mdic & E1000_MDIC_READY)
    8abe:	a9 00 00 00 10       	test   $0x10000000,%eax
    8ac3:	74 df                	je     8aa4 <e1000_write_phy_reg_ex+0x64>
		mdic |= (u32) phy_data;

		e1000_shift_out_mdi_bits(hw, mdic, 32);
	}

	return E1000_SUCCESS;
    8ac5:	31 c0                	xor    %eax,%eax
}
    8ac7:	5b                   	pop    %rbx
    8ac8:	41 5c                	pop    %r12
    8aca:	41 5d                	pop    %r13
    8acc:	5d                   	pop    %rbp
    8acd:	c3                   	retq   
{
	u32 i;
	u32 mdic = 0;
	const u32 phy_addr = (hw->mac_type == e1000_ce4100) ? hw->phy_addr : 1;

	if (reg_addr > MAX_PHY_REG_ADDRESS) {
    8ace:	83 fe 1f             	cmp    $0x1f,%esi
static s32 e1000_write_phy_reg_ex(struct e1000_hw *hw, u32 reg_addr,
				  u16 phy_data)
{
	u32 i;
	u32 mdic = 0;
	const u32 phy_addr = (hw->mac_type == e1000_ce4100) ? hw->phy_addr : 1;
    8ad1:	8b 87 88 00 00 00    	mov    0x88(%rdi),%eax

	if (reg_addr > MAX_PHY_REG_ADDRESS) {
    8ad7:	77 8a                	ja     8a63 <e1000_write_phy_reg_ex+0x23>
		 * intended for the PHY register in the MDI Control register.
		 * The MAC will take care of interfacing with the PHY to send
		 * the desired data.
		 */
		if (hw->mac_type == e1000_ce4100) {
			mdic = (((u32) phy_data) |
    8ad9:	44 0f b7 ea          	movzwl %dx,%r13d
				(reg_addr << E1000_MDIC_REG_SHIFT) |
    8add:	c1 e3 10             	shl    $0x10,%ebx
    8ae0:	c1 e0 15             	shl    $0x15,%eax
		 * intended for the PHY register in the MDI Control register.
		 * The MAC will take care of interfacing with the PHY to send
		 * the desired data.
		 */
		if (hw->mac_type == e1000_ce4100) {
			mdic = (((u32) phy_data) |
    8ae3:	41 81 cd 00 00 00 84 	or     $0x84000000,%r13d
				(reg_addr << E1000_MDIC_REG_SHIFT) |
				(phy_addr << E1000_MDIC_PHY_SHIFT) |
				(INTEL_CE_GBE_MDIC_OP_WRITE) |
				(INTEL_CE_GBE_MDIC_GO));

			writel(mdic, E1000_MDIO_CMD);
    8aea:	48 8b 57 10          	mov    0x10(%rdi),%rdx
		 * The MAC will take care of interfacing with the PHY to send
		 * the desired data.
		 */
		if (hw->mac_type == e1000_ce4100) {
			mdic = (((u32) phy_data) |
				(reg_addr << E1000_MDIC_REG_SHIFT) |
    8aee:	41 09 dd             	or     %ebx,%r13d
		 * intended for the PHY register in the MDI Control register.
		 * The MAC will take care of interfacing with the PHY to send
		 * the desired data.
		 */
		if (hw->mac_type == e1000_ce4100) {
			mdic = (((u32) phy_data) |
    8af1:	44 09 e8             	or     %r13d,%eax
build_mmio_read(__readw, "w", unsigned short, "=r", )
build_mmio_read(__readl, "l", unsigned int, "=r", )

build_mmio_write(writeb, "b", unsigned char, "q", :"memory")
build_mmio_write(writew, "w", unsigned short, "r", :"memory")
build_mmio_write(writel, "l", unsigned int, "r", :"memory")
    8af4:	89 42 04             	mov    %eax,0x4(%rdx)
    8af7:	bb 80 02 00 00       	mov    $0x280,%ebx
    8afc:	eb 05                	jmp    8b03 <e1000_write_phy_reg_ex+0xc3>
			writel(mdic, E1000_MDIO_CMD);

			/* Poll the ready bit to see if the MDI read
			 * completed
			 */
			for (i = 0; i < 640; i++) {
    8afe:	83 eb 01             	sub    $0x1,%ebx
    8b01:	74 62                	je     8b65 <e1000_write_phy_reg_ex+0x125>
				udelay(5);
    8b03:	bf e3 53 00 00       	mov    $0x53e3,%edi
    8b08:	e8 00 00 00 00       	callq  8b0d <e1000_write_phy_reg_ex+0xcd>
				mdic = readl(E1000_MDIO_CMD);
    8b0d:	49 8b 44 24 10       	mov    0x10(%r12),%rax
{ asm volatile("mov" size " %0,%1": :reg (val), \
"m" (*(volatile type __force *)addr) barrier); }

build_mmio_read(readb, "b", unsigned char, "=q", :"memory")
build_mmio_read(readw, "w", unsigned short, "=r", :"memory")
build_mmio_read(readl, "l", unsigned int, "=r", :"memory")
    8b12:	8b 40 04             	mov    0x4(%rax),%eax
				if (!(mdic & INTEL_CE_GBE_MDIC_GO))
    8b15:	85 c0                	test   %eax,%eax
    8b17:	78 e5                	js     8afe <e1000_write_phy_reg_ex+0xbe>
		mdic |= (u32) phy_data;

		e1000_shift_out_mdi_bits(hw, mdic, 32);
	}

	return E1000_SUCCESS;
    8b19:	31 c0                	xor    %eax,%eax
    8b1b:	eb aa                	jmp    8ac7 <e1000_write_phy_reg_ex+0x87>
		/* We'll need to use the SW defined pins to shift the write
		 * command out to the PHY. We first send a preamble to the PHY
		 * to signal the beginning of the MII instruction.  This is done
		 * by sending 32 consecutive "1" bits.
		 */
		e1000_shift_out_mdi_bits(hw, PHY_PREAMBLE, PHY_PREAMBLE_SIZE);
    8b1d:	ba 20 00 00 00       	mov    $0x20,%edx
    8b22:	be ff ff ff ff       	mov    $0xffffffff,%esi
		 * <Preamble><SOF><OpCode><PhyAddr><RegAddr><Turnaround><Data>.
		 */
		mdic = ((PHY_TURNAROUND) | (reg_addr << 2) | (phy_addr << 7) |
			(PHY_OP_WRITE << 12) | (PHY_SOF << 14));
		mdic <<= 16;
		mdic |= (u32) phy_data;
    8b27:	45 0f b7 ed          	movzwl %r13w,%r13d
		/* We'll need to use the SW defined pins to shift the write
		 * command out to the PHY. We first send a preamble to the PHY
		 * to signal the beginning of the MII instruction.  This is done
		 * by sending 32 consecutive "1" bits.
		 */
		e1000_shift_out_mdi_bits(hw, PHY_PREAMBLE, PHY_PREAMBLE_SIZE);
    8b2b:	e8 60 fe ff ff       	callq  8990 <e1000_shift_out_mdi_bits>
		 * a write operation. We use this method instead of calling the
		 * e1000_shift_out_mdi_bits routine for each field in the
		 * command. The format of a MII write instruction is as follows:
		 * <Preamble><SOF><OpCode><PhyAddr><RegAddr><Turnaround><Data>.
		 */
		mdic = ((PHY_TURNAROUND) | (reg_addr << 2) | (phy_addr << 7) |
    8b30:	89 de                	mov    %ebx,%esi
			(PHY_OP_WRITE << 12) | (PHY_SOF << 14));
		mdic <<= 16;
		mdic |= (u32) phy_data;

		e1000_shift_out_mdi_bits(hw, mdic, 32);
    8b32:	ba 20 00 00 00       	mov    $0x20,%edx
    8b37:	4c 89 e7             	mov    %r12,%rdi
		 * a write operation. We use this method instead of calling the
		 * e1000_shift_out_mdi_bits routine for each field in the
		 * command. The format of a MII write instruction is as follows:
		 * <Preamble><SOF><OpCode><PhyAddr><RegAddr><Turnaround><Data>.
		 */
		mdic = ((PHY_TURNAROUND) | (reg_addr << 2) | (phy_addr << 7) |
    8b3a:	c1 e6 12             	shl    $0x12,%esi
			(PHY_OP_WRITE << 12) | (PHY_SOF << 14));
		mdic <<= 16;
    8b3d:	81 ce 00 00 82 50    	or     $0x50820000,%esi
		mdic |= (u32) phy_data;
    8b43:	44 09 ee             	or     %r13d,%esi

		e1000_shift_out_mdi_bits(hw, mdic, 32);
    8b46:	e8 45 fe ff ff       	callq  8990 <e1000_shift_out_mdi_bits>
	}

	return E1000_SUCCESS;
    8b4b:	31 c0                	xor    %eax,%eax
    8b4d:	e9 75 ff ff ff       	jmpq   8ac7 <e1000_write_phy_reg_ex+0x87>
				mdic = er32(MDIC);
				if (mdic & E1000_MDIC_READY)
					break;
			}
			if (!(mdic & E1000_MDIC_READY)) {
				e_dbg("MDI Write did not complete\n");
    8b52:	f6 05 00 00 00 00 04 	testb  $0x4,0x0(%rip)        # 8b59 <e1000_write_phy_reg_ex+0x119>
    8b59:	75 69                	jne    8bc4 <e1000_write_phy_reg_ex+0x184>
				if (!(mdic & INTEL_CE_GBE_MDIC_GO))
					break;
			}
			if (mdic & INTEL_CE_GBE_MDIC_GO) {
				e_dbg("MDI Write did not complete\n");
				return -E1000_ERR_PHY;
    8b5b:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
    8b60:	e9 10 ff ff ff       	jmpq   8a75 <e1000_write_phy_reg_ex+0x35>
				mdic = readl(E1000_MDIO_CMD);
				if (!(mdic & INTEL_CE_GBE_MDIC_GO))
					break;
			}
			if (mdic & INTEL_CE_GBE_MDIC_GO) {
				e_dbg("MDI Write did not complete\n");
    8b65:	f6 05 00 00 00 00 04 	testb  $0x4,0x0(%rip)        # 8b6c <e1000_write_phy_reg_ex+0x12c>
    8b6c:	74 ed                	je     8b5b <e1000_write_phy_reg_ex+0x11b>
    8b6e:	4c 89 e7             	mov    %r12,%rdi
    8b71:	e8 00 00 00 00       	callq  8b76 <e1000_write_phy_reg_ex+0x136>
    8b76:	48 c7 c2 00 00 00 00 	mov    $0x0,%rdx
    8b7d:	48 89 c6             	mov    %rax,%rsi
    8b80:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
    8b87:	31 c0                	xor    %eax,%eax
    8b89:	e8 00 00 00 00       	callq  8b8e <e1000_write_phy_reg_ex+0x14e>
				return -E1000_ERR_PHY;
    8b8e:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
    8b93:	e9 dd fe ff ff       	jmpq   8a75 <e1000_write_phy_reg_ex+0x35>
	u32 i;
	u32 mdic = 0;
	const u32 phy_addr = (hw->mac_type == e1000_ce4100) ? hw->phy_addr : 1;

	if (reg_addr > MAX_PHY_REG_ADDRESS) {
		e_dbg("PHY Address %d is out of range\n", reg_addr);
    8b98:	4c 89 e7             	mov    %r12,%rdi
    8b9b:	e8 00 00 00 00       	callq  8ba0 <e1000_write_phy_reg_ex+0x160>
    8ba0:	89 d9                	mov    %ebx,%ecx
    8ba2:	48 89 c6             	mov    %rax,%rsi
    8ba5:	48 c7 c2 00 00 00 00 	mov    $0x0,%rdx
    8bac:	31 c0                	xor    %eax,%eax
    8bae:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
    8bb5:	e8 00 00 00 00       	callq  8bba <e1000_write_phy_reg_ex+0x17a>
		return -E1000_ERR_PARAM;
    8bba:	b8 fc ff ff ff       	mov    $0xfffffffc,%eax
    8bbf:	e9 b1 fe ff ff       	jmpq   8a75 <e1000_write_phy_reg_ex+0x35>
				mdic = er32(MDIC);
				if (mdic & E1000_MDIC_READY)
					break;
			}
			if (!(mdic & E1000_MDIC_READY)) {
				e_dbg("MDI Write did not complete\n");
    8bc4:	4c 89 e7             	mov    %r12,%rdi
    8bc7:	e8 00 00 00 00       	callq  8bcc <e1000_write_phy_reg_ex+0x18c>
    8bcc:	48 c7 c2 00 00 00 00 	mov    $0x0,%rdx
    8bd3:	48 89 c6             	mov    %rax,%rsi
    8bd6:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
    8bdd:	31 c0                	xor    %eax,%eax
    8bdf:	e8 00 00 00 00       	callq  8be4 <e1000_write_phy_reg_ex+0x1a4>
				return -E1000_ERR_PHY;
    8be4:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
    8be9:	e9 87 fe ff ff       	jmpq   8a75 <e1000_write_phy_reg_ex+0x35>
    8bee:	66 90                	xchg   %ax,%ax

0000000000008bf0 <e1000_acquire_eeprom>:
 *
 * Lowers EEPROM clock. Clears input pin. Sets the chip select pin. This
 * function should be called before issuing a command to the EEPROM.
 */
static s32 e1000_acquire_eeprom(struct e1000_hw *hw)
{
    8bf0:	e8 00 00 00 00       	callq  8bf5 <e1000_acquire_eeprom+0x5>
    8bf5:	55                   	push   %rbp
    8bf6:	48 89 e5             	mov    %rsp,%rbp
    8bf9:	41 54                	push   %r12
    8bfb:	49 89 fc             	mov    %rdi,%r12
    8bfe:	53                   	push   %rbx
    8bff:	48 83 ec 08          	sub    $0x8,%rsp
	struct e1000_eeprom_info *eeprom = &hw->eeprom;
	u32 eecd, i = 0;

	eecd = er32(EECD);
    8c03:	48 8b 07             	mov    (%rdi),%rax
    8c06:	8b 40 10             	mov    0x10(%rax),%eax

	/* Request EEPROM Access */
	if (hw->mac_type > e1000_82544) {
    8c09:	83 7f 18 04          	cmpl   $0x4,0x18(%rdi)
    8c0d:	89 c2                	mov    %eax,%edx
    8c0f:	76 37                	jbe    8c48 <e1000_acquire_eeprom+0x58>
		eecd |= E1000_EECD_REQ;
    8c11:	83 c8 40             	or     $0x40,%eax
		ew32(EECD, eecd);
    8c14:	48 8b 17             	mov    (%rdi),%rdx
build_mmio_read(__readw, "w", unsigned short, "=r", )
build_mmio_read(__readl, "l", unsigned int, "=r", )

build_mmio_write(writeb, "b", unsigned char, "q", :"memory")
build_mmio_write(writew, "w", unsigned short, "r", :"memory")
build_mmio_write(writel, "l", unsigned int, "r", :"memory")
    8c17:	89 42 10             	mov    %eax,0x10(%rdx)
		eecd = er32(EECD);
    8c1a:	48 8b 07             	mov    (%rdi),%rax
{ asm volatile("mov" size " %0,%1": :reg (val), \
"m" (*(volatile type __force *)addr) barrier); }

build_mmio_read(readb, "b", unsigned char, "=q", :"memory")
build_mmio_read(readw, "w", unsigned short, "=r", :"memory")
build_mmio_read(readl, "l", unsigned int, "=r", :"memory")
    8c1d:	8b 50 10             	mov    0x10(%rax),%edx
		while ((!(eecd & E1000_EECD_GNT)) &&
    8c20:	f6 c2 80             	test   $0x80,%dl
    8c23:	75 23                	jne    8c48 <e1000_acquire_eeprom+0x58>
    8c25:	bb e8 03 00 00       	mov    $0x3e8,%ebx
    8c2a:	eb 05                	jmp    8c31 <e1000_acquire_eeprom+0x41>
    8c2c:	83 eb 01             	sub    $0x1,%ebx
    8c2f:	74 7a                	je     8cab <e1000_acquire_eeprom+0xbb>
		       (i < E1000_EEPROM_GRANT_ATTEMPTS)) {
			i++;
			udelay(5);
    8c31:	bf e3 53 00 00       	mov    $0x53e3,%edi
    8c36:	e8 00 00 00 00       	callq  8c3b <e1000_acquire_eeprom+0x4b>
			eecd = er32(EECD);
    8c3b:	49 8b 04 24          	mov    (%r12),%rax
    8c3f:	8b 40 10             	mov    0x10(%rax),%eax
	/* Request EEPROM Access */
	if (hw->mac_type > e1000_82544) {
		eecd |= E1000_EECD_REQ;
		ew32(EECD, eecd);
		eecd = er32(EECD);
		while ((!(eecd & E1000_EECD_GNT)) &&
    8c42:	a8 80                	test   $0x80,%al
    8c44:	89 c2                	mov    %eax,%edx
    8c46:	74 e4                	je     8c2c <e1000_acquire_eeprom+0x3c>
		}
	}

	/* Setup EEPROM for Read/Write */

	if (eeprom->type == e1000_eeprom_microwire) {
    8c48:	41 8b 4c 24 50       	mov    0x50(%r12),%ecx
    8c4d:	83 f9 02             	cmp    $0x2,%ecx
    8c50:	74 3a                	je     8c8c <e1000_acquire_eeprom+0x9c>
		ew32(EECD, eecd);
		E1000_WRITE_FLUSH();
		udelay(1);
	}

	return E1000_SUCCESS;
    8c52:	31 c0                	xor    %eax,%eax
		ew32(EECD, eecd);

		/* Set CS */
		eecd |= E1000_EECD_CS;
		ew32(EECD, eecd);
	} else if (eeprom->type == e1000_eeprom_spi) {
    8c54:	83 f9 01             	cmp    $0x1,%ecx
    8c57:	74 09                	je     8c62 <e1000_acquire_eeprom+0x72>
		E1000_WRITE_FLUSH();
		udelay(1);
	}

	return E1000_SUCCESS;
}
    8c59:	48 83 c4 08          	add    $0x8,%rsp
    8c5d:	5b                   	pop    %rbx
    8c5e:	41 5c                	pop    %r12
    8c60:	5d                   	pop    %rbp
    8c61:	c3                   	retq   
    8c62:	89 45 ec             	mov    %eax,-0x14(%rbp)
		/* Set CS */
		eecd |= E1000_EECD_CS;
		ew32(EECD, eecd);
	} else if (eeprom->type == e1000_eeprom_spi) {
		/* Clear SK and CS */
		eecd &= ~(E1000_EECD_CS | E1000_EECD_SK);
    8c65:	83 e2 fc             	and    $0xfffffffc,%edx
		ew32(EECD, eecd);
    8c68:	49 8b 0c 24          	mov    (%r12),%rcx
build_mmio_read(__readw, "w", unsigned short, "=r", )
build_mmio_read(__readl, "l", unsigned int, "=r", )

build_mmio_write(writeb, "b", unsigned char, "q", :"memory")
build_mmio_write(writew, "w", unsigned short, "r", :"memory")
build_mmio_write(writel, "l", unsigned int, "r", :"memory")
    8c6c:	89 51 10             	mov    %edx,0x10(%rcx)
		E1000_WRITE_FLUSH();
    8c6f:	49 8b 14 24          	mov    (%r12),%rdx
{ asm volatile("mov" size " %0,%1": :reg (val), \
"m" (*(volatile type __force *)addr) barrier); }

build_mmio_read(readb, "b", unsigned char, "=q", :"memory")
build_mmio_read(readw, "w", unsigned short, "=r", :"memory")
build_mmio_read(readl, "l", unsigned int, "=r", :"memory")
    8c73:	8b 52 08             	mov    0x8(%rdx),%edx
		udelay(1);
    8c76:	bf c7 10 00 00       	mov    $0x10c7,%edi
    8c7b:	e8 00 00 00 00       	callq  8c80 <e1000_acquire_eeprom+0x90>
    8c80:	8b 45 ec             	mov    -0x14(%rbp),%eax
	}

	return E1000_SUCCESS;
}
    8c83:	48 83 c4 08          	add    $0x8,%rsp
    8c87:	5b                   	pop    %rbx
    8c88:	41 5c                	pop    %r12
    8c8a:	5d                   	pop    %rbp
    8c8b:	c3                   	retq   

	/* Setup EEPROM for Read/Write */

	if (eeprom->type == e1000_eeprom_microwire) {
		/* Clear SK and DI */
		eecd &= ~(E1000_EECD_DI | E1000_EECD_SK);
    8c8c:	83 e2 fa             	and    $0xfffffffa,%edx
		ew32(EECD, eecd);
    8c8f:	49 8b 04 24          	mov    (%r12),%rax
build_mmio_read(__readw, "w", unsigned short, "=r", )
build_mmio_read(__readl, "l", unsigned int, "=r", )

build_mmio_write(writeb, "b", unsigned char, "q", :"memory")
build_mmio_write(writew, "w", unsigned short, "r", :"memory")
build_mmio_write(writel, "l", unsigned int, "r", :"memory")
    8c93:	89 50 10             	mov    %edx,0x10(%rax)

		/* Set CS */
		eecd |= E1000_EECD_CS;
    8c96:	83 ca 02             	or     $0x2,%edx
		ew32(EECD, eecd);
    8c99:	49 8b 04 24          	mov    (%r12),%rax
    8c9d:	89 50 10             	mov    %edx,0x10(%rax)
		E1000_WRITE_FLUSH();
		udelay(1);
	}

	return E1000_SUCCESS;
}
    8ca0:	48 83 c4 08          	add    $0x8,%rsp
		ew32(EECD, eecd);
		E1000_WRITE_FLUSH();
		udelay(1);
	}

	return E1000_SUCCESS;
    8ca4:	31 c0                	xor    %eax,%eax
}
    8ca6:	5b                   	pop    %rbx
    8ca7:	41 5c                	pop    %r12
    8ca9:	5d                   	pop    %rbp
    8caa:	c3                   	retq   
			i++;
			udelay(5);
			eecd = er32(EECD);
		}
		if (!(eecd & E1000_EECD_GNT)) {
			eecd &= ~E1000_EECD_REQ;
    8cab:	83 e0 bf             	and    $0xffffffbf,%eax
			ew32(EECD, eecd);
    8cae:	49 8b 14 24          	mov    (%r12),%rdx
    8cb2:	89 42 10             	mov    %eax,0x10(%rdx)
			e_dbg("Could not acquire EEPROM grant\n");
    8cb5:	f6 05 00 00 00 00 04 	testb  $0x4,0x0(%rip)        # 8cbc <e1000_acquire_eeprom+0xcc>
    8cbc:	75 07                	jne    8cc5 <e1000_acquire_eeprom+0xd5>
			return -E1000_ERR_EEPROM;
    8cbe:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
    8cc3:	eb 94                	jmp    8c59 <e1000_acquire_eeprom+0x69>
			eecd = er32(EECD);
		}
		if (!(eecd & E1000_EECD_GNT)) {
			eecd &= ~E1000_EECD_REQ;
			ew32(EECD, eecd);
			e_dbg("Could not acquire EEPROM grant\n");
    8cc5:	4c 89 e7             	mov    %r12,%rdi
    8cc8:	e8 00 00 00 00       	callq  8ccd <e1000_acquire_eeprom+0xdd>
    8ccd:	48 c7 c2 00 00 00 00 	mov    $0x0,%rdx
    8cd4:	48 89 c6             	mov    %rax,%rsi
    8cd7:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
    8cde:	31 c0                	xor    %eax,%eax
    8ce0:	e8 00 00 00 00       	callq  8ce5 <e1000_acquire_eeprom+0xf5>
			return -E1000_ERR_EEPROM;
    8ce5:	83 c8 ff             	or     $0xffffffff,%eax
    8ce8:	e9 6c ff ff ff       	jmpq   8c59 <e1000_acquire_eeprom+0x69>
    8ced:	0f 1f 00             	nopl   (%rax)

0000000000008cf0 <e1000_standby_eeprom>:
/**
 * e1000_standby_eeprom - Returns EEPROM to a "standby" state
 * @hw: Struct containing variables accessed by shared code
 */
static void e1000_standby_eeprom(struct e1000_hw *hw)
{
    8cf0:	e8 00 00 00 00       	callq  8cf5 <e1000_standby_eeprom+0x5>
    8cf5:	55                   	push   %rbp
    8cf6:	48 89 e5             	mov    %rsp,%rbp
    8cf9:	41 54                	push   %r12
    8cfb:	53                   	push   %rbx
    8cfc:	48 89 fb             	mov    %rdi,%rbx
	struct e1000_eeprom_info *eeprom = &hw->eeprom;
	u32 eecd;

	eecd = er32(EECD);
    8cff:	48 8b 07             	mov    (%rdi),%rax
{ asm volatile("mov" size " %0,%1": :reg (val), \
"m" (*(volatile type __force *)addr) barrier); }

build_mmio_read(readb, "b", unsigned char, "=q", :"memory")
build_mmio_read(readw, "w", unsigned short, "=r", :"memory")
build_mmio_read(readl, "l", unsigned int, "=r", :"memory")
    8d02:	44 8b 60 10          	mov    0x10(%rax),%r12d

	if (eeprom->type == e1000_eeprom_microwire) {
    8d06:	8b 47 50             	mov    0x50(%rdi),%eax
    8d09:	83 f8 02             	cmp    $0x2,%eax
    8d0c:	74 44                	je     8d52 <e1000_standby_eeprom+0x62>
		/* Clock low */
		eecd &= ~E1000_EECD_SK;
		ew32(EECD, eecd);
		E1000_WRITE_FLUSH();
		udelay(eeprom->delay_usec);
	} else if (eeprom->type == e1000_eeprom_spi) {
    8d0e:	83 f8 01             	cmp    $0x1,%eax
    8d11:	74 05                	je     8d18 <e1000_standby_eeprom+0x28>
		eecd &= ~E1000_EECD_CS;
		ew32(EECD, eecd);
		E1000_WRITE_FLUSH();
		udelay(eeprom->delay_usec);
	}
}
    8d13:	5b                   	pop    %rbx
    8d14:	41 5c                	pop    %r12
    8d16:	5d                   	pop    %rbp
    8d17:	c3                   	retq   
		ew32(EECD, eecd);
		E1000_WRITE_FLUSH();
		udelay(eeprom->delay_usec);
	} else if (eeprom->type == e1000_eeprom_spi) {
		/* Toggle CS to flush commands */
		eecd |= E1000_EECD_CS;
    8d18:	44 89 e0             	mov    %r12d,%eax
		ew32(EECD, eecd);
    8d1b:	48 8b 17             	mov    (%rdi),%rdx
		ew32(EECD, eecd);
		E1000_WRITE_FLUSH();
		udelay(eeprom->delay_usec);
	} else if (eeprom->type == e1000_eeprom_spi) {
		/* Toggle CS to flush commands */
		eecd |= E1000_EECD_CS;
    8d1e:	83 c8 02             	or     $0x2,%eax
build_mmio_read(__readw, "w", unsigned short, "=r", )
build_mmio_read(__readl, "l", unsigned int, "=r", )

build_mmio_write(writeb, "b", unsigned char, "q", :"memory")
build_mmio_write(writew, "w", unsigned short, "r", :"memory")
build_mmio_write(writel, "l", unsigned int, "r", :"memory")
    8d21:	89 42 10             	mov    %eax,0x10(%rdx)
		ew32(EECD, eecd);
		E1000_WRITE_FLUSH();
    8d24:	48 8b 07             	mov    (%rdi),%rax
{ asm volatile("mov" size " %0,%1": :reg (val), \
"m" (*(volatile type __force *)addr) barrier); }

build_mmio_read(readb, "b", unsigned char, "=q", :"memory")
build_mmio_read(readw, "w", unsigned short, "=r", :"memory")
build_mmio_read(readl, "l", unsigned int, "=r", :"memory")
    8d27:	8b 40 08             	mov    0x8(%rax),%eax
		udelay(eeprom->delay_usec);
    8d2a:	0f b7 7f 5a          	movzwl 0x5a(%rdi),%edi
		eecd &= ~E1000_EECD_CS;
    8d2e:	41 83 e4 fd          	and    $0xfffffffd,%r12d
	} else if (eeprom->type == e1000_eeprom_spi) {
		/* Toggle CS to flush commands */
		eecd |= E1000_EECD_CS;
		ew32(EECD, eecd);
		E1000_WRITE_FLUSH();
		udelay(eeprom->delay_usec);
    8d32:	e8 00 00 00 00       	callq  8d37 <e1000_standby_eeprom+0x47>
		eecd &= ~E1000_EECD_CS;
		ew32(EECD, eecd);
    8d37:	48 8b 03             	mov    (%rbx),%rax
build_mmio_read(__readw, "w", unsigned short, "=r", )
build_mmio_read(__readl, "l", unsigned int, "=r", )

build_mmio_write(writeb, "b", unsigned char, "q", :"memory")
build_mmio_write(writew, "w", unsigned short, "r", :"memory")
build_mmio_write(writel, "l", unsigned int, "r", :"memory")
    8d3a:	44 89 60 10          	mov    %r12d,0x10(%rax)
		E1000_WRITE_FLUSH();
    8d3e:	48 8b 03             	mov    (%rbx),%rax
{ asm volatile("mov" size " %0,%1": :reg (val), \
"m" (*(volatile type __force *)addr) barrier); }

build_mmio_read(readb, "b", unsigned char, "=q", :"memory")
build_mmio_read(readw, "w", unsigned short, "=r", :"memory")
build_mmio_read(readl, "l", unsigned int, "=r", :"memory")
    8d41:	8b 40 08             	mov    0x8(%rax),%eax
		udelay(eeprom->delay_usec);
    8d44:	0f b7 7b 5a          	movzwl 0x5a(%rbx),%edi
    8d48:	e8 00 00 00 00       	callq  8d4d <e1000_standby_eeprom+0x5d>
	}
}
    8d4d:	5b                   	pop    %rbx
    8d4e:	41 5c                	pop    %r12
    8d50:	5d                   	pop    %rbp
    8d51:	c3                   	retq   
	u32 eecd;

	eecd = er32(EECD);

	if (eeprom->type == e1000_eeprom_microwire) {
		eecd &= ~(E1000_EECD_CS | E1000_EECD_SK);
    8d52:	41 83 e4 fc          	and    $0xfffffffc,%r12d
		ew32(EECD, eecd);
    8d56:	48 8b 07             	mov    (%rdi),%rax
build_mmio_read(__readw, "w", unsigned short, "=r", )
build_mmio_read(__readl, "l", unsigned int, "=r", )

build_mmio_write(writeb, "b", unsigned char, "q", :"memory")
build_mmio_write(writew, "w", unsigned short, "r", :"memory")
build_mmio_write(writel, "l", unsigned int, "r", :"memory")
    8d59:	44 89 60 10          	mov    %r12d,0x10(%rax)
		E1000_WRITE_FLUSH();
    8d5d:	48 8b 07             	mov    (%rdi),%rax
{ asm volatile("mov" size " %0,%1": :reg (val), \
"m" (*(volatile type __force *)addr) barrier); }

build_mmio_read(readb, "b", unsigned char, "=q", :"memory")
build_mmio_read(readw, "w", unsigned short, "=r", :"memory")
build_mmio_read(readl, "l", unsigned int, "=r", :"memory")
    8d60:	8b 40 08             	mov    0x8(%rax),%eax
		udelay(eeprom->delay_usec);
    8d63:	0f b7 7f 5a          	movzwl 0x5a(%rdi),%edi
    8d67:	e8 00 00 00 00       	callq  8d6c <e1000_standby_eeprom+0x7c>

		/* Clock high */
		eecd |= E1000_EECD_SK;
    8d6c:	44 89 e0             	mov    %r12d,%eax
		ew32(EECD, eecd);
    8d6f:	48 8b 13             	mov    (%rbx),%rdx
		ew32(EECD, eecd);
		E1000_WRITE_FLUSH();
		udelay(eeprom->delay_usec);

		/* Clock high */
		eecd |= E1000_EECD_SK;
    8d72:	83 c8 01             	or     $0x1,%eax
build_mmio_read(__readw, "w", unsigned short, "=r", )
build_mmio_read(__readl, "l", unsigned int, "=r", )

build_mmio_write(writeb, "b", unsigned char, "q", :"memory")
build_mmio_write(writew, "w", unsigned short, "r", :"memory")
build_mmio_write(writel, "l", unsigned int, "r", :"memory")
    8d75:	89 42 10             	mov    %eax,0x10(%rdx)
		ew32(EECD, eecd);
		E1000_WRITE_FLUSH();
    8d78:	48 8b 03             	mov    (%rbx),%rax
{ asm volatile("mov" size " %0,%1": :reg (val), \
"m" (*(volatile type __force *)addr) barrier); }

build_mmio_read(readb, "b", unsigned char, "=q", :"memory")
build_mmio_read(readw, "w", unsigned short, "=r", :"memory")
build_mmio_read(readl, "l", unsigned int, "=r", :"memory")
    8d7b:	8b 40 08             	mov    0x8(%rax),%eax
		udelay(eeprom->delay_usec);
    8d7e:	0f b7 7b 5a          	movzwl 0x5a(%rbx),%edi
    8d82:	e8 00 00 00 00       	callq  8d87 <e1000_standby_eeprom+0x97>

		/* Select EEPROM */
		eecd |= E1000_EECD_CS;
    8d87:	44 89 e0             	mov    %r12d,%eax
		ew32(EECD, eecd);
    8d8a:	48 8b 13             	mov    (%rbx),%rdx
		ew32(EECD, eecd);
		E1000_WRITE_FLUSH();
		udelay(eeprom->delay_usec);

		/* Select EEPROM */
		eecd |= E1000_EECD_CS;
    8d8d:	83 c8 03             	or     $0x3,%eax
build_mmio_read(__readw, "w", unsigned short, "=r", )
build_mmio_read(__readl, "l", unsigned int, "=r", )

build_mmio_write(writeb, "b", unsigned char, "q", :"memory")
build_mmio_write(writew, "w", unsigned short, "r", :"memory")
build_mmio_write(writel, "l", unsigned int, "r", :"memory")
    8d90:	89 42 10             	mov    %eax,0x10(%rdx)
		ew32(EECD, eecd);
		E1000_WRITE_FLUSH();
    8d93:	48 8b 03             	mov    (%rbx),%rax
{ asm volatile("mov" size " %0,%1": :reg (val), \
"m" (*(volatile type __force *)addr) barrier); }

build_mmio_read(readb, "b", unsigned char, "=q", :"memory")
build_mmio_read(readw, "w", unsigned short, "=r", :"memory")
build_mmio_read(readl, "l", unsigned int, "=r", :"memory")
    8d96:	8b 40 08             	mov    0x8(%rax),%eax
		udelay(eeprom->delay_usec);
    8d99:	0f b7 7b 5a          	movzwl 0x5a(%rbx),%edi

		/* Clock low */
		eecd &= ~E1000_EECD_SK;
    8d9d:	41 83 cc 02          	or     $0x2,%r12d

		/* Select EEPROM */
		eecd |= E1000_EECD_CS;
		ew32(EECD, eecd);
		E1000_WRITE_FLUSH();
		udelay(eeprom->delay_usec);
    8da1:	e8 00 00 00 00       	callq  8da6 <e1000_standby_eeprom+0xb6>
    8da6:	eb 8f                	jmp    8d37 <e1000_standby_eeprom+0x47>
    8da8:	0f 1f 84 00 00 00 00 	nopl   0x0(%rax,%rax,1)
    8daf:	00 

0000000000008db0 <e1000_release_eeprom>:
 * @hw: Struct containing variables accessed by shared code
 *
 * Terminates a command by inverting the EEPROM's chip select pin
 */
static void e1000_release_eeprom(struct e1000_hw *hw)
{
    8db0:	e8 00 00 00 00       	callq  8db5 <e1000_release_eeprom+0x5>
    8db5:	55                   	push   %rbp
    8db6:	48 89 e5             	mov    %rsp,%rbp
    8db9:	41 54                	push   %r12
    8dbb:	53                   	push   %rbx
    8dbc:	48 89 fb             	mov    %rdi,%rbx
	u32 eecd;

	eecd = er32(EECD);
    8dbf:	48 8b 07             	mov    (%rdi),%rax
    8dc2:	44 8b 60 10          	mov    0x10(%rax),%r12d

	if (hw->eeprom.type == e1000_eeprom_spi) {
    8dc6:	8b 47 50             	mov    0x50(%rdi),%eax
    8dc9:	83 f8 01             	cmp    $0x1,%eax
    8dcc:	74 1b                	je     8de9 <e1000_release_eeprom+0x39>

		ew32(EECD, eecd);
		E1000_WRITE_FLUSH();

		udelay(hw->eeprom.delay_usec);
	} else if (hw->eeprom.type == e1000_eeprom_microwire) {
    8dce:	83 f8 02             	cmp    $0x2,%eax
    8dd1:	74 36                	je     8e09 <e1000_release_eeprom+0x59>
		E1000_WRITE_FLUSH();
		udelay(hw->eeprom.delay_usec);
	}

	/* Stop requesting EEPROM access */
	if (hw->mac_type > e1000_82544) {
    8dd3:	83 7b 18 04          	cmpl   $0x4,0x18(%rbx)
    8dd7:	76 0b                	jbe    8de4 <e1000_release_eeprom+0x34>
		eecd &= ~E1000_EECD_REQ;
    8dd9:	41 83 e4 bf          	and    $0xffffffbf,%r12d
		ew32(EECD, eecd);
    8ddd:	48 8b 03             	mov    (%rbx),%rax
build_mmio_read(__readw, "w", unsigned short, "=r", )
build_mmio_read(__readl, "l", unsigned int, "=r", )

build_mmio_write(writeb, "b", unsigned char, "q", :"memory")
build_mmio_write(writew, "w", unsigned short, "r", :"memory")
build_mmio_write(writel, "l", unsigned int, "r", :"memory")
    8de0:	44 89 60 10          	mov    %r12d,0x10(%rax)
	}
}
    8de4:	5b                   	pop    %rbx
    8de5:	41 5c                	pop    %r12
    8de7:	5d                   	pop    %rbp
    8de8:	c3                   	retq   

	eecd = er32(EECD);

	if (hw->eeprom.type == e1000_eeprom_spi) {
		eecd |= E1000_EECD_CS;	/* Pull CS high */
		eecd &= ~E1000_EECD_SK;	/* Lower SCK */
    8de9:	41 83 e4 fe          	and    $0xfffffffe,%r12d
    8ded:	41 83 cc 02          	or     $0x2,%r12d
		E1000_WRITE_FLUSH();
		udelay(hw->eeprom.delay_usec);

		/* Falling edge of clock */
		eecd &= ~E1000_EECD_SK;
		ew32(EECD, eecd);
    8df1:	48 8b 03             	mov    (%rbx),%rax
    8df4:	44 89 60 10          	mov    %r12d,0x10(%rax)
		E1000_WRITE_FLUSH();
    8df8:	48 8b 03             	mov    (%rbx),%rax
{ asm volatile("mov" size " %0,%1": :reg (val), \
"m" (*(volatile type __force *)addr) barrier); }

build_mmio_read(readb, "b", unsigned char, "=q", :"memory")
build_mmio_read(readw, "w", unsigned short, "=r", :"memory")
build_mmio_read(readl, "l", unsigned int, "=r", :"memory")
    8dfb:	8b 40 08             	mov    0x8(%rax),%eax
		udelay(hw->eeprom.delay_usec);
    8dfe:	0f b7 7b 5a          	movzwl 0x5a(%rbx),%edi
    8e02:	e8 00 00 00 00       	callq  8e07 <e1000_release_eeprom+0x57>
    8e07:	eb ca                	jmp    8dd3 <e1000_release_eeprom+0x23>
		udelay(hw->eeprom.delay_usec);
	} else if (hw->eeprom.type == e1000_eeprom_microwire) {
		/* cleanup eeprom */

		/* CS on Microwire is active-high */
		eecd &= ~(E1000_EECD_CS | E1000_EECD_DI);
    8e09:	44 89 e0             	mov    %r12d,%eax

		ew32(EECD, eecd);
    8e0c:	48 8b 17             	mov    (%rdi),%rdx
		udelay(hw->eeprom.delay_usec);
	} else if (hw->eeprom.type == e1000_eeprom_microwire) {
		/* cleanup eeprom */

		/* CS on Microwire is active-high */
		eecd &= ~(E1000_EECD_CS | E1000_EECD_DI);
    8e0f:	83 e0 f9             	and    $0xfffffff9,%eax
build_mmio_read(__readw, "w", unsigned short, "=r", )
build_mmio_read(__readl, "l", unsigned int, "=r", )

build_mmio_write(writeb, "b", unsigned char, "q", :"memory")
build_mmio_write(writew, "w", unsigned short, "r", :"memory")
build_mmio_write(writel, "l", unsigned int, "r", :"memory")
    8e12:	89 42 10             	mov    %eax,0x10(%rdx)

		ew32(EECD, eecd);

		/* Rising edge of clock */
		eecd |= E1000_EECD_SK;
    8e15:	83 c8 01             	or     $0x1,%eax
		ew32(EECD, eecd);
    8e18:	48 8b 17             	mov    (%rdi),%rdx
    8e1b:	89 42 10             	mov    %eax,0x10(%rdx)
		E1000_WRITE_FLUSH();
    8e1e:	48 8b 07             	mov    (%rdi),%rax
{ asm volatile("mov" size " %0,%1": :reg (val), \
"m" (*(volatile type __force *)addr) barrier); }

build_mmio_read(readb, "b", unsigned char, "=q", :"memory")
build_mmio_read(readw, "w", unsigned short, "=r", :"memory")
build_mmio_read(readl, "l", unsigned int, "=r", :"memory")
    8e21:	8b 40 08             	mov    0x8(%rax),%eax
		udelay(hw->eeprom.delay_usec);
    8e24:	0f b7 7f 5a          	movzwl 0x5a(%rdi),%edi

		/* Falling edge of clock */
		eecd &= ~E1000_EECD_SK;
    8e28:	41 83 e4 f8          	and    $0xfffffff8,%r12d

		/* Rising edge of clock */
		eecd |= E1000_EECD_SK;
		ew32(EECD, eecd);
		E1000_WRITE_FLUSH();
		udelay(hw->eeprom.delay_usec);
    8e2c:	e8 00 00 00 00       	callq  8e31 <e1000_release_eeprom+0x81>
    8e31:	eb be                	jmp    8df1 <e1000_release_eeprom+0x41>
    8e33:	66 66 66 66 2e 0f 1f 	data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
    8e3a:	84 00 00 00 00 00 

0000000000008e40 <e1000_raise_ee_clk.isra.6>:
/**
 * e1000_raise_ee_clk - Raises the EEPROM's clock input.
 * @hw: Struct containing variables accessed by shared code
 * @eecd: EECD's current value
 */
static void e1000_raise_ee_clk(struct e1000_hw *hw, u32 *eecd)
    8e40:	e8 00 00 00 00       	callq  8e45 <e1000_raise_ee_clk.isra.6+0x5>
    8e45:	55                   	push   %rbp
{
	/* Raise the clock input to the EEPROM (by setting the SK bit), and then
	 * wait <delay> microseconds.
	 */
	*eecd = *eecd | E1000_EECD_SK;
    8e46:	8b 02                	mov    (%rdx),%eax
/**
 * e1000_raise_ee_clk - Raises the EEPROM's clock input.
 * @hw: Struct containing variables accessed by shared code
 * @eecd: EECD's current value
 */
static void e1000_raise_ee_clk(struct e1000_hw *hw, u32 *eecd)
    8e48:	48 89 e5             	mov    %rsp,%rbp
{
	/* Raise the clock input to the EEPROM (by setting the SK bit), and then
	 * wait <delay> microseconds.
	 */
	*eecd = *eecd | E1000_EECD_SK;
    8e4b:	83 c8 01             	or     $0x1,%eax
    8e4e:	89 02                	mov    %eax,(%rdx)
	ew32(EECD, *eecd);
    8e50:	48 8b 17             	mov    (%rdi),%rdx
build_mmio_read(__readw, "w", unsigned short, "=r", )
build_mmio_read(__readl, "l", unsigned int, "=r", )

build_mmio_write(writeb, "b", unsigned char, "q", :"memory")
build_mmio_write(writew, "w", unsigned short, "r", :"memory")
build_mmio_write(writel, "l", unsigned int, "r", :"memory")
    8e53:	89 42 10             	mov    %eax,0x10(%rdx)
	E1000_WRITE_FLUSH();
    8e56:	48 8b 07             	mov    (%rdi),%rax
{ asm volatile("mov" size " %0,%1": :reg (val), \
"m" (*(volatile type __force *)addr) barrier); }

build_mmio_read(readb, "b", unsigned char, "=q", :"memory")
build_mmio_read(readw, "w", unsigned short, "=r", :"memory")
build_mmio_read(readl, "l", unsigned int, "=r", :"memory")
    8e59:	8b 40 08             	mov    0x8(%rax),%eax
	udelay(hw->eeprom.delay_usec);
    8e5c:	0f b7 3e             	movzwl (%rsi),%edi
    8e5f:	e8 00 00 00 00       	callq  8e64 <e1000_raise_ee_clk.isra.6+0x24>
}
    8e64:	5d                   	pop    %rbp
    8e65:	c3                   	retq   
    8e66:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    8e6d:	00 00 00 

0000000000008e70 <e1000_lower_ee_clk.isra.7>:
/**
 * e1000_lower_ee_clk - Lowers the EEPROM's clock input.
 * @hw: Struct containing variables accessed by shared code
 * @eecd: EECD's current value
 */
static void e1000_lower_ee_clk(struct e1000_hw *hw, u32 *eecd)
    8e70:	e8 00 00 00 00       	callq  8e75 <e1000_lower_ee_clk.isra.7+0x5>
    8e75:	55                   	push   %rbp
{
	/* Lower the clock input to the EEPROM (by clearing the SK bit), and
	 * then wait 50 microseconds.
	 */
	*eecd = *eecd & ~E1000_EECD_SK;
    8e76:	8b 02                	mov    (%rdx),%eax
/**
 * e1000_lower_ee_clk - Lowers the EEPROM's clock input.
 * @hw: Struct containing variables accessed by shared code
 * @eecd: EECD's current value
 */
static void e1000_lower_ee_clk(struct e1000_hw *hw, u32 *eecd)
    8e78:	48 89 e5             	mov    %rsp,%rbp
{
	/* Lower the clock input to the EEPROM (by clearing the SK bit), and
	 * then wait 50 microseconds.
	 */
	*eecd = *eecd & ~E1000_EECD_SK;
    8e7b:	83 e0 fe             	and    $0xfffffffe,%eax
    8e7e:	89 02                	mov    %eax,(%rdx)
	ew32(EECD, *eecd);
    8e80:	48 8b 17             	mov    (%rdi),%rdx
build_mmio_read(__readw, "w", unsigned short, "=r", )
build_mmio_read(__readl, "l", unsigned int, "=r", )

build_mmio_write(writeb, "b", unsigned char, "q", :"memory")
build_mmio_write(writew, "w", unsigned short, "r", :"memory")
build_mmio_write(writel, "l", unsigned int, "r", :"memory")
    8e83:	89 42 10             	mov    %eax,0x10(%rdx)
	E1000_WRITE_FLUSH();
    8e86:	48 8b 07             	mov    (%rdi),%rax
{ asm volatile("mov" size " %0,%1": :reg (val), \
"m" (*(volatile type __force *)addr) barrier); }

build_mmio_read(readb, "b", unsigned char, "=q", :"memory")
build_mmio_read(readw, "w", unsigned short, "=r", :"memory")
build_mmio_read(readl, "l", unsigned int, "=r", :"memory")
    8e89:	8b 40 08             	mov    0x8(%rax),%eax
	udelay(hw->eeprom.delay_usec);
    8e8c:	0f b7 3e             	movzwl (%rsi),%edi
    8e8f:	e8 00 00 00 00       	callq  8e94 <e1000_lower_ee_clk.isra.7+0x24>
}
    8e94:	5d                   	pop    %rbp
    8e95:	c3                   	retq   
    8e96:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    8e9d:	00 00 00 

0000000000008ea0 <e1000_shift_out_ee_bits>:
 * @hw: Struct containing variables accessed by shared code
 * @data: data to send to the EEPROM
 * @count: number of bits to shift out
 */
static void e1000_shift_out_ee_bits(struct e1000_hw *hw, u16 data, u16 count)
{
    8ea0:	e8 00 00 00 00       	callq  8ea5 <e1000_shift_out_ee_bits+0x5>
    8ea5:	55                   	push   %rbp

	/* We need to shift "count" bits out to the EEPROM. So, value in the
	 * "data" parameter will be shifted out to the EEPROM one bit at a time.
	 * In order to do this, "data" must be broken down into bits.
	 */
	mask = 0x01 << (count - 1);
    8ea6:	8d 4a ff             	lea    -0x1(%rdx),%ecx
 * @hw: Struct containing variables accessed by shared code
 * @data: data to send to the EEPROM
 * @count: number of bits to shift out
 */
static void e1000_shift_out_ee_bits(struct e1000_hw *hw, u16 data, u16 count)
{
    8ea9:	48 89 e5             	mov    %rsp,%rbp
    8eac:	41 56                	push   %r14
    8eae:	41 55                	push   %r13
    8eb0:	41 54                	push   %r12

	/* We need to shift "count" bits out to the EEPROM. So, value in the
	 * "data" parameter will be shifted out to the EEPROM one bit at a time.
	 * In order to do this, "data" must be broken down into bits.
	 */
	mask = 0x01 << (count - 1);
    8eb2:	41 bc 01 00 00 00    	mov    $0x1,%r12d
    8eb8:	41 d3 e4             	shl    %cl,%r12d
 * @hw: Struct containing variables accessed by shared code
 * @data: data to send to the EEPROM
 * @count: number of bits to shift out
 */
static void e1000_shift_out_ee_bits(struct e1000_hw *hw, u16 data, u16 count)
{
    8ebb:	53                   	push   %rbx
    8ebc:	48 89 fb             	mov    %rdi,%rbx
    8ebf:	48 83 ec 08          	sub    $0x8,%rsp
	/* We need to shift "count" bits out to the EEPROM. So, value in the
	 * "data" parameter will be shifted out to the EEPROM one bit at a time.
	 * In order to do this, "data" must be broken down into bits.
	 */
	mask = 0x01 << (count - 1);
	eecd = er32(EECD);
    8ec3:	48 8b 07             	mov    (%rdi),%rax
    8ec6:	8b 40 10             	mov    0x10(%rax),%eax
	if (eeprom->type == e1000_eeprom_microwire) {
    8ec9:	8b 57 50             	mov    0x50(%rdi),%edx
	/* We need to shift "count" bits out to the EEPROM. So, value in the
	 * "data" parameter will be shifted out to the EEPROM one bit at a time.
	 * In order to do this, "data" must be broken down into bits.
	 */
	mask = 0x01 << (count - 1);
	eecd = er32(EECD);
    8ecc:	89 45 dc             	mov    %eax,-0x24(%rbp)
	if (eeprom->type == e1000_eeprom_microwire) {
    8ecf:	83 fa 02             	cmp    $0x2,%edx
    8ed2:	74 75                	je     8f49 <e1000_shift_out_ee_bits+0xa9>
		eecd &= ~E1000_EECD_DO;
	} else if (eeprom->type == e1000_eeprom_spi) {
		eecd |= E1000_EECD_DO;
    8ed4:	89 c1                	mov    %eax,%ecx
    8ed6:	83 c9 08             	or     $0x8,%ecx
    8ed9:	83 fa 01             	cmp    $0x1,%edx
    8edc:	0f 44 c1             	cmove  %ecx,%eax
    8edf:	4c 8d 6b 5a          	lea    0x5a(%rbx),%r13
    8ee3:	44 0f b7 f6          	movzwl %si,%r14d
		 * "1", and then raising and then lowering the clock (the SK bit
		 * controls the clock input to the EEPROM).  A "0" is shifted
		 * out to the EEPROM by setting "DI" to "0" and then raising and
		 * then lowering the clock.
		 */
		eecd &= ~E1000_EECD_DI;
    8ee7:	83 e0 fb             	and    $0xfffffffb,%eax

		if (data & mask)
    8eea:	45 85 f4             	test   %r14d,%r12d
    8eed:	74 03                	je     8ef2 <e1000_shift_out_ee_bits+0x52>
			eecd |= E1000_EECD_DI;
    8eef:	83 c8 04             	or     $0x4,%eax
    8ef2:	89 45 dc             	mov    %eax,-0x24(%rbp)

		ew32(EECD, eecd);
    8ef5:	48 8b 13             	mov    (%rbx),%rdx
build_mmio_read(__readw, "w", unsigned short, "=r", )
build_mmio_read(__readl, "l", unsigned int, "=r", )

build_mmio_write(writeb, "b", unsigned char, "q", :"memory")
build_mmio_write(writew, "w", unsigned short, "r", :"memory")
build_mmio_write(writel, "l", unsigned int, "r", :"memory")
    8ef8:	89 42 10             	mov    %eax,0x10(%rdx)
		E1000_WRITE_FLUSH();
    8efb:	48 8b 03             	mov    (%rbx),%rax
{ asm volatile("mov" size " %0,%1": :reg (val), \
"m" (*(volatile type __force *)addr) barrier); }

build_mmio_read(readb, "b", unsigned char, "=q", :"memory")
build_mmio_read(readw, "w", unsigned short, "=r", :"memory")
build_mmio_read(readl, "l", unsigned int, "=r", :"memory")
    8efe:	8b 40 08             	mov    0x8(%rax),%eax

		udelay(eeprom->delay_usec);
    8f01:	0f b7 7b 5a          	movzwl 0x5a(%rbx),%edi
    8f05:	e8 00 00 00 00       	callq  8f0a <e1000_shift_out_ee_bits+0x6a>

		e1000_raise_ee_clk(hw, &eecd);
    8f0a:	48 8d 55 dc          	lea    -0x24(%rbp),%rdx
    8f0e:	4c 89 ee             	mov    %r13,%rsi
    8f11:	48 89 df             	mov    %rbx,%rdi
    8f14:	e8 27 ff ff ff       	callq  8e40 <e1000_raise_ee_clk.isra.6>
		e1000_lower_ee_clk(hw, &eecd);
    8f19:	48 8d 55 dc          	lea    -0x24(%rbp),%rdx
    8f1d:	4c 89 ee             	mov    %r13,%rsi
    8f20:	48 89 df             	mov    %rbx,%rdi
    8f23:	e8 48 ff ff ff       	callq  8e70 <e1000_lower_ee_clk.isra.7>

		mask = mask >> 1;

	} while (mask);
    8f28:	41 d1 ec             	shr    %r12d
    8f2b:	8b 45 dc             	mov    -0x24(%rbp),%eax
    8f2e:	75 b7                	jne    8ee7 <e1000_shift_out_ee_bits+0x47>

	/* We leave the "DI" bit set to "0" when we leave this routine. */
	eecd &= ~E1000_EECD_DI;
    8f30:	83 e0 fb             	and    $0xfffffffb,%eax
	ew32(EECD, eecd);
    8f33:	48 8b 13             	mov    (%rbx),%rdx
		mask = mask >> 1;

	} while (mask);

	/* We leave the "DI" bit set to "0" when we leave this routine. */
	eecd &= ~E1000_EECD_DI;
    8f36:	89 45 dc             	mov    %eax,-0x24(%rbp)
build_mmio_read(__readw, "w", unsigned short, "=r", )
build_mmio_read(__readl, "l", unsigned int, "=r", )

build_mmio_write(writeb, "b", unsigned char, "q", :"memory")
build_mmio_write(writew, "w", unsigned short, "r", :"memory")
build_mmio_write(writel, "l", unsigned int, "r", :"memory")
    8f39:	89 42 10             	mov    %eax,0x10(%rdx)
	ew32(EECD, eecd);
}
    8f3c:	48 83 c4 08          	add    $0x8,%rsp
    8f40:	5b                   	pop    %rbx
    8f41:	41 5c                	pop    %r12
    8f43:	41 5d                	pop    %r13
    8f45:	41 5e                	pop    %r14
    8f47:	5d                   	pop    %rbp
    8f48:	c3                   	retq   
    8f49:	83 e0 f7             	and    $0xfffffff7,%eax
    8f4c:	eb 91                	jmp    8edf <e1000_shift_out_ee_bits+0x3f>
    8f4e:	66 90                	xchg   %ax,%ax

0000000000008f50 <e1000_shift_in_ee_bits>:
 * e1000_shift_in_ee_bits - Shift data bits in from the EEPROM
 * @hw: Struct containing variables accessed by shared code
 * @count: number of bits to shift in
 */
static u16 e1000_shift_in_ee_bits(struct e1000_hw *hw, u16 count)
{
    8f50:	e8 00 00 00 00       	callq  8f55 <e1000_shift_in_ee_bits+0x5>
    8f55:	55                   	push   %rbp
    8f56:	48 89 e5             	mov    %rsp,%rbp
    8f59:	41 57                	push   %r15
    8f5b:	41 56                	push   %r14
    8f5d:	41 55                	push   %r13
    8f5f:	41 54                	push   %r12
    8f61:	49 89 fc             	mov    %rdi,%r12
    8f64:	53                   	push   %rbx
    8f65:	48 83 ec 08          	sub    $0x8,%rsp
	 * input to the EEPROM (setting the SK bit), and then reading the value
	 * of the "DO" bit.  During this "shifting in" process the "DI" bit
	 * should always be clear.
	 */

	eecd = er32(EECD);
    8f69:	48 8b 07             	mov    (%rdi),%rax
{ asm volatile("mov" size " %0,%1": :reg (val), \
"m" (*(volatile type __force *)addr) barrier); }

build_mmio_read(readb, "b", unsigned char, "=q", :"memory")
build_mmio_read(readw, "w", unsigned short, "=r", :"memory")
build_mmio_read(readl, "l", unsigned int, "=r", :"memory")
    8f6c:	8b 40 10             	mov    0x10(%rax),%eax

	eecd &= ~(E1000_EECD_DO | E1000_EECD_DI);
	data = 0;

	for (i = 0; i < count; i++) {
    8f6f:	44 0f b7 fe          	movzwl %si,%r15d
	 * should always be clear.
	 */

	eecd = er32(EECD);

	eecd &= ~(E1000_EECD_DO | E1000_EECD_DI);
    8f73:	83 e0 f3             	and    $0xfffffff3,%eax
	data = 0;

	for (i = 0; i < count; i++) {
    8f76:	45 85 ff             	test   %r15d,%r15d
	 * should always be clear.
	 */

	eecd = er32(EECD);

	eecd &= ~(E1000_EECD_DO | E1000_EECD_DI);
    8f79:	89 45 d4             	mov    %eax,-0x2c(%rbp)
	data = 0;

	for (i = 0; i < count; i++) {
    8f7c:	74 5c                	je     8fda <e1000_shift_in_ee_bits+0x8a>
    8f7e:	4c 8d 77 5a          	lea    0x5a(%rdi),%r14
	 */

	eecd = er32(EECD);

	eecd &= ~(E1000_EECD_DO | E1000_EECD_DI);
	data = 0;
    8f82:	31 db                	xor    %ebx,%ebx

	for (i = 0; i < count; i++) {
    8f84:	45 31 ed             	xor    %r13d,%r13d
		data = data << 1;
		e1000_raise_ee_clk(hw, &eecd);
    8f87:	48 8d 55 d4          	lea    -0x2c(%rbp),%rdx
    8f8b:	4c 89 f6             	mov    %r14,%rsi
    8f8e:	4c 89 e7             	mov    %r12,%rdi

	eecd &= ~(E1000_EECD_DO | E1000_EECD_DI);
	data = 0;

	for (i = 0; i < count; i++) {
		data = data << 1;
    8f91:	01 db                	add    %ebx,%ebx
		e1000_raise_ee_clk(hw, &eecd);
    8f93:	e8 a8 fe ff ff       	callq  8e40 <e1000_raise_ee_clk.isra.6>

		eecd = er32(EECD);
    8f98:	49 8b 04 24          	mov    (%r12),%rax
    8f9c:	8b 40 10             	mov    0x10(%rax),%eax

		eecd &= ~(E1000_EECD_DI);
    8f9f:	89 c2                	mov    %eax,%edx
		if (eecd & E1000_EECD_DO)
			data |= 1;

		e1000_lower_ee_clk(hw, &eecd);
    8fa1:	4c 89 f6             	mov    %r14,%rsi
    8fa4:	4c 89 e7             	mov    %r12,%rdi
		data = data << 1;
		e1000_raise_ee_clk(hw, &eecd);

		eecd = er32(EECD);

		eecd &= ~(E1000_EECD_DI);
    8fa7:	83 e2 fb             	and    $0xfffffffb,%edx
    8faa:	89 55 d4             	mov    %edx,-0x2c(%rbp)
		if (eecd & E1000_EECD_DO)
			data |= 1;
    8fad:	89 da                	mov    %ebx,%edx
    8faf:	83 ca 01             	or     $0x1,%edx
    8fb2:	a8 08                	test   $0x8,%al
    8fb4:	0f 45 da             	cmovne %edx,%ebx

		e1000_lower_ee_clk(hw, &eecd);
    8fb7:	48 8d 55 d4          	lea    -0x2c(%rbp),%rdx
	eecd = er32(EECD);

	eecd &= ~(E1000_EECD_DO | E1000_EECD_DI);
	data = 0;

	for (i = 0; i < count; i++) {
    8fbb:	41 83 c5 01          	add    $0x1,%r13d

		eecd &= ~(E1000_EECD_DI);
		if (eecd & E1000_EECD_DO)
			data |= 1;

		e1000_lower_ee_clk(hw, &eecd);
    8fbf:	e8 ac fe ff ff       	callq  8e70 <e1000_lower_ee_clk.isra.7>
	eecd = er32(EECD);

	eecd &= ~(E1000_EECD_DO | E1000_EECD_DI);
	data = 0;

	for (i = 0; i < count; i++) {
    8fc4:	45 39 fd             	cmp    %r15d,%r13d
    8fc7:	72 be                	jb     8f87 <e1000_shift_in_ee_bits+0x37>

		e1000_lower_ee_clk(hw, &eecd);
	}

	return data;
}
    8fc9:	48 83 c4 08          	add    $0x8,%rsp
    8fcd:	89 d8                	mov    %ebx,%eax
    8fcf:	5b                   	pop    %rbx
    8fd0:	41 5c                	pop    %r12
    8fd2:	41 5d                	pop    %r13
    8fd4:	41 5e                	pop    %r14
    8fd6:	41 5f                	pop    %r15
    8fd8:	5d                   	pop    %rbp
    8fd9:	c3                   	retq   
	 */

	eecd = er32(EECD);

	eecd &= ~(E1000_EECD_DO | E1000_EECD_DI);
	data = 0;
    8fda:	31 db                	xor    %ebx,%ebx
    8fdc:	eb eb                	jmp    8fc9 <e1000_shift_in_ee_bits+0x79>
    8fde:	66 90                	xchg   %ax,%ax

0000000000008fe0 <e1000_spi_eeprom_ready>:
/**
 * e1000_spi_eeprom_ready - Reads a 16 bit word from the EEPROM.
 * @hw: Struct containing variables accessed by shared code
 */
static s32 e1000_spi_eeprom_ready(struct e1000_hw *hw)
{
    8fe0:	e8 00 00 00 00       	callq  8fe5 <e1000_spi_eeprom_ready+0x5>
    8fe5:	55                   	push   %rbp
    8fe6:	48 89 e5             	mov    %rsp,%rbp
    8fe9:	41 54                	push   %r12
    8feb:	41 bc e8 03 00 00    	mov    $0x3e8,%r12d
    8ff1:	53                   	push   %rbx
    8ff2:	48 89 fb             	mov    %rdi,%rbx
    8ff5:	eb 19                	jmp    9010 <e1000_spi_eeprom_ready+0x30>
					hw->eeprom.opcode_bits);
		spi_stat_reg = (u8) e1000_shift_in_ee_bits(hw, 8);
		if (!(spi_stat_reg & EEPROM_STATUS_RDY_SPI))
			break;

		udelay(5);
    8ff7:	bf e3 53 00 00       	mov    $0x53e3,%edi
    8ffc:	e8 00 00 00 00       	callq  9001 <e1000_spi_eeprom_ready+0x21>
		retry_count += 5;

		e1000_standby_eeprom(hw);
    9001:	48 89 df             	mov    %rbx,%rdi
    9004:	e8 e7 fc ff ff       	callq  8cf0 <e1000_standby_eeprom>
	} while (retry_count < EEPROM_MAX_RETRY_SPI);
    9009:	66 41 83 ec 01       	sub    $0x1,%r12w
    900e:	74 29                	je     9039 <e1000_spi_eeprom_ready+0x59>
	 * bit 0 of the internal status register.  If it's not cleared within
	 * 5 milliseconds, then error out.
	 */
	retry_count = 0;
	do {
		e1000_shift_out_ee_bits(hw, EEPROM_RDSR_OPCODE_SPI,
    9010:	0f b7 53 56          	movzwl 0x56(%rbx),%edx
    9014:	be 05 00 00 00       	mov    $0x5,%esi
    9019:	48 89 df             	mov    %rbx,%rdi
    901c:	e8 7f fe ff ff       	callq  8ea0 <e1000_shift_out_ee_bits>
					hw->eeprom.opcode_bits);
		spi_stat_reg = (u8) e1000_shift_in_ee_bits(hw, 8);
    9021:	be 08 00 00 00       	mov    $0x8,%esi
    9026:	48 89 df             	mov    %rbx,%rdi
    9029:	e8 22 ff ff ff       	callq  8f50 <e1000_shift_in_ee_bits>
		if (!(spi_stat_reg & EEPROM_STATUS_RDY_SPI))
    902e:	a8 01                	test   $0x1,%al
    9030:	75 c5                	jne    8ff7 <e1000_spi_eeprom_ready+0x17>
	if (retry_count >= EEPROM_MAX_RETRY_SPI) {
		e_dbg("SPI EEPROM Status error\n");
		return -E1000_ERR_EEPROM;
	}

	return E1000_SUCCESS;
    9032:	31 c0                	xor    %eax,%eax
}
    9034:	5b                   	pop    %rbx
    9035:	41 5c                	pop    %r12
    9037:	5d                   	pop    %rbp
    9038:	c3                   	retq   

	/* ATMEL SPI write time could vary from 0-20mSec on 3.3V devices (and
	 * only 0-5mSec on 5V devices)
	 */
	if (retry_count >= EEPROM_MAX_RETRY_SPI) {
		e_dbg("SPI EEPROM Status error\n");
    9039:	f6 05 00 00 00 00 04 	testb  $0x4,0x0(%rip)        # 9040 <e1000_spi_eeprom_ready+0x60>
    9040:	75 0a                	jne    904c <e1000_spi_eeprom_ready+0x6c>
		return -E1000_ERR_EEPROM;
	}

	return E1000_SUCCESS;
}
    9042:	5b                   	pop    %rbx
    9043:	41 5c                	pop    %r12
	/* ATMEL SPI write time could vary from 0-20mSec on 3.3V devices (and
	 * only 0-5mSec on 5V devices)
	 */
	if (retry_count >= EEPROM_MAX_RETRY_SPI) {
		e_dbg("SPI EEPROM Status error\n");
		return -E1000_ERR_EEPROM;
    9045:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
	}

	return E1000_SUCCESS;
}
    904a:	5d                   	pop    %rbp
    904b:	c3                   	retq   

	/* ATMEL SPI write time could vary from 0-20mSec on 3.3V devices (and
	 * only 0-5mSec on 5V devices)
	 */
	if (retry_count >= EEPROM_MAX_RETRY_SPI) {
		e_dbg("SPI EEPROM Status error\n");
    904c:	48 89 df             	mov    %rbx,%rdi
    904f:	e8 00 00 00 00       	callq  9054 <e1000_spi_eeprom_ready+0x74>
    9054:	48 c7 c2 00 00 00 00 	mov    $0x0,%rdx
    905b:	48 89 c6             	mov    %rax,%rsi
    905e:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
    9065:	31 c0                	xor    %eax,%eax
    9067:	e8 00 00 00 00       	callq  906c <e1000_spi_eeprom_ready+0x8c>
    906c:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
    9071:	eb c1                	jmp    9034 <e1000_spi_eeprom_ready+0x54>
    9073:	66 66 66 66 2e 0f 1f 	data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
    907a:	84 00 00 00 00 00 

0000000000009080 <e1000_set_mac_type>:
/**
 * e1000_set_mac_type - Set the mac type member in the hw struct.
 * @hw: Struct containing variables accessed by shared code
 */
s32 e1000_set_mac_type(struct e1000_hw *hw)
{
    9080:	e8 00 00 00 00       	callq  9085 <e1000_set_mac_type+0x5>
    9085:	55                   	push   %rbp
	switch (hw->device_id) {
    9086:	0f b7 87 e6 00 00 00 	movzwl 0xe6(%rdi),%eax
/**
 * e1000_set_mac_type - Set the mac type member in the hw struct.
 * @hw: Struct containing variables accessed by shared code
 */
s32 e1000_set_mac_type(struct e1000_hw *hw)
{
    908d:	48 89 e5             	mov    %rsp,%rbp
	switch (hw->device_id) {
    9090:	66 3d 18 10          	cmp    $0x1018,%ax
    9094:	0f 84 37 01 00 00    	je     91d1 <e1000_set_mac_type+0x151>
    909a:	76 46                	jbe    90e2 <e1000_set_mac_type+0x62>
    909c:	66 3d 78 10          	cmp    $0x1078,%ax
    90a0:	0f 87 9c 00 00 00    	ja     9142 <e1000_set_mac_type+0xc2>
    90a6:	66 3d 76 10          	cmp    $0x1076,%ax
    90aa:	0f 83 3f 01 00 00    	jae    91ef <e1000_set_mac_type+0x16f>
    90b0:	66 3d 1e 10          	cmp    $0x101e,%ax
    90b4:	0f 84 20 01 00 00    	je     91da <e1000_set_mac_type+0x15a>
    90ba:	0f 86 b4 00 00 00    	jbe    9174 <e1000_set_mac_type+0xf4>
    90c0:	66 3d 26 10          	cmp    $0x1026,%ax
    90c4:	0f 82 eb 00 00 00    	jb     91b5 <e1000_set_mac_type+0x135>
    90ca:	66 3d 28 10          	cmp    $0x1028,%ax
    90ce:	66 90                	xchg   %ax,%ax
    90d0:	0f 87 e6 00 00 00    	ja     91bc <e1000_set_mac_type+0x13c>
		hw->mac_type = e1000_82545;
		break;
	case E1000_DEV_ID_82545GM_COPPER:
	case E1000_DEV_ID_82545GM_FIBER:
	case E1000_DEV_ID_82545GM_SERDES:
		hw->mac_type = e1000_82545_rev_3;
    90d6:	c7 47 18 07 00 00 00 	movl   $0x7,0x18(%rdi)
		break;
    90dd:	e9 87 00 00 00       	jmpq   9169 <e1000_set_mac_type+0xe9>
 * e1000_set_mac_type - Set the mac type member in the hw struct.
 * @hw: Struct containing variables accessed by shared code
 */
s32 e1000_set_mac_type(struct e1000_hw *hw)
{
	switch (hw->device_id) {
    90e2:	66 3d 0e 10          	cmp    $0x100e,%ax
    90e6:	0f 84 ee 00 00 00    	je     91da <e1000_set_mac_type+0x15a>
    90ec:	0f 87 9c 00 00 00    	ja     918e <e1000_set_mac_type+0x10e>
    90f2:	66 3d 09 10          	cmp    $0x1009,%ax
    90f6:	0f 87 1a 01 00 00    	ja     9216 <e1000_set_mac_type+0x196>
    90fc:	66 3d 08 10          	cmp    $0x1008,%ax
    9100:	0f 83 16 01 00 00    	jae    921c <e1000_set_mac_type+0x19c>
    9106:	66 3d 01 10          	cmp    $0x1001,%ax
    910a:	0f 84 f4 00 00 00    	je     9204 <e1000_set_mac_type+0x184>
    9110:	66 3d 04 10          	cmp    $0x1004,%ax
    9114:	0f 84 ea 00 00 00    	je     9204 <e1000_set_mac_type+0x184>
    911a:	66 3d 00 10          	cmp    $0x1000,%ax
    911e:	0f 85 91 00 00 00    	jne    91b5 <e1000_set_mac_type+0x135>
	case E1000_DEV_ID_82542:
		switch (hw->revision_id) {
    9124:	0f b6 87 ee 00 00 00 	movzbl 0xee(%rdi),%eax
    912b:	3c 02                	cmp    $0x2,%al
    912d:	0f 84 09 01 00 00    	je     923c <e1000_set_mac_type+0x1bc>
    9133:	3c 03                	cmp    $0x3,%al
    9135:	75 7e                	jne    91b5 <e1000_set_mac_type+0x135>
		case E1000_82542_2_0_REV_ID:
			hw->mac_type = e1000_82542_rev2_0;
			break;
		case E1000_82542_2_1_REV_ID:
			hw->mac_type = e1000_82542_rev2_1;
    9137:	c7 47 18 02 00 00 00 	movl   $0x2,0x18(%rdi)
		hw->bad_tx_carr_stats_fd = true;

	if (hw->mac_type > e1000_82544)
		hw->has_smbus = true;

	return E1000_SUCCESS;
    913e:	31 c0                	xor    %eax,%eax
}
    9140:	5d                   	pop    %rbp
    9141:	c3                   	retq   
 * e1000_set_mac_type - Set the mac type member in the hw struct.
 * @hw: Struct containing variables accessed by shared code
 */
s32 e1000_set_mac_type(struct e1000_hw *hw)
{
	switch (hw->device_id) {
    9142:	66 3d 8a 10          	cmp    $0x108a,%ax
    9146:	0f 84 ac 00 00 00    	je     91f8 <e1000_set_mac_type+0x178>
    914c:	0f 86 91 00 00 00    	jbe    91e3 <e1000_set_mac_type+0x163>
    9152:	66 3d b5 10          	cmp    $0x10b5,%ax
    9156:	0f 84 9c 00 00 00    	je     91f8 <e1000_set_mac_type+0x178>
    915c:	66 3d 6e 2e          	cmp    $0x2e6e,%ax
    9160:	75 4d                	jne    91af <e1000_set_mac_type+0x12f>
		break;
	case E1000_DEV_ID_82547GI:
		hw->mac_type = e1000_82547_rev_2;
		break;
	case E1000_DEV_ID_INTEL_CE4100_GBE:
		hw->mac_type = e1000_ce4100;
    9162:	c7 47 18 09 00 00 00 	movl   $0x9,0x18(%rdi)
	 */
	if (hw->mac_type == e1000_82543)
		hw->bad_tx_carr_stats_fd = true;

	if (hw->mac_type > e1000_82544)
		hw->has_smbus = true;
    9169:	c6 87 1c 01 00 00 01 	movb   $0x1,0x11c(%rdi)

	return E1000_SUCCESS;
    9170:	31 c0                	xor    %eax,%eax
}
    9172:	5d                   	pop    %rbp
    9173:	c3                   	retq   
 * e1000_set_mac_type - Set the mac type member in the hw struct.
 * @hw: Struct containing variables accessed by shared code
 */
s32 e1000_set_mac_type(struct e1000_hw *hw)
{
	switch (hw->device_id) {
    9174:	66 3d 1a 10          	cmp    $0x101a,%ax
    9178:	0f 87 ac 00 00 00    	ja     922a <e1000_set_mac_type+0x1aa>
	case E1000_DEV_ID_82541GI_MOBILE:
		hw->mac_type = e1000_82541_rev_2;
		break;
	case E1000_DEV_ID_82547EI:
	case E1000_DEV_ID_82547EI_MOBILE:
		hw->mac_type = e1000_82547;
    917e:	c7 47 18 0d 00 00 00 	movl   $0xd,0x18(%rdi)
	switch (hw->mac_type) {
	case e1000_82541:
	case e1000_82547:
	case e1000_82541_rev_2:
	case e1000_82547_rev_2:
		hw->asf_firmware_present = true;
    9185:	c7 47 6c 01 00 00 00 	movl   $0x1,0x6c(%rdi)
    918c:	eb db                	jmp    9169 <e1000_set_mac_type+0xe9>
 * e1000_set_mac_type - Set the mac type member in the hw struct.
 * @hw: Struct containing variables accessed by shared code
 */
s32 e1000_set_mac_type(struct e1000_hw *hw)
{
	switch (hw->device_id) {
    918e:	66 3d 12 10          	cmp    $0x1012,%ax
    9192:	0f 84 98 00 00 00    	je     9230 <e1000_set_mac_type+0x1b0>
    9198:	77 31                	ja     91cb <e1000_set_mac_type+0x14b>
    919a:	66 3d 10 10          	cmp    $0x1010,%ax
    919e:	66 90                	xchg   %ax,%ax
    91a0:	0f 84 8a 00 00 00    	je     9230 <e1000_set_mac_type+0x1b0>
	case E1000_DEV_ID_82540EP_LP:
		hw->mac_type = e1000_82540;
		break;
	case E1000_DEV_ID_82545EM_COPPER:
	case E1000_DEV_ID_82545EM_FIBER:
		hw->mac_type = e1000_82545;
    91a6:	c7 47 18 06 00 00 00 	movl   $0x6,0x18(%rdi)
		break;
    91ad:	eb ba                	jmp    9169 <e1000_set_mac_type+0xe9>
 * e1000_set_mac_type - Set the mac type member in the hw struct.
 * @hw: Struct containing variables accessed by shared code
 */
s32 e1000_set_mac_type(struct e1000_hw *hw)
{
	switch (hw->device_id) {
    91af:	66 3d 99 10          	cmp    $0x1099,%ax
    91b3:	74 43                	je     91f8 <e1000_set_mac_type+0x178>
		case E1000_82542_2_1_REV_ID:
			hw->mac_type = e1000_82542_rev2_1;
			break;
		default:
			/* Invalid 82542 revision ID */
			return -E1000_ERR_MAC_TYPE;
    91b5:	b8 fb ff ff ff       	mov    $0xfffffffb,%eax

	if (hw->mac_type > e1000_82544)
		hw->has_smbus = true;

	return E1000_SUCCESS;
}
    91ba:	5d                   	pop    %rbp
    91bb:	c3                   	retq   
 * e1000_set_mac_type - Set the mac type member in the hw struct.
 * @hw: Struct containing variables accessed by shared code
 */
s32 e1000_set_mac_type(struct e1000_hw *hw)
{
	switch (hw->device_id) {
    91bc:	66 3d 75 10          	cmp    $0x1075,%ax
    91c0:	75 f3                	jne    91b5 <e1000_set_mac_type+0x135>
	case E1000_DEV_ID_82547EI:
	case E1000_DEV_ID_82547EI_MOBILE:
		hw->mac_type = e1000_82547;
		break;
	case E1000_DEV_ID_82547GI:
		hw->mac_type = e1000_82547_rev_2;
    91c2:	c7 47 18 0e 00 00 00 	movl   $0xe,0x18(%rdi)
		break;
    91c9:	eb ba                	jmp    9185 <e1000_set_mac_type+0x105>
 * e1000_set_mac_type - Set the mac type member in the hw struct.
 * @hw: Struct containing variables accessed by shared code
 */
s32 e1000_set_mac_type(struct e1000_hw *hw)
{
	switch (hw->device_id) {
    91cb:	66 3d 14 10          	cmp    $0x1014,%ax
    91cf:	77 09                	ja     91da <e1000_set_mac_type+0x15a>
		hw->mac_type = e1000_82546_rev_3;
		break;
	case E1000_DEV_ID_82541EI:
	case E1000_DEV_ID_82541EI_MOBILE:
	case E1000_DEV_ID_82541ER_LOM:
		hw->mac_type = e1000_82541;
    91d1:	c7 47 18 0b 00 00 00 	movl   $0xb,0x18(%rdi)
		break;
    91d8:	eb ab                	jmp    9185 <e1000_set_mac_type+0x105>
	case E1000_DEV_ID_82540EM:
	case E1000_DEV_ID_82540EM_LOM:
	case E1000_DEV_ID_82540EP:
	case E1000_DEV_ID_82540EP_LOM:
	case E1000_DEV_ID_82540EP_LP:
		hw->mac_type = e1000_82540;
    91da:	c7 47 18 05 00 00 00 	movl   $0x5,0x18(%rdi)
		break;
    91e1:	eb 86                	jmp    9169 <e1000_set_mac_type+0xe9>
 * e1000_set_mac_type - Set the mac type member in the hw struct.
 * @hw: Struct containing variables accessed by shared code
 */
s32 e1000_set_mac_type(struct e1000_hw *hw)
{
	switch (hw->device_id) {
    91e3:	66 3d 7b 10          	cmp    $0x107b,%ax
    91e7:	76 0f                	jbe    91f8 <e1000_set_mac_type+0x178>
    91e9:	66 3d 7c 10          	cmp    $0x107c,%ax
    91ed:	75 c6                	jne    91b5 <e1000_set_mac_type+0x135>
		break;
	case E1000_DEV_ID_82541ER:
	case E1000_DEV_ID_82541GI:
	case E1000_DEV_ID_82541GI_LF:
	case E1000_DEV_ID_82541GI_MOBILE:
		hw->mac_type = e1000_82541_rev_2;
    91ef:	c7 47 18 0c 00 00 00 	movl   $0xc,0x18(%rdi)
		break;
    91f6:	eb 8d                	jmp    9185 <e1000_set_mac_type+0x105>
	case E1000_DEV_ID_82546GB_FIBER:
	case E1000_DEV_ID_82546GB_SERDES:
	case E1000_DEV_ID_82546GB_PCIE:
	case E1000_DEV_ID_82546GB_QUAD_COPPER:
	case E1000_DEV_ID_82546GB_QUAD_COPPER_KSP3:
		hw->mac_type = e1000_82546_rev_3;
    91f8:	c7 47 18 0a 00 00 00 	movl   $0xa,0x18(%rdi)
		break;
    91ff:	e9 65 ff ff ff       	jmpq   9169 <e1000_set_mac_type+0xe9>
			return -E1000_ERR_MAC_TYPE;
		}
		break;
	case E1000_DEV_ID_82543GC_FIBER:
	case E1000_DEV_ID_82543GC_COPPER:
		hw->mac_type = e1000_82543;
    9204:	c7 47 18 03 00 00 00 	movl   $0x3,0x18(%rdi)

	/* The 82543 chip does not count tx_carrier_errors properly in
	 * FD mode
	 */
	if (hw->mac_type == e1000_82543)
		hw->bad_tx_carr_stats_fd = true;
    920b:	c6 87 1b 01 00 00 01 	movb   $0x1,0x11b(%rdi)

	if (hw->mac_type > e1000_82544)
		hw->has_smbus = true;

	return E1000_SUCCESS;
    9212:	31 c0                	xor    %eax,%eax
}
    9214:	5d                   	pop    %rbp
    9215:	c3                   	retq   
 * e1000_set_mac_type - Set the mac type member in the hw struct.
 * @hw: Struct containing variables accessed by shared code
 */
s32 e1000_set_mac_type(struct e1000_hw *hw)
{
	switch (hw->device_id) {
    9216:	66 3d 0c 10          	cmp    $0x100c,%ax
    921a:	72 99                	jb     91b5 <e1000_set_mac_type+0x135>
		break;
	case E1000_DEV_ID_82544EI_COPPER:
	case E1000_DEV_ID_82544EI_FIBER:
	case E1000_DEV_ID_82544GC_COPPER:
	case E1000_DEV_ID_82544GC_LOM:
		hw->mac_type = e1000_82544;
    921c:	c7 47 18 04 00 00 00 	movl   $0x4,0x18(%rdi)
		hw->bad_tx_carr_stats_fd = true;

	if (hw->mac_type > e1000_82544)
		hw->has_smbus = true;

	return E1000_SUCCESS;
    9223:	31 c0                	xor    %eax,%eax
    9225:	e9 16 ff ff ff       	jmpq   9140 <e1000_set_mac_type+0xc0>
 * e1000_set_mac_type - Set the mac type member in the hw struct.
 * @hw: Struct containing variables accessed by shared code
 */
s32 e1000_set_mac_type(struct e1000_hw *hw)
{
	switch (hw->device_id) {
    922a:	66 3d 1d 10          	cmp    $0x101d,%ax
    922e:	75 85                	jne    91b5 <e1000_set_mac_type+0x135>
		hw->mac_type = e1000_82545_rev_3;
		break;
	case E1000_DEV_ID_82546EB_COPPER:
	case E1000_DEV_ID_82546EB_FIBER:
	case E1000_DEV_ID_82546EB_QUAD_COPPER:
		hw->mac_type = e1000_82546;
    9230:	c7 47 18 08 00 00 00 	movl   $0x8,0x18(%rdi)
		break;
    9237:	e9 2d ff ff ff       	jmpq   9169 <e1000_set_mac_type+0xe9>
{
	switch (hw->device_id) {
	case E1000_DEV_ID_82542:
		switch (hw->revision_id) {
		case E1000_82542_2_0_REV_ID:
			hw->mac_type = e1000_82542_rev2_0;
    923c:	c7 47 18 01 00 00 00 	movl   $0x1,0x18(%rdi)
		hw->bad_tx_carr_stats_fd = true;

	if (hw->mac_type > e1000_82544)
		hw->has_smbus = true;

	return E1000_SUCCESS;
    9243:	31 c0                	xor    %eax,%eax
    9245:	e9 f6 fe ff ff       	jmpq   9140 <e1000_set_mac_type+0xc0>
    924a:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)

0000000000009250 <e1000_set_media_type>:
/**
 * e1000_set_media_type - Set media type and TBI compatibility.
 * @hw: Struct containing variables accessed by shared code
 */
void e1000_set_media_type(struct e1000_hw *hw)
{
    9250:	e8 00 00 00 00       	callq  9255 <e1000_set_media_type+0x5>
    9255:	55                   	push   %rbp
	u32 status;

	if (hw->mac_type != e1000_82543) {
    9256:	8b 47 18             	mov    0x18(%rdi),%eax
/**
 * e1000_set_media_type - Set media type and TBI compatibility.
 * @hw: Struct containing variables accessed by shared code
 */
void e1000_set_media_type(struct e1000_hw *hw)
{
    9259:	48 89 e5             	mov    %rsp,%rbp
	u32 status;

	if (hw->mac_type != e1000_82543) {
    925c:	83 f8 03             	cmp    $0x3,%eax
    925f:	74 07                	je     9268 <e1000_set_media_type+0x18>
		/* tbi_compatibility is only valid on 82543 */
		hw->tbi_compatibility_en = false;
    9261:	c6 87 0e 01 00 00 00 	movb   $0x0,0x10e(%rdi)
	}

	switch (hw->device_id) {
    9268:	0f b7 97 e6 00 00 00 	movzwl 0xe6(%rdi),%edx
    926f:	66 81 fa 28 10       	cmp    $0x1028,%dx
    9274:	74 28                	je     929e <e1000_set_media_type+0x4e>
    9276:	66 81 fa 7b 10       	cmp    $0x107b,%dx
    927b:	74 21                	je     929e <e1000_set_media_type+0x4e>
	case E1000_DEV_ID_82545GM_SERDES:
	case E1000_DEV_ID_82546GB_SERDES:
		hw->media_type = e1000_media_type_internal_serdes;
		break;
	default:
		switch (hw->mac_type) {
    927d:	83 f8 01             	cmp    $0x1,%eax
    9280:	72 25                	jb     92a7 <e1000_set_media_type+0x57>
    9282:	83 f8 02             	cmp    $0x2,%eax
    9285:	76 0e                	jbe    9295 <e1000_set_media_type+0x45>
    9287:	83 f8 09             	cmp    $0x9,%eax
    928a:	75 1b                	jne    92a7 <e1000_set_media_type+0x57>
			if (status & E1000_STATUS_TBIMODE) {
				hw->media_type = e1000_media_type_fiber;
				/* tbi_compatibility not valid on fiber */
				hw->tbi_compatibility_en = false;
			} else {
				hw->media_type = e1000_media_type_copper;
    928c:	c7 47 24 00 00 00 00 	movl   $0x0,0x24(%rdi)
			}
			break;
		}
	}
}
    9293:	5d                   	pop    %rbp
    9294:	c3                   	retq   
		break;
	default:
		switch (hw->mac_type) {
		case e1000_82542_rev2_0:
		case e1000_82542_rev2_1:
			hw->media_type = e1000_media_type_fiber;
    9295:	c7 47 24 01 00 00 00 	movl   $0x1,0x24(%rdi)
				hw->media_type = e1000_media_type_copper;
			}
			break;
		}
	}
}
    929c:	5d                   	pop    %rbp
    929d:	c3                   	retq   
	}

	switch (hw->device_id) {
	case E1000_DEV_ID_82545GM_SERDES:
	case E1000_DEV_ID_82546GB_SERDES:
		hw->media_type = e1000_media_type_internal_serdes;
    929e:	c7 47 24 02 00 00 00 	movl   $0x2,0x24(%rdi)
				hw->media_type = e1000_media_type_copper;
			}
			break;
		}
	}
}
    92a5:	5d                   	pop    %rbp
    92a6:	c3                   	retq   
			break;
		case e1000_ce4100:
			hw->media_type = e1000_media_type_copper;
			break;
		default:
			status = er32(STATUS);
    92a7:	48 8b 07             	mov    (%rdi),%rax
    92aa:	8b 40 08             	mov    0x8(%rax),%eax
			if (status & E1000_STATUS_TBIMODE) {
    92ad:	a8 20                	test   $0x20,%al
    92af:	74 db                	je     928c <e1000_set_media_type+0x3c>
				hw->media_type = e1000_media_type_fiber;
    92b1:	c7 47 24 01 00 00 00 	movl   $0x1,0x24(%rdi)
				/* tbi_compatibility not valid on fiber */
				hw->tbi_compatibility_en = false;
    92b8:	c6 87 0e 01 00 00 00 	movb   $0x0,0x10e(%rdi)
				hw->media_type = e1000_media_type_copper;
			}
			break;
		}
	}
}
    92bf:	5d                   	pop    %rbp
    92c0:	c3                   	retq   
    92c1:	66 66 66 66 66 66 2e 	data32 data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
    92c8:	0f 1f 84 00 00 00 00 
    92cf:	00 

00000000000092d0 <e1000_config_collision_dist>:
 * Sets the collision distance in the Transmit Control register.
 * Link should have been established previously. Reads the speed and duplex
 * information from the Device Status register.
 */
void e1000_config_collision_dist(struct e1000_hw *hw)
{
    92d0:	e8 00 00 00 00       	callq  92d5 <e1000_config_collision_dist+0x5>
    92d5:	55                   	push   %rbp
	u32 tctl, coll_dist;

	if (hw->mac_type < e1000_82543)
    92d6:	83 7f 18 03          	cmpl   $0x3,0x18(%rdi)
		coll_dist = E1000_COLLISION_DISTANCE_82542;
	else
		coll_dist = E1000_COLLISION_DISTANCE;

	tctl = er32(TCTL);
    92da:	48 8b 07             	mov    (%rdi),%rax
 * Sets the collision distance in the Transmit Control register.
 * Link should have been established previously. Reads the speed and duplex
 * information from the Device Status register.
 */
void e1000_config_collision_dist(struct e1000_hw *hw)
{
    92dd:	48 89 e5             	mov    %rsp,%rbp
	u32 tctl, coll_dist;

	if (hw->mac_type < e1000_82543)
    92e0:	19 d2                	sbb    %edx,%edx
    92e2:	81 e2 00 10 00 00    	and    $0x1000,%edx
    92e8:	81 c2 00 f0 03 00    	add    $0x3f000,%edx
    92ee:	8b 80 00 04 00 00    	mov    0x400(%rax),%eax
	else
		coll_dist = E1000_COLLISION_DISTANCE;

	tctl = er32(TCTL);

	tctl &= ~E1000_TCTL_COLD;
    92f4:	25 ff 0f c0 ff       	and    $0xffc00fff,%eax
	tctl |= coll_dist << E1000_COLD_SHIFT;
    92f9:	09 d0                	or     %edx,%eax

	ew32(TCTL, tctl);
    92fb:	48 8b 17             	mov    (%rdi),%rdx
build_mmio_read(__readw, "w", unsigned short, "=r", )
build_mmio_read(__readl, "l", unsigned int, "=r", )

build_mmio_write(writeb, "b", unsigned char, "q", :"memory")
build_mmio_write(writew, "w", unsigned short, "r", :"memory")
build_mmio_write(writel, "l", unsigned int, "r", :"memory")
    92fe:	89 82 00 04 00 00    	mov    %eax,0x400(%rdx)
	E1000_WRITE_FLUSH();
    9304:	48 8b 07             	mov    (%rdi),%rax
{ asm volatile("mov" size " %0,%1": :reg (val), \
"m" (*(volatile type __force *)addr) barrier); }

build_mmio_read(readb, "b", unsigned char, "=q", :"memory")
build_mmio_read(readw, "w", unsigned short, "=r", :"memory")
build_mmio_read(readl, "l", unsigned int, "=r", :"memory")
    9307:	8b 40 08             	mov    0x8(%rax),%eax
}
    930a:	5d                   	pop    %rbp
    930b:	c3                   	retq   
    930c:	0f 1f 40 00          	nopl   0x0(%rax)

0000000000009310 <e1000_force_mac_fc>:
 * software when a Copper PHY is used because autonegotiation is managed
 * by the PHY rather than the MAC. Software must also configure these
 * bits when link is forced on a fiber connection.
 */
s32 e1000_force_mac_fc(struct e1000_hw *hw)
{
    9310:	e8 00 00 00 00       	callq  9315 <e1000_force_mac_fc+0x5>
	u32 ctrl;

	/* Get the current configuration of the Device Control Register */
	ctrl = er32(CTRL);
    9315:	48 8b 07             	mov    (%rdi),%rax
    9318:	8b 00                	mov    (%rax),%eax
	 *          frames but we do not receive pause frames).
	 *      3:  Both Rx and TX flow control (symmetric) is enabled.
	 *  other:  No other values should be possible at this point.
	 */

	switch (hw->fc) {
    931a:	8b 57 40             	mov    0x40(%rdi),%edx
    931d:	83 fa 01             	cmp    $0x1,%edx
    9320:	74 4e                	je     9370 <e1000_force_mac_fc+0x60>
    9322:	72 45                	jb     9369 <e1000_force_mac_fc+0x59>
    9324:	83 fa 02             	cmp    $0x2,%edx
    9327:	74 25                	je     934e <e1000_force_mac_fc+0x3e>
    9329:	83 fa 03             	cmp    $0x3,%edx
    932c:	0f 1f 40 00          	nopl   0x0(%rax)
    9330:	75 28                	jne    935a <e1000_force_mac_fc+0x4a>
	case E1000_FC_TX_PAUSE:
		ctrl &= (~E1000_CTRL_RFCE);
		ctrl |= E1000_CTRL_TFCE;
		break;
	case E1000_FC_FULL:
		ctrl |= (E1000_CTRL_TFCE | E1000_CTRL_RFCE);
    9332:	0d 00 00 00 18       	or     $0x18000000,%eax
		return -E1000_ERR_CONFIG;
	}

	/* Disable TX Flow Control for 82542 (rev 2.0) */
	if (hw->mac_type == e1000_82542_rev2_0)
		ctrl &= (~E1000_CTRL_TFCE);
    9337:	89 c2                	mov    %eax,%edx
    9339:	81 e2 ff ff ff ef    	and    $0xefffffff,%edx
    933f:	83 7f 18 01          	cmpl   $0x1,0x18(%rdi)
    9343:	0f 44 c2             	cmove  %edx,%eax

	ew32(CTRL, ctrl);
    9346:	48 8b 17             	mov    (%rdi),%rdx
build_mmio_read(__readw, "w", unsigned short, "=r", )
build_mmio_read(__readl, "l", unsigned int, "=r", )

build_mmio_write(writeb, "b", unsigned char, "q", :"memory")
build_mmio_write(writew, "w", unsigned short, "r", :"memory")
build_mmio_write(writel, "l", unsigned int, "r", :"memory")
    9349:	89 02                	mov    %eax,(%rdx)
	return E1000_SUCCESS;
    934b:	31 c0                	xor    %eax,%eax
    934d:	c3                   	retq   
	case E1000_FC_RX_PAUSE:
		ctrl &= (~E1000_CTRL_TFCE);
		ctrl |= E1000_CTRL_RFCE;
		break;
	case E1000_FC_TX_PAUSE:
		ctrl &= (~E1000_CTRL_RFCE);
    934e:	25 ff ff ff f7       	and    $0xf7ffffff,%eax
		ctrl |= E1000_CTRL_TFCE;
    9353:	0d 00 00 00 10       	or     $0x10000000,%eax
		break;
    9358:	eb dd                	jmp    9337 <e1000_force_mac_fc+0x27>
	case E1000_FC_FULL:
		ctrl |= (E1000_CTRL_TFCE | E1000_CTRL_RFCE);
		break;
	default:
		e_dbg("Flow control param set incorrectly\n");
    935a:	f6 05 00 00 00 00 04 	testb  $0x4,0x0(%rip)        # 9361 <e1000_force_mac_fc+0x51>
    9361:	75 19                	jne    937c <e1000_force_mac_fc+0x6c>
		return -E1000_ERR_CONFIG;
    9363:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
    9368:	c3                   	retq   
	 *  other:  No other values should be possible at this point.
	 */

	switch (hw->fc) {
	case E1000_FC_NONE:
		ctrl &= (~(E1000_CTRL_TFCE | E1000_CTRL_RFCE));
    9369:	25 ff ff ff e7       	and    $0xe7ffffff,%eax
		break;
    936e:	eb c7                	jmp    9337 <e1000_force_mac_fc+0x27>
	case E1000_FC_RX_PAUSE:
		ctrl &= (~E1000_CTRL_TFCE);
    9370:	25 ff ff ff ef       	and    $0xefffffff,%eax
		ctrl |= E1000_CTRL_RFCE;
    9375:	0d 00 00 00 08       	or     $0x8000000,%eax
		break;
    937a:	eb bb                	jmp    9337 <e1000_force_mac_fc+0x27>
 * software when a Copper PHY is used because autonegotiation is managed
 * by the PHY rather than the MAC. Software must also configure these
 * bits when link is forced on a fiber connection.
 */
s32 e1000_force_mac_fc(struct e1000_hw *hw)
{
    937c:	55                   	push   %rbp
    937d:	48 89 e5             	mov    %rsp,%rbp
		break;
	case E1000_FC_FULL:
		ctrl |= (E1000_CTRL_TFCE | E1000_CTRL_RFCE);
		break;
	default:
		e_dbg("Flow control param set incorrectly\n");
    9380:	e8 00 00 00 00       	callq  9385 <e1000_force_mac_fc+0x75>
    9385:	48 c7 c2 00 00 00 00 	mov    $0x0,%rdx
    938c:	48 89 c6             	mov    %rax,%rsi
    938f:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
    9396:	31 c0                	xor    %eax,%eax
    9398:	e8 00 00 00 00       	callq  939d <e1000_force_mac_fc+0x8d>
    939d:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
	if (hw->mac_type == e1000_82542_rev2_0)
		ctrl &= (~E1000_CTRL_TFCE);

	ew32(CTRL, ctrl);
	return E1000_SUCCESS;
}
    93a2:	5d                   	pop    %rbp
    93a3:	c3                   	retq   
    93a4:	66 66 66 2e 0f 1f 84 	data32 data32 nopw %cs:0x0(%rax,%rax,1)
    93ab:	00 00 00 00 00 

00000000000093b0 <e1000_read_phy_reg>:
 *
 * Reads the value from a PHY register, if the value is on a specific non zero
 * page, sets the page first.
 */
s32 e1000_read_phy_reg(struct e1000_hw *hw, u32 reg_addr, u16 *phy_data)
{
    93b0:	e8 00 00 00 00       	callq  93b5 <e1000_read_phy_reg+0x5>
    93b5:	55                   	push   %rbp
    93b6:	48 89 e5             	mov    %rsp,%rbp
    93b9:	41 57                	push   %r15
    93bb:	41 56                	push   %r14
    93bd:	41 55                	push   %r13
    93bf:	41 54                	push   %r12
    93c1:	41 89 f4             	mov    %esi,%r12d
    93c4:	53                   	push   %rbx
    93c5:	48 89 fb             	mov    %rdi,%rbx
	u32 ret_val;
	unsigned long flags;

	spin_lock_irqsave(&e1000_phy_lock, flags);
    93c8:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
 *
 * Reads the value from a PHY register, if the value is on a specific non zero
 * page, sets the page first.
 */
s32 e1000_read_phy_reg(struct e1000_hw *hw, u32 reg_addr, u16 *phy_data)
{
    93cf:	48 83 ec 10          	sub    $0x10,%rsp
    93d3:	48 89 55 c8          	mov    %rdx,-0x38(%rbp)
	u32 ret_val;
	unsigned long flags;

	spin_lock_irqsave(&e1000_phy_lock, flags);
    93d7:	e8 00 00 00 00       	callq  93dc <e1000_read_phy_reg+0x2c>

	if ((hw->phy_type == e1000_phy_igp) &&
    93dc:	83 7b 1c 01          	cmpl   $0x1,0x1c(%rbx)
s32 e1000_read_phy_reg(struct e1000_hw *hw, u32 reg_addr, u16 *phy_data)
{
	u32 ret_val;
	unsigned long flags;

	spin_lock_irqsave(&e1000_phy_lock, flags);
    93e0:	48 89 45 d0          	mov    %rax,-0x30(%rbp)

	if ((hw->phy_type == e1000_phy_igp) &&
    93e4:	0f 84 92 00 00 00    	je     947c <e1000_read_phy_reg+0xcc>
static s32 e1000_read_phy_reg_ex(struct e1000_hw *hw, u32 reg_addr,
				 u16 *phy_data)
{
	u32 i;
	u32 mdic = 0;
	const u32 phy_addr = (hw->mac_type == e1000_ce4100) ? hw->phy_addr : 1;
    93ea:	8b 43 18             	mov    0x18(%rbx),%eax
			spin_unlock_irqrestore(&e1000_phy_lock, flags);
			return ret_val;
		}
	}

	ret_val = e1000_read_phy_reg_ex(hw, MAX_PHY_REG_ADDRESS & reg_addr,
    93ed:	41 83 e4 1f          	and    $0x1f,%r12d
static s32 e1000_read_phy_reg_ex(struct e1000_hw *hw, u32 reg_addr,
				 u16 *phy_data)
{
	u32 i;
	u32 mdic = 0;
	const u32 phy_addr = (hw->mac_type == e1000_ce4100) ? hw->phy_addr : 1;
    93f1:	83 f8 09             	cmp    $0x9,%eax
    93f4:	0f 84 bf 00 00 00    	je     94b9 <e1000_read_phy_reg+0x109>
	if (reg_addr > MAX_PHY_REG_ADDRESS) {
		e_dbg("PHY Address %d is out of range\n", reg_addr);
		return -E1000_ERR_PARAM;
	}

	if (hw->mac_type > e1000_82543) {
    93fa:	83 f8 03             	cmp    $0x3,%eax
    93fd:	0f 86 15 01 00 00    	jbe    9518 <e1000_read_phy_reg+0x168>
				e_dbg("MDI Read Error\n");
				return -E1000_ERR_PHY;
			}
			*phy_data = (u16) mdic;
		} else {
			mdic = ((reg_addr << E1000_MDIC_REG_SHIFT) |
    9403:	41 c1 e4 10          	shl    $0x10,%r12d
				(phy_addr << E1000_MDIC_PHY_SHIFT) |
				(E1000_MDIC_OP_READ));

			ew32(MDIC, mdic);
    9407:	48 8b 03             	mov    (%rbx),%rax
				e_dbg("MDI Read Error\n");
				return -E1000_ERR_PHY;
			}
			*phy_data = (u16) mdic;
		} else {
			mdic = ((reg_addr << E1000_MDIC_REG_SHIFT) |
    940a:	41 81 cc 00 00 20 08 	or     $0x8200000,%r12d
    9411:	44 89 60 20          	mov    %r12d,0x20(%rax)
    9415:	41 bc 40 00 00 00    	mov    $0x40,%r12d
    941b:	eb 0a                	jmp    9427 <e1000_read_phy_reg+0x77>
			ew32(MDIC, mdic);

			/* Poll the ready bit to see if the MDI read
			 * completed
			 */
			for (i = 0; i < 64; i++) {
    941d:	41 83 ec 01          	sub    $0x1,%r12d
    9421:	0f 84 1a 02 00 00    	je     9641 <e1000_read_phy_reg+0x291>
				udelay(50);
    9427:	bf de 46 03 00       	mov    $0x346de,%edi
    942c:	e8 00 00 00 00       	callq  9431 <e1000_read_phy_reg+0x81>
				mdic = er32(MDIC);
    9431:	48 8b 03             	mov    (%rbx),%rax
{ asm volatile("mov" size " %0,%1": :reg (val), \
"m" (*(volatile type __force *)addr) barrier); }

build_mmio_read(readb, "b", unsigned char, "=q", :"memory")
build_mmio_read(readw, "w", unsigned short, "=r", :"memory")
build_mmio_read(readl, "l", unsigned int, "=r", :"memory")
    9434:	8b 40 20             	mov    0x20(%rax),%eax
				if (mdic & E1000_MDIC_READY)
    9437:	a9 00 00 00 10       	test   $0x10000000,%eax
    943c:	74 df                	je     941d <e1000_read_phy_reg+0x6d>
			}
			if (!(mdic & E1000_MDIC_READY)) {
				e_dbg("MDI Read did not complete\n");
				return -E1000_ERR_PHY;
			}
			if (mdic & E1000_MDIC_ERROR) {
    943e:	a9 00 00 00 40       	test   $0x40000000,%eax
    9443:	0f 84 c1 00 00 00    	je     950a <e1000_read_phy_reg+0x15a>
				e_dbg("MDI Error\n");
    9449:	f6 05 00 00 00 00 04 	testb  $0x4,0x0(%rip)        # 9450 <e1000_read_phy_reg+0xa0>
    9450:	0f 85 90 02 00 00    	jne    96e6 <e1000_read_phy_reg+0x336>
				return -E1000_ERR_PHY;
    9456:	bb fe ff ff ff       	mov    $0xfffffffe,%ebx
    945b:	48 8b 75 d0          	mov    -0x30(%rbp),%rsi
    945f:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
    9466:	e8 00 00 00 00       	callq  946b <e1000_read_phy_reg+0xbb>
	ret_val = e1000_read_phy_reg_ex(hw, MAX_PHY_REG_ADDRESS & reg_addr,
					phy_data);
	spin_unlock_irqrestore(&e1000_phy_lock, flags);

	return ret_val;
}
    946b:	48 83 c4 10          	add    $0x10,%rsp
    946f:	89 d8                	mov    %ebx,%eax
    9471:	5b                   	pop    %rbx
    9472:	41 5c                	pop    %r12
    9474:	41 5d                	pop    %r13
    9476:	41 5e                	pop    %r14
    9478:	41 5f                	pop    %r15
    947a:	5d                   	pop    %rbp
    947b:	c3                   	retq   
	u32 ret_val;
	unsigned long flags;

	spin_lock_irqsave(&e1000_phy_lock, flags);

	if ((hw->phy_type == e1000_phy_igp) &&
    947c:	41 83 fc 0f          	cmp    $0xf,%r12d
    9480:	0f 86 64 ff ff ff    	jbe    93ea <e1000_read_phy_reg+0x3a>
    9486:	41 0f b7 d4          	movzwl %r12w,%edx
	    (reg_addr > MAX_PHY_MULTI_PAGE_REG)) {
		ret_val = e1000_write_phy_reg_ex(hw, IGP01E1000_PHY_PAGE_SELECT,
    948a:	be 1f 00 00 00       	mov    $0x1f,%esi
    948f:	48 89 df             	mov    %rbx,%rdi
    9492:	e8 a9 f5 ff ff       	callq  8a40 <e1000_write_phy_reg_ex>
						 (u16) reg_addr);
		if (ret_val) {
    9497:	85 c0                	test   %eax,%eax
    9499:	0f 84 4b ff ff ff    	je     93ea <e1000_read_phy_reg+0x3a>
    949f:	48 8b 75 d0          	mov    -0x30(%rbp),%rsi
    94a3:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
    94aa:	89 45 c8             	mov    %eax,-0x38(%rbp)
    94ad:	e8 00 00 00 00       	callq  94b2 <e1000_read_phy_reg+0x102>
			spin_unlock_irqrestore(&e1000_phy_lock, flags);
			return ret_val;
    94b2:	8b 45 c8             	mov    -0x38(%rbp),%eax
    94b5:	89 c3                	mov    %eax,%ebx
    94b7:	eb b2                	jmp    946b <e1000_read_phy_reg+0xbb>
		 * Control register.  The MAC will take care of interfacing with
		 * the PHY to retrieve the desired data.
		 */
		if (hw->mac_type == e1000_ce4100) {
			mdic = ((reg_addr << E1000_MDIC_REG_SHIFT) |
				(phy_addr << E1000_MDIC_PHY_SHIFT) |
    94b9:	8b 83 88 00 00 00    	mov    0x88(%rbx),%eax
		/* Set up Op-code, Phy Address, and register address in the MDI
		 * Control register.  The MAC will take care of interfacing with
		 * the PHY to retrieve the desired data.
		 */
		if (hw->mac_type == e1000_ce4100) {
			mdic = ((reg_addr << E1000_MDIC_REG_SHIFT) |
    94bf:	41 c1 e4 10          	shl    $0x10,%r12d
				(phy_addr << E1000_MDIC_PHY_SHIFT) |
				(INTEL_CE_GBE_MDIC_OP_READ) |
				(INTEL_CE_GBE_MDIC_GO));

			writel(mdic, E1000_MDIO_CMD);
    94c3:	48 8b 53 10          	mov    0x10(%rbx),%rdx
		 * Control register.  The MAC will take care of interfacing with
		 * the PHY to retrieve the desired data.
		 */
		if (hw->mac_type == e1000_ce4100) {
			mdic = ((reg_addr << E1000_MDIC_REG_SHIFT) |
				(phy_addr << E1000_MDIC_PHY_SHIFT) |
    94c7:	c1 e0 15             	shl    $0x15,%eax
    94ca:	0d 00 00 00 80       	or     $0x80000000,%eax
		/* Set up Op-code, Phy Address, and register address in the MDI
		 * Control register.  The MAC will take care of interfacing with
		 * the PHY to retrieve the desired data.
		 */
		if (hw->mac_type == e1000_ce4100) {
			mdic = ((reg_addr << E1000_MDIC_REG_SHIFT) |
    94cf:	44 09 e0             	or     %r12d,%eax
build_mmio_read(__readw, "w", unsigned short, "=r", )
build_mmio_read(__readl, "l", unsigned int, "=r", )

build_mmio_write(writeb, "b", unsigned char, "q", :"memory")
build_mmio_write(writew, "w", unsigned short, "r", :"memory")
build_mmio_write(writel, "l", unsigned int, "r", :"memory")
    94d2:	89 42 04             	mov    %eax,0x4(%rdx)
    94d5:	41 bc 40 00 00 00    	mov    $0x40,%r12d
    94db:	eb 0a                	jmp    94e7 <e1000_read_phy_reg+0x137>
			writel(mdic, E1000_MDIO_CMD);

			/* Poll the ready bit to see if the MDI read
			 * completed
			 */
			for (i = 0; i < 64; i++) {
    94dd:	41 83 ec 01          	sub    $0x1,%r12d
    94e1:	0f 84 c8 01 00 00    	je     96af <e1000_read_phy_reg+0x2ff>
				udelay(50);
    94e7:	bf de 46 03 00       	mov    $0x346de,%edi
    94ec:	e8 00 00 00 00       	callq  94f1 <e1000_read_phy_reg+0x141>
				mdic = readl(E1000_MDIO_CMD);
    94f1:	48 8b 43 10          	mov    0x10(%rbx),%rax
{ asm volatile("mov" size " %0,%1": :reg (val), \
"m" (*(volatile type __force *)addr) barrier); }

build_mmio_read(readb, "b", unsigned char, "=q", :"memory")
build_mmio_read(readw, "w", unsigned short, "=r", :"memory")
build_mmio_read(readl, "l", unsigned int, "=r", :"memory")
    94f5:	8b 40 04             	mov    0x4(%rax),%eax
				if (!(mdic & INTEL_CE_GBE_MDIC_GO))
    94f8:	85 c0                	test   %eax,%eax
    94fa:	78 e1                	js     94dd <e1000_read_phy_reg+0x12d>
			if (mdic & INTEL_CE_GBE_MDIC_GO) {
				e_dbg("MDI Read did not complete\n");
				return -E1000_ERR_PHY;
			}

			mdic = readl(E1000_MDIO_STS);
    94fc:	48 8b 43 10          	mov    0x10(%rbx),%rax
    9500:	8b 00                	mov    (%rax),%eax
			if (mdic & INTEL_CE_GBE_MDIC_READ_ERROR) {
    9502:	85 c0                	test   %eax,%eax
    9504:	0f 88 6e 01 00 00    	js     9678 <e1000_read_phy_reg+0x2c8>
			}
			if (mdic & E1000_MDIC_ERROR) {
				e_dbg("MDI Error\n");
				return -E1000_ERR_PHY;
			}
			*phy_data = (u16) mdic;
    950a:	48 8b 75 c8          	mov    -0x38(%rbp),%rsi
		 * need to "shift in" the 16-bit value (18 total bits) of the
		 * requested PHY register address.
		 */
		*phy_data = e1000_shift_in_mdi_bits(hw);
	}
	return E1000_SUCCESS;
    950e:	31 db                	xor    %ebx,%ebx
			}
			if (mdic & E1000_MDIC_ERROR) {
				e_dbg("MDI Error\n");
				return -E1000_ERR_PHY;
			}
			*phy_data = (u16) mdic;
    9510:	66 89 06             	mov    %ax,(%rsi)
    9513:	e9 43 ff ff ff       	jmpq   945b <e1000_read_phy_reg+0xab>
	} else {
		/* We must first send a preamble through the MDIO pin to signal
		 * the beginning of an MII instruction.  This is done by sending
		 * 32 consecutive "1" bits.
		 */
		e1000_shift_out_mdi_bits(hw, PHY_PREAMBLE, PHY_PREAMBLE_SIZE);
    9518:	48 89 df             	mov    %rbx,%rdi
    951b:	ba 20 00 00 00       	mov    $0x20,%edx
    9520:	be ff ff ff ff       	mov    $0xffffffff,%esi
    9525:	e8 66 f4 ff ff       	callq  8990 <e1000_shift_out_mdi_bits>
		 * shifted in are TurnAround bits used to avoid contention on
		 * the MDIO pin when a READ operation is performed.  These two
		 * bits are thrown away followed by a shift in of 16 bits which
		 * contains the desired data.
		 */
		mdic = ((reg_addr) | (phy_addr << 5) |
    952a:	44 89 e6             	mov    %r12d,%esi
			(PHY_OP_READ << 10) | (PHY_SOF << 12));

		e1000_shift_out_mdi_bits(hw, mdic, 14);
    952d:	ba 0e 00 00 00       	mov    $0xe,%edx
    9532:	48 89 df             	mov    %rbx,%rdi
		 * shifted in are TurnAround bits used to avoid contention on
		 * the MDIO pin when a READ operation is performed.  These two
		 * bits are thrown away followed by a shift in of 16 bits which
		 * contains the desired data.
		 */
		mdic = ((reg_addr) | (phy_addr << 5) |
    9535:	81 ce 20 18 00 00    	or     $0x1820,%esi
			(PHY_OP_READ << 10) | (PHY_SOF << 12));

		e1000_shift_out_mdi_bits(hw, mdic, 14);
    953b:	e8 50 f4 ff ff       	callq  8990 <e1000_shift_out_mdi_bits>
	 * used to avoid contention on the MDIO pin when a read operation is
	 * performed. These two bits are ignored by us and thrown away. Bits are
	 * "shifted in" by raising the input to the Management Data Clock
	 * (setting the MDC bit), and then reading the value of the MDIO bit.
	 */
	ctrl = er32(CTRL);
    9540:	48 8b 03             	mov    (%rbx),%rax
    9543:	44 8b 20             	mov    (%rax),%r12d

	/* Clear MDIO_DIR (SWDPIO1) to indicate this bit is to be used as
	 * input.
	 */
	ctrl &= ~E1000_CTRL_MDIO_DIR;
	ctrl &= ~E1000_CTRL_MDIO;
    9546:	45 89 e5             	mov    %r12d,%r13d

	ew32(CTRL, ctrl);
    9549:	48 8b 03             	mov    (%rbx),%rax

	/* Clear MDIO_DIR (SWDPIO1) to indicate this bit is to be used as
	 * input.
	 */
	ctrl &= ~E1000_CTRL_MDIO_DIR;
	ctrl &= ~E1000_CTRL_MDIO;
    954c:	41 81 e5 ff ff ef fe 	and    $0xfeefffff,%r13d
build_mmio_read(__readw, "w", unsigned short, "=r", )
build_mmio_read(__readl, "l", unsigned int, "=r", )

build_mmio_write(writeb, "b", unsigned char, "q", :"memory")
build_mmio_write(writew, "w", unsigned short, "r", :"memory")
build_mmio_write(writel, "l", unsigned int, "r", :"memory")
    9553:	44 89 28             	mov    %r13d,(%rax)

	ew32(CTRL, ctrl);
	E1000_WRITE_FLUSH();
    9556:	48 8b 03             	mov    (%rbx),%rax
{ asm volatile("mov" size " %0,%1": :reg (val), \
"m" (*(volatile type __force *)addr) barrier); }

build_mmio_read(readb, "b", unsigned char, "=q", :"memory")
build_mmio_read(readw, "w", unsigned short, "=r", :"memory")
build_mmio_read(readl, "l", unsigned int, "=r", :"memory")
    9559:	8b 40 08             	mov    0x8(%rax),%eax
static void e1000_raise_mdi_clk(struct e1000_hw *hw, u32 *ctrl)
{
	/* Raise the clock input to the Management Data Clock (by setting the
	 * MDC bit), and then delay 10 microseconds.
	 */
	ew32(CTRL, (*ctrl | E1000_CTRL_MDC));
    955c:	44 89 e8             	mov    %r13d,%eax
    955f:	48 8b 0b             	mov    (%rbx),%rcx
    9562:	0d 00 00 20 00       	or     $0x200000,%eax
build_mmio_read(__readw, "w", unsigned short, "=r", )
build_mmio_read(__readl, "l", unsigned int, "=r", )

build_mmio_write(writeb, "b", unsigned char, "q", :"memory")
build_mmio_write(writew, "w", unsigned short, "r", :"memory")
build_mmio_write(writel, "l", unsigned int, "r", :"memory")
    9567:	89 01                	mov    %eax,(%rcx)
	E1000_WRITE_FLUSH();
    9569:	48 8b 03             	mov    (%rbx),%rax
{ asm volatile("mov" size " %0,%1": :reg (val), \
"m" (*(volatile type __force *)addr) barrier); }

build_mmio_read(readb, "b", unsigned char, "=q", :"memory")
build_mmio_read(readw, "w", unsigned short, "=r", :"memory")
build_mmio_read(readl, "l", unsigned int, "=r", :"memory")
    956c:	8b 40 08             	mov    0x8(%rax),%eax
	udelay(10);
    956f:	bf c6 a7 00 00       	mov    $0xa7c6,%edi
static void e1000_lower_mdi_clk(struct e1000_hw *hw, u32 *ctrl)
{
	/* Lower the clock input to the Management Data Clock (by clearing the
	 * MDC bit), and then delay 10 microseconds.
	 */
	ew32(CTRL, (*ctrl & ~E1000_CTRL_MDC));
    9574:	41 81 e4 ff ff cf fe 	and    $0xfecfffff,%r12d
	/* Raise the clock input to the Management Data Clock (by setting the
	 * MDC bit), and then delay 10 microseconds.
	 */
	ew32(CTRL, (*ctrl | E1000_CTRL_MDC));
	E1000_WRITE_FLUSH();
	udelay(10);
    957b:	e8 00 00 00 00       	callq  9580 <e1000_read_phy_reg+0x1d0>
static void e1000_lower_mdi_clk(struct e1000_hw *hw, u32 *ctrl)
{
	/* Lower the clock input to the Management Data Clock (by clearing the
	 * MDC bit), and then delay 10 microseconds.
	 */
	ew32(CTRL, (*ctrl & ~E1000_CTRL_MDC));
    9580:	48 8b 03             	mov    (%rbx),%rax
build_mmio_read(__readw, "w", unsigned short, "=r", )
build_mmio_read(__readl, "l", unsigned int, "=r", )

build_mmio_write(writeb, "b", unsigned char, "q", :"memory")
build_mmio_write(writew, "w", unsigned short, "r", :"memory")
build_mmio_write(writel, "l", unsigned int, "r", :"memory")
    9583:	44 89 20             	mov    %r12d,(%rax)
	E1000_WRITE_FLUSH();
    9586:	48 8b 03             	mov    (%rbx),%rax
{ asm volatile("mov" size " %0,%1": :reg (val), \
"m" (*(volatile type __force *)addr) barrier); }

build_mmio_read(readb, "b", unsigned char, "=q", :"memory")
build_mmio_read(readw, "w", unsigned short, "=r", :"memory")
build_mmio_read(readl, "l", unsigned int, "=r", :"memory")
    9589:	8b 40 08             	mov    0x8(%rax),%eax
	udelay(10);
    958c:	bf c6 a7 00 00       	mov    $0xa7c6,%edi
    9591:	41 bc 10 00 00 00    	mov    $0x10,%r12d
	 * the last bit of the Register Address.
	 */
	e1000_raise_mdi_clk(hw, &ctrl);
	e1000_lower_mdi_clk(hw, &ctrl);

	for (data = 0, i = 0; i < 16; i++) {
    9597:	45 31 f6             	xor    %r14d,%r14d
	/* Lower the clock input to the Management Data Clock (by clearing the
	 * MDC bit), and then delay 10 microseconds.
	 */
	ew32(CTRL, (*ctrl & ~E1000_CTRL_MDC));
	E1000_WRITE_FLUSH();
	udelay(10);
    959a:	e8 00 00 00 00       	callq  959f <e1000_read_phy_reg+0x1ef>
static void e1000_raise_mdi_clk(struct e1000_hw *hw, u32 *ctrl)
{
	/* Raise the clock input to the Management Data Clock (by setting the
	 * MDC bit), and then delay 10 microseconds.
	 */
	ew32(CTRL, (*ctrl | E1000_CTRL_MDC));
    959f:	44 89 ea             	mov    %r13d,%edx
	 */
	e1000_raise_mdi_clk(hw, &ctrl);
	e1000_lower_mdi_clk(hw, &ctrl);

	for (data = 0, i = 0; i < 16; i++) {
		data = data << 1;
    95a2:	45 01 f6             	add    %r14d,%r14d
static void e1000_raise_mdi_clk(struct e1000_hw *hw, u32 *ctrl)
{
	/* Raise the clock input to the Management Data Clock (by setting the
	 * MDC bit), and then delay 10 microseconds.
	 */
	ew32(CTRL, (*ctrl | E1000_CTRL_MDC));
    95a5:	48 8b 0b             	mov    (%rbx),%rcx
    95a8:	81 ca 00 00 20 00    	or     $0x200000,%edx
build_mmio_read(__readw, "w", unsigned short, "=r", )
build_mmio_read(__readl, "l", unsigned int, "=r", )

build_mmio_write(writeb, "b", unsigned char, "q", :"memory")
build_mmio_write(writew, "w", unsigned short, "r", :"memory")
build_mmio_write(writel, "l", unsigned int, "r", :"memory")
    95ae:	89 11                	mov    %edx,(%rcx)
	E1000_WRITE_FLUSH();
    95b0:	48 8b 13             	mov    (%rbx),%rdx
{ asm volatile("mov" size " %0,%1": :reg (val), \
"m" (*(volatile type __force *)addr) barrier); }

build_mmio_read(readb, "b", unsigned char, "=q", :"memory")
build_mmio_read(readw, "w", unsigned short, "=r", :"memory")
build_mmio_read(readl, "l", unsigned int, "=r", :"memory")
    95b3:	8b 52 08             	mov    0x8(%rdx),%edx
	udelay(10);
    95b6:	bf c6 a7 00 00       	mov    $0xa7c6,%edi
    95bb:	e8 00 00 00 00       	callq  95c0 <e1000_read_phy_reg+0x210>
	e1000_lower_mdi_clk(hw, &ctrl);

	for (data = 0, i = 0; i < 16; i++) {
		data = data << 1;
		e1000_raise_mdi_clk(hw, &ctrl);
		ctrl = er32(CTRL);
    95c0:	48 8b 13             	mov    (%rbx),%rdx
    95c3:	8b 12                	mov    (%rdx),%edx
		/* Check to see if we shifted in a "1". */
		if (ctrl & E1000_CTRL_MDIO)
			data |= 1;
    95c5:	44 89 f1             	mov    %r14d,%ecx
static void e1000_lower_mdi_clk(struct e1000_hw *hw, u32 *ctrl)
{
	/* Lower the clock input to the Management Data Clock (by clearing the
	 * MDC bit), and then delay 10 microseconds.
	 */
	ew32(CTRL, (*ctrl & ~E1000_CTRL_MDC));
    95c8:	41 89 d7             	mov    %edx,%r15d
    95cb:	41 89 d5             	mov    %edx,%r13d
		data = data << 1;
		e1000_raise_mdi_clk(hw, &ctrl);
		ctrl = er32(CTRL);
		/* Check to see if we shifted in a "1". */
		if (ctrl & E1000_CTRL_MDIO)
			data |= 1;
    95ce:	83 c9 01             	or     $0x1,%ecx
    95d1:	f7 c2 00 00 10 00    	test   $0x100000,%edx
    95d7:	44 0f 45 f1          	cmovne %ecx,%r14d
static void e1000_lower_mdi_clk(struct e1000_hw *hw, u32 *ctrl)
{
	/* Lower the clock input to the Management Data Clock (by clearing the
	 * MDC bit), and then delay 10 microseconds.
	 */
	ew32(CTRL, (*ctrl & ~E1000_CTRL_MDC));
    95db:	48 8b 0b             	mov    (%rbx),%rcx
    95de:	41 81 e7 ff ff df ff 	and    $0xffdfffff,%r15d
build_mmio_read(__readw, "w", unsigned short, "=r", )
build_mmio_read(__readl, "l", unsigned int, "=r", )

build_mmio_write(writeb, "b", unsigned char, "q", :"memory")
build_mmio_write(writew, "w", unsigned short, "r", :"memory")
build_mmio_write(writel, "l", unsigned int, "r", :"memory")
    95e5:	44 89 39             	mov    %r15d,(%rcx)
	E1000_WRITE_FLUSH();
    95e8:	48 8b 0b             	mov    (%rbx),%rcx
{ asm volatile("mov" size " %0,%1": :reg (val), \
"m" (*(volatile type __force *)addr) barrier); }

build_mmio_read(readb, "b", unsigned char, "=q", :"memory")
build_mmio_read(readw, "w", unsigned short, "=r", :"memory")
build_mmio_read(readl, "l", unsigned int, "=r", :"memory")
    95eb:	8b 49 08             	mov    0x8(%rcx),%ecx
	udelay(10);
    95ee:	bf c6 a7 00 00       	mov    $0xa7c6,%edi
    95f3:	e8 00 00 00 00       	callq  95f8 <e1000_read_phy_reg+0x248>
	 * the last bit of the Register Address.
	 */
	e1000_raise_mdi_clk(hw, &ctrl);
	e1000_lower_mdi_clk(hw, &ctrl);

	for (data = 0, i = 0; i < 16; i++) {
    95f8:	41 80 ec 01          	sub    $0x1,%r12b
    95fc:	75 a1                	jne    959f <e1000_read_phy_reg+0x1ef>
static void e1000_raise_mdi_clk(struct e1000_hw *hw, u32 *ctrl)
{
	/* Raise the clock input to the Management Data Clock (by setting the
	 * MDC bit), and then delay 10 microseconds.
	 */
	ew32(CTRL, (*ctrl | E1000_CTRL_MDC));
    95fe:	44 89 ea             	mov    %r13d,%edx
    9601:	48 8b 0b             	mov    (%rbx),%rcx
    9604:	81 ca 00 00 20 00    	or     $0x200000,%edx
build_mmio_read(__readw, "w", unsigned short, "=r", )
build_mmio_read(__readl, "l", unsigned int, "=r", )

build_mmio_write(writeb, "b", unsigned char, "q", :"memory")
build_mmio_write(writew, "w", unsigned short, "r", :"memory")
build_mmio_write(writel, "l", unsigned int, "r", :"memory")
    960a:	89 11                	mov    %edx,(%rcx)
	E1000_WRITE_FLUSH();
    960c:	48 8b 13             	mov    (%rbx),%rdx
{ asm volatile("mov" size " %0,%1": :reg (val), \
"m" (*(volatile type __force *)addr) barrier); }

build_mmio_read(readb, "b", unsigned char, "=q", :"memory")
build_mmio_read(readw, "w", unsigned short, "=r", :"memory")
build_mmio_read(readl, "l", unsigned int, "=r", :"memory")
    960f:	8b 52 08             	mov    0x8(%rdx),%edx
	udelay(10);
    9612:	bf c6 a7 00 00       	mov    $0xa7c6,%edi
    9617:	e8 00 00 00 00       	callq  961c <e1000_read_phy_reg+0x26c>
static void e1000_lower_mdi_clk(struct e1000_hw *hw, u32 *ctrl)
{
	/* Lower the clock input to the Management Data Clock (by clearing the
	 * MDC bit), and then delay 10 microseconds.
	 */
	ew32(CTRL, (*ctrl & ~E1000_CTRL_MDC));
    961c:	48 8b 13             	mov    (%rbx),%rdx
build_mmio_read(__readw, "w", unsigned short, "=r", )
build_mmio_read(__readl, "l", unsigned int, "=r", )

build_mmio_write(writeb, "b", unsigned char, "q", :"memory")
build_mmio_write(writew, "w", unsigned short, "r", :"memory")
build_mmio_write(writel, "l", unsigned int, "r", :"memory")
    961f:	44 89 3a             	mov    %r15d,(%rdx)
	E1000_WRITE_FLUSH();
    9622:	48 8b 13             	mov    (%rbx),%rdx
{ asm volatile("mov" size " %0,%1": :reg (val), \
"m" (*(volatile type __force *)addr) barrier); }

build_mmio_read(readb, "b", unsigned char, "=q", :"memory")
build_mmio_read(readw, "w", unsigned short, "=r", :"memory")
build_mmio_read(readl, "l", unsigned int, "=r", :"memory")
    9625:	8b 52 08             	mov    0x8(%rdx),%edx
	udelay(10);
    9628:	bf c6 a7 00 00       	mov    $0xa7c6,%edi
		 * need to "shift in" the 16-bit value (18 total bits) of the
		 * requested PHY register address.
		 */
		*phy_data = e1000_shift_in_mdi_bits(hw);
	}
	return E1000_SUCCESS;
    962d:	31 db                	xor    %ebx,%ebx
	/* Lower the clock input to the Management Data Clock (by clearing the
	 * MDC bit), and then delay 10 microseconds.
	 */
	ew32(CTRL, (*ctrl & ~E1000_CTRL_MDC));
	E1000_WRITE_FLUSH();
	udelay(10);
    962f:	e8 00 00 00 00       	callq  9634 <e1000_read_phy_reg+0x284>

		/* Now that we've shifted out the read command to the MII, we
		 * need to "shift in" the 16-bit value (18 total bits) of the
		 * requested PHY register address.
		 */
		*phy_data = e1000_shift_in_mdi_bits(hw);
    9634:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
    9638:	66 44 89 30          	mov    %r14w,(%rax)
    963c:	e9 1a fe ff ff       	jmpq   945b <e1000_read_phy_reg+0xab>
				mdic = er32(MDIC);
				if (mdic & E1000_MDIC_READY)
					break;
			}
			if (!(mdic & E1000_MDIC_READY)) {
				e_dbg("MDI Read did not complete\n");
    9641:	f6 05 00 00 00 00 04 	testb  $0x4,0x0(%rip)        # 9648 <e1000_read_phy_reg+0x298>
    9648:	0f 84 08 fe ff ff    	je     9456 <e1000_read_phy_reg+0xa6>
    964e:	48 89 df             	mov    %rbx,%rdi
				return -E1000_ERR_PHY;
    9651:	bb fe ff ff ff       	mov    $0xfffffffe,%ebx
				mdic = er32(MDIC);
				if (mdic & E1000_MDIC_READY)
					break;
			}
			if (!(mdic & E1000_MDIC_READY)) {
				e_dbg("MDI Read did not complete\n");
    9656:	e8 00 00 00 00       	callq  965b <e1000_read_phy_reg+0x2ab>
    965b:	48 c7 c2 00 00 00 00 	mov    $0x0,%rdx
    9662:	48 89 c6             	mov    %rax,%rsi
    9665:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
    966c:	31 c0                	xor    %eax,%eax
    966e:	e8 00 00 00 00       	callq  9673 <e1000_read_phy_reg+0x2c3>
    9673:	e9 e3 fd ff ff       	jmpq   945b <e1000_read_phy_reg+0xab>
				return -E1000_ERR_PHY;
			}

			mdic = readl(E1000_MDIO_STS);
			if (mdic & INTEL_CE_GBE_MDIC_READ_ERROR) {
				e_dbg("MDI Read Error\n");
    9678:	f6 05 00 00 00 00 04 	testb  $0x4,0x0(%rip)        # 967f <e1000_read_phy_reg+0x2cf>
    967f:	0f 84 d1 fd ff ff    	je     9456 <e1000_read_phy_reg+0xa6>
    9685:	48 89 df             	mov    %rbx,%rdi
				return -E1000_ERR_PHY;
    9688:	bb fe ff ff ff       	mov    $0xfffffffe,%ebx
				return -E1000_ERR_PHY;
			}

			mdic = readl(E1000_MDIO_STS);
			if (mdic & INTEL_CE_GBE_MDIC_READ_ERROR) {
				e_dbg("MDI Read Error\n");
    968d:	e8 00 00 00 00       	callq  9692 <e1000_read_phy_reg+0x2e2>
    9692:	48 c7 c2 00 00 00 00 	mov    $0x0,%rdx
    9699:	48 89 c6             	mov    %rax,%rsi
    969c:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
    96a3:	31 c0                	xor    %eax,%eax
    96a5:	e8 00 00 00 00       	callq  96aa <e1000_read_phy_reg+0x2fa>
    96aa:	e9 ac fd ff ff       	jmpq   945b <e1000_read_phy_reg+0xab>
				if (!(mdic & INTEL_CE_GBE_MDIC_GO))
					break;
			}

			if (mdic & INTEL_CE_GBE_MDIC_GO) {
				e_dbg("MDI Read did not complete\n");
    96af:	f6 05 00 00 00 00 04 	testb  $0x4,0x0(%rip)        # 96b6 <e1000_read_phy_reg+0x306>
    96b6:	0f 84 9a fd ff ff    	je     9456 <e1000_read_phy_reg+0xa6>
    96bc:	48 89 df             	mov    %rbx,%rdi
				return -E1000_ERR_PHY;
    96bf:	bb fe ff ff ff       	mov    $0xfffffffe,%ebx
				if (!(mdic & INTEL_CE_GBE_MDIC_GO))
					break;
			}

			if (mdic & INTEL_CE_GBE_MDIC_GO) {
				e_dbg("MDI Read did not complete\n");
    96c4:	e8 00 00 00 00       	callq  96c9 <e1000_read_phy_reg+0x319>
    96c9:	48 c7 c2 00 00 00 00 	mov    $0x0,%rdx
    96d0:	48 89 c6             	mov    %rax,%rsi
    96d3:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
    96da:	31 c0                	xor    %eax,%eax
    96dc:	e8 00 00 00 00       	callq  96e1 <e1000_read_phy_reg+0x331>
    96e1:	e9 75 fd ff ff       	jmpq   945b <e1000_read_phy_reg+0xab>
			if (!(mdic & E1000_MDIC_READY)) {
				e_dbg("MDI Read did not complete\n");
				return -E1000_ERR_PHY;
			}
			if (mdic & E1000_MDIC_ERROR) {
				e_dbg("MDI Error\n");
    96e6:	48 89 df             	mov    %rbx,%rdi
    96e9:	e8 00 00 00 00       	callq  96ee <e1000_read_phy_reg+0x33e>
    96ee:	48 c7 c2 00 00 00 00 	mov    $0x0,%rdx
    96f5:	48 89 c6             	mov    %rax,%rsi
    96f8:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
    96ff:	31 c0                	xor    %eax,%eax
    9701:	e8 00 00 00 00       	callq  9706 <e1000_read_phy_reg+0x356>
    9706:	e9 4b fd ff ff       	jmpq   9456 <e1000_read_phy_reg+0xa6>
    970b:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)

0000000000009710 <e1000_config_mac_to_phy.part.10>:
 *
 * Sets MAC speed and duplex settings to reflect the those in the PHY
 * The contents of the PHY register containing the needed information need to
 * be passed in.
 */
static s32 e1000_config_mac_to_phy(struct e1000_hw *hw)
    9710:	e8 00 00 00 00       	callq  9715 <e1000_config_mac_to_phy.part.10+0x5>
    9715:	55                   	push   %rbp
    9716:	48 89 e5             	mov    %rsp,%rbp
    9719:	41 55                	push   %r13
    971b:	41 54                	push   %r12
    971d:	53                   	push   %rbx
    971e:	48 89 fb             	mov    %rdi,%rbx
    9721:	48 83 ec 08          	sub    $0x8,%rsp
		return E1000_SUCCESS;

	/* Read the Device Control Register and set the bits to Force Speed
	 * and Duplex.
	 */
	ctrl = er32(CTRL);
    9725:	48 8b 07             	mov    (%rdi),%rax
    9728:	44 8b 20             	mov    (%rax),%r12d
	ctrl |= (E1000_CTRL_FRCSPD | E1000_CTRL_FRCDPX);
	ctrl &= ~(E1000_CTRL_SPD_SEL | E1000_CTRL_ILOS);
    972b:	45 89 e5             	mov    %r12d,%r13d

	switch (hw->phy_type) {
	case e1000_phy_8201:
		ret_val = e1000_read_phy_reg(hw, PHY_CTRL, &phy_data);
    972e:	48 8d 55 e6          	lea    -0x1a(%rbp),%rdx
	/* Read the Device Control Register and set the bits to Force Speed
	 * and Duplex.
	 */
	ctrl = er32(CTRL);
	ctrl |= (E1000_CTRL_FRCSPD | E1000_CTRL_FRCDPX);
	ctrl &= ~(E1000_CTRL_SPD_SEL | E1000_CTRL_ILOS);
    9732:	41 81 e5 7f fc ff ff 	and    $0xfffffc7f,%r13d

	switch (hw->phy_type) {
    9739:	83 7f 1c 03          	cmpl   $0x3,0x1c(%rdi)
    973d:	75 64                	jne    97a3 <e1000_config_mac_to_phy.part.10+0x93>
	case e1000_phy_8201:
		ret_val = e1000_read_phy_reg(hw, PHY_CTRL, &phy_data);
    973f:	31 f6                	xor    %esi,%esi
    9741:	e8 00 00 00 00       	callq  9746 <e1000_config_mac_to_phy.part.10+0x36>
		if (ret_val)
    9746:	85 c0                	test   %eax,%eax
    9748:	75 4e                	jne    9798 <e1000_config_mac_to_phy.part.10+0x88>
			return ret_val;

		if (phy_data & RTL_PHY_CTRL_FD)
    974a:	f6 45 e7 01          	testb  $0x1,-0x19(%rbp)
    974e:	0f 85 c2 00 00 00    	jne    9816 <e1000_config_mac_to_phy.part.10+0x106>
			ctrl |= E1000_CTRL_FD;
		else
			ctrl &= ~E1000_CTRL_FD;
    9754:	44 89 e0             	mov    %r12d,%eax
    9757:	25 7e fc ff ff       	and    $0xfffffc7e,%eax
    975c:	80 cc 18             	or     $0x18,%ah
 */
void e1000_config_collision_dist(struct e1000_hw *hw)
{
	u32 tctl, coll_dist;

	if (hw->mac_type < e1000_82543)
    975f:	83 7b 18 03          	cmpl   $0x3,0x18(%rbx)
		coll_dist = E1000_COLLISION_DISTANCE_82542;
	else
		coll_dist = E1000_COLLISION_DISTANCE;

	tctl = er32(TCTL);
    9763:	48 8b 13             	mov    (%rbx),%rdx
 */
void e1000_config_collision_dist(struct e1000_hw *hw)
{
	u32 tctl, coll_dist;

	if (hw->mac_type < e1000_82543)
    9766:	19 c9                	sbb    %ecx,%ecx
    9768:	81 e1 00 10 00 00    	and    $0x1000,%ecx
    976e:	81 c1 00 f0 03 00    	add    $0x3f000,%ecx
    9774:	8b 92 00 04 00 00    	mov    0x400(%rdx),%edx
	else
		coll_dist = E1000_COLLISION_DISTANCE;

	tctl = er32(TCTL);

	tctl &= ~E1000_TCTL_COLD;
    977a:	81 e2 ff 0f c0 ff    	and    $0xffc00fff,%edx
	tctl |= coll_dist << E1000_COLD_SHIFT;
    9780:	09 ca                	or     %ecx,%edx

	ew32(TCTL, tctl);
    9782:	48 8b 0b             	mov    (%rbx),%rcx
build_mmio_read(__readw, "w", unsigned short, "=r", )
build_mmio_read(__readl, "l", unsigned int, "=r", )

build_mmio_write(writeb, "b", unsigned char, "q", :"memory")
build_mmio_write(writew, "w", unsigned short, "r", :"memory")
build_mmio_write(writel, "l", unsigned int, "r", :"memory")
    9785:	89 91 00 04 00 00    	mov    %edx,0x400(%rcx)
	E1000_WRITE_FLUSH();
    978b:	48 8b 13             	mov    (%rbx),%rdx
{ asm volatile("mov" size " %0,%1": :reg (val), \
"m" (*(volatile type __force *)addr) barrier); }

build_mmio_read(readb, "b", unsigned char, "=q", :"memory")
build_mmio_read(readw, "w", unsigned short, "=r", :"memory")
build_mmio_read(readl, "l", unsigned int, "=r", :"memory")
    978e:	8b 52 08             	mov    0x8(%rdx),%edx
			 M88E1000_PSSR_100MBS)
			ctrl |= E1000_CTRL_SPD_100;
	}

	/* Write the configured values back to the Device Control Reg. */
	ew32(CTRL, ctrl);
    9791:	48 8b 13             	mov    (%rbx),%rdx
build_mmio_read(__readw, "w", unsigned short, "=r", )
build_mmio_read(__readl, "l", unsigned int, "=r", )

build_mmio_write(writeb, "b", unsigned char, "q", :"memory")
build_mmio_write(writew, "w", unsigned short, "r", :"memory")
build_mmio_write(writel, "l", unsigned int, "r", :"memory")
    9794:	89 02                	mov    %eax,(%rdx)
	return E1000_SUCCESS;
    9796:	31 c0                	xor    %eax,%eax
}
    9798:	48 83 c4 08          	add    $0x8,%rsp
    979c:	5b                   	pop    %rbx
    979d:	41 5c                	pop    %r12
    979f:	41 5d                	pop    %r13
    97a1:	5d                   	pop    %rbp
    97a2:	c3                   	retq   
		break;
	default:
		/* Set up duplex in the Device Control and Transmit Control
		 * registers depending on negotiated values.
		 */
		ret_val = e1000_read_phy_reg(hw, M88E1000_PHY_SPEC_STATUS,
    97a3:	be 11 00 00 00       	mov    $0x11,%esi
    97a8:	e8 00 00 00 00       	callq  97ad <e1000_config_mac_to_phy.part.10+0x9d>
					     &phy_data);
		if (ret_val)
    97ad:	85 c0                	test   %eax,%eax
    97af:	75 e7                	jne    9798 <e1000_config_mac_to_phy.part.10+0x88>
			return ret_val;

		if (phy_data & M88E1000_PSSR_DPLX)
    97b1:	f6 45 e7 20          	testb  $0x20,-0x19(%rbp)
    97b5:	75 6c                	jne    9823 <e1000_config_mac_to_phy.part.10+0x113>
			ctrl |= E1000_CTRL_FD;
		else
			ctrl &= ~E1000_CTRL_FD;
    97b7:	44 89 e0             	mov    %r12d,%eax
    97ba:	25 7e fc ff ff       	and    $0xfffffc7e,%eax
    97bf:	80 cc 18             	or     $0x18,%ah
 */
void e1000_config_collision_dist(struct e1000_hw *hw)
{
	u32 tctl, coll_dist;

	if (hw->mac_type < e1000_82543)
    97c2:	83 7b 18 03          	cmpl   $0x3,0x18(%rbx)
		coll_dist = E1000_COLLISION_DISTANCE_82542;
	else
		coll_dist = E1000_COLLISION_DISTANCE;

	tctl = er32(TCTL);
    97c6:	48 8b 13             	mov    (%rbx),%rdx
 */
void e1000_config_collision_dist(struct e1000_hw *hw)
{
	u32 tctl, coll_dist;

	if (hw->mac_type < e1000_82543)
    97c9:	19 c9                	sbb    %ecx,%ecx
    97cb:	81 e1 00 10 00 00    	and    $0x1000,%ecx
    97d1:	81 c1 00 f0 03 00    	add    $0x3f000,%ecx
{ asm volatile("mov" size " %0,%1": :reg (val), \
"m" (*(volatile type __force *)addr) barrier); }

build_mmio_read(readb, "b", unsigned char, "=q", :"memory")
build_mmio_read(readw, "w", unsigned short, "=r", :"memory")
build_mmio_read(readl, "l", unsigned int, "=r", :"memory")
    97d7:	8b 92 00 04 00 00    	mov    0x400(%rdx),%edx
	else
		coll_dist = E1000_COLLISION_DISTANCE;

	tctl = er32(TCTL);

	tctl &= ~E1000_TCTL_COLD;
    97dd:	81 e2 ff 0f c0 ff    	and    $0xffc00fff,%edx
	tctl |= coll_dist << E1000_COLD_SHIFT;
    97e3:	09 ca                	or     %ecx,%edx

	ew32(TCTL, tctl);
    97e5:	48 8b 0b             	mov    (%rbx),%rcx
build_mmio_read(__readw, "w", unsigned short, "=r", )
build_mmio_read(__readl, "l", unsigned int, "=r", )

build_mmio_write(writeb, "b", unsigned char, "q", :"memory")
build_mmio_write(writew, "w", unsigned short, "r", :"memory")
build_mmio_write(writel, "l", unsigned int, "r", :"memory")
    97e8:	89 91 00 04 00 00    	mov    %edx,0x400(%rcx)
	E1000_WRITE_FLUSH();
    97ee:	48 8b 13             	mov    (%rbx),%rdx
{ asm volatile("mov" size " %0,%1": :reg (val), \
"m" (*(volatile type __force *)addr) barrier); }

build_mmio_read(readb, "b", unsigned char, "=q", :"memory")
build_mmio_read(readw, "w", unsigned short, "=r", :"memory")
build_mmio_read(readl, "l", unsigned int, "=r", :"memory")
    97f1:	8b 52 08             	mov    0x8(%rdx),%edx
		e1000_config_collision_dist(hw);

		/* Set up speed in the Device Control register depending on
		 * negotiated values.
		 */
		if ((phy_data & M88E1000_PSSR_SPEED) == M88E1000_PSSR_1000MBS)
    97f4:	0f b7 55 e6          	movzwl -0x1a(%rbp),%edx
    97f8:	66 81 e2 00 c0       	and    $0xc000,%dx
    97fd:	66 81 fa 00 80       	cmp    $0x8000,%dx
    9802:	74 29                	je     982d <e1000_config_mac_to_phy.part.10+0x11d>
			ctrl |= E1000_CTRL_SPD_1000;
		else if ((phy_data & M88E1000_PSSR_SPEED) ==
			 M88E1000_PSSR_100MBS)
			ctrl |= E1000_CTRL_SPD_100;
    9804:	89 c1                	mov    %eax,%ecx
    9806:	80 cd 01             	or     $0x1,%ch
    9809:	66 81 fa 00 40       	cmp    $0x4000,%dx
    980e:	0f 44 c1             	cmove  %ecx,%eax
    9811:	e9 7b ff ff ff       	jmpq   9791 <e1000_config_mac_to_phy.part.10+0x81>
		ret_val = e1000_read_phy_reg(hw, PHY_CTRL, &phy_data);
		if (ret_val)
			return ret_val;

		if (phy_data & RTL_PHY_CTRL_FD)
			ctrl |= E1000_CTRL_FD;
    9816:	44 89 e8             	mov    %r13d,%eax
    9819:	0d 01 18 00 00       	or     $0x1801,%eax
    981e:	e9 3c ff ff ff       	jmpq   975f <e1000_config_mac_to_phy.part.10+0x4f>
					     &phy_data);
		if (ret_val)
			return ret_val;

		if (phy_data & M88E1000_PSSR_DPLX)
			ctrl |= E1000_CTRL_FD;
    9823:	44 89 e8             	mov    %r13d,%eax
    9826:	0d 01 18 00 00       	or     $0x1801,%eax
    982b:	eb 95                	jmp    97c2 <e1000_config_mac_to_phy.part.10+0xb2>

		/* Set up speed in the Device Control register depending on
		 * negotiated values.
		 */
		if ((phy_data & M88E1000_PSSR_SPEED) == M88E1000_PSSR_1000MBS)
			ctrl |= E1000_CTRL_SPD_1000;
    982d:	80 cc 02             	or     $0x2,%ah
    9830:	e9 5c ff ff ff       	jmpq   9791 <e1000_config_mac_to_phy.part.10+0x81>
    9835:	66 66 2e 0f 1f 84 00 	data32 nopw %cs:0x0(%rax,%rax,1)
    983c:	00 00 00 00 

0000000000009840 <e1000_get_cable_length>:
 * register to the minimum and maximum range.
 * For IGP phy's, the function calculates the range by the AGC registers.
 */
static s32 e1000_get_cable_length(struct e1000_hw *hw, u16 *min_length,
				  u16 *max_length)
{
    9840:	e8 00 00 00 00       	callq  9845 <e1000_get_cable_length+0x5>
    9845:	55                   	push   %rbp
	s32 ret_val;
	u16 agc_value = 0;
	u16 i, phy_data;
	u16 cable_length;

	*min_length = *max_length = 0;
    9846:	31 c0                	xor    %eax,%eax
 * register to the minimum and maximum range.
 * For IGP phy's, the function calculates the range by the AGC registers.
 */
static s32 e1000_get_cable_length(struct e1000_hw *hw, u16 *min_length,
				  u16 *max_length)
{
    9848:	48 89 e5             	mov    %rsp,%rbp
    984b:	41 57                	push   %r15
    984d:	49 89 d7             	mov    %rdx,%r15
    9850:	41 56                	push   %r14
    9852:	49 89 f6             	mov    %rsi,%r14
    9855:	41 55                	push   %r13
	s32 ret_val;
	u16 agc_value = 0;
	u16 i, phy_data;
	u16 cable_length;

	*min_length = *max_length = 0;
    9857:	45 31 ed             	xor    %r13d,%r13d
 * register to the minimum and maximum range.
 * For IGP phy's, the function calculates the range by the AGC registers.
 */
static s32 e1000_get_cable_length(struct e1000_hw *hw, u16 *min_length,
				  u16 *max_length)
{
    985a:	41 54                	push   %r12
    985c:	49 89 fc             	mov    %rdi,%r12
    985f:	53                   	push   %rbx
    9860:	48 83 ec 10          	sub    $0x10,%rsp
	s32 ret_val;
	u16 agc_value = 0;
	u16 i, phy_data;
	u16 cable_length;

	*min_length = *max_length = 0;
    9864:	66 44 89 2a          	mov    %r13w,(%rdx)
    9868:	66 89 06             	mov    %ax,(%rsi)

	/* Use old method for Phy older than IGP */
	if (hw->phy_type == e1000_phy_m88) {
    986b:	8b 4f 1c             	mov    0x1c(%rdi),%ecx
    986e:	85 c9                	test   %ecx,%ecx
    9870:	0f 84 bf 00 00 00    	je     9935 <e1000_get_cable_length+0xf5>
		     IGP01E1000_AGC_RANGE) : 0;
		*max_length = e1000_igp_cable_length_table[agc_value] +
		    IGP01E1000_AGC_RANGE;
	}

	return E1000_SUCCESS;
    9876:	31 c0                	xor    %eax,%eax
			*max_length = e1000_igp_cable_length_170;
			break;
		default:
			return -E1000_ERR_PHY;
		}
	} else if (hw->phy_type == e1000_phy_igp) {	/* For IGP PHY */
    9878:	83 f9 01             	cmp    $0x1,%ecx
    987b:	74 0f                	je     988c <e1000_get_cable_length+0x4c>
		*max_length = e1000_igp_cable_length_table[agc_value] +
		    IGP01E1000_AGC_RANGE;
	}

	return E1000_SUCCESS;
}
    987d:	48 83 c4 10          	add    $0x10,%rsp
    9881:	5b                   	pop    %rbx
    9882:	41 5c                	pop    %r12
    9884:	41 5d                	pop    %r13
    9886:	41 5e                	pop    %r14
    9888:	41 5f                	pop    %r15
    988a:	5d                   	pop    %rbp
    988b:	c3                   	retq   
    988c:	48 c7 c3 00 00 00 00 	mov    $0x0,%rbx
			*max_length = e1000_igp_cable_length_170;
			break;
		default:
			return -E1000_ERR_PHY;
		}
	} else if (hw->phy_type == e1000_phy_igp) {	/* For IGP PHY */
    9893:	41 bd 80 00 00 00    	mov    $0x80,%r13d
    9899:	30 c9                	xor    %cl,%cl
		};
		/* Read the AGC registers for all channels */
		for (i = 0; i < IGP01E1000_PHY_CHANNEL_NUM; i++) {

			ret_val =
			    e1000_read_phy_reg(hw, agc_reg_array[i], &phy_data);
    989b:	0f b7 33             	movzwl (%rbx),%esi
		       IGP01E1000_PHY_AGC_D
		};
		/* Read the AGC registers for all channels */
		for (i = 0; i < IGP01E1000_PHY_CHANNEL_NUM; i++) {

			ret_val =
    989e:	48 8d 55 d6          	lea    -0x2a(%rbp),%rdx
    98a2:	4c 89 e7             	mov    %r12,%rdi
    98a5:	89 4d cc             	mov    %ecx,-0x34(%rbp)
    98a8:	e8 00 00 00 00       	callq  98ad <e1000_get_cable_length+0x6d>
			    e1000_read_phy_reg(hw, agc_reg_array[i], &phy_data);
			if (ret_val)
    98ad:	85 c0                	test   %eax,%eax
    98af:	75 cc                	jne    987d <e1000_get_cable_length+0x3d>
				return ret_val;

			cur_agc_value = phy_data >> IGP01E1000_AGC_LENGTH_SHIFT;
    98b1:	0f b7 45 d6          	movzwl -0x2a(%rbp),%eax
    98b5:	66 c1 e8 07          	shr    $0x7,%ax

			/* Value bound check. */
			if ((cur_agc_value >=
			     IGP01E1000_AGC_LENGTH_TABLE_SIZE - 1)
			    || (cur_agc_value == 0))
    98b9:	8d 50 ff             	lea    -0x1(%rax),%edx
				return ret_val;

			cur_agc_value = phy_data >> IGP01E1000_AGC_LENGTH_SHIFT;

			/* Value bound check. */
			if ((cur_agc_value >=
    98bc:	66 83 fa 7d          	cmp    $0x7d,%dx
    98c0:	0f 87 25 01 00 00    	ja     99eb <e1000_get_cable_length+0x1ab>
			     IGP01E1000_AGC_LENGTH_TABLE_SIZE - 1)
			    || (cur_agc_value == 0))
				return -E1000_ERR_PHY;

			agc_value += cur_agc_value;
    98c6:	8b 4d cc             	mov    -0x34(%rbp),%ecx
    98c9:	01 c1                	add    %eax,%ecx
    98cb:	66 41 39 c5          	cmp    %ax,%r13w
    98cf:	44 0f 47 e8          	cmova  %eax,%r13d
    98d3:	48 83 c3 02          	add    $0x2,%rbx
		       IGP01E1000_PHY_AGC_B,
		       IGP01E1000_PHY_AGC_C,
		       IGP01E1000_PHY_AGC_D
		};
		/* Read the AGC registers for all channels */
		for (i = 0; i < IGP01E1000_PHY_CHANNEL_NUM; i++) {
    98d7:	48 81 fb 00 00 00 00 	cmp    $0x0,%rbx
    98de:	75 bb                	jne    989b <e1000_get_cable_length+0x5b>

			/* Get the average length of the remaining 3 channels */
			agc_value /= (IGP01E1000_PHY_CHANNEL_NUM - 1);
		} else {
			/* Get the average length of all the 4 channels. */
			agc_value /= IGP01E1000_PHY_CHANNEL_NUM;
    98e0:	89 c8                	mov    %ecx,%eax
    98e2:	66 c1 e8 02          	shr    $0x2,%ax
			if (min_agc_value > cur_agc_value)
				min_agc_value = cur_agc_value;
		}

		/* Remove the minimal AGC result for length < 50m */
		if (agc_value <
    98e6:	66 81 f9 c7 00       	cmp    $0xc7,%cx
    98eb:	77 11                	ja     98fe <e1000_get_cable_length+0xbe>
		    IGP01E1000_PHY_CHANNEL_NUM * e1000_igp_cable_length_50) {
			agc_value -= min_agc_value;
    98ed:	89 c8                	mov    %ecx,%eax
    98ef:	44 29 e8             	sub    %r13d,%eax

			/* Get the average length of the remaining 3 channels */
			agc_value /= (IGP01E1000_PHY_CHANNEL_NUM - 1);
    98f2:	0f b7 c0             	movzwl %ax,%eax
    98f5:	69 c0 ab aa 00 00    	imul   $0xaaab,%eax,%eax
    98fb:	c1 e8 11             	shr    $0x11,%eax
		}

		/* Set the range of the calculated length. */
		*min_length = ((e1000_igp_cable_length_table[agc_value] -
				IGP01E1000_AGC_RANGE) > 0) ?
		    (e1000_igp_cable_length_table[agc_value] -
    98fe:	25 ff 7f 00 00       	and    $0x7fff,%eax
		     IGP01E1000_AGC_RANGE) : 0;
    9903:	b9 00 00 00 00       	mov    $0x0,%ecx
		}

		/* Set the range of the calculated length. */
		*min_length = ((e1000_igp_cable_length_table[agc_value] -
				IGP01E1000_AGC_RANGE) > 0) ?
		    (e1000_igp_cable_length_table[agc_value] -
    9908:	0f b7 94 00 00 00 00 	movzwl 0x0(%rax,%rax,1),%edx
    990f:	00 
    9910:	0f b7 c2             	movzwl %dx,%eax
		     IGP01E1000_AGC_RANGE) : 0;
    9913:	83 e8 0a             	sub    $0xa,%eax
    9916:	0f 48 c1             	cmovs  %ecx,%eax
		*max_length = e1000_igp_cable_length_table[agc_value] +
    9919:	83 c2 0a             	add    $0xa,%edx
			/* Get the average length of all the 4 channels. */
			agc_value /= IGP01E1000_PHY_CHANNEL_NUM;
		}

		/* Set the range of the calculated length. */
		*min_length = ((e1000_igp_cable_length_table[agc_value] -
    991c:	66 41 89 06          	mov    %ax,(%r14)
				IGP01E1000_AGC_RANGE) > 0) ?
		    (e1000_igp_cable_length_table[agc_value] -
		     IGP01E1000_AGC_RANGE) : 0;
		*max_length = e1000_igp_cable_length_table[agc_value] +
    9920:	66 41 89 17          	mov    %dx,(%r15)
		    IGP01E1000_AGC_RANGE;
	}

	return E1000_SUCCESS;
}
    9924:	48 83 c4 10          	add    $0x10,%rsp
    9928:	5b                   	pop    %rbx
    9929:	41 5c                	pop    %r12
    992b:	41 5d                	pop    %r13
    992d:	41 5e                	pop    %r14
    992f:	41 5f                	pop    %r15
		     IGP01E1000_AGC_RANGE) : 0;
		*max_length = e1000_igp_cable_length_table[agc_value] +
		    IGP01E1000_AGC_RANGE;
	}

	return E1000_SUCCESS;
    9931:	31 c0                	xor    %eax,%eax
}
    9933:	5d                   	pop    %rbp
    9934:	c3                   	retq   
	*min_length = *max_length = 0;

	/* Use old method for Phy older than IGP */
	if (hw->phy_type == e1000_phy_m88) {

		ret_val = e1000_read_phy_reg(hw, M88E1000_PHY_SPEC_STATUS,
    9935:	48 8d 55 d6          	lea    -0x2a(%rbp),%rdx
    9939:	be 11 00 00 00       	mov    $0x11,%esi
    993e:	e8 00 00 00 00       	callq  9943 <e1000_get_cable_length+0x103>
					     &phy_data);
		if (ret_val)
    9943:	85 c0                	test   %eax,%eax
    9945:	0f 85 32 ff ff ff    	jne    987d <e1000_get_cable_length+0x3d>
			return ret_val;
		cable_length = (phy_data & M88E1000_PSSR_CABLE_LENGTH) >>
    994b:	0f b7 55 d6          	movzwl -0x2a(%rbp),%edx
		case e1000_cable_length_140:
			*min_length = e1000_igp_cable_length_140;
			*max_length = e1000_igp_cable_length_170;
			break;
		default:
			return -E1000_ERR_PHY;
    994f:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax

		ret_val = e1000_read_phy_reg(hw, M88E1000_PHY_SPEC_STATUS,
					     &phy_data);
		if (ret_val)
			return ret_val;
		cable_length = (phy_data & M88E1000_PSSR_CABLE_LENGTH) >>
    9954:	81 e2 80 03 00 00    	and    $0x380,%edx
    995a:	c1 fa 07             	sar    $0x7,%edx
		    M88E1000_PSSR_CABLE_LENGTH_SHIFT;

		/* Convert the enum value to ranged values */
		switch (cable_length) {
    995d:	83 fa 04             	cmp    $0x4,%edx
    9960:	0f 87 17 ff ff ff    	ja     987d <e1000_get_cable_length+0x3d>
    9966:	ff 24 d5 00 00 00 00 	jmpq   *0x0(,%rdx,8)
		case e1000_cable_length_80_110:
			*min_length = e1000_igp_cable_length_80;
			*max_length = e1000_igp_cable_length_110;
			break;
		case e1000_cable_length_110_140:
			*min_length = e1000_igp_cable_length_110;
    996d:	b9 6e 00 00 00       	mov    $0x6e,%ecx
			*max_length = e1000_igp_cable_length_140;
    9972:	be 8c 00 00 00       	mov    $0x8c,%esi
		     IGP01E1000_AGC_RANGE) : 0;
		*max_length = e1000_igp_cable_length_table[agc_value] +
		    IGP01E1000_AGC_RANGE;
	}

	return E1000_SUCCESS;
    9977:	31 c0                	xor    %eax,%eax
		case e1000_cable_length_80_110:
			*min_length = e1000_igp_cable_length_80;
			*max_length = e1000_igp_cable_length_110;
			break;
		case e1000_cable_length_110_140:
			*min_length = e1000_igp_cable_length_110;
    9979:	66 41 89 0e          	mov    %cx,(%r14)
			*max_length = e1000_igp_cable_length_140;
    997d:	66 41 89 37          	mov    %si,(%r15)
			break;
    9981:	e9 f7 fe ff ff       	jmpq   987d <e1000_get_cable_length+0x3d>
		case e1000_cable_length_50_80:
			*min_length = e1000_igp_cable_length_50;
			*max_length = e1000_igp_cable_length_80;
			break;
		case e1000_cable_length_80_110:
			*min_length = e1000_igp_cable_length_80;
    9986:	bf 50 00 00 00       	mov    $0x50,%edi
			*max_length = e1000_igp_cable_length_110;
    998b:	41 b8 6e 00 00 00    	mov    $0x6e,%r8d
		     IGP01E1000_AGC_RANGE) : 0;
		*max_length = e1000_igp_cable_length_table[agc_value] +
		    IGP01E1000_AGC_RANGE;
	}

	return E1000_SUCCESS;
    9991:	31 c0                	xor    %eax,%eax
		case e1000_cable_length_50_80:
			*min_length = e1000_igp_cable_length_50;
			*max_length = e1000_igp_cable_length_80;
			break;
		case e1000_cable_length_80_110:
			*min_length = e1000_igp_cable_length_80;
    9993:	66 41 89 3e          	mov    %di,(%r14)
			*max_length = e1000_igp_cable_length_110;
    9997:	66 45 89 07          	mov    %r8w,(%r15)
			break;
    999b:	e9 dd fe ff ff       	jmpq   987d <e1000_get_cable_length+0x3d>
		case e1000_cable_length_50:
			*min_length = 0;
			*max_length = e1000_igp_cable_length_50;
			break;
		case e1000_cable_length_50_80:
			*min_length = e1000_igp_cable_length_50;
    99a0:	41 b9 32 00 00 00    	mov    $0x32,%r9d
			*max_length = e1000_igp_cable_length_80;
    99a6:	41 ba 50 00 00 00    	mov    $0x50,%r10d
		     IGP01E1000_AGC_RANGE) : 0;
		*max_length = e1000_igp_cable_length_table[agc_value] +
		    IGP01E1000_AGC_RANGE;
	}

	return E1000_SUCCESS;
    99ac:	31 c0                	xor    %eax,%eax
		case e1000_cable_length_50:
			*min_length = 0;
			*max_length = e1000_igp_cable_length_50;
			break;
		case e1000_cable_length_50_80:
			*min_length = e1000_igp_cable_length_50;
    99ae:	66 45 89 0e          	mov    %r9w,(%r14)
			*max_length = e1000_igp_cable_length_80;
    99b2:	66 45 89 17          	mov    %r10w,(%r15)
			break;
    99b6:	e9 c2 fe ff ff       	jmpq   987d <e1000_get_cable_length+0x3d>
		    M88E1000_PSSR_CABLE_LENGTH_SHIFT;

		/* Convert the enum value to ranged values */
		switch (cable_length) {
		case e1000_cable_length_50:
			*min_length = 0;
    99bb:	45 31 db             	xor    %r11d,%r11d
			*max_length = e1000_igp_cable_length_50;
    99be:	bb 32 00 00 00       	mov    $0x32,%ebx
		     IGP01E1000_AGC_RANGE) : 0;
		*max_length = e1000_igp_cable_length_table[agc_value] +
		    IGP01E1000_AGC_RANGE;
	}

	return E1000_SUCCESS;
    99c3:	31 c0                	xor    %eax,%eax
		    M88E1000_PSSR_CABLE_LENGTH_SHIFT;

		/* Convert the enum value to ranged values */
		switch (cable_length) {
		case e1000_cable_length_50:
			*min_length = 0;
    99c5:	66 45 89 1e          	mov    %r11w,(%r14)
			*max_length = e1000_igp_cable_length_50;
    99c9:	66 41 89 1f          	mov    %bx,(%r15)
			break;
    99cd:	e9 ab fe ff ff       	jmpq   987d <e1000_get_cable_length+0x3d>
		case e1000_cable_length_110_140:
			*min_length = e1000_igp_cable_length_110;
			*max_length = e1000_igp_cable_length_140;
			break;
		case e1000_cable_length_140:
			*min_length = e1000_igp_cable_length_140;
    99d2:	b8 8c 00 00 00       	mov    $0x8c,%eax
			*max_length = e1000_igp_cable_length_170;
    99d7:	ba aa 00 00 00       	mov    $0xaa,%edx
		case e1000_cable_length_110_140:
			*min_length = e1000_igp_cable_length_110;
			*max_length = e1000_igp_cable_length_140;
			break;
		case e1000_cable_length_140:
			*min_length = e1000_igp_cable_length_140;
    99dc:	66 41 89 06          	mov    %ax,(%r14)
			*max_length = e1000_igp_cable_length_170;
    99e0:	66 41 89 17          	mov    %dx,(%r15)
		     IGP01E1000_AGC_RANGE) : 0;
		*max_length = e1000_igp_cable_length_table[agc_value] +
		    IGP01E1000_AGC_RANGE;
	}

	return E1000_SUCCESS;
    99e4:	31 c0                	xor    %eax,%eax
			*max_length = e1000_igp_cable_length_140;
			break;
		case e1000_cable_length_140:
			*min_length = e1000_igp_cable_length_140;
			*max_length = e1000_igp_cable_length_170;
			break;
    99e6:	e9 92 fe ff ff       	jmpq   987d <e1000_get_cable_length+0x3d>

			/* Value bound check. */
			if ((cur_agc_value >=
			     IGP01E1000_AGC_LENGTH_TABLE_SIZE - 1)
			    || (cur_agc_value == 0))
				return -E1000_ERR_PHY;
    99eb:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
    99f0:	e9 88 fe ff ff       	jmpq   987d <e1000_get_cable_length+0x3d>
    99f5:	66 66 2e 0f 1f 84 00 	data32 nopw %cs:0x0(%rax,%rax,1)
    99fc:	00 00 00 00 

0000000000009a00 <e1000_get_speed_and_duplex>:
 * @duplex: Duplex setting of the connection
 *
 * Detects the current speed and duplex settings of the hardware.
 */
s32 e1000_get_speed_and_duplex(struct e1000_hw *hw, u16 *speed, u16 *duplex)
{
    9a00:	e8 00 00 00 00       	callq  9a05 <e1000_get_speed_and_duplex+0x5>
    9a05:	55                   	push   %rbp
    9a06:	48 89 e5             	mov    %rsp,%rbp
    9a09:	41 56                	push   %r14
    9a0b:	41 55                	push   %r13
    9a0d:	49 89 f5             	mov    %rsi,%r13
    9a10:	41 54                	push   %r12
    9a12:	49 89 d4             	mov    %rdx,%r12
    9a15:	53                   	push   %rbx
    9a16:	48 89 fb             	mov    %rdi,%rbx
    9a19:	48 83 ec 08          	sub    $0x8,%rsp
	u32 status;
	s32 ret_val;
	u16 phy_data;

	if (hw->mac_type >= e1000_82543) {
    9a1d:	83 7f 18 02          	cmpl   $0x2,0x18(%rdi)
    9a21:	76 67                	jbe    9a8a <e1000_get_speed_and_duplex+0x8a>
		status = er32(STATUS);
    9a23:	48 8b 07             	mov    (%rdi),%rax
    9a26:	44 8b 70 08          	mov    0x8(%rax),%r14d
		if (status & E1000_STATUS_SPEED_1000) {
    9a2a:	41 f6 c6 80          	test   $0x80,%r14b
    9a2e:	0f 84 c0 00 00 00    	je     9af4 <e1000_get_speed_and_duplex+0xf4>
			*speed = SPEED_1000;
    9a34:	41 ba e8 03 00 00    	mov    $0x3e8,%r10d
    9a3a:	66 44 89 16          	mov    %r10w,(%rsi)
			e_dbg("1000 Mbs, ");
    9a3e:	f6 05 00 00 00 00 04 	testb  $0x4,0x0(%rip)        # 9a45 <e1000_get_speed_and_duplex+0x45>
    9a45:	0f 85 cb 01 00 00    	jne    9c16 <e1000_get_speed_and_duplex+0x216>
		} else {
			*speed = SPEED_10;
			e_dbg("10 Mbs, ");
		}

		if (status & E1000_STATUS_FD) {
    9a4b:	41 83 e6 01          	and    $0x1,%r14d
    9a4f:	0f 84 de 00 00 00    	je     9b33 <e1000_get_speed_and_duplex+0x133>
			*duplex = FULL_DUPLEX;
    9a55:	bf 02 00 00 00       	mov    $0x2,%edi
    9a5a:	66 41 89 3c 24       	mov    %di,(%r12)
			e_dbg("Full Duplex\n");
    9a5f:	f6 05 00 00 00 00 04 	testb  $0x4,0x0(%rip)        # 9a66 <e1000_get_speed_and_duplex+0x66>
    9a66:	74 43                	je     9aab <e1000_get_speed_and_duplex+0xab>
    9a68:	48 89 df             	mov    %rbx,%rdi
    9a6b:	e8 00 00 00 00       	callq  9a70 <e1000_get_speed_and_duplex+0x70>
    9a70:	48 c7 c2 00 00 00 00 	mov    $0x0,%rdx
    9a77:	48 89 c6             	mov    %rax,%rsi
    9a7a:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
    9a81:	31 c0                	xor    %eax,%eax
    9a83:	e8 00 00 00 00       	callq  9a88 <e1000_get_speed_and_duplex+0x88>
    9a88:	eb 21                	jmp    9aab <e1000_get_speed_and_duplex+0xab>
		} else {
			*duplex = HALF_DUPLEX;
			e_dbg(" Half Duplex\n");
		}
	} else {
		e_dbg("1000 Mbs, Full Duplex\n");
    9a8a:	f6 05 00 00 00 00 04 	testb  $0x4,0x0(%rip)        # 9a91 <e1000_get_speed_and_duplex+0x91>
    9a91:	0f 85 11 01 00 00    	jne    9ba8 <e1000_get_speed_and_duplex+0x1a8>
		*speed = SPEED_1000;
    9a97:	ba e8 03 00 00       	mov    $0x3e8,%edx
		*duplex = FULL_DUPLEX;
    9a9c:	b9 02 00 00 00       	mov    $0x2,%ecx
			*duplex = HALF_DUPLEX;
			e_dbg(" Half Duplex\n");
		}
	} else {
		e_dbg("1000 Mbs, Full Duplex\n");
		*speed = SPEED_1000;
    9aa1:	66 41 89 55 00       	mov    %dx,0x0(%r13)
		*duplex = FULL_DUPLEX;
    9aa6:	66 41 89 0c 24       	mov    %cx,(%r12)

	/* IGP01 PHY may advertise full duplex operation after speed downgrade
	 * even if it is operating at half duplex.  Here we set the duplex
	 * settings to match the duplex in the link partner's capabilities.
	 */
	if (hw->phy_type == e1000_phy_igp && hw->speed_downgraded) {
    9aab:	83 7b 1c 01          	cmpl   $0x1,0x1c(%rbx)
    9aaf:	74 0f                	je     9ac0 <e1000_get_speed_and_duplex+0xc0>
				&& !(phy_data & NWAY_LPAR_10T_FD_CAPS)))
				*duplex = HALF_DUPLEX;
		}
	}

	return E1000_SUCCESS;
    9ab1:	31 c0                	xor    %eax,%eax
}
    9ab3:	48 83 c4 08          	add    $0x8,%rsp
    9ab7:	5b                   	pop    %rbx
    9ab8:	41 5c                	pop    %r12
    9aba:	41 5d                	pop    %r13
    9abc:	41 5e                	pop    %r14
    9abe:	5d                   	pop    %rbp
    9abf:	c3                   	retq   

	/* IGP01 PHY may advertise full duplex operation after speed downgrade
	 * even if it is operating at half duplex.  Here we set the duplex
	 * settings to match the duplex in the link partner's capabilities.
	 */
	if (hw->phy_type == e1000_phy_igp && hw->speed_downgraded) {
    9ac0:	80 bb 01 01 00 00 00 	cmpb   $0x0,0x101(%rbx)
    9ac7:	74 e8                	je     9ab1 <e1000_get_speed_and_duplex+0xb1>
		ret_val = e1000_read_phy_reg(hw, PHY_AUTONEG_EXP, &phy_data);
    9ac9:	48 8d 55 de          	lea    -0x22(%rbp),%rdx
    9acd:	be 06 00 00 00       	mov    $0x6,%esi
    9ad2:	48 89 df             	mov    %rbx,%rdi
    9ad5:	e8 00 00 00 00       	callq  9ada <e1000_get_speed_and_duplex+0xda>
		if (ret_val)
    9ada:	85 c0                	test   %eax,%eax
    9adc:	75 d5                	jne    9ab3 <e1000_get_speed_and_duplex+0xb3>
			return ret_val;

		if (!(phy_data & NWAY_ER_LP_NWAY_CAPS))
    9ade:	f6 45 de 01          	testb  $0x1,-0x22(%rbp)
    9ae2:	0f 85 e2 00 00 00    	jne    9bca <e1000_get_speed_and_duplex+0x1ca>
			*duplex = HALF_DUPLEX;
    9ae8:	b8 01 00 00 00       	mov    $0x1,%eax
    9aed:	66 41 89 04 24       	mov    %ax,(%r12)
    9af2:	eb bd                	jmp    9ab1 <e1000_get_speed_and_duplex+0xb1>
	if (hw->mac_type >= e1000_82543) {
		status = er32(STATUS);
		if (status & E1000_STATUS_SPEED_1000) {
			*speed = SPEED_1000;
			e_dbg("1000 Mbs, ");
		} else if (status & E1000_STATUS_SPEED_100) {
    9af4:	41 f6 c6 40          	test   $0x40,%r14b
    9af8:	74 75                	je     9b6f <e1000_get_speed_and_duplex+0x16f>
			*speed = SPEED_100;
    9afa:	41 b9 64 00 00 00    	mov    $0x64,%r9d
    9b00:	66 44 89 0e          	mov    %r9w,(%rsi)
			e_dbg("100 Mbs, ");
    9b04:	f6 05 00 00 00 00 04 	testb  $0x4,0x0(%rip)        # 9b0b <e1000_get_speed_and_duplex+0x10b>
    9b0b:	0f 84 3a ff ff ff    	je     9a4b <e1000_get_speed_and_duplex+0x4b>
    9b11:	e8 00 00 00 00       	callq  9b16 <e1000_get_speed_and_duplex+0x116>
    9b16:	48 c7 c2 00 00 00 00 	mov    $0x0,%rdx
    9b1d:	48 89 c6             	mov    %rax,%rsi
    9b20:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
    9b27:	31 c0                	xor    %eax,%eax
    9b29:	e8 00 00 00 00       	callq  9b2e <e1000_get_speed_and_duplex+0x12e>
    9b2e:	e9 18 ff ff ff       	jmpq   9a4b <e1000_get_speed_and_duplex+0x4b>

		if (status & E1000_STATUS_FD) {
			*duplex = FULL_DUPLEX;
			e_dbg("Full Duplex\n");
		} else {
			*duplex = HALF_DUPLEX;
    9b33:	be 01 00 00 00       	mov    $0x1,%esi
    9b38:	66 41 89 34 24       	mov    %si,(%r12)
			e_dbg(" Half Duplex\n");
    9b3d:	f6 05 00 00 00 00 04 	testb  $0x4,0x0(%rip)        # 9b44 <e1000_get_speed_and_duplex+0x144>
    9b44:	0f 84 61 ff ff ff    	je     9aab <e1000_get_speed_and_duplex+0xab>
    9b4a:	48 89 df             	mov    %rbx,%rdi
    9b4d:	e8 00 00 00 00       	callq  9b52 <e1000_get_speed_and_duplex+0x152>
    9b52:	48 c7 c2 00 00 00 00 	mov    $0x0,%rdx
    9b59:	48 89 c6             	mov    %rax,%rsi
    9b5c:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
    9b63:	31 c0                	xor    %eax,%eax
    9b65:	e8 00 00 00 00       	callq  9b6a <e1000_get_speed_and_duplex+0x16a>
    9b6a:	e9 3c ff ff ff       	jmpq   9aab <e1000_get_speed_and_duplex+0xab>
			e_dbg("1000 Mbs, ");
		} else if (status & E1000_STATUS_SPEED_100) {
			*speed = SPEED_100;
			e_dbg("100 Mbs, ");
		} else {
			*speed = SPEED_10;
    9b6f:	41 b8 0a 00 00 00    	mov    $0xa,%r8d
    9b75:	66 44 89 06          	mov    %r8w,(%rsi)
			e_dbg("10 Mbs, ");
    9b79:	f6 05 00 00 00 00 04 	testb  $0x4,0x0(%rip)        # 9b80 <e1000_get_speed_and_duplex+0x180>
    9b80:	0f 84 c5 fe ff ff    	je     9a4b <e1000_get_speed_and_duplex+0x4b>
    9b86:	e8 00 00 00 00       	callq  9b8b <e1000_get_speed_and_duplex+0x18b>
    9b8b:	48 c7 c2 00 00 00 00 	mov    $0x0,%rdx
    9b92:	48 89 c6             	mov    %rax,%rsi
    9b95:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
    9b9c:	31 c0                	xor    %eax,%eax
    9b9e:	e8 00 00 00 00       	callq  9ba3 <e1000_get_speed_and_duplex+0x1a3>
    9ba3:	e9 a3 fe ff ff       	jmpq   9a4b <e1000_get_speed_and_duplex+0x4b>
		} else {
			*duplex = HALF_DUPLEX;
			e_dbg(" Half Duplex\n");
		}
	} else {
		e_dbg("1000 Mbs, Full Duplex\n");
    9ba8:	e8 00 00 00 00       	callq  9bad <e1000_get_speed_and_duplex+0x1ad>
    9bad:	48 c7 c2 00 00 00 00 	mov    $0x0,%rdx
    9bb4:	48 89 c6             	mov    %rax,%rsi
    9bb7:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
    9bbe:	31 c0                	xor    %eax,%eax
    9bc0:	e8 00 00 00 00       	callq  9bc5 <e1000_get_speed_and_duplex+0x1c5>
    9bc5:	e9 cd fe ff ff       	jmpq   9a97 <e1000_get_speed_and_duplex+0x97>
			return ret_val;

		if (!(phy_data & NWAY_ER_LP_NWAY_CAPS))
			*duplex = HALF_DUPLEX;
		else {
			ret_val =
    9bca:	48 8d 55 de          	lea    -0x22(%rbp),%rdx
    9bce:	be 05 00 00 00       	mov    $0x5,%esi
    9bd3:	48 89 df             	mov    %rbx,%rdi
    9bd6:	e8 00 00 00 00       	callq  9bdb <e1000_get_speed_and_duplex+0x1db>
			    e1000_read_phy_reg(hw, PHY_LP_ABILITY, &phy_data);
			if (ret_val)
    9bdb:	85 c0                	test   %eax,%eax
    9bdd:	0f 85 d0 fe ff ff    	jne    9ab3 <e1000_get_speed_and_duplex+0xb3>
				return ret_val;
			if ((*speed == SPEED_100
    9be3:	41 0f b7 45 00       	movzwl 0x0(%r13),%eax
    9be8:	66 83 f8 64          	cmp    $0x64,%ax
    9bec:	74 19                	je     9c07 <e1000_get_speed_and_duplex+0x207>
			     && !(phy_data & NWAY_LPAR_100TX_FD_CAPS))
			    || (*speed == SPEED_10
    9bee:	66 83 f8 0a          	cmp    $0xa,%ax
    9bf2:	0f 85 b9 fe ff ff    	jne    9ab1 <e1000_get_speed_and_duplex+0xb1>
				&& !(phy_data & NWAY_LPAR_10T_FD_CAPS)))
    9bf8:	f6 45 de 40          	testb  $0x40,-0x22(%rbp)
    9bfc:	0f 84 e6 fe ff ff    	je     9ae8 <e1000_get_speed_and_duplex+0xe8>
    9c02:	e9 aa fe ff ff       	jmpq   9ab1 <e1000_get_speed_and_duplex+0xb1>
			ret_val =
			    e1000_read_phy_reg(hw, PHY_LP_ABILITY, &phy_data);
			if (ret_val)
				return ret_val;
			if ((*speed == SPEED_100
			     && !(phy_data & NWAY_LPAR_100TX_FD_CAPS))
    9c07:	f6 45 df 01          	testb  $0x1,-0x21(%rbp)
    9c0b:	0f 84 d7 fe ff ff    	je     9ae8 <e1000_get_speed_and_duplex+0xe8>
    9c11:	e9 9b fe ff ff       	jmpq   9ab1 <e1000_get_speed_and_duplex+0xb1>

	if (hw->mac_type >= e1000_82543) {
		status = er32(STATUS);
		if (status & E1000_STATUS_SPEED_1000) {
			*speed = SPEED_1000;
			e_dbg("1000 Mbs, ");
    9c16:	e8 00 00 00 00       	callq  9c1b <e1000_get_speed_and_duplex+0x21b>
    9c1b:	48 c7 c2 00 00 00 00 	mov    $0x0,%rdx
    9c22:	48 89 c6             	mov    %rax,%rsi
    9c25:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
    9c2c:	31 c0                	xor    %eax,%eax
    9c2e:	e8 00 00 00 00       	callq  9c33 <e1000_get_speed_and_duplex+0x233>
    9c33:	e9 13 fe ff ff       	jmpq   9a4b <e1000_get_speed_and_duplex+0x4b>
    9c38:	0f 1f 84 00 00 00 00 	nopl   0x0(%rax,%rax,1)
    9c3f:	00 

0000000000009c40 <e1000_config_fc_after_link_up>:
 * and autonegotiation is enabled, the MAC flow control settings will be set
 * based on the flow control negotiated by the PHY. In TBI mode, the TFCE
 * and RFCE bits will be automatically set to the negotiated flow control mode.
 */
static s32 e1000_config_fc_after_link_up(struct e1000_hw *hw)
{
    9c40:	e8 00 00 00 00       	callq  9c45 <e1000_config_fc_after_link_up+0x5>
    9c45:	55                   	push   %rbp
    9c46:	48 89 e5             	mov    %rsp,%rbp
    9c49:	41 54                	push   %r12
    9c4b:	53                   	push   %rbx
    9c4c:	48 89 fb             	mov    %rdi,%rbx
    9c4f:	48 83 ec 10          	sub    $0x10,%rsp

	/* Check for the case where we have fiber media and auto-neg failed
	 * so we had to force link.  In this case, we need to force the
	 * configuration of the MAC to match the "fc" parameter.
	 */
	if (((hw->media_type == e1000_media_type_fiber) && (hw->autoneg_failed))
    9c53:	8b 47 24             	mov    0x24(%rdi),%eax
	    || ((hw->media_type == e1000_media_type_internal_serdes)
    9c56:	8d 50 ff             	lea    -0x1(%rax),%edx

	/* Check for the case where we have fiber media and auto-neg failed
	 * so we had to force link.  In this case, we need to force the
	 * configuration of the MAC to match the "fc" parameter.
	 */
	if (((hw->media_type == e1000_media_type_fiber) && (hw->autoneg_failed))
    9c59:	83 fa 01             	cmp    $0x1,%edx
    9c5c:	76 76                	jbe    9cd4 <e1000_config_fc_after_link_up+0x94>
	    || ((hw->media_type == e1000_media_type_internal_serdes)
		&& (hw->autoneg_failed))
	    || ((hw->media_type == e1000_media_type_copper)
    9c5e:	85 c0                	test   %eax,%eax
    9c60:	0f 85 9b 00 00 00    	jne    9d01 <e1000_config_fc_after_link_up+0xc1>
		&& (!hw->autoneg))) {
    9c66:	80 bf ef 00 00 00 00 	cmpb   $0x0,0xef(%rdi)
    9c6d:	74 6f                	je     9cde <e1000_config_fc_after_link_up+0x9e>
	if ((hw->media_type == e1000_media_type_copper) && hw->autoneg) {
		/* Read the MII Status Register and check to see if AutoNeg
		 * has completed.  We read this twice because this reg has
		 * some "sticky" (latched) bits.
		 */
		ret_val = e1000_read_phy_reg(hw, PHY_STATUS, &mii_status_reg);
    9c6f:	48 8d 55 e6          	lea    -0x1a(%rbp),%rdx
    9c73:	be 01 00 00 00       	mov    $0x1,%esi
    9c78:	48 89 df             	mov    %rbx,%rdi
    9c7b:	e8 00 00 00 00       	callq  9c80 <e1000_config_fc_after_link_up+0x40>
		if (ret_val)
    9c80:	85 c0                	test   %eax,%eax
	if ((hw->media_type == e1000_media_type_copper) && hw->autoneg) {
		/* Read the MII Status Register and check to see if AutoNeg
		 * has completed.  We read this twice because this reg has
		 * some "sticky" (latched) bits.
		 */
		ret_val = e1000_read_phy_reg(hw, PHY_STATUS, &mii_status_reg);
    9c82:	41 89 c4             	mov    %eax,%r12d
		if (ret_val)
    9c85:	75 7d                	jne    9d04 <e1000_config_fc_after_link_up+0xc4>
			return ret_val;
		ret_val = e1000_read_phy_reg(hw, PHY_STATUS, &mii_status_reg);
    9c87:	48 8d 55 e6          	lea    -0x1a(%rbp),%rdx
    9c8b:	be 01 00 00 00       	mov    $0x1,%esi
    9c90:	48 89 df             	mov    %rbx,%rdi
    9c93:	e8 00 00 00 00       	callq  9c98 <e1000_config_fc_after_link_up+0x58>
		if (ret_val)
    9c98:	85 c0                	test   %eax,%eax
		 * some "sticky" (latched) bits.
		 */
		ret_val = e1000_read_phy_reg(hw, PHY_STATUS, &mii_status_reg);
		if (ret_val)
			return ret_val;
		ret_val = e1000_read_phy_reg(hw, PHY_STATUS, &mii_status_reg);
    9c9a:	41 89 c4             	mov    %eax,%r12d
		if (ret_val)
    9c9d:	75 65                	jne    9d04 <e1000_config_fc_after_link_up+0xc4>
			return ret_val;

		if (mii_status_reg & MII_SR_AUTONEG_COMPLETE) {
    9c9f:	f6 45 e6 20          	testb  $0x20,-0x1a(%rbp)
    9ca3:	0f 85 92 00 00 00    	jne    9d3b <e1000_config_fc_after_link_up+0xfb>
				e_dbg
				    ("Error forcing flow control settings\n");
				return ret_val;
			}
		} else {
			e_dbg
    9ca9:	f6 05 00 00 00 00 04 	testb  $0x4,0x0(%rip)        # 9cb0 <e1000_config_fc_after_link_up+0x70>
    9cb0:	74 4f                	je     9d01 <e1000_config_fc_after_link_up+0xc1>
    9cb2:	48 89 df             	mov    %rbx,%rdi
    9cb5:	e8 00 00 00 00       	callq  9cba <e1000_config_fc_after_link_up+0x7a>
    9cba:	48 c7 c2 00 00 00 00 	mov    $0x0,%rdx
    9cc1:	48 89 c6             	mov    %rax,%rsi
    9cc4:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
    9ccb:	31 c0                	xor    %eax,%eax
    9ccd:	e8 00 00 00 00       	callq  9cd2 <e1000_config_fc_after_link_up+0x92>
    9cd2:	eb 30                	jmp    9d04 <e1000_config_fc_after_link_up+0xc4>
	/* Check for the case where we have fiber media and auto-neg failed
	 * so we had to force link.  In this case, we need to force the
	 * configuration of the MAC to match the "fc" parameter.
	 */
	if (((hw->media_type == e1000_media_type_fiber) && (hw->autoneg_failed))
	    || ((hw->media_type == e1000_media_type_internal_serdes)
    9cd4:	8b 97 94 00 00 00    	mov    0x94(%rdi),%edx
    9cda:	85 d2                	test   %edx,%edx
    9cdc:	74 23                	je     9d01 <e1000_config_fc_after_link_up+0xc1>
		&& (hw->autoneg_failed))
	    || ((hw->media_type == e1000_media_type_copper)
		&& (!hw->autoneg))) {
		ret_val = e1000_force_mac_fc(hw);
    9cde:	48 89 df             	mov    %rbx,%rdi
    9ce1:	e8 00 00 00 00       	callq  9ce6 <e1000_config_fc_after_link_up+0xa6>
		if (ret_val) {
    9ce6:	85 c0                	test   %eax,%eax
	if (((hw->media_type == e1000_media_type_fiber) && (hw->autoneg_failed))
	    || ((hw->media_type == e1000_media_type_internal_serdes)
		&& (hw->autoneg_failed))
	    || ((hw->media_type == e1000_media_type_copper)
		&& (!hw->autoneg))) {
		ret_val = e1000_force_mac_fc(hw);
    9ce8:	41 89 c4             	mov    %eax,%r12d
		if (ret_val) {
    9ceb:	75 23                	jne    9d10 <e1000_config_fc_after_link_up+0xd0>
	/* Check for the case where we have copper media and auto-neg is
	 * enabled.  In this case, we need to check and see if Auto-Neg
	 * has completed, and if so, how the PHY and link partner has
	 * flow control configured.
	 */
	if ((hw->media_type == e1000_media_type_copper) && hw->autoneg) {
    9ced:	8b 43 24             	mov    0x24(%rbx),%eax
    9cf0:	85 c0                	test   %eax,%eax
    9cf2:	75 0d                	jne    9d01 <e1000_config_fc_after_link_up+0xc1>
    9cf4:	80 bb ef 00 00 00 00 	cmpb   $0x0,0xef(%rbx)
    9cfb:	0f 85 6e ff ff ff    	jne    9c6f <e1000_config_fc_after_link_up+0x2f>
		} else {
			e_dbg
			    ("Copper PHY and Auto Neg has not completed.\n");
		}
	}
	return E1000_SUCCESS;
    9d01:	45 31 e4             	xor    %r12d,%r12d
}
    9d04:	48 83 c4 10          	add    $0x10,%rsp
    9d08:	44 89 e0             	mov    %r12d,%eax
    9d0b:	5b                   	pop    %rbx
    9d0c:	41 5c                	pop    %r12
    9d0e:	5d                   	pop    %rbp
    9d0f:	c3                   	retq   
		&& (hw->autoneg_failed))
	    || ((hw->media_type == e1000_media_type_copper)
		&& (!hw->autoneg))) {
		ret_val = e1000_force_mac_fc(hw);
		if (ret_val) {
			e_dbg("Error forcing flow control settings\n");
    9d10:	f6 05 00 00 00 00 04 	testb  $0x4,0x0(%rip)        # 9d17 <e1000_config_fc_after_link_up+0xd7>
    9d17:	74 eb                	je     9d04 <e1000_config_fc_after_link_up+0xc4>
    9d19:	48 89 df             	mov    %rbx,%rdi
    9d1c:	e8 00 00 00 00       	callq  9d21 <e1000_config_fc_after_link_up+0xe1>
    9d21:	48 c7 c2 00 00 00 00 	mov    $0x0,%rdx
    9d28:	48 89 c6             	mov    %rax,%rsi
    9d2b:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
    9d32:	31 c0                	xor    %eax,%eax
    9d34:	e8 00 00 00 00       	callq  9d39 <e1000_config_fc_after_link_up+0xf9>
    9d39:	eb c9                	jmp    9d04 <e1000_config_fc_after_link_up+0xc4>
			 * read both the Auto Negotiation Advertisement Register
			 * (Address 4) and the Auto_Negotiation Base Page
			 * Ability Register (Address 5) to determine how flow
			 * control was negotiated.
			 */
			ret_val = e1000_read_phy_reg(hw, PHY_AUTONEG_ADV,
    9d3b:	48 8d 55 e8          	lea    -0x18(%rbp),%rdx
    9d3f:	be 04 00 00 00       	mov    $0x4,%esi
    9d44:	48 89 df             	mov    %rbx,%rdi
    9d47:	e8 00 00 00 00       	callq  9d4c <e1000_config_fc_after_link_up+0x10c>
						     &mii_nway_adv_reg);
			if (ret_val)
    9d4c:	85 c0                	test   %eax,%eax
    9d4e:	41 89 c4             	mov    %eax,%r12d
    9d51:	75 b1                	jne    9d04 <e1000_config_fc_after_link_up+0xc4>
				return ret_val;
			ret_val = e1000_read_phy_reg(hw, PHY_LP_ABILITY,
    9d53:	48 8d 55 ea          	lea    -0x16(%rbp),%rdx
    9d57:	be 05 00 00 00       	mov    $0x5,%esi
    9d5c:	48 89 df             	mov    %rbx,%rdi
    9d5f:	e8 00 00 00 00       	callq  9d64 <e1000_config_fc_after_link_up+0x124>
						     &mii_nway_lp_ability_reg);
			if (ret_val)
    9d64:	85 c0                	test   %eax,%eax
    9d66:	41 89 c4             	mov    %eax,%r12d
    9d69:	75 99                	jne    9d04 <e1000_config_fc_after_link_up+0xc4>
			 * PAUSE | ASM_DIR | PAUSE | ASM_DIR | Result
			 *-------|---------|-------|---------|------------------
			 *   1   |   DC    |   1   |   DC    | E1000_FC_FULL
			 *
			 */
			if ((mii_nway_adv_reg & NWAY_AR_PAUSE) &&
    9d6b:	0f b7 45 e8          	movzwl -0x18(%rbp),%eax
    9d6f:	f6 c4 04             	test   $0x4,%ah
    9d72:	74 74                	je     9de8 <e1000_config_fc_after_link_up+0x1a8>
    9d74:	f6 45 eb 04          	testb  $0x4,-0x15(%rbp)
    9d78:	74 6e                	je     9de8 <e1000_config_fc_after_link_up+0x1a8>
				 * to advertise FULL flow control because we
				 * could not advertise Rx ONLY. Hence, we must
				 * now check to see if we need to turn OFF the
				 * TRANSMISSION of PAUSE frames.
				 */
				if (hw->original_fc == E1000_FC_FULL) {
    9d7a:	83 bb 8c 00 00 00 03 	cmpl   $0x3,0x8c(%rbx)
    9d81:	0f 84 fa 01 00 00    	je     9f81 <e1000_config_fc_after_link_up+0x341>
					hw->fc = E1000_FC_FULL;
					e_dbg("Flow Control = FULL.\n");
				} else {
					hw->fc = E1000_FC_RX_PAUSE;
    9d87:	c7 43 40 01 00 00 00 	movl   $0x1,0x40(%rbx)
					e_dbg
    9d8e:	f6 05 00 00 00 00 04 	testb  $0x4,0x0(%rip)        # 9d95 <e1000_config_fc_after_link_up+0x155>
    9d95:	0f 85 1f 02 00 00    	jne    9fba <e1000_config_fc_after_link_up+0x37a>

			/* Now we need to do one last check...  If we auto-
			 * negotiated to HALF DUPLEX, flow control should not be
			 * enabled per IEEE 802.3 spec.
			 */
			ret_val =
    9d9b:	48 8d 55 ee          	lea    -0x12(%rbp),%rdx
    9d9f:	48 8d 75 ec          	lea    -0x14(%rbp),%rsi
    9da3:	48 89 df             	mov    %rbx,%rdi
    9da6:	e8 00 00 00 00       	callq  9dab <e1000_config_fc_after_link_up+0x16b>
			    e1000_get_speed_and_duplex(hw, &speed, &duplex);
			if (ret_val) {
    9dab:	85 c0                	test   %eax,%eax

			/* Now we need to do one last check...  If we auto-
			 * negotiated to HALF DUPLEX, flow control should not be
			 * enabled per IEEE 802.3 spec.
			 */
			ret_val =
    9dad:	41 89 c4             	mov    %eax,%r12d
			    e1000_get_speed_and_duplex(hw, &speed, &duplex);
			if (ret_val) {
    9db0:	0f 84 a0 00 00 00    	je     9e56 <e1000_config_fc_after_link_up+0x216>
				e_dbg
    9db6:	f6 05 00 00 00 00 04 	testb  $0x4,0x0(%rip)        # 9dbd <e1000_config_fc_after_link_up+0x17d>
    9dbd:	0f 84 41 ff ff ff    	je     9d04 <e1000_config_fc_after_link_up+0xc4>
    9dc3:	48 89 df             	mov    %rbx,%rdi
    9dc6:	e8 00 00 00 00       	callq  9dcb <e1000_config_fc_after_link_up+0x18b>
    9dcb:	48 c7 c2 00 00 00 00 	mov    $0x0,%rdx
    9dd2:	48 89 c6             	mov    %rax,%rsi
    9dd5:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
    9ddc:	31 c0                	xor    %eax,%eax
    9dde:	e8 00 00 00 00       	callq  9de3 <e1000_config_fc_after_link_up+0x1a3>
    9de3:	e9 1c ff ff ff       	jmpq   9d04 <e1000_config_fc_after_link_up+0xc4>
			 * PAUSE | ASM_DIR | PAUSE | ASM_DIR | Result
			 *-------|---------|-------|---------|------------------
			 *   0   |    1    |   1   |    1    | E1000_FC_TX_PAUSE
			 *
			 */
			else if (!(mii_nway_adv_reg & NWAY_AR_PAUSE) &&
    9de8:	66 25 00 0c          	and    $0xc00,%ax
    9dec:	66 3d 00 08          	cmp    $0x800,%ax
    9df0:	0f 84 e9 00 00 00    	je     9edf <e1000_config_fc_after_link_up+0x29f>
			 * PAUSE | ASM_DIR | PAUSE | ASM_DIR | Result
			 *-------|---------|-------|---------|------------------
			 *   1   |    1    |   0   |    1    | E1000_FC_RX_PAUSE
			 *
			 */
			else if ((mii_nway_adv_reg & NWAY_AR_PAUSE) &&
    9df6:	66 3d 00 0c          	cmp    $0xc00,%ax
    9dfa:	0f 84 2a 01 00 00    	je     9f2a <e1000_config_fc_after_link_up+0x2ea>
			 * cases, since we are predominantly a server NIC, more
			 * times than not we will be asked to delay transmission
			 * of packets than asking our link partner to pause
			 * transmission of frames.
			 */
			else if ((hw->original_fc == E1000_FC_NONE ||
    9e00:	f7 83 8c 00 00 00 fd 	testl  $0xfffffffd,0x8c(%rbx)
    9e07:	ff ff ff 
    9e0a:	0f 84 96 00 00 00    	je     9ea6 <e1000_config_fc_after_link_up+0x266>
				  hw->original_fc == E1000_FC_TX_PAUSE) ||
    9e10:	80 bb 14 01 00 00 00 	cmpb   $0x0,0x114(%rbx)
    9e17:	0f 85 89 00 00 00    	jne    9ea6 <e1000_config_fc_after_link_up+0x266>
				 hw->fc_strict_ieee) {
				hw->fc = E1000_FC_NONE;
				e_dbg("Flow Control = NONE.\n");
			} else {
				hw->fc = E1000_FC_RX_PAUSE;
    9e1d:	c7 43 40 01 00 00 00 	movl   $0x1,0x40(%rbx)
				e_dbg
    9e24:	f6 05 00 00 00 00 04 	testb  $0x4,0x0(%rip)        # 9e2b <e1000_config_fc_after_link_up+0x1eb>
    9e2b:	0f 84 6a ff ff ff    	je     9d9b <e1000_config_fc_after_link_up+0x15b>
    9e31:	48 89 df             	mov    %rbx,%rdi
    9e34:	e8 00 00 00 00       	callq  9e39 <e1000_config_fc_after_link_up+0x1f9>
    9e39:	48 c7 c2 00 00 00 00 	mov    $0x0,%rdx
    9e40:	48 89 c6             	mov    %rax,%rsi
    9e43:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
    9e4a:	31 c0                	xor    %eax,%eax
    9e4c:	e8 00 00 00 00       	callq  9e51 <e1000_config_fc_after_link_up+0x211>
    9e51:	e9 45 ff ff ff       	jmpq   9d9b <e1000_config_fc_after_link_up+0x15b>
				e_dbg
				    ("Error getting link speed and duplex\n");
				return ret_val;
			}

			if (duplex == HALF_DUPLEX)
    9e56:	66 83 7d ee 01       	cmpw   $0x1,-0x12(%rbp)
    9e5b:	0f 84 14 01 00 00    	je     9f75 <e1000_config_fc_after_link_up+0x335>
				hw->fc = E1000_FC_NONE;

			/* Now we call a subroutine to actually force the MAC
			 * controller to use the correct flow control settings.
			 */
			ret_val = e1000_force_mac_fc(hw);
    9e61:	48 89 df             	mov    %rbx,%rdi
    9e64:	e8 00 00 00 00       	callq  9e69 <e1000_config_fc_after_link_up+0x229>
			if (ret_val) {
    9e69:	85 c0                	test   %eax,%eax
				hw->fc = E1000_FC_NONE;

			/* Now we call a subroutine to actually force the MAC
			 * controller to use the correct flow control settings.
			 */
			ret_val = e1000_force_mac_fc(hw);
    9e6b:	41 89 c4             	mov    %eax,%r12d
			if (ret_val) {
    9e6e:	0f 84 8d fe ff ff    	je     9d01 <e1000_config_fc_after_link_up+0xc1>
				e_dbg
    9e74:	f6 05 00 00 00 00 04 	testb  $0x4,0x0(%rip)        # 9e7b <e1000_config_fc_after_link_up+0x23b>
    9e7b:	0f 84 83 fe ff ff    	je     9d04 <e1000_config_fc_after_link_up+0xc4>
    9e81:	48 89 df             	mov    %rbx,%rdi
    9e84:	e8 00 00 00 00       	callq  9e89 <e1000_config_fc_after_link_up+0x249>
    9e89:	48 c7 c2 00 00 00 00 	mov    $0x0,%rdx
    9e90:	48 89 c6             	mov    %rax,%rsi
    9e93:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
    9e9a:	31 c0                	xor    %eax,%eax
    9e9c:	e8 00 00 00 00       	callq  9ea1 <e1000_config_fc_after_link_up+0x261>
    9ea1:	e9 5e fe ff ff       	jmpq   9d04 <e1000_config_fc_after_link_up+0xc4>
			 * transmission of frames.
			 */
			else if ((hw->original_fc == E1000_FC_NONE ||
				  hw->original_fc == E1000_FC_TX_PAUSE) ||
				 hw->fc_strict_ieee) {
				hw->fc = E1000_FC_NONE;
    9ea6:	c7 43 40 00 00 00 00 	movl   $0x0,0x40(%rbx)
				e_dbg("Flow Control = NONE.\n");
    9ead:	f6 05 00 00 00 00 04 	testb  $0x4,0x0(%rip)        # 9eb4 <e1000_config_fc_after_link_up+0x274>
    9eb4:	0f 84 e1 fe ff ff    	je     9d9b <e1000_config_fc_after_link_up+0x15b>
    9eba:	48 89 df             	mov    %rbx,%rdi
    9ebd:	e8 00 00 00 00       	callq  9ec2 <e1000_config_fc_after_link_up+0x282>
    9ec2:	48 c7 c2 00 00 00 00 	mov    $0x0,%rdx
    9ec9:	48 89 c6             	mov    %rax,%rsi
    9ecc:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
    9ed3:	31 c0                	xor    %eax,%eax
    9ed5:	e8 00 00 00 00       	callq  9eda <e1000_config_fc_after_link_up+0x29a>
    9eda:	e9 bc fe ff ff       	jmpq   9d9b <e1000_config_fc_after_link_up+0x15b>
			 *   0   |    1    |   1   |    1    | E1000_FC_TX_PAUSE
			 *
			 */
			else if (!(mii_nway_adv_reg & NWAY_AR_PAUSE) &&
				 (mii_nway_adv_reg & NWAY_AR_ASM_DIR) &&
				 (mii_nway_lp_ability_reg & NWAY_LPAR_PAUSE) &&
    9edf:	0f b7 45 ea          	movzwl -0x16(%rbp),%eax
    9ee3:	66 25 00 0c          	and    $0xc00,%ax
    9ee7:	66 3d 00 0c          	cmp    $0xc00,%ax
    9eeb:	0f 85 0f ff ff ff    	jne    9e00 <e1000_config_fc_after_link_up+0x1c0>
				 (mii_nway_lp_ability_reg & NWAY_LPAR_ASM_DIR))
			{
				hw->fc = E1000_FC_TX_PAUSE;
    9ef1:	c7 43 40 02 00 00 00 	movl   $0x2,0x40(%rbx)
				e_dbg
    9ef8:	f6 05 00 00 00 00 04 	testb  $0x4,0x0(%rip)        # 9eff <e1000_config_fc_after_link_up+0x2bf>
    9eff:	0f 84 96 fe ff ff    	je     9d9b <e1000_config_fc_after_link_up+0x15b>
    9f05:	48 89 df             	mov    %rbx,%rdi
    9f08:	e8 00 00 00 00       	callq  9f0d <e1000_config_fc_after_link_up+0x2cd>
    9f0d:	48 c7 c2 00 00 00 00 	mov    $0x0,%rdx
    9f14:	48 89 c6             	mov    %rax,%rsi
    9f17:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
    9f1e:	31 c0                	xor    %eax,%eax
    9f20:	e8 00 00 00 00       	callq  9f25 <e1000_config_fc_after_link_up+0x2e5>
    9f25:	e9 71 fe ff ff       	jmpq   9d9b <e1000_config_fc_after_link_up+0x15b>
			 *   1   |    1    |   0   |    1    | E1000_FC_RX_PAUSE
			 *
			 */
			else if ((mii_nway_adv_reg & NWAY_AR_PAUSE) &&
				 (mii_nway_adv_reg & NWAY_AR_ASM_DIR) &&
				 !(mii_nway_lp_ability_reg & NWAY_LPAR_PAUSE) &&
    9f2a:	0f b7 45 ea          	movzwl -0x16(%rbp),%eax
    9f2e:	66 25 00 0c          	and    $0xc00,%ax
    9f32:	66 3d 00 08          	cmp    $0x800,%ax
    9f36:	0f 85 c4 fe ff ff    	jne    9e00 <e1000_config_fc_after_link_up+0x1c0>
				 (mii_nway_lp_ability_reg & NWAY_LPAR_ASM_DIR))
			{
				hw->fc = E1000_FC_RX_PAUSE;
    9f3c:	c7 43 40 01 00 00 00 	movl   $0x1,0x40(%rbx)
				e_dbg
    9f43:	f6 05 00 00 00 00 04 	testb  $0x4,0x0(%rip)        # 9f4a <e1000_config_fc_after_link_up+0x30a>
    9f4a:	0f 84 4b fe ff ff    	je     9d9b <e1000_config_fc_after_link_up+0x15b>
    9f50:	48 89 df             	mov    %rbx,%rdi
    9f53:	e8 00 00 00 00       	callq  9f58 <e1000_config_fc_after_link_up+0x318>
    9f58:	48 c7 c2 00 00 00 00 	mov    $0x0,%rdx
    9f5f:	48 89 c6             	mov    %rax,%rsi
    9f62:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
    9f69:	31 c0                	xor    %eax,%eax
    9f6b:	e8 00 00 00 00       	callq  9f70 <e1000_config_fc_after_link_up+0x330>
    9f70:	e9 26 fe ff ff       	jmpq   9d9b <e1000_config_fc_after_link_up+0x15b>
				    ("Error getting link speed and duplex\n");
				return ret_val;
			}

			if (duplex == HALF_DUPLEX)
				hw->fc = E1000_FC_NONE;
    9f75:	c7 43 40 00 00 00 00 	movl   $0x0,0x40(%rbx)
    9f7c:	e9 e0 fe ff ff       	jmpq   9e61 <e1000_config_fc_after_link_up+0x221>
				 * could not advertise Rx ONLY. Hence, we must
				 * now check to see if we need to turn OFF the
				 * TRANSMISSION of PAUSE frames.
				 */
				if (hw->original_fc == E1000_FC_FULL) {
					hw->fc = E1000_FC_FULL;
    9f81:	c7 43 40 03 00 00 00 	movl   $0x3,0x40(%rbx)
					e_dbg("Flow Control = FULL.\n");
    9f88:	f6 05 00 00 00 00 04 	testb  $0x4,0x0(%rip)        # 9f8f <e1000_config_fc_after_link_up+0x34f>
    9f8f:	0f 84 06 fe ff ff    	je     9d9b <e1000_config_fc_after_link_up+0x15b>
    9f95:	48 89 df             	mov    %rbx,%rdi
    9f98:	e8 00 00 00 00       	callq  9f9d <e1000_config_fc_after_link_up+0x35d>
    9f9d:	48 c7 c2 00 00 00 00 	mov    $0x0,%rdx
    9fa4:	48 89 c6             	mov    %rax,%rsi
    9fa7:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
    9fae:	31 c0                	xor    %eax,%eax
    9fb0:	e8 00 00 00 00       	callq  9fb5 <e1000_config_fc_after_link_up+0x375>
    9fb5:	e9 e1 fd ff ff       	jmpq   9d9b <e1000_config_fc_after_link_up+0x15b>
				} else {
					hw->fc = E1000_FC_RX_PAUSE;
					e_dbg
    9fba:	48 89 df             	mov    %rbx,%rdi
    9fbd:	e8 00 00 00 00       	callq  9fc2 <e1000_config_fc_after_link_up+0x382>
    9fc2:	48 c7 c2 00 00 00 00 	mov    $0x0,%rdx
    9fc9:	48 89 c6             	mov    %rax,%rsi
    9fcc:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
    9fd3:	31 c0                	xor    %eax,%eax
    9fd5:	e8 00 00 00 00       	callq  9fda <e1000_config_fc_after_link_up+0x39a>
    9fda:	e9 bc fd ff ff       	jmpq   9d9b <e1000_config_fc_after_link_up+0x15b>
    9fdf:	90                   	nop

0000000000009fe0 <e1000_check_polarity>:
 * return 0.  If the link speed is 1000 Mbps the polarity status is in the
 * IGP01E1000_PHY_PCS_INIT_REG.
 */
static s32 e1000_check_polarity(struct e1000_hw *hw,
				e1000_rev_polarity *polarity)
{
    9fe0:	e8 00 00 00 00       	callq  9fe5 <e1000_check_polarity+0x5>
    9fe5:	55                   	push   %rbp
    9fe6:	48 89 e5             	mov    %rsp,%rbp
    9fe9:	41 54                	push   %r12
    9feb:	49 89 f4             	mov    %rsi,%r12
    9fee:	53                   	push   %rbx
    9fef:	48 89 fb             	mov    %rdi,%rbx
    9ff2:	48 83 ec 08          	sub    $0x8,%rsp
	s32 ret_val;
	u16 phy_data;

	if (hw->phy_type == e1000_phy_m88) {
    9ff6:	8b 57 1c             	mov    0x1c(%rdi),%edx
    9ff9:	85 d2                	test   %edx,%edx
    9ffb:	74 10                	je     a00d <e1000_check_polarity+0x2d>
			    (phy_data & IGP01E1000_PSSR_POLARITY_REVERSED) ?
			    e1000_rev_polarity_reversed :
			    e1000_rev_polarity_normal;
		}
	}
	return E1000_SUCCESS;
    9ffd:	31 c0                	xor    %eax,%eax
			return ret_val;
		*polarity = ((phy_data & M88E1000_PSSR_REV_POLARITY) >>
			     M88E1000_PSSR_REV_POLARITY_SHIFT) ?
		    e1000_rev_polarity_reversed : e1000_rev_polarity_normal;

	} else if (hw->phy_type == e1000_phy_igp) {
    9fff:	83 fa 01             	cmp    $0x1,%edx
    a002:	74 31                	je     a035 <e1000_check_polarity+0x55>
			    e1000_rev_polarity_reversed :
			    e1000_rev_polarity_normal;
		}
	}
	return E1000_SUCCESS;
}
    a004:	48 83 c4 08          	add    $0x8,%rsp
    a008:	5b                   	pop    %rbx
    a009:	41 5c                	pop    %r12
    a00b:	5d                   	pop    %rbp
    a00c:	c3                   	retq   
	s32 ret_val;
	u16 phy_data;

	if (hw->phy_type == e1000_phy_m88) {
		/* return the Polarity bit in the Status register. */
		ret_val = e1000_read_phy_reg(hw, M88E1000_PHY_SPEC_STATUS,
    a00d:	48 8d 55 ee          	lea    -0x12(%rbp),%rdx
    a011:	be 11 00 00 00       	mov    $0x11,%esi
    a016:	e8 00 00 00 00       	callq  a01b <e1000_check_polarity+0x3b>
					     &phy_data);
		if (ret_val)
    a01b:	85 c0                	test   %eax,%eax
    a01d:	75 e5                	jne    a004 <e1000_check_polarity+0x24>
			return ret_val;
		*polarity = ((phy_data & M88E1000_PSSR_REV_POLARITY) >>
    a01f:	0f b7 55 ee          	movzwl -0x12(%rbp),%edx
    a023:	d1 ea                	shr    %edx
    a025:	83 e2 01             	and    $0x1,%edx
    a028:	41 89 14 24          	mov    %edx,(%r12)
			    e1000_rev_polarity_reversed :
			    e1000_rev_polarity_normal;
		}
	}
	return E1000_SUCCESS;
}
    a02c:	48 83 c4 08          	add    $0x8,%rsp
    a030:	5b                   	pop    %rbx
    a031:	41 5c                	pop    %r12
    a033:	5d                   	pop    %rbp
    a034:	c3                   	retq   
			     M88E1000_PSSR_REV_POLARITY_SHIFT) ?
		    e1000_rev_polarity_reversed : e1000_rev_polarity_normal;

	} else if (hw->phy_type == e1000_phy_igp) {
		/* Read the Status register to check the speed */
		ret_val = e1000_read_phy_reg(hw, IGP01E1000_PHY_PORT_STATUS,
    a035:	48 8d 55 ee          	lea    -0x12(%rbp),%rdx
    a039:	be 11 00 00 00       	mov    $0x11,%esi
    a03e:	e8 00 00 00 00       	callq  a043 <e1000_check_polarity+0x63>
					     &phy_data);
		if (ret_val)
    a043:	85 c0                	test   %eax,%eax
    a045:	75 bd                	jne    a004 <e1000_check_polarity+0x24>
			return ret_val;

		/* If speed is 1000 Mbps, must read the
		 * IGP01E1000_PHY_PCS_INIT_REG to find the polarity status
		 */
		if ((phy_data & IGP01E1000_PSSR_SPEED_MASK) ==
    a047:	0f b7 55 ee          	movzwl -0x12(%rbp),%edx
    a04b:	89 d1                	mov    %edx,%ecx
    a04d:	66 81 e1 00 c0       	and    $0xc000,%cx
    a052:	66 81 f9 00 c0       	cmp    $0xc000,%cx
    a057:	74 0c                	je     a065 <e1000_check_polarity+0x85>
			/* For 10 Mbps, read the polarity bit in the status
			 * register. (for 100 Mbps this bit is always 0)
			 */
			*polarity =
			    (phy_data & IGP01E1000_PSSR_POLARITY_REVERSED) ?
			    e1000_rev_polarity_reversed :
    a059:	66 d1 ea             	shr    %dx
    a05c:	83 e2 01             	and    $0x1,%edx
			    e1000_rev_polarity_normal;
		} else {
			/* For 10 Mbps, read the polarity bit in the status
			 * register. (for 100 Mbps this bit is always 0)
			 */
			*polarity =
    a05f:	41 89 14 24          	mov    %edx,(%r12)
    a063:	eb 9f                	jmp    a004 <e1000_check_polarity+0x24>
		 */
		if ((phy_data & IGP01E1000_PSSR_SPEED_MASK) ==
		    IGP01E1000_PSSR_SPEED_1000MBPS) {

			/* Read the GIG initialization PCS register (0x00B4) */
			ret_val =
    a065:	48 8d 55 ee          	lea    -0x12(%rbp),%rdx
    a069:	be b4 00 00 00       	mov    $0xb4,%esi
    a06e:	48 89 df             	mov    %rbx,%rdi
    a071:	e8 00 00 00 00       	callq  a076 <e1000_check_polarity+0x96>
			    e1000_read_phy_reg(hw, IGP01E1000_PHY_PCS_INIT_REG,
					       &phy_data);
			if (ret_val)
    a076:	85 c0                	test   %eax,%eax
    a078:	75 8a                	jne    a004 <e1000_check_polarity+0x24>
				return ret_val;

			/* Check the polarity bits */
			*polarity = (phy_data & IGP01E1000_PHY_POLARITY_MASK) ?
			    e1000_rev_polarity_reversed :
    a07a:	31 d2                	xor    %edx,%edx
    a07c:	f6 45 ee 78          	testb  $0x78,-0x12(%rbp)
    a080:	0f 95 c2             	setne  %dl
					       &phy_data);
			if (ret_val)
				return ret_val;

			/* Check the polarity bits */
			*polarity = (phy_data & IGP01E1000_PHY_POLARITY_MASK) ?
    a083:	41 89 14 24          	mov    %edx,(%r12)
    a087:	e9 78 ff ff ff       	jmpq   a004 <e1000_check_polarity+0x24>
    a08c:	0f 1f 40 00          	nopl   0x0(%rax)

000000000000a090 <e1000_write_phy_reg>:
 * @data: data to write to the PHY
 *
 * Writes a value to a PHY register
 */
s32 e1000_write_phy_reg(struct e1000_hw *hw, u32 reg_addr, u16 phy_data)
{
    a090:	e8 00 00 00 00       	callq  a095 <e1000_write_phy_reg+0x5>
    a095:	55                   	push   %rbp
    a096:	48 89 e5             	mov    %rsp,%rbp
    a099:	41 56                	push   %r14
    a09b:	41 89 d6             	mov    %edx,%r14d
    a09e:	41 55                	push   %r13
    a0a0:	41 54                	push   %r12
    a0a2:	41 89 f4             	mov    %esi,%r12d
    a0a5:	53                   	push   %rbx
    a0a6:	48 89 fb             	mov    %rdi,%rbx
	u32 ret_val;
	unsigned long flags;

	spin_lock_irqsave(&e1000_phy_lock, flags);
    a0a9:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
 * @data: data to write to the PHY
 *
 * Writes a value to a PHY register
 */
s32 e1000_write_phy_reg(struct e1000_hw *hw, u32 reg_addr, u16 phy_data)
{
    a0b0:	48 83 ec 08          	sub    $0x8,%rsp
	u32 ret_val;
	unsigned long flags;

	spin_lock_irqsave(&e1000_phy_lock, flags);
    a0b4:	e8 00 00 00 00       	callq  a0b9 <e1000_write_phy_reg+0x29>

	if ((hw->phy_type == e1000_phy_igp) &&
    a0b9:	83 7b 1c 01          	cmpl   $0x1,0x1c(%rbx)
s32 e1000_write_phy_reg(struct e1000_hw *hw, u32 reg_addr, u16 phy_data)
{
	u32 ret_val;
	unsigned long flags;

	spin_lock_irqsave(&e1000_phy_lock, flags);
    a0bd:	49 89 c5             	mov    %rax,%r13

	if ((hw->phy_type == e1000_phy_igp) &&
    a0c0:	74 32                	je     a0f4 <e1000_write_phy_reg+0x64>
			spin_unlock_irqrestore(&e1000_phy_lock, flags);
			return ret_val;
		}
	}

	ret_val = e1000_write_phy_reg_ex(hw, MAX_PHY_REG_ADDRESS & reg_addr,
    a0c2:	44 89 e6             	mov    %r12d,%esi
    a0c5:	48 89 df             	mov    %rbx,%rdi
    a0c8:	41 0f b7 d6          	movzwl %r14w,%edx
    a0cc:	83 e6 1f             	and    $0x1f,%esi
    a0cf:	e8 6c e9 ff ff       	callq  8a40 <e1000_write_phy_reg_ex>
    a0d4:	4c 89 ee             	mov    %r13,%rsi
    a0d7:	89 c3                	mov    %eax,%ebx
    a0d9:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
    a0e0:	e8 00 00 00 00       	callq  a0e5 <e1000_write_phy_reg+0x55>
					 phy_data);
	spin_unlock_irqrestore(&e1000_phy_lock, flags);

	return ret_val;
    a0e5:	89 d8                	mov    %ebx,%eax
}
    a0e7:	48 83 c4 08          	add    $0x8,%rsp
    a0eb:	5b                   	pop    %rbx
    a0ec:	41 5c                	pop    %r12
    a0ee:	41 5d                	pop    %r13
    a0f0:	41 5e                	pop    %r14
    a0f2:	5d                   	pop    %rbp
    a0f3:	c3                   	retq   
	u32 ret_val;
	unsigned long flags;

	spin_lock_irqsave(&e1000_phy_lock, flags);

	if ((hw->phy_type == e1000_phy_igp) &&
    a0f4:	41 83 fc 0f          	cmp    $0xf,%r12d
    a0f8:	76 c8                	jbe    a0c2 <e1000_write_phy_reg+0x32>
    a0fa:	41 0f b7 d4          	movzwl %r12w,%edx
	    (reg_addr > MAX_PHY_MULTI_PAGE_REG)) {
		ret_val = e1000_write_phy_reg_ex(hw, IGP01E1000_PHY_PAGE_SELECT,
    a0fe:	be 1f 00 00 00       	mov    $0x1f,%esi
    a103:	48 89 df             	mov    %rbx,%rdi
    a106:	e8 35 e9 ff ff       	callq  8a40 <e1000_write_phy_reg_ex>
						 (u16) reg_addr);
		if (ret_val) {
    a10b:	85 c0                	test   %eax,%eax
    a10d:	74 b3                	je     a0c2 <e1000_write_phy_reg+0x32>
    a10f:	4c 89 ee             	mov    %r13,%rsi
    a112:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
    a119:	89 45 dc             	mov    %eax,-0x24(%rbp)
    a11c:	e8 00 00 00 00       	callq  a121 <e1000_write_phy_reg+0x91>
			spin_unlock_irqrestore(&e1000_phy_lock, flags);
			return ret_val;
    a121:	8b 45 dc             	mov    -0x24(%rbp),%eax
    a124:	eb c1                	jmp    a0e7 <e1000_write_phy_reg+0x57>
    a126:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    a12d:	00 00 00 

000000000000a130 <e1000_phy_init_script.part.13>:

/**
 * e1000_phy_init_script - IGP phy init script - initializes the GbE PHY
 * @hw: Struct containing variables accessed by shared code
 */
static void e1000_phy_init_script(struct e1000_hw *hw)
    a130:	e8 00 00 00 00       	callq  a135 <e1000_phy_init_script.part.13+0x5>
    a135:	55                   	push   %rbp
    a136:	48 89 e5             	mov    %rsp,%rbp
    a139:	53                   	push   %rbx
    a13a:	48 89 fb             	mov    %rdi,%rbx
{
	u32 ret_val;
	u16 phy_saved_data;

	if (hw->phy_init_script) {
		msleep(20);
    a13d:	bf 14 00 00 00       	mov    $0x14,%edi

/**
 * e1000_phy_init_script - IGP phy init script - initializes the GbE PHY
 * @hw: Struct containing variables accessed by shared code
 */
static void e1000_phy_init_script(struct e1000_hw *hw)
    a142:	48 83 ec 08          	sub    $0x8,%rsp
{
	u32 ret_val;
	u16 phy_saved_data;

	if (hw->phy_init_script) {
		msleep(20);
    a146:	e8 00 00 00 00       	callq  a14b <e1000_phy_init_script.part.13+0x1b>

		/* Save off the current value of register 0x2F5B to be restored
		 * at the end of this routine.
		 */
		ret_val = e1000_read_phy_reg(hw, 0x2F5B, &phy_saved_data);
    a14b:	48 8d 55 f4          	lea    -0xc(%rbp),%rdx
    a14f:	be 5b 2f 00 00       	mov    $0x2f5b,%esi
    a154:	48 89 df             	mov    %rbx,%rdi
    a157:	e8 00 00 00 00       	callq  a15c <e1000_phy_init_script.part.13+0x2c>

		/* Disabled the PHY transmitter */
		e1000_write_phy_reg(hw, 0x2F5B, 0x0003);
    a15c:	ba 03 00 00 00       	mov    $0x3,%edx
    a161:	be 5b 2f 00 00       	mov    $0x2f5b,%esi
    a166:	48 89 df             	mov    %rbx,%rdi
    a169:	e8 00 00 00 00       	callq  a16e <e1000_phy_init_script.part.13+0x3e>
		msleep(20);
    a16e:	bf 14 00 00 00       	mov    $0x14,%edi
    a173:	e8 00 00 00 00       	callq  a178 <e1000_phy_init_script.part.13+0x48>

		e1000_write_phy_reg(hw, 0x0000, 0x0140);
    a178:	31 f6                	xor    %esi,%esi
    a17a:	ba 40 01 00 00       	mov    $0x140,%edx
    a17f:	48 89 df             	mov    %rbx,%rdi
    a182:	e8 00 00 00 00       	callq  a187 <e1000_phy_init_script.part.13+0x57>
		msleep(5);
    a187:	bf 05 00 00 00       	mov    $0x5,%edi
    a18c:	e8 00 00 00 00       	callq  a191 <e1000_phy_init_script.part.13+0x61>

		switch (hw->mac_type) {
    a191:	8b 43 18             	mov    0x18(%rbx),%eax
    a194:	83 f8 0c             	cmp    $0xc,%eax
    a197:	0f 84 f7 00 00 00    	je     a294 <e1000_phy_init_script.part.13+0x164>
    a19d:	76 49                	jbe    a1e8 <e1000_phy_init_script.part.13+0xb8>
    a19f:	83 f8 0d             	cmp    $0xd,%eax
    a1a2:	74 49                	je     a1ed <e1000_phy_init_script.part.13+0xbd>
    a1a4:	83 f8 0e             	cmp    $0xe,%eax
    a1a7:	0f 84 e7 00 00 00    	je     a294 <e1000_phy_init_script.part.13+0x164>
			break;
		default:
			break;
		}

		e1000_write_phy_reg(hw, 0x0000, 0x3300);
    a1ad:	31 f6                	xor    %esi,%esi
    a1af:	ba 00 33 00 00       	mov    $0x3300,%edx
    a1b4:	48 89 df             	mov    %rbx,%rdi
    a1b7:	e8 00 00 00 00       	callq  a1bc <e1000_phy_init_script.part.13+0x8c>
		msleep(20);
    a1bc:	bf 14 00 00 00       	mov    $0x14,%edi
    a1c1:	e8 00 00 00 00       	callq  a1c6 <e1000_phy_init_script.part.13+0x96>

		/* Now enable the transmitter */
		e1000_write_phy_reg(hw, 0x2F5B, phy_saved_data);
    a1c6:	0f b7 55 f4          	movzwl -0xc(%rbp),%edx
    a1ca:	be 5b 2f 00 00       	mov    $0x2f5b,%esi
    a1cf:	48 89 df             	mov    %rbx,%rdi
    a1d2:	e8 00 00 00 00       	callq  a1d7 <e1000_phy_init_script.part.13+0xa7>

		if (hw->mac_type == e1000_82547) {
    a1d7:	83 7b 18 0d          	cmpl   $0xd,0x18(%rbx)
    a1db:	0f 84 ca 00 00 00    	je     a2ab <e1000_phy_init_script.part.13+0x17b>
						    IGP01E1000_ANALOG_FUSE_BYPASS,
						    IGP01E1000_ANALOG_FUSE_ENABLE_SW_CONTROL);
			}
		}
	}
}
    a1e1:	48 83 c4 08          	add    $0x8,%rsp
    a1e5:	5b                   	pop    %rbx
    a1e6:	5d                   	pop    %rbp
    a1e7:	c3                   	retq   
		msleep(20);

		e1000_write_phy_reg(hw, 0x0000, 0x0140);
		msleep(5);

		switch (hw->mac_type) {
    a1e8:	83 f8 0b             	cmp    $0xb,%eax
    a1eb:	75 c0                	jne    a1ad <e1000_phy_init_script.part.13+0x7d>
		case e1000_82541:
		case e1000_82547:
			e1000_write_phy_reg(hw, 0x1F95, 0x0001);
    a1ed:	48 89 df             	mov    %rbx,%rdi
    a1f0:	ba 01 00 00 00       	mov    $0x1,%edx
    a1f5:	be 95 1f 00 00       	mov    $0x1f95,%esi
    a1fa:	e8 00 00 00 00       	callq  a1ff <e1000_phy_init_script.part.13+0xcf>
			e1000_write_phy_reg(hw, 0x1F71, 0xBD21);
    a1ff:	48 89 df             	mov    %rbx,%rdi
    a202:	ba 21 bd 00 00       	mov    $0xbd21,%edx
    a207:	be 71 1f 00 00       	mov    $0x1f71,%esi
    a20c:	e8 00 00 00 00       	callq  a211 <e1000_phy_init_script.part.13+0xe1>
			e1000_write_phy_reg(hw, 0x1F79, 0x0018);
    a211:	48 89 df             	mov    %rbx,%rdi
    a214:	ba 18 00 00 00       	mov    $0x18,%edx
    a219:	be 79 1f 00 00       	mov    $0x1f79,%esi
    a21e:	e8 00 00 00 00       	callq  a223 <e1000_phy_init_script.part.13+0xf3>
			e1000_write_phy_reg(hw, 0x1F30, 0x1600);
    a223:	48 89 df             	mov    %rbx,%rdi
    a226:	ba 00 16 00 00       	mov    $0x1600,%edx
    a22b:	be 30 1f 00 00       	mov    $0x1f30,%esi
    a230:	e8 00 00 00 00       	callq  a235 <e1000_phy_init_script.part.13+0x105>
			e1000_write_phy_reg(hw, 0x1F31, 0x0014);
    a235:	48 89 df             	mov    %rbx,%rdi
    a238:	ba 14 00 00 00       	mov    $0x14,%edx
    a23d:	be 31 1f 00 00       	mov    $0x1f31,%esi
    a242:	e8 00 00 00 00       	callq  a247 <e1000_phy_init_script.part.13+0x117>
			e1000_write_phy_reg(hw, 0x1F32, 0x161C);
    a247:	48 89 df             	mov    %rbx,%rdi
    a24a:	ba 1c 16 00 00       	mov    $0x161c,%edx
    a24f:	be 32 1f 00 00       	mov    $0x1f32,%esi
    a254:	e8 00 00 00 00       	callq  a259 <e1000_phy_init_script.part.13+0x129>
			e1000_write_phy_reg(hw, 0x1F94, 0x0003);
    a259:	48 89 df             	mov    %rbx,%rdi
    a25c:	ba 03 00 00 00       	mov    $0x3,%edx
    a261:	be 94 1f 00 00       	mov    $0x1f94,%esi
    a266:	e8 00 00 00 00       	callq  a26b <e1000_phy_init_script.part.13+0x13b>
			e1000_write_phy_reg(hw, 0x1F96, 0x003F);
    a26b:	48 89 df             	mov    %rbx,%rdi
    a26e:	ba 3f 00 00 00       	mov    $0x3f,%edx
    a273:	be 96 1f 00 00       	mov    $0x1f96,%esi
    a278:	e8 00 00 00 00       	callq  a27d <e1000_phy_init_script.part.13+0x14d>
			e1000_write_phy_reg(hw, 0x2010, 0x0008);
    a27d:	ba 08 00 00 00       	mov    $0x8,%edx
    a282:	be 10 20 00 00       	mov    $0x2010,%esi
    a287:	48 89 df             	mov    %rbx,%rdi
    a28a:	e8 00 00 00 00       	callq  a28f <e1000_phy_init_script.part.13+0x15f>
    a28f:	e9 19 ff ff ff       	jmpq   a1ad <e1000_phy_init_script.part.13+0x7d>
			break;

		case e1000_82541_rev_2:
		case e1000_82547_rev_2:
			e1000_write_phy_reg(hw, 0x1F73, 0x0099);
    a294:	ba 99 00 00 00       	mov    $0x99,%edx
    a299:	be 73 1f 00 00       	mov    $0x1f73,%esi
    a29e:	48 89 df             	mov    %rbx,%rdi
    a2a1:	e8 00 00 00 00       	callq  a2a6 <e1000_phy_init_script.part.13+0x176>
    a2a6:	e9 02 ff ff ff       	jmpq   a1ad <e1000_phy_init_script.part.13+0x7d>

		if (hw->mac_type == e1000_82547) {
			u16 fused, fine, coarse;

			/* Move to analog registers page */
			e1000_read_phy_reg(hw,
    a2ab:	48 8d 55 f6          	lea    -0xa(%rbp),%rdx
    a2af:	be d1 20 00 00       	mov    $0x20d1,%esi
    a2b4:	48 89 df             	mov    %rbx,%rdi
    a2b7:	e8 00 00 00 00       	callq  a2bc <e1000_phy_init_script.part.13+0x18c>
					   IGP01E1000_ANALOG_SPARE_FUSE_STATUS,
					   &fused);

			if (!(fused & IGP01E1000_ANALOG_SPARE_FUSE_ENABLED)) {
    a2bc:	f6 45 f7 01          	testb  $0x1,-0x9(%rbp)
    a2c0:	0f 85 1b ff ff ff    	jne    a1e1 <e1000_phy_init_script.part.13+0xb1>
				e1000_read_phy_reg(hw,
    a2c6:	48 8d 55 f6          	lea    -0xa(%rbp),%rdx
    a2ca:	be d0 20 00 00       	mov    $0x20d0,%esi
    a2cf:	48 89 df             	mov    %rbx,%rdi
    a2d2:	e8 00 00 00 00       	callq  a2d7 <e1000_phy_init_script.part.13+0x1a7>
						   IGP01E1000_ANALOG_FUSE_STATUS,
						   &fused);

				fine = fused & IGP01E1000_ANALOG_FUSE_FINE_MASK;
    a2d7:	0f b7 4d f6          	movzwl -0xa(%rbp),%ecx
				coarse =
    a2db:	89 c8                	mov    %ecx,%eax
			if (!(fused & IGP01E1000_ANALOG_SPARE_FUSE_ENABLED)) {
				e1000_read_phy_reg(hw,
						   IGP01E1000_ANALOG_FUSE_STATUS,
						   &fused);

				fine = fused & IGP01E1000_ANALOG_FUSE_FINE_MASK;
    a2dd:	89 ca                	mov    %ecx,%edx
				coarse =
    a2df:	83 e0 70             	and    $0x70,%eax
			if (!(fused & IGP01E1000_ANALOG_SPARE_FUSE_ENABLED)) {
				e1000_read_phy_reg(hw,
						   IGP01E1000_ANALOG_FUSE_STATUS,
						   &fused);

				fine = fused & IGP01E1000_ANALOG_FUSE_FINE_MASK;
    a2e2:	66 81 e2 80 0f       	and    $0xf80,%dx
				coarse =
				    fused & IGP01E1000_ANALOG_FUSE_COARSE_MASK;

				if (coarse >
    a2e7:	66 83 f8 40          	cmp    $0x40,%ax
    a2eb:	77 49                	ja     a336 <e1000_phy_init_script.part.13+0x206>
					coarse -=
					    IGP01E1000_ANALOG_FUSE_COARSE_10;
					fine -= IGP01E1000_ANALOG_FUSE_FINE_1;
				} else if (coarse ==
					   IGP01E1000_ANALOG_FUSE_COARSE_THRESH)
					fine -= IGP01E1000_ANALOG_FUSE_FINE_10;
    a2ed:	8d b2 00 fb ff ff    	lea    -0x500(%rdx),%esi
    a2f3:	66 83 f8 40          	cmp    $0x40,%ax
    a2f7:	0f 44 d6             	cmove  %esi,%edx

				fused =
    a2fa:	83 e0 70             	and    $0x70,%eax
    a2fd:	66 81 e2 80 0f       	and    $0xf80,%dx
    a302:	66 81 e1 00 f0       	and    $0xf000,%cx
    a307:	09 c2                	or     %eax,%edx
				    (fused & IGP01E1000_ANALOG_FUSE_POLY_MASK) |
				    (fine & IGP01E1000_ANALOG_FUSE_FINE_MASK) |
				    (coarse &
				     IGP01E1000_ANALOG_FUSE_COARSE_MASK);

				e1000_write_phy_reg(hw,
    a309:	48 89 df             	mov    %rbx,%rdi
    a30c:	be dc 20 00 00       	mov    $0x20dc,%esi
					fine -= IGP01E1000_ANALOG_FUSE_FINE_1;
				} else if (coarse ==
					   IGP01E1000_ANALOG_FUSE_COARSE_THRESH)
					fine -= IGP01E1000_ANALOG_FUSE_FINE_10;

				fused =
    a311:	09 ca                	or     %ecx,%edx
    a313:	66 89 55 f6          	mov    %dx,-0xa(%rbp)
				    (fused & IGP01E1000_ANALOG_FUSE_POLY_MASK) |
				    (fine & IGP01E1000_ANALOG_FUSE_FINE_MASK) |
				    (coarse &
				     IGP01E1000_ANALOG_FUSE_COARSE_MASK);

				e1000_write_phy_reg(hw,
    a317:	0f b7 d2             	movzwl %dx,%edx
    a31a:	e8 00 00 00 00       	callq  a31f <e1000_phy_init_script.part.13+0x1ef>
						    IGP01E1000_ANALOG_FUSE_CONTROL,
						    fused);
				e1000_write_phy_reg(hw,
    a31f:	ba 02 00 00 00       	mov    $0x2,%edx
    a324:	be de 20 00 00       	mov    $0x20de,%esi
    a329:	48 89 df             	mov    %rbx,%rdi
    a32c:	e8 00 00 00 00       	callq  a331 <e1000_phy_init_script.part.13+0x201>
    a331:	e9 ab fe ff ff       	jmpq   a1e1 <e1000_phy_init_script.part.13+0xb1>
				coarse =
				    fused & IGP01E1000_ANALOG_FUSE_COARSE_MASK;

				if (coarse >
				    IGP01E1000_ANALOG_FUSE_COARSE_THRESH) {
					coarse -=
    a336:	83 e8 10             	sub    $0x10,%eax
					    IGP01E1000_ANALOG_FUSE_COARSE_10;
					fine -= IGP01E1000_ANALOG_FUSE_FINE_1;
    a339:	83 c2 80             	add    $0xffffff80,%edx
    a33c:	eb bc                	jmp    a2fa <e1000_phy_init_script.part.13+0x1ca>
    a33e:	66 90                	xchg   %ax,%ax

000000000000a340 <e1000_reset_hw>:
 * @hw: Struct containing variables accessed by shared code
 *
 * Reset the transmit and receive units; mask and clear all interrupts.
 */
s32 e1000_reset_hw(struct e1000_hw *hw)
{
    a340:	e8 00 00 00 00       	callq  a345 <e1000_reset_hw+0x5>
    a345:	55                   	push   %rbp
    a346:	48 89 e5             	mov    %rsp,%rbp
    a349:	41 55                	push   %r13
    a34b:	41 54                	push   %r12
    a34d:	53                   	push   %rbx
	u32 manc;
	u32 led_ctrl;
	s32 ret_val;

	/* For 82542 (rev 2.0), disable MWI before issuing a device reset */
	if (hw->mac_type == e1000_82542_rev2_0) {
    a34e:	83 7f 18 01          	cmpl   $0x1,0x18(%rdi)
 * @hw: Struct containing variables accessed by shared code
 *
 * Reset the transmit and receive units; mask and clear all interrupts.
 */
s32 e1000_reset_hw(struct e1000_hw *hw)
{
    a352:	48 89 fb             	mov    %rdi,%rbx
	u32 manc;
	u32 led_ctrl;
	s32 ret_val;

	/* For 82542 (rev 2.0), disable MWI before issuing a device reset */
	if (hw->mac_type == e1000_82542_rev2_0) {
    a355:	0f 84 c9 01 00 00    	je     a524 <e1000_reset_hw+0x1e4>
		e_dbg("Disabling MWI on 82542 rev 2.0\n");
		e1000_pci_clear_mwi(hw);
	}

	/* Clear interrupt mask to stop board from generating interrupts */
	e_dbg("Masking off all interrupts\n");
    a35b:	f6 05 00 00 00 00 04 	testb  $0x4,0x0(%rip)        # a362 <e1000_reset_hw+0x22>
    a362:	0f 85 21 02 00 00    	jne    a589 <e1000_reset_hw+0x249>
	ew32(IMC, 0xffffffff);
    a368:	48 8b 13             	mov    (%rbx),%rdx
build_mmio_read(__readw, "w", unsigned short, "=r", )
build_mmio_read(__readl, "l", unsigned int, "=r", )

build_mmio_write(writeb, "b", unsigned char, "q", :"memory")
build_mmio_write(writew, "w", unsigned short, "r", :"memory")
build_mmio_write(writel, "l", unsigned int, "r", :"memory")
    a36b:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
    a370:	89 82 d8 00 00 00    	mov    %eax,0xd8(%rdx)
    a376:	31 c0                	xor    %eax,%eax

	/* Disable the Transmit and Receive units.  Then delay to allow
	 * any pending transactions to complete before we hit the MAC with
	 * the global reset.
	 */
	ew32(RCTL, 0);
    a378:	48 8b 13             	mov    (%rbx),%rdx
    a37b:	89 82 00 01 00 00    	mov    %eax,0x100(%rdx)
	ew32(TCTL, E1000_TCTL_PSP);
    a381:	48 8b 13             	mov    (%rbx),%rdx
    a384:	b0 08                	mov    $0x8,%al
    a386:	89 82 00 04 00 00    	mov    %eax,0x400(%rdx)
	E1000_WRITE_FLUSH();
    a38c:	48 8b 03             	mov    (%rbx),%rax
{ asm volatile("mov" size " %0,%1": :reg (val), \
"m" (*(volatile type __force *)addr) barrier); }

build_mmio_read(readb, "b", unsigned char, "=q", :"memory")
build_mmio_read(readw, "w", unsigned short, "=r", :"memory")
build_mmio_read(readl, "l", unsigned int, "=r", :"memory")
    a38f:	8b 40 08             	mov    0x8(%rax),%eax
	hw->tbi_compatibility_on = false;

	/* Delay to allow any outstanding PCI transactions to complete before
	 * resetting the device
	 */
	msleep(10);
    a392:	bf 0a 00 00 00       	mov    $0xa,%edi
	ew32(RCTL, 0);
	ew32(TCTL, E1000_TCTL_PSP);
	E1000_WRITE_FLUSH();

	/* The tbi_compatibility_on Flag must be cleared when Rctl is cleared. */
	hw->tbi_compatibility_on = false;
    a397:	c6 83 0f 01 00 00 00 	movb   $0x0,0x10f(%rbx)

	/* Delay to allow any outstanding PCI transactions to complete before
	 * resetting the device
	 */
	msleep(10);
    a39e:	e8 00 00 00 00       	callq  a3a3 <e1000_reset_hw+0x63>

	ctrl = er32(CTRL);
    a3a3:	48 8b 03             	mov    (%rbx),%rax
    a3a6:	44 8b 20             	mov    (%rax),%r12d

	/* Must reset the PHY before resetting the MAC */
	if ((hw->mac_type == e1000_82541) || (hw->mac_type == e1000_82547)) {
    a3a9:	8b 43 18             	mov    0x18(%rbx),%eax
    a3ac:	83 f8 0d             	cmp    $0xd,%eax
    a3af:	0f 84 4d 01 00 00    	je     a502 <e1000_reset_hw+0x1c2>
    a3b5:	83 f8 0b             	cmp    $0xb,%eax
    a3b8:	0f 84 44 01 00 00    	je     a502 <e1000_reset_hw+0x1c2>
	/* Issue a global reset to the MAC.  This will reset the chip's
	 * transmit, receive, DMA, and link units.  It will not effect
	 * the current PCI configuration.  The global reset bit is self-
	 * clearing, and should clear within a microsecond.
	 */
	e_dbg("Issuing a global reset to MAC\n");
    a3be:	f6 05 00 00 00 00 04 	testb  $0x4,0x0(%rip)        # a3c5 <e1000_reset_hw+0x85>
    a3c5:	0f 85 e3 01 00 00    	jne    a5ae <e1000_reset_hw+0x26e>
    a3cb:	8b 43 18             	mov    0x18(%rbx),%eax
    a3ce:	8d 48 fc             	lea    -0x4(%rax),%ecx
    a3d1:	83 f9 08             	cmp    $0x8,%ecx
    a3d4:	77 1b                	ja     a3f1 <e1000_reset_hw+0xb1>
    a3d6:	b8 01 00 00 00       	mov    $0x1,%eax
    a3db:	48 d3 e0             	shl    %cl,%rax
    a3de:	a9 97 01 00 00       	test   $0x197,%eax
    a3e3:	0f 85 68 01 00 00    	jne    a551 <e1000_reset_hw+0x211>
    a3e9:	a8 48                	test   $0x48,%al
    a3eb:	0f 85 4d 01 00 00    	jne    a53e <e1000_reset_hw+0x1fe>
		/* Reset is performed on a shadow of the control register */
		ew32(CTRL_DUP, (ctrl | E1000_CTRL_RST));
		break;
	case e1000_ce4100:
	default:
		ew32(CTRL, (ctrl | E1000_CTRL_RST));
    a3f1:	48 8b 03             	mov    (%rbx),%rax
    a3f4:	41 81 cc 00 00 00 04 	or     $0x4000000,%r12d
build_mmio_read(__readw, "w", unsigned short, "=r", )
build_mmio_read(__readl, "l", unsigned int, "=r", )

build_mmio_write(writeb, "b", unsigned char, "q", :"memory")
build_mmio_write(writew, "w", unsigned short, "r", :"memory")
build_mmio_write(writel, "l", unsigned int, "r", :"memory")
    a3fb:	44 89 20             	mov    %r12d,(%rax)

	/* After MAC reset, force reload of EEPROM to restore power-on settings
	 * to device.  Later controllers reload the EEPROM automatically, so
	 * just wait for reload to complete.
	 */
	switch (hw->mac_type) {
    a3fe:	8b 43 18             	mov    0x18(%rbx),%eax
    a401:	83 f8 01             	cmp    $0x1,%eax
    a404:	0f 82 a1 00 00 00    	jb     a4ab <e1000_reset_hw+0x16b>
    a40a:	83 f8 04             	cmp    $0x4,%eax
    a40d:	0f 86 c1 00 00 00    	jbe    a4d4 <e1000_reset_hw+0x194>
    a413:	83 e8 0b             	sub    $0xb,%eax
    a416:	83 f8 03             	cmp    $0x3,%eax
    a419:	0f 87 8c 00 00 00    	ja     a4ab <e1000_reset_hw+0x16b>
	case e1000_82541:
	case e1000_82541_rev_2:
	case e1000_82547:
	case e1000_82547_rev_2:
		/* Wait for EEPROM reload */
		msleep(20);
    a41f:	bf 14 00 00 00       	mov    $0x14,%edi
    a424:	e8 00 00 00 00       	callq  a429 <e1000_reset_hw+0xe9>
			return ret_val;
		break;
	}

	/* Disable HW ARPs on ASF enabled adapters */
	if (hw->mac_type >= e1000_82540) {
    a429:	8b 43 18             	mov    0x18(%rbx),%eax
    a42c:	83 f8 04             	cmp    $0x4,%eax
    a42f:	76 18                	jbe    a449 <e1000_reset_hw+0x109>
		manc = er32(MANC);
    a431:	48 8b 03             	mov    (%rbx),%rax
{ asm volatile("mov" size " %0,%1": :reg (val), \
"m" (*(volatile type __force *)addr) barrier); }

build_mmio_read(readb, "b", unsigned char, "=q", :"memory")
build_mmio_read(readw, "w", unsigned short, "=r", :"memory")
build_mmio_read(readl, "l", unsigned int, "=r", :"memory")
    a434:	8b 80 20 58 00 00    	mov    0x5820(%rax),%eax
		manc &= ~(E1000_MANC_ARP_EN);
    a43a:	80 e4 df             	and    $0xdf,%ah
		ew32(MANC, manc);
    a43d:	48 8b 13             	mov    (%rbx),%rdx
build_mmio_read(__readw, "w", unsigned short, "=r", )
build_mmio_read(__readl, "l", unsigned int, "=r", )

build_mmio_write(writeb, "b", unsigned char, "q", :"memory")
build_mmio_write(writew, "w", unsigned short, "r", :"memory")
build_mmio_write(writel, "l", unsigned int, "r", :"memory")
    a440:	89 82 20 58 00 00    	mov    %eax,0x5820(%rdx)
    a446:	8b 43 18             	mov    0x18(%rbx),%eax
	}

	if ((hw->mac_type == e1000_82541) || (hw->mac_type == e1000_82547)) {
    a449:	83 f8 0d             	cmp    $0xd,%eax
    a44c:	74 05                	je     a453 <e1000_reset_hw+0x113>
    a44e:	83 f8 0b             	cmp    $0xb,%eax
    a451:	75 25                	jne    a478 <e1000_reset_hw+0x138>
static void e1000_phy_init_script(struct e1000_hw *hw)
{
	u32 ret_val;
	u16 phy_saved_data;

	if (hw->phy_init_script) {
    a453:	8b 43 20             	mov    0x20(%rbx),%eax
    a456:	85 c0                	test   %eax,%eax
    a458:	0f 85 1e 01 00 00    	jne    a57c <e1000_reset_hw+0x23c>

	if ((hw->mac_type == e1000_82541) || (hw->mac_type == e1000_82547)) {
		e1000_phy_init_script(hw);

		/* Configure activity LED after PHY reset */
		led_ctrl = er32(LEDCTL);
    a45e:	48 8b 03             	mov    (%rbx),%rax
{ asm volatile("mov" size " %0,%1": :reg (val), \
"m" (*(volatile type __force *)addr) barrier); }

build_mmio_read(readb, "b", unsigned char, "=q", :"memory")
build_mmio_read(readw, "w", unsigned short, "=r", :"memory")
build_mmio_read(readl, "l", unsigned int, "=r", :"memory")
    a461:	8b 80 00 0e 00 00    	mov    0xe00(%rax),%eax
		led_ctrl &= IGP_ACTIVITY_LED_MASK;
    a467:	80 e4 f0             	and    $0xf0,%ah
		led_ctrl |= (IGP_ACTIVITY_LED_ENABLE | IGP_LED3_MODE);
		ew32(LEDCTL, led_ctrl);
    a46a:	48 8b 13             	mov    (%rbx),%rdx
		e1000_phy_init_script(hw);

		/* Configure activity LED after PHY reset */
		led_ctrl = er32(LEDCTL);
		led_ctrl &= IGP_ACTIVITY_LED_MASK;
		led_ctrl |= (IGP_ACTIVITY_LED_ENABLE | IGP_LED3_MODE);
    a46d:	0d 00 03 00 07       	or     $0x7000300,%eax
build_mmio_read(__readw, "w", unsigned short, "=r", )
build_mmio_read(__readl, "l", unsigned int, "=r", )

build_mmio_write(writeb, "b", unsigned char, "q", :"memory")
build_mmio_write(writew, "w", unsigned short, "r", :"memory")
build_mmio_write(writel, "l", unsigned int, "r", :"memory")
    a472:	89 82 00 0e 00 00    	mov    %eax,0xe00(%rdx)
		ew32(LEDCTL, led_ctrl);
	}

	/* Clear interrupt mask to stop board from generating interrupts */
	e_dbg("Masking off all interrupts\n");
    a478:	f6 05 00 00 00 00 04 	testb  $0x4,0x0(%rip)        # a47f <e1000_reset_hw+0x13f>
    a47f:	0f 85 4e 01 00 00    	jne    a5d3 <e1000_reset_hw+0x293>
	ew32(IMC, 0xffffffff);
    a485:	48 8b 13             	mov    (%rbx),%rdx
    a488:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
    a48d:	89 82 d8 00 00 00    	mov    %eax,0xd8(%rdx)

	/* Clear any pending interrupt events. */
	icr = er32(ICR);
    a493:	48 8b 03             	mov    (%rbx),%rax
{ asm volatile("mov" size " %0,%1": :reg (val), \
"m" (*(volatile type __force *)addr) barrier); }

build_mmio_read(readb, "b", unsigned char, "=q", :"memory")
build_mmio_read(readw, "w", unsigned short, "=r", :"memory")
build_mmio_read(readl, "l", unsigned int, "=r", :"memory")
    a496:	8b 80 c0 00 00 00    	mov    0xc0(%rax),%eax

	/* If MWI was previously enabled, reenable it. */
	if (hw->mac_type == e1000_82542_rev2_0) {
    a49c:	83 7b 18 01          	cmpl   $0x1,0x18(%rbx)
    a4a0:	74 18                	je     a4ba <e1000_reset_hw+0x17a>
		if (hw->pci_cmd_word & PCI_COMMAND_INVALIDATE)
			e1000_pci_set_mwi(hw);
	}

	return E1000_SUCCESS;
}
    a4a2:	5b                   	pop    %rbx
    a4a3:	41 5c                	pop    %r12
    a4a5:	41 5d                	pop    %r13
    a4a7:	31 c0                	xor    %eax,%eax
    a4a9:	5d                   	pop    %rbp
    a4aa:	c3                   	retq   
 * returns: - E1000_ERR_RESET if fail to reset MAC
 *            E1000_SUCCESS at any other case.
 */
static s32 e1000_get_auto_rd_done(struct e1000_hw *hw)
{
	msleep(5);
    a4ab:	bf 05 00 00 00       	mov    $0x5,%edi
    a4b0:	e8 00 00 00 00       	callq  a4b5 <e1000_reset_hw+0x175>
    a4b5:	e9 6f ff ff ff       	jmpq   a429 <e1000_reset_hw+0xe9>
	/* Clear any pending interrupt events. */
	icr = er32(ICR);

	/* If MWI was previously enabled, reenable it. */
	if (hw->mac_type == e1000_82542_rev2_0) {
		if (hw->pci_cmd_word & PCI_COMMAND_INVALIDATE)
    a4ba:	f6 83 d4 00 00 00 10 	testb  $0x10,0xd4(%rbx)
    a4c1:	74 df                	je     a4a2 <e1000_reset_hw+0x162>
			e1000_pci_set_mwi(hw);
    a4c3:	48 89 df             	mov    %rbx,%rdi
    a4c6:	e8 00 00 00 00       	callq  a4cb <e1000_reset_hw+0x18b>
	}

	return E1000_SUCCESS;
}
    a4cb:	5b                   	pop    %rbx
    a4cc:	41 5c                	pop    %r12
    a4ce:	41 5d                	pop    %r13
    a4d0:	31 c0                	xor    %eax,%eax
    a4d2:	5d                   	pop    %rbp
    a4d3:	c3                   	retq   
	case e1000_82542_rev2_0:
	case e1000_82542_rev2_1:
	case e1000_82543:
	case e1000_82544:
		/* Wait for reset to complete */
		udelay(10);
    a4d4:	bf c6 a7 00 00       	mov    $0xa7c6,%edi
    a4d9:	e8 00 00 00 00       	callq  a4de <e1000_reset_hw+0x19e>
		ctrl_ext = er32(CTRL_EXT);
    a4de:	48 8b 03             	mov    (%rbx),%rax
    a4e1:	8b 40 18             	mov    0x18(%rax),%eax
		ctrl_ext |= E1000_CTRL_EXT_EE_RST;
    a4e4:	80 cc 20             	or     $0x20,%ah
		ew32(CTRL_EXT, ctrl_ext);
    a4e7:	48 8b 13             	mov    (%rbx),%rdx
build_mmio_read(__readw, "w", unsigned short, "=r", )
build_mmio_read(__readl, "l", unsigned int, "=r", )

build_mmio_write(writeb, "b", unsigned char, "q", :"memory")
build_mmio_write(writew, "w", unsigned short, "r", :"memory")
build_mmio_write(writel, "l", unsigned int, "r", :"memory")
    a4ea:	89 42 18             	mov    %eax,0x18(%rdx)
		E1000_WRITE_FLUSH();
    a4ed:	48 8b 03             	mov    (%rbx),%rax
{ asm volatile("mov" size " %0,%1": :reg (val), \
"m" (*(volatile type __force *)addr) barrier); }

build_mmio_read(readb, "b", unsigned char, "=q", :"memory")
build_mmio_read(readw, "w", unsigned short, "=r", :"memory")
build_mmio_read(readl, "l", unsigned int, "=r", :"memory")
    a4f0:	8b 40 08             	mov    0x8(%rax),%eax
		/* Wait for EEPROM reload */
		msleep(2);
    a4f3:	bf 02 00 00 00       	mov    $0x2,%edi
    a4f8:	e8 00 00 00 00       	callq  a4fd <e1000_reset_hw+0x1bd>
		break;
    a4fd:	e9 27 ff ff ff       	jmpq   a429 <e1000_reset_hw+0xe9>

	ctrl = er32(CTRL);

	/* Must reset the PHY before resetting the MAC */
	if ((hw->mac_type == e1000_82541) || (hw->mac_type == e1000_82547)) {
		ew32(CTRL, (ctrl | E1000_CTRL_PHY_RST));
    a502:	44 89 e0             	mov    %r12d,%eax
    a505:	48 8b 13             	mov    (%rbx),%rdx
    a508:	0d 00 00 00 80       	or     $0x80000000,%eax
build_mmio_read(__readw, "w", unsigned short, "=r", )
build_mmio_read(__readl, "l", unsigned int, "=r", )

build_mmio_write(writeb, "b", unsigned char, "q", :"memory")
build_mmio_write(writew, "w", unsigned short, "r", :"memory")
build_mmio_write(writel, "l", unsigned int, "r", :"memory")
    a50d:	89 02                	mov    %eax,(%rdx)
		E1000_WRITE_FLUSH();
    a50f:	48 8b 03             	mov    (%rbx),%rax
{ asm volatile("mov" size " %0,%1": :reg (val), \
"m" (*(volatile type __force *)addr) barrier); }

build_mmio_read(readb, "b", unsigned char, "=q", :"memory")
build_mmio_read(readw, "w", unsigned short, "=r", :"memory")
build_mmio_read(readl, "l", unsigned int, "=r", :"memory")
    a512:	8b 40 08             	mov    0x8(%rax),%eax
		msleep(5);
    a515:	bf 05 00 00 00       	mov    $0x5,%edi
    a51a:	e8 00 00 00 00       	callq  a51f <e1000_reset_hw+0x1df>
    a51f:	e9 9a fe ff ff       	jmpq   a3be <e1000_reset_hw+0x7e>
	u32 led_ctrl;
	s32 ret_val;

	/* For 82542 (rev 2.0), disable MWI before issuing a device reset */
	if (hw->mac_type == e1000_82542_rev2_0) {
		e_dbg("Disabling MWI on 82542 rev 2.0\n");
    a524:	f6 05 00 00 00 00 04 	testb  $0x4,0x0(%rip)        # a52b <e1000_reset_hw+0x1eb>
    a52b:	0f 85 c7 00 00 00    	jne    a5f8 <e1000_reset_hw+0x2b8>
		e1000_pci_clear_mwi(hw);
    a531:	48 89 df             	mov    %rbx,%rdi
    a534:	e8 00 00 00 00       	callq  a539 <e1000_reset_hw+0x1f9>
    a539:	e9 1d fe ff ff       	jmpq   a35b <e1000_reset_hw+0x1b>
		E1000_WRITE_REG_IO(hw, CTRL, (ctrl | E1000_CTRL_RST));
		break;
	case e1000_82545_rev_3:
	case e1000_82546_rev_3:
		/* Reset is performed on a shadow of the control register */
		ew32(CTRL_DUP, (ctrl | E1000_CTRL_RST));
    a53e:	48 8b 03             	mov    (%rbx),%rax
    a541:	41 81 cc 00 00 00 04 	or     $0x4000000,%r12d
build_mmio_read(__readw, "w", unsigned short, "=r", )
build_mmio_read(__readl, "l", unsigned int, "=r", )

build_mmio_write(writeb, "b", unsigned char, "q", :"memory")
build_mmio_write(writew, "w", unsigned short, "r", :"memory")
build_mmio_write(writel, "l", unsigned int, "r", :"memory")
    a548:	44 89 60 04          	mov    %r12d,0x4(%rax)
    a54c:	e9 ad fe ff ff       	jmpq   a3fe <e1000_reset_hw+0xbe>
 * Writes a value to one of the devices registers using port I/O (as opposed to
 * memory mapped I/O). Only 82544 and newer devices support port I/O.
 */
static void e1000_write_reg_io(struct e1000_hw *hw, u32 offset, u32 value)
{
	unsigned long io_addr = hw->io_base;
    a551:	4c 8b 6b 78          	mov    0x78(%rbx),%r13
	unsigned long io_data = hw->io_base + 4;

	e1000_io_write(hw, io_addr, offset);
    a555:	31 d2                	xor    %edx,%edx
    a557:	48 89 df             	mov    %rbx,%rdi
    a55a:	4c 89 ee             	mov    %r13,%rsi
    a55d:	e8 00 00 00 00       	callq  a562 <e1000_reset_hw+0x222>
	case e1000_82541:
	case e1000_82541_rev_2:
		/* These controllers can't ack the 64-bit write when issuing the
		 * reset, so use IO-mapping as a workaround to issue the reset
		 */
		E1000_WRITE_REG_IO(hw, CTRL, (ctrl | E1000_CTRL_RST));
    a562:	44 89 e2             	mov    %r12d,%edx
 * memory mapped I/O). Only 82544 and newer devices support port I/O.
 */
static void e1000_write_reg_io(struct e1000_hw *hw, u32 offset, u32 value)
{
	unsigned long io_addr = hw->io_base;
	unsigned long io_data = hw->io_base + 4;
    a565:	49 8d 75 04          	lea    0x4(%r13),%rsi

	e1000_io_write(hw, io_addr, offset);
	e1000_io_write(hw, io_data, value);
    a569:	48 89 df             	mov    %rbx,%rdi
	case e1000_82541:
	case e1000_82541_rev_2:
		/* These controllers can't ack the 64-bit write when issuing the
		 * reset, so use IO-mapping as a workaround to issue the reset
		 */
		E1000_WRITE_REG_IO(hw, CTRL, (ctrl | E1000_CTRL_RST));
    a56c:	81 ca 00 00 00 04    	or     $0x4000000,%edx
{
	unsigned long io_addr = hw->io_base;
	unsigned long io_data = hw->io_base + 4;

	e1000_io_write(hw, io_addr, offset);
	e1000_io_write(hw, io_data, value);
    a572:	e8 00 00 00 00       	callq  a577 <e1000_reset_hw+0x237>
    a577:	e9 82 fe ff ff       	jmpq   a3fe <e1000_reset_hw+0xbe>
    a57c:	48 89 df             	mov    %rbx,%rdi
    a57f:	e8 ac fb ff ff       	callq  a130 <e1000_phy_init_script.part.13>
    a584:	e9 d5 fe ff ff       	jmpq   a45e <e1000_reset_hw+0x11e>
		e_dbg("Disabling MWI on 82542 rev 2.0\n");
		e1000_pci_clear_mwi(hw);
	}

	/* Clear interrupt mask to stop board from generating interrupts */
	e_dbg("Masking off all interrupts\n");
    a589:	48 89 df             	mov    %rbx,%rdi
    a58c:	e8 00 00 00 00       	callq  a591 <e1000_reset_hw+0x251>
    a591:	48 c7 c2 00 00 00 00 	mov    $0x0,%rdx
    a598:	48 89 c6             	mov    %rax,%rsi
    a59b:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
    a5a2:	31 c0                	xor    %eax,%eax
    a5a4:	e8 00 00 00 00       	callq  a5a9 <e1000_reset_hw+0x269>
    a5a9:	e9 ba fd ff ff       	jmpq   a368 <e1000_reset_hw+0x28>
	/* Issue a global reset to the MAC.  This will reset the chip's
	 * transmit, receive, DMA, and link units.  It will not effect
	 * the current PCI configuration.  The global reset bit is self-
	 * clearing, and should clear within a microsecond.
	 */
	e_dbg("Issuing a global reset to MAC\n");
    a5ae:	48 89 df             	mov    %rbx,%rdi
    a5b1:	e8 00 00 00 00       	callq  a5b6 <e1000_reset_hw+0x276>
    a5b6:	48 c7 c2 00 00 00 00 	mov    $0x0,%rdx
    a5bd:	48 89 c6             	mov    %rax,%rsi
    a5c0:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
    a5c7:	31 c0                	xor    %eax,%eax
    a5c9:	e8 00 00 00 00       	callq  a5ce <e1000_reset_hw+0x28e>
    a5ce:	e9 f8 fd ff ff       	jmpq   a3cb <e1000_reset_hw+0x8b>
		led_ctrl |= (IGP_ACTIVITY_LED_ENABLE | IGP_LED3_MODE);
		ew32(LEDCTL, led_ctrl);
	}

	/* Clear interrupt mask to stop board from generating interrupts */
	e_dbg("Masking off all interrupts\n");
    a5d3:	48 89 df             	mov    %rbx,%rdi
    a5d6:	e8 00 00 00 00       	callq  a5db <e1000_reset_hw+0x29b>
    a5db:	48 c7 c2 00 00 00 00 	mov    $0x0,%rdx
    a5e2:	48 89 c6             	mov    %rax,%rsi
    a5e5:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
    a5ec:	31 c0                	xor    %eax,%eax
    a5ee:	e8 00 00 00 00       	callq  a5f3 <e1000_reset_hw+0x2b3>
    a5f3:	e9 8d fe ff ff       	jmpq   a485 <e1000_reset_hw+0x145>
	u32 led_ctrl;
	s32 ret_val;

	/* For 82542 (rev 2.0), disable MWI before issuing a device reset */
	if (hw->mac_type == e1000_82542_rev2_0) {
		e_dbg("Disabling MWI on 82542 rev 2.0\n");
    a5f8:	e8 00 00 00 00       	callq  a5fd <e1000_reset_hw+0x2bd>
    a5fd:	48 c7 c2 00 00 00 00 	mov    $0x0,%rdx
    a604:	48 89 c6             	mov    %rax,%rsi
    a607:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
    a60e:	31 c0                	xor    %eax,%eax
    a610:	e8 00 00 00 00       	callq  a615 <e1000_reset_hw+0x2d5>
    a615:	e9 17 ff ff ff       	jmpq   a531 <e1000_reset_hw+0x1f1>
    a61a:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)

000000000000a620 <e1000_config_dsp_after_link_change>:
 * 82541_rev_2 & 82547_rev_2 have the capability to configure the DSP when a
 * gigabit link is achieved to improve link quality.
 */

static s32 e1000_config_dsp_after_link_change(struct e1000_hw *hw, bool link_up)
{
    a620:	e8 00 00 00 00       	callq  a625 <e1000_config_dsp_after_link_change+0x5>
    a625:	55                   	push   %rbp
    a626:	48 89 e5             	mov    %rsp,%rbp
    a629:	41 57                	push   %r15
    a62b:	41 56                	push   %r14
    a62d:	41 55                	push   %r13
    a62f:	41 54                	push   %r12
    a631:	53                   	push   %rbx
    a632:	48 89 fb             	mov    %rdi,%rbx
    a635:	48 83 ec 10          	sub    $0x10,%rsp
	s32 ret_val;
	u16 phy_data, phy_saved_data, speed, duplex, i;

	if (hw->phy_type != e1000_phy_igp)
    a639:	83 7f 1c 01          	cmpl   $0x1,0x1c(%rdi)
    a63d:	74 11                	je     a650 <e1000_config_dsp_after_link_change+0x30>
				return ret_val;

			hw->ffe_config_state = e1000_ffe_config_enabled;
		}
	}
	return E1000_SUCCESS;
    a63f:	31 c0                	xor    %eax,%eax
}
    a641:	48 83 c4 10          	add    $0x10,%rsp
    a645:	5b                   	pop    %rbx
    a646:	41 5c                	pop    %r12
    a648:	41 5d                	pop    %r13
    a64a:	41 5e                	pop    %r14
    a64c:	41 5f                	pop    %r15
    a64e:	5d                   	pop    %rbp
    a64f:	c3                   	retq   
	u16 phy_data, phy_saved_data, speed, duplex, i;

	if (hw->phy_type != e1000_phy_igp)
		return E1000_SUCCESS;

	if (link_up) {
    a650:	40 84 f6             	test   %sil,%sil
    a653:	0f 85 bd 00 00 00    	jne    a716 <e1000_config_dsp_after_link_change+0xf6>
			ret_val = e1000_1000Mb_check_cable_length(hw);
			if (ret_val)
				return ret_val;
		}
	} else {
		if (hw->dsp_config_state == e1000_dsp_config_activated) {
    a659:	83 bf 08 01 00 00 02 	cmpl   $0x2,0x108(%rdi)
    a660:	0f 84 99 01 00 00    	je     a7ff <e1000_config_dsp_after_link_change+0x1df>
				return ret_val;

			hw->ffe_config_state = e1000_ffe_config_enabled;
		}
	}
	return E1000_SUCCESS;
    a666:	31 c0                	xor    %eax,%eax
				return ret_val;

			hw->dsp_config_state = e1000_dsp_config_enabled;
		}

		if (hw->ffe_config_state == e1000_ffe_config_active) {
    a668:	83 7b 68 01          	cmpl   $0x1,0x68(%rbx)
    a66c:	75 d3                	jne    a641 <e1000_config_dsp_after_link_change+0x21>
			/* Save off the current value of register 0x2F5B to be
			 * restored at the end of the routines.
			 */
			ret_val =
    a66e:	48 8d 55 d6          	lea    -0x2a(%rbp),%rdx
    a672:	be 5b 2f 00 00       	mov    $0x2f5b,%esi
    a677:	48 89 df             	mov    %rbx,%rdi
    a67a:	e8 00 00 00 00       	callq  a67f <e1000_config_dsp_after_link_change+0x5f>
			    e1000_read_phy_reg(hw, 0x2F5B, &phy_saved_data);

			if (ret_val)
    a67f:	85 c0                	test   %eax,%eax
    a681:	75 be                	jne    a641 <e1000_config_dsp_after_link_change+0x21>
				return ret_val;

			/* Disable the PHY transmitter */
			ret_val = e1000_write_phy_reg(hw, 0x2F5B, 0x0003);
    a683:	ba 03 00 00 00       	mov    $0x3,%edx
    a688:	be 5b 2f 00 00       	mov    $0x2f5b,%esi
    a68d:	48 89 df             	mov    %rbx,%rdi
    a690:	e8 00 00 00 00       	callq  a695 <e1000_config_dsp_after_link_change+0x75>

			if (ret_val)
    a695:	85 c0                	test   %eax,%eax
    a697:	75 a8                	jne    a641 <e1000_config_dsp_after_link_change+0x21>
				return ret_val;

			msleep(20);
    a699:	bf 14 00 00 00       	mov    $0x14,%edi
    a69e:	e8 00 00 00 00       	callq  a6a3 <e1000_config_dsp_after_link_change+0x83>

			ret_val = e1000_write_phy_reg(hw, 0x0000,
    a6a3:	31 f6                	xor    %esi,%esi
    a6a5:	ba 40 01 00 00       	mov    $0x140,%edx
    a6aa:	48 89 df             	mov    %rbx,%rdi
    a6ad:	e8 00 00 00 00       	callq  a6b2 <e1000_config_dsp_after_link_change+0x92>
						    IGP01E1000_IEEE_FORCE_GIGA);
			if (ret_val)
    a6b2:	85 c0                	test   %eax,%eax
    a6b4:	75 8b                	jne    a641 <e1000_config_dsp_after_link_change+0x21>
				return ret_val;
			ret_val =
    a6b6:	ba 2a 00 00 00       	mov    $0x2a,%edx
    a6bb:	be 35 1f 00 00       	mov    $0x1f35,%esi
    a6c0:	48 89 df             	mov    %rbx,%rdi
    a6c3:	e8 00 00 00 00       	callq  a6c8 <e1000_config_dsp_after_link_change+0xa8>
			    e1000_write_phy_reg(hw, IGP01E1000_PHY_DSP_FFE,
						IGP01E1000_PHY_DSP_FFE_DEFAULT);
			if (ret_val)
    a6c8:	85 c0                	test   %eax,%eax
    a6ca:	0f 85 71 ff ff ff    	jne    a641 <e1000_config_dsp_after_link_change+0x21>
				return ret_val;

			ret_val = e1000_write_phy_reg(hw, 0x0000,
    a6d0:	31 f6                	xor    %esi,%esi
    a6d2:	ba 00 33 00 00       	mov    $0x3300,%edx
    a6d7:	48 89 df             	mov    %rbx,%rdi
    a6da:	e8 00 00 00 00       	callq  a6df <e1000_config_dsp_after_link_change+0xbf>
					IGP01E1000_IEEE_RESTART_AUTONEG);
			if (ret_val)
    a6df:	85 c0                	test   %eax,%eax
    a6e1:	0f 85 5a ff ff ff    	jne    a641 <e1000_config_dsp_after_link_change+0x21>
				return ret_val;

			msleep(20);
    a6e7:	bf 14 00 00 00       	mov    $0x14,%edi
    a6ec:	e8 00 00 00 00       	callq  a6f1 <e1000_config_dsp_after_link_change+0xd1>

			/* Now enable the transmitter */
			ret_val =
			    e1000_write_phy_reg(hw, 0x2F5B, phy_saved_data);
    a6f1:	0f b7 55 d6          	movzwl -0x2a(%rbp),%edx
				return ret_val;

			msleep(20);

			/* Now enable the transmitter */
			ret_val =
    a6f5:	be 5b 2f 00 00       	mov    $0x2f5b,%esi
    a6fa:	48 89 df             	mov    %rbx,%rdi
    a6fd:	e8 00 00 00 00       	callq  a702 <e1000_config_dsp_after_link_change+0xe2>
			    e1000_write_phy_reg(hw, 0x2F5B, phy_saved_data);

			if (ret_val)
    a702:	85 c0                	test   %eax,%eax
    a704:	0f 85 37 ff ff ff    	jne    a641 <e1000_config_dsp_after_link_change+0x21>
				return ret_val;

			hw->ffe_config_state = e1000_ffe_config_enabled;
    a70a:	c7 43 68 00 00 00 00 	movl   $0x0,0x68(%rbx)
    a711:	e9 2b ff ff ff       	jmpq   a641 <e1000_config_dsp_after_link_change+0x21>

	if (hw->phy_type != e1000_phy_igp)
		return E1000_SUCCESS;

	if (link_up) {
		ret_val = e1000_get_speed_and_duplex(hw, &speed, &duplex);
    a716:	48 8d 55 d0          	lea    -0x30(%rbp),%rdx
    a71a:	48 8d 75 ce          	lea    -0x32(%rbp),%rsi
    a71e:	e8 00 00 00 00       	callq  a723 <e1000_config_dsp_after_link_change+0x103>
		if (ret_val) {
    a723:	85 c0                	test   %eax,%eax

	if (hw->phy_type != e1000_phy_igp)
		return E1000_SUCCESS;

	if (link_up) {
		ret_val = e1000_get_speed_and_duplex(hw, &speed, &duplex);
    a725:	41 89 c4             	mov    %eax,%r12d
		if (ret_val) {
    a728:	74 35                	je     a75f <e1000_config_dsp_after_link_change+0x13f>
			e_dbg("Error getting link speed and duplex\n");
    a72a:	f6 05 00 00 00 00 04 	testb  $0x4,0x0(%rip)        # a731 <e1000_config_dsp_after_link_change+0x111>
    a731:	0f 84 0a ff ff ff    	je     a641 <e1000_config_dsp_after_link_change+0x21>
    a737:	48 89 df             	mov    %rbx,%rdi
    a73a:	e8 00 00 00 00       	callq  a73f <e1000_config_dsp_after_link_change+0x11f>
    a73f:	48 c7 c2 00 00 00 00 	mov    $0x0,%rdx
    a746:	48 89 c6             	mov    %rax,%rsi
    a749:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
    a750:	31 c0                	xor    %eax,%eax
    a752:	e8 00 00 00 00       	callq  a757 <e1000_config_dsp_after_link_change+0x137>
    a757:	44 89 e0             	mov    %r12d,%eax
    a75a:	e9 e2 fe ff ff       	jmpq   a641 <e1000_config_dsp_after_link_change+0x21>
			return ret_val;
		}

		if (speed == SPEED_1000) {
    a75f:	66 81 7d ce e8 03    	cmpw   $0x3e8,-0x32(%rbp)
    a765:	0f 85 d4 fe ff ff    	jne    a63f <e1000_config_dsp_after_link_change+0x1f>
{
	u16 min_length, max_length;
	u16 phy_data, i;
	s32 ret_val;

	ret_val = e1000_get_cable_length(hw, &min_length, &max_length);
    a76b:	48 8d 55 d4          	lea    -0x2c(%rbp),%rdx
    a76f:	48 8d 75 d2          	lea    -0x2e(%rbp),%rsi
    a773:	48 89 df             	mov    %rbx,%rdi
    a776:	e8 c5 f0 ff ff       	callq  9840 <e1000_get_cable_length>
	if (ret_val)
    a77b:	85 c0                	test   %eax,%eax
    a77d:	0f 85 be fe ff ff    	jne    a641 <e1000_config_dsp_after_link_change+0x21>
		return ret_val;

	if (hw->dsp_config_state != e1000_dsp_config_enabled)
    a783:	83 bb 08 01 00 00 01 	cmpl   $0x1,0x108(%rbx)
    a78a:	0f 85 af fe ff ff    	jne    a63f <e1000_config_dsp_after_link_change+0x1f>
		return 0;

	if (min_length >= e1000_igp_cable_length_50) {
    a790:	66 83 7d d2 31       	cmpw   $0x31,-0x2e(%rbp)
    a795:	0f 86 54 01 00 00    	jbe    a8ef <e1000_config_dsp_after_link_change+0x2cf>
    a79b:	4c 8d 6d d6          	lea    -0x2a(%rbp),%r13
    a79f:	49 c7 c4 00 00 00 00 	mov    $0x0,%r12
		for (i = 0; i < IGP01E1000_PHY_CHANNEL_NUM; i++) {
			ret_val = e1000_read_phy_reg(hw, dsp_reg_array[i],
    a7a6:	45 0f b7 34 24       	movzwl (%r12),%r14d
    a7ab:	4c 89 ea             	mov    %r13,%rdx
    a7ae:	48 89 df             	mov    %rbx,%rdi
    a7b1:	44 89 f6             	mov    %r14d,%esi
    a7b4:	e8 00 00 00 00       	callq  a7b9 <e1000_config_dsp_after_link_change+0x199>
						     &phy_data);
			if (ret_val)
    a7b9:	85 c0                	test   %eax,%eax
    a7bb:	0f 85 80 fe ff ff    	jne    a641 <e1000_config_dsp_after_link_change+0x21>
				return ret_val;

			phy_data &= ~IGP01E1000_PHY_EDAC_MU_INDEX;
    a7c1:	0f b7 45 d6          	movzwl -0x2a(%rbp),%eax

			ret_val = e1000_write_phy_reg(hw, dsp_reg_array[i],
    a7c5:	44 89 f6             	mov    %r14d,%esi
    a7c8:	48 89 df             	mov    %rbx,%rdi
			ret_val = e1000_read_phy_reg(hw, dsp_reg_array[i],
						     &phy_data);
			if (ret_val)
				return ret_val;

			phy_data &= ~IGP01E1000_PHY_EDAC_MU_INDEX;
    a7cb:	66 25 ff 3f          	and    $0x3fff,%ax

			ret_val = e1000_write_phy_reg(hw, dsp_reg_array[i],
    a7cf:	0f b7 d0             	movzwl %ax,%edx
			ret_val = e1000_read_phy_reg(hw, dsp_reg_array[i],
						     &phy_data);
			if (ret_val)
				return ret_val;

			phy_data &= ~IGP01E1000_PHY_EDAC_MU_INDEX;
    a7d2:	66 89 45 d6          	mov    %ax,-0x2a(%rbp)

			ret_val = e1000_write_phy_reg(hw, dsp_reg_array[i],
    a7d6:	e8 00 00 00 00       	callq  a7db <e1000_config_dsp_after_link_change+0x1bb>
						      phy_data);
			if (ret_val)
    a7db:	85 c0                	test   %eax,%eax
    a7dd:	0f 85 5e fe ff ff    	jne    a641 <e1000_config_dsp_after_link_change+0x21>
    a7e3:	49 83 c4 02          	add    $0x2,%r12

	if (hw->dsp_config_state != e1000_dsp_config_enabled)
		return 0;

	if (min_length >= e1000_igp_cable_length_50) {
		for (i = 0; i < IGP01E1000_PHY_CHANNEL_NUM; i++) {
    a7e7:	49 81 fc 00 00 00 00 	cmp    $0x0,%r12
    a7ee:	75 b6                	jne    a7a6 <e1000_config_dsp_after_link_change+0x186>
			ret_val = e1000_write_phy_reg(hw, dsp_reg_array[i],
						      phy_data);
			if (ret_val)
				return ret_val;
		}
		hw->dsp_config_state = e1000_dsp_config_activated;
    a7f0:	c7 83 08 01 00 00 02 	movl   $0x2,0x108(%rbx)
    a7f7:	00 00 00 
    a7fa:	e9 40 fe ff ff       	jmpq   a63f <e1000_config_dsp_after_link_change+0x1f>
	} else {
		if (hw->dsp_config_state == e1000_dsp_config_activated) {
			/* Save off the current value of register 0x2F5B to be
			 * restored at the end of the routines.
			 */
			ret_val =
    a7ff:	48 8d 55 d6          	lea    -0x2a(%rbp),%rdx
    a803:	be 5b 2f 00 00       	mov    $0x2f5b,%esi
    a808:	e8 00 00 00 00       	callq  a80d <e1000_config_dsp_after_link_change+0x1ed>
			    e1000_read_phy_reg(hw, 0x2F5B, &phy_saved_data);

			if (ret_val)
    a80d:	85 c0                	test   %eax,%eax
    a80f:	0f 85 2c fe ff ff    	jne    a641 <e1000_config_dsp_after_link_change+0x21>
				return ret_val;

			/* Disable the PHY transmitter */
			ret_val = e1000_write_phy_reg(hw, 0x2F5B, 0x0003);
    a815:	ba 03 00 00 00       	mov    $0x3,%edx
    a81a:	be 5b 2f 00 00       	mov    $0x2f5b,%esi
    a81f:	48 89 df             	mov    %rbx,%rdi
    a822:	e8 00 00 00 00       	callq  a827 <e1000_config_dsp_after_link_change+0x207>

			if (ret_val)
    a827:	85 c0                	test   %eax,%eax
    a829:	0f 85 12 fe ff ff    	jne    a641 <e1000_config_dsp_after_link_change+0x21>
				return ret_val;

			msleep(20);
    a82f:	bf 14 00 00 00       	mov    $0x14,%edi
    a834:	e8 00 00 00 00       	callq  a839 <e1000_config_dsp_after_link_change+0x219>

			ret_val = e1000_write_phy_reg(hw, 0x0000,
    a839:	31 f6                	xor    %esi,%esi
    a83b:	ba 40 01 00 00       	mov    $0x140,%edx
    a840:	48 89 df             	mov    %rbx,%rdi
    a843:	e8 00 00 00 00       	callq  a848 <e1000_config_dsp_after_link_change+0x228>
						    IGP01E1000_IEEE_FORCE_GIGA);
			if (ret_val)
    a848:	85 c0                	test   %eax,%eax
    a84a:	0f 85 f1 fd ff ff    	jne    a641 <e1000_config_dsp_after_link_change+0x21>
    a850:	49 c7 c4 00 00 00 00 	mov    $0x0,%r12
				return ret_val;
			for (i = 0; i < IGP01E1000_PHY_CHANNEL_NUM; i++) {
				ret_val =
				    e1000_read_phy_reg(hw, dsp_reg_array[i],
    a857:	45 0f b7 2c 24       	movzwl (%r12),%r13d
			ret_val = e1000_write_phy_reg(hw, 0x0000,
						    IGP01E1000_IEEE_FORCE_GIGA);
			if (ret_val)
				return ret_val;
			for (i = 0; i < IGP01E1000_PHY_CHANNEL_NUM; i++) {
				ret_val =
    a85c:	48 8d 55 d4          	lea    -0x2c(%rbp),%rdx
    a860:	48 89 df             	mov    %rbx,%rdi
    a863:	44 89 ee             	mov    %r13d,%esi
    a866:	e8 00 00 00 00       	callq  a86b <e1000_config_dsp_after_link_change+0x24b>
				    e1000_read_phy_reg(hw, dsp_reg_array[i],
						       &phy_data);
				if (ret_val)
    a86b:	85 c0                	test   %eax,%eax
    a86d:	0f 85 ce fd ff ff    	jne    a641 <e1000_config_dsp_after_link_change+0x21>
					return ret_val;

				phy_data &= ~IGP01E1000_PHY_EDAC_MU_INDEX;
    a873:	0f b7 45 d4          	movzwl -0x2c(%rbp),%eax
				phy_data |= IGP01E1000_PHY_EDAC_SIGN_EXT_9_BITS;

				ret_val =
    a877:	44 89 ee             	mov    %r13d,%esi
    a87a:	48 89 df             	mov    %rbx,%rdi
				    e1000_read_phy_reg(hw, dsp_reg_array[i],
						       &phy_data);
				if (ret_val)
					return ret_val;

				phy_data &= ~IGP01E1000_PHY_EDAC_MU_INDEX;
    a87d:	66 25 ff 3f          	and    $0x3fff,%ax
				phy_data |= IGP01E1000_PHY_EDAC_SIGN_EXT_9_BITS;
    a881:	66 0d 00 80          	or     $0x8000,%ax

				ret_val =
				    e1000_write_phy_reg(hw, dsp_reg_array[i],
    a885:	0f b7 d0             	movzwl %ax,%edx
						       &phy_data);
				if (ret_val)
					return ret_val;

				phy_data &= ~IGP01E1000_PHY_EDAC_MU_INDEX;
				phy_data |= IGP01E1000_PHY_EDAC_SIGN_EXT_9_BITS;
    a888:	66 89 45 d4          	mov    %ax,-0x2c(%rbp)

				ret_val =
    a88c:	e8 00 00 00 00       	callq  a891 <e1000_config_dsp_after_link_change+0x271>
				    e1000_write_phy_reg(hw, dsp_reg_array[i],
							phy_data);
				if (ret_val)
    a891:	85 c0                	test   %eax,%eax
    a893:	0f 85 a8 fd ff ff    	jne    a641 <e1000_config_dsp_after_link_change+0x21>
    a899:	49 83 c4 02          	add    $0x2,%r12

			ret_val = e1000_write_phy_reg(hw, 0x0000,
						    IGP01E1000_IEEE_FORCE_GIGA);
			if (ret_val)
				return ret_val;
			for (i = 0; i < IGP01E1000_PHY_CHANNEL_NUM; i++) {
    a89d:	49 81 fc 00 00 00 00 	cmp    $0x0,%r12
    a8a4:	75 b1                	jne    a857 <e1000_config_dsp_after_link_change+0x237>
							phy_data);
				if (ret_val)
					return ret_val;
			}

			ret_val = e1000_write_phy_reg(hw, 0x0000,
    a8a6:	31 f6                	xor    %esi,%esi
    a8a8:	ba 00 33 00 00       	mov    $0x3300,%edx
    a8ad:	48 89 df             	mov    %rbx,%rdi
    a8b0:	e8 00 00 00 00       	callq  a8b5 <e1000_config_dsp_after_link_change+0x295>
					IGP01E1000_IEEE_RESTART_AUTONEG);
			if (ret_val)
    a8b5:	85 c0                	test   %eax,%eax
    a8b7:	0f 85 84 fd ff ff    	jne    a641 <e1000_config_dsp_after_link_change+0x21>
				return ret_val;

			msleep(20);
    a8bd:	bf 14 00 00 00       	mov    $0x14,%edi
    a8c2:	e8 00 00 00 00       	callq  a8c7 <e1000_config_dsp_after_link_change+0x2a7>

			/* Now enable the transmitter */
			ret_val =
			    e1000_write_phy_reg(hw, 0x2F5B, phy_saved_data);
    a8c7:	0f b7 55 d6          	movzwl -0x2a(%rbp),%edx
				return ret_val;

			msleep(20);

			/* Now enable the transmitter */
			ret_val =
    a8cb:	be 5b 2f 00 00       	mov    $0x2f5b,%esi
    a8d0:	48 89 df             	mov    %rbx,%rdi
    a8d3:	e8 00 00 00 00       	callq  a8d8 <e1000_config_dsp_after_link_change+0x2b8>
			    e1000_write_phy_reg(hw, 0x2F5B, phy_saved_data);

			if (ret_val)
    a8d8:	85 c0                	test   %eax,%eax
    a8da:	0f 85 61 fd ff ff    	jne    a641 <e1000_config_dsp_after_link_change+0x21>
				return ret_val;

			hw->dsp_config_state = e1000_dsp_config_enabled;
    a8e0:	c7 83 08 01 00 00 01 	movl   $0x1,0x108(%rbx)
    a8e7:	00 00 00 
    a8ea:	e9 77 fd ff ff       	jmpq   a666 <e1000_config_dsp_after_link_change+0x46>
	} else {
		u16 ffe_idle_err_timeout = FFE_IDLE_ERR_COUNT_TIMEOUT_20;
		u32 idle_errs = 0;

		/* clear previous idle error counts */
		ret_val = e1000_read_phy_reg(hw, PHY_1000T_STATUS, &phy_data);
    a8ef:	4c 8d 6d d6          	lea    -0x2a(%rbp),%r13
    a8f3:	be 0a 00 00 00       	mov    $0xa,%esi
    a8f8:	48 89 df             	mov    %rbx,%rdi
    a8fb:	4c 89 ea             	mov    %r13,%rdx
    a8fe:	e8 00 00 00 00       	callq  a903 <e1000_config_dsp_after_link_change+0x2e3>
		if (ret_val)
    a903:	85 c0                	test   %eax,%eax
    a905:	0f 85 36 fd ff ff    	jne    a641 <e1000_config_dsp_after_link_change+0x21>
    a90b:	41 bf 14 00 00 00    	mov    $0x14,%r15d
    a911:	45 31 f6             	xor    %r14d,%r14d
    a914:	45 31 e4             	xor    %r12d,%r12d
			return ret_val;

		for (i = 0; i < ffe_idle_err_timeout; i++) {
			udelay(1000);
    a917:	bf 58 89 41 00       	mov    $0x418958,%edi
    a91c:	e8 00 00 00 00       	callq  a921 <e1000_config_dsp_after_link_change+0x301>
			ret_val = e1000_read_phy_reg(hw, PHY_1000T_STATUS,
    a921:	4c 89 ea             	mov    %r13,%rdx
    a924:	be 0a 00 00 00       	mov    $0xa,%esi
    a929:	48 89 df             	mov    %rbx,%rdi
    a92c:	e8 00 00 00 00       	callq  a931 <e1000_config_dsp_after_link_change+0x311>
						     &phy_data);
			if (ret_val)
    a931:	85 c0                	test   %eax,%eax
    a933:	0f 85 08 fd ff ff    	jne    a641 <e1000_config_dsp_after_link_change+0x21>
				return ret_val;

			idle_errs += (phy_data & SR_1000T_IDLE_ERROR_CNT);
    a939:	0f b6 45 d6          	movzbl -0x2a(%rbp),%eax
    a93d:	41 01 c4             	add    %eax,%r12d
			if (idle_errs > SR_1000T_PHY_EXCESSIVE_IDLE_ERR_COUNT) {
    a940:	41 83 fc 05          	cmp    $0x5,%r12d
    a944:	77 1b                	ja     a961 <e1000_config_dsp_after_link_change+0x341>
					return ret_val;
				break;
			}

			if (idle_errs)
				ffe_idle_err_timeout =
    a946:	45 85 e4             	test   %r12d,%r12d
    a949:	b8 64 00 00 00       	mov    $0x64,%eax
    a94e:	44 0f 45 f8          	cmovne %eax,%r15d
		/* clear previous idle error counts */
		ret_val = e1000_read_phy_reg(hw, PHY_1000T_STATUS, &phy_data);
		if (ret_val)
			return ret_val;

		for (i = 0; i < ffe_idle_err_timeout; i++) {
    a952:	41 83 c6 01          	add    $0x1,%r14d
    a956:	66 45 39 fe          	cmp    %r15w,%r14w
    a95a:	72 bb                	jb     a917 <e1000_config_dsp_after_link_change+0x2f7>
    a95c:	e9 de fc ff ff       	jmpq   a63f <e1000_config_dsp_after_link_change+0x1f>
			if (ret_val)
				return ret_val;

			idle_errs += (phy_data & SR_1000T_IDLE_ERROR_CNT);
			if (idle_errs > SR_1000T_PHY_EXCESSIVE_IDLE_ERR_COUNT) {
				hw->ffe_config_state = e1000_ffe_config_active;
    a961:	c7 43 68 01 00 00 00 	movl   $0x1,0x68(%rbx)

				ret_val = e1000_write_phy_reg(hw,
    a968:	ba 69 00 00 00       	mov    $0x69,%edx
    a96d:	be 35 1f 00 00       	mov    $0x1f35,%esi
    a972:	48 89 df             	mov    %rbx,%rdi
    a975:	e8 00 00 00 00       	callq  a97a <e1000_config_dsp_after_link_change+0x35a>
					      IGP01E1000_PHY_DSP_FFE,
					      IGP01E1000_PHY_DSP_FFE_CM_CP);
				if (ret_val)
    a97a:	85 c0                	test   %eax,%eax
    a97c:	0f 85 bf fc ff ff    	jne    a641 <e1000_config_dsp_after_link_change+0x21>
    a982:	e9 b8 fc ff ff       	jmpq   a63f <e1000_config_dsp_after_link_change+0x1f>
    a987:	66 0f 1f 84 00 00 00 	nopw   0x0(%rax,%rax,1)
    a98e:	00 00 

000000000000a990 <e1000_check_for_link>:
 *
 * Checks to see if the link status of the hardware has changed.
 * Called by any function that needs to check the link status of the adapter.
 */
s32 e1000_check_for_link(struct e1000_hw *hw)
{
    a990:	e8 00 00 00 00       	callq  a995 <e1000_check_for_link+0x5>
    a995:	55                   	push   %rbp
    a996:	48 89 e5             	mov    %rsp,%rbp
    a999:	41 55                	push   %r13
    a99b:	41 54                	push   %r12
    a99d:	53                   	push   %rbx
    a99e:	48 89 fb             	mov    %rdi,%rbx
    a9a1:	48 83 ec 08          	sub    $0x8,%rsp
	u32 icr;
	u32 signal = 0;
	s32 ret_val;
	u16 phy_data;

	ctrl = er32(CTRL);
    a9a5:	48 8b 07             	mov    (%rdi),%rax
{ asm volatile("mov" size " %0,%1": :reg (val), \
"m" (*(volatile type __force *)addr) barrier); }

build_mmio_read(readb, "b", unsigned char, "=q", :"memory")
build_mmio_read(readw, "w", unsigned short, "=r", :"memory")
build_mmio_read(readl, "l", unsigned int, "=r", :"memory")
    a9a8:	8b 00                	mov    (%rax),%eax
	status = er32(STATUS);
    a9aa:	48 8b 07             	mov    (%rdi),%rax
    a9ad:	8b 48 08             	mov    0x8(%rax),%ecx

	/* On adapters with a MAC newer than 82544, SW Definable pin 1 will be
	 * set when the optics detect a signal. On older adapters, it will be
	 * cleared when there is a signal.  This applies to fiber media only.
	 */
	if ((hw->media_type == e1000_media_type_fiber) ||
    a9b0:	8b 47 24             	mov    0x24(%rdi),%eax
    a9b3:	8d 50 ff             	lea    -0x1(%rax),%edx
    a9b6:	41 89 c4             	mov    %eax,%r12d
    a9b9:	83 fa 01             	cmp    $0x1,%edx
    a9bc:	0f 86 e8 00 00 00    	jbe    aaaa <e1000_check_for_link+0x11a>
	 * registers to see if Auto-Neg has completed and/or if our link
	 * status has changed.  The get_link_status flag will be set if we
	 * receive a Link Status Change interrupt or we have Rx Sequence
	 * Errors.
	 */
	if ((hw->media_type == e1000_media_type_copper) && hw->get_link_status) {
    a9c2:	45 85 e4             	test   %r12d,%r12d
    a9c5:	75 2f                	jne    a9f6 <e1000_check_for_link+0x66>
    a9c7:	80 bb 0c 01 00 00 00 	cmpb   $0x0,0x10c(%rbx)
    a9ce:	0f 85 02 01 00 00    	jne    aad6 <e1000_check_for_link+0x146>

	if ((hw->media_type == e1000_media_type_fiber) ||
	    (hw->media_type == e1000_media_type_internal_serdes))
		e1000_check_for_serdes_link_generic(hw);

	return E1000_SUCCESS;
    a9d4:	45 31 ed             	xor    %r13d,%r13d
}
    a9d7:	48 83 c4 08          	add    $0x8,%rsp
    a9db:	44 89 e8             	mov    %r13d,%eax
    a9de:	5b                   	pop    %rbx
    a9df:	41 5c                	pop    %r12
    a9e1:	41 5d                	pop    %r13
    a9e3:	5d                   	pop    %rbp
    a9e4:	c3                   	retq   
		 * determine if TBI compatibility needs to be turned on or off.
		 * If the link is not at gigabit speed, then TBI compatibility
		 * is not needed.  If we are at gigabit speed, we turn on TBI
		 * compatibility.
		 */
		if (hw->tbi_compatibility_en) {
    a9e5:	80 bb 0e 01 00 00 00 	cmpb   $0x0,0x10e(%rbx)
    a9ec:	0f 85 ed 04 00 00    	jne    aedf <e1000_check_for_link+0x54f>
    a9f2:	44 8b 63 24          	mov    0x24(%rbx),%r12d
				}
			}
		}
	}

	if ((hw->media_type == e1000_media_type_fiber) ||
    a9f6:	41 83 ec 01          	sub    $0x1,%r12d
    a9fa:	41 83 fc 01          	cmp    $0x1,%r12d
    a9fe:	77 d4                	ja     a9d4 <e1000_check_for_link+0x44>
	u32 rxcw;
	u32 ctrl;
	u32 status;
	s32 ret_val = E1000_SUCCESS;

	ctrl = er32(CTRL);
    aa00:	48 8b 03             	mov    (%rbx),%rax
    aa03:	44 8b 20             	mov    (%rax),%r12d
	status = er32(STATUS);
    aa06:	48 8b 03             	mov    (%rbx),%rax
    aa09:	8b 40 08             	mov    0x8(%rax),%eax
	rxcw = er32(RXCW);
    aa0c:	48 8b 13             	mov    (%rbx),%rdx
    aa0f:	8b 92 80 01 00 00    	mov    0x180(%rdx),%edx
	 * auto-negotiate with us (we are receiving idles or data),
	 * we need to force link up. We also need to give auto-negotiation
	 * time to complete.
	 */
	/* (ctrl & E1000_CTRL_SWDPIN1) == 1 == have signal */
	if ((!(status & E1000_STATUS_LU)) && (!(rxcw & E1000_RXCW_C))) {
    aa15:	a8 02                	test   $0x2,%al
    aa17:	0f 85 bb 01 00 00    	jne    abd8 <e1000_check_for_link+0x248>
    aa1d:	f7 c2 00 00 00 20    	test   $0x20000000,%edx
    aa23:	0f 85 af 01 00 00    	jne    abd8 <e1000_check_for_link+0x248>
		if (hw->autoneg_failed == 0) {
    aa29:	8b 83 94 00 00 00    	mov    0x94(%rbx),%eax
    aa2f:	85 c0                	test   %eax,%eax
    aa31:	0f 84 e0 02 00 00    	je     ad17 <e1000_check_for_link+0x387>
			hw->autoneg_failed = 1;
			goto out;
		}
		e_dbg("NOT RXing /C/, disable AutoNeg and force link.\n");
    aa37:	f6 05 00 00 00 00 04 	testb  $0x4,0x0(%rip)        # aa3e <e1000_check_for_link+0xae>
    aa3e:	0f 85 a9 05 00 00    	jne    afed <e1000_check_for_link+0x65d>

		/* Disable auto-negotiation in the TXCW register */
		ew32(TXCW, (hw->txcw & ~E1000_TXCW_ANE));
    aa44:	8b 83 90 00 00 00    	mov    0x90(%rbx),%eax
    aa4a:	48 8b 13             	mov    (%rbx),%rdx
    aa4d:	25 ff ff ff 7f       	and    $0x7fffffff,%eax
build_mmio_read(__readw, "w", unsigned short, "=r", )
build_mmio_read(__readl, "l", unsigned int, "=r", )

build_mmio_write(writeb, "b", unsigned char, "q", :"memory")
build_mmio_write(writew, "w", unsigned short, "r", :"memory")
build_mmio_write(writel, "l", unsigned int, "r", :"memory")
    aa52:	89 82 78 01 00 00    	mov    %eax,0x178(%rdx)

		/* Force link-up and also force full-duplex. */
		ctrl = er32(CTRL);
    aa58:	48 8b 03             	mov    (%rbx),%rax
{ asm volatile("mov" size " %0,%1": :reg (val), \
"m" (*(volatile type __force *)addr) barrier); }

build_mmio_read(readb, "b", unsigned char, "=q", :"memory")
build_mmio_read(readw, "w", unsigned short, "=r", :"memory")
build_mmio_read(readl, "l", unsigned int, "=r", :"memory")
    aa5b:	8b 00                	mov    (%rax),%eax
		ctrl |= (E1000_CTRL_SLU | E1000_CTRL_FD);
    aa5d:	83 c8 41             	or     $0x41,%eax
		ew32(CTRL, ctrl);
    aa60:	48 8b 13             	mov    (%rbx),%rdx
build_mmio_read(__readw, "w", unsigned short, "=r", )
build_mmio_read(__readl, "l", unsigned int, "=r", )

build_mmio_write(writeb, "b", unsigned char, "q", :"memory")
build_mmio_write(writew, "w", unsigned short, "r", :"memory")
build_mmio_write(writel, "l", unsigned int, "r", :"memory")
    aa63:	89 02                	mov    %eax,(%rdx)

		/* Configure Flow Control after forcing link up. */
		ret_val = e1000_config_fc_after_link_up(hw);
    aa65:	48 89 df             	mov    %rbx,%rdi
    aa68:	e8 d3 f1 ff ff       	callq  9c40 <e1000_config_fc_after_link_up>
		if (ret_val) {
    aa6d:	85 c0                	test   %eax,%eax
    aa6f:	0f 84 a6 01 00 00    	je     ac1b <e1000_check_for_link+0x28b>
			e_dbg("Error configuring flow control\n");
    aa75:	f6 05 00 00 00 00 04 	testb  $0x4,0x0(%rip)        # aa7c <e1000_check_for_link+0xec>
    aa7c:	0f 84 52 ff ff ff    	je     a9d4 <e1000_check_for_link+0x44>
    aa82:	48 89 df             	mov    %rbx,%rdi

	if ((hw->media_type == e1000_media_type_fiber) ||
	    (hw->media_type == e1000_media_type_internal_serdes))
		e1000_check_for_serdes_link_generic(hw);

	return E1000_SUCCESS;
    aa85:	45 31 ed             	xor    %r13d,%r13d
		ew32(CTRL, ctrl);

		/* Configure Flow Control after forcing link up. */
		ret_val = e1000_config_fc_after_link_up(hw);
		if (ret_val) {
			e_dbg("Error configuring flow control\n");
    aa88:	e8 00 00 00 00       	callq  aa8d <e1000_check_for_link+0xfd>
    aa8d:	48 c7 c2 00 00 00 00 	mov    $0x0,%rdx
    aa94:	48 89 c6             	mov    %rax,%rsi
    aa97:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
    aa9e:	31 c0                	xor    %eax,%eax
    aaa0:	e8 00 00 00 00       	callq  aaa5 <e1000_check_for_link+0x115>
    aaa5:	e9 2d ff ff ff       	jmpq   a9d7 <e1000_check_for_link+0x47>
	 * set when the optics detect a signal. On older adapters, it will be
	 * cleared when there is a signal.  This applies to fiber media only.
	 */
	if ((hw->media_type == e1000_media_type_fiber) ||
	    (hw->media_type == e1000_media_type_internal_serdes)) {
		rxcw = er32(RXCW);
    aaaa:	48 8b 07             	mov    (%rdi),%rax
{ asm volatile("mov" size " %0,%1": :reg (val), \
"m" (*(volatile type __force *)addr) barrier); }

build_mmio_read(readb, "b", unsigned char, "=q", :"memory")
build_mmio_read(readw, "w", unsigned short, "=r", :"memory")
build_mmio_read(readl, "l", unsigned int, "=r", :"memory")
    aaad:	8b 80 80 01 00 00    	mov    0x180(%rax),%eax
    aab3:	44 8b 67 24          	mov    0x24(%rdi),%r12d

		if (hw->media_type == e1000_media_type_fiber) {
    aab7:	41 83 fc 01          	cmp    $0x1,%r12d
    aabb:	0f 85 01 ff ff ff    	jne    a9c2 <e1000_check_for_link+0x32>
			signal =
			    (hw->mac_type >
			     e1000_82544) ? E1000_CTRL_SWDPIN1 : 0;
			if (status & E1000_STATUS_LU)
    aac1:	83 e1 02             	and    $0x2,%ecx
    aac4:	0f 84 36 ff ff ff    	je     aa00 <e1000_check_for_link+0x70>
				hw->get_link_status = false;
    aaca:	c6 87 0c 01 00 00 00 	movb   $0x0,0x10c(%rdi)
    aad1:	e9 2a ff ff ff       	jmpq   aa00 <e1000_check_for_link+0x70>
		/* First we want to see if the MII Status Register reports
		 * link.  If so, then we want to get the current speed/duplex
		 * of the PHY.
		 * Read the register twice since the link bit is sticky.
		 */
		ret_val = e1000_read_phy_reg(hw, PHY_STATUS, &phy_data);
    aad6:	48 8d 55 e2          	lea    -0x1e(%rbp),%rdx
    aada:	be 01 00 00 00       	mov    $0x1,%esi
    aadf:	48 89 df             	mov    %rbx,%rdi
    aae2:	e8 00 00 00 00       	callq  aae7 <e1000_check_for_link+0x157>
		if (ret_val)
    aae7:	85 c0                	test   %eax,%eax
		/* First we want to see if the MII Status Register reports
		 * link.  If so, then we want to get the current speed/duplex
		 * of the PHY.
		 * Read the register twice since the link bit is sticky.
		 */
		ret_val = e1000_read_phy_reg(hw, PHY_STATUS, &phy_data);
    aae9:	41 89 c5             	mov    %eax,%r13d
		if (ret_val)
    aaec:	0f 85 e5 fe ff ff    	jne    a9d7 <e1000_check_for_link+0x47>
			return ret_val;
		ret_val = e1000_read_phy_reg(hw, PHY_STATUS, &phy_data);
    aaf2:	48 8d 55 e2          	lea    -0x1e(%rbp),%rdx
    aaf6:	be 01 00 00 00       	mov    $0x1,%esi
    aafb:	48 89 df             	mov    %rbx,%rdi
    aafe:	e8 00 00 00 00       	callq  ab03 <e1000_check_for_link+0x173>
		if (ret_val)
    ab03:	85 c0                	test   %eax,%eax
		 * Read the register twice since the link bit is sticky.
		 */
		ret_val = e1000_read_phy_reg(hw, PHY_STATUS, &phy_data);
		if (ret_val)
			return ret_val;
		ret_val = e1000_read_phy_reg(hw, PHY_STATUS, &phy_data);
    ab05:	41 89 c5             	mov    %eax,%r13d
		if (ret_val)
    ab08:	0f 85 c9 fe ff ff    	jne    a9d7 <e1000_check_for_link+0x47>
			return ret_val;

		if (phy_data & MII_SR_LINK_STATUS) {
    ab0e:	f6 45 e2 04          	testb  $0x4,-0x1e(%rbp)
    ab12:	0f 84 72 02 00 00    	je     ad8a <e1000_check_for_link+0x3fa>
static s32 e1000_check_downshift(struct e1000_hw *hw)
{
	s32 ret_val;
	u16 phy_data;

	if (hw->phy_type == e1000_phy_igp) {
    ab18:	8b 43 1c             	mov    0x1c(%rbx),%eax
		ret_val = e1000_read_phy_reg(hw, PHY_STATUS, &phy_data);
		if (ret_val)
			return ret_val;

		if (phy_data & MII_SR_LINK_STATUS) {
			hw->get_link_status = false;
    ab1b:	c6 83 0c 01 00 00 00 	movb   $0x0,0x10c(%rbx)
static s32 e1000_check_downshift(struct e1000_hw *hw)
{
	s32 ret_val;
	u16 phy_data;

	if (hw->phy_type == e1000_phy_igp) {
    ab22:	83 f8 01             	cmp    $0x1,%eax
    ab25:	0f 84 88 03 00 00    	je     aeb3 <e1000_check_for_link+0x523>
		if (ret_val)
			return ret_val;

		hw->speed_downgraded =
		    (phy_data & IGP01E1000_PLHR_SS_DOWNGRADE) ? 1 : 0;
	} else if (hw->phy_type == e1000_phy_m88) {
    ab2b:	85 c0                	test   %eax,%eax
    ab2d:	0f 84 a5 02 00 00    	je     add8 <e1000_check_for_link+0x448>
			 * link status change interrupt which will
			 * happen due to the execution of this workaround.
			 */

			if ((hw->mac_type == e1000_82544
			     || hw->mac_type == e1000_82543) && (!hw->autoneg)
    ab33:	8b 43 18             	mov    0x18(%rbx),%eax
    ab36:	83 e8 03             	sub    $0x3,%eax
			 * interrupt state to its previous value except for the
			 * link status change interrupt which will
			 * happen due to the execution of this workaround.
			 */

			if ((hw->mac_type == e1000_82544
    ab39:	83 f8 01             	cmp    $0x1,%eax
    ab3c:	0f 86 cb 02 00 00    	jbe    ae0d <e1000_check_for_link+0x47d>
		}

		/* If we are forcing speed/duplex, then we simply return since
		 * we have already determined whether we have link or not.
		 */
		if (!hw->autoneg)
    ab42:	80 bb ef 00 00 00 00 	cmpb   $0x0,0xef(%rbx)
    ab49:	0f 84 d8 02 00 00    	je     ae27 <e1000_check_for_link+0x497>
			return -E1000_ERR_CONFIG;

		/* optimize the dsp settings for the igp phy */
		e1000_config_dsp_after_link_change(hw, true);
    ab4f:	be 01 00 00 00       	mov    $0x1,%esi
    ab54:	48 89 df             	mov    %rbx,%rdi
    ab57:	e8 c4 fa ff ff       	callq  a620 <e1000_config_dsp_after_link_change>
		 * configuration.  So we only need to configure Collision
		 * Distance in the MAC.  Otherwise, we need to force
		 * speed/duplex on the MAC to the current PHY speed/duplex
		 * settings.
		 */
		if ((hw->mac_type >= e1000_82544) &&
    ab5c:	8b 43 18             	mov    0x18(%rbx),%eax
    ab5f:	83 f8 09             	cmp    $0x9,%eax
    ab62:	0f 84 06 03 00 00    	je     ae6e <e1000_check_for_link+0x4de>
    ab68:	83 f8 03             	cmp    $0x3,%eax
    ab6b:	0f 86 fd 02 00 00    	jbe    ae6e <e1000_check_for_link+0x4de>
	if (hw->mac_type < e1000_82543)
		coll_dist = E1000_COLLISION_DISTANCE_82542;
	else
		coll_dist = E1000_COLLISION_DISTANCE;

	tctl = er32(TCTL);
    ab71:	48 8b 03             	mov    (%rbx),%rax
    ab74:	8b 80 00 04 00 00    	mov    0x400(%rax),%eax

	tctl &= ~E1000_TCTL_COLD;
    ab7a:	25 ff 0f c0 ff       	and    $0xffc00fff,%eax
	tctl |= coll_dist << E1000_COLD_SHIFT;

	ew32(TCTL, tctl);
    ab7f:	48 8b 13             	mov    (%rbx),%rdx
		coll_dist = E1000_COLLISION_DISTANCE;

	tctl = er32(TCTL);

	tctl &= ~E1000_TCTL_COLD;
	tctl |= coll_dist << E1000_COLD_SHIFT;
    ab82:	0d 00 f0 03 00       	or     $0x3f000,%eax
build_mmio_read(__readw, "w", unsigned short, "=r", )
build_mmio_read(__readl, "l", unsigned int, "=r", )

build_mmio_write(writeb, "b", unsigned char, "q", :"memory")
build_mmio_write(writew, "w", unsigned short, "r", :"memory")
build_mmio_write(writel, "l", unsigned int, "r", :"memory")
    ab87:	89 82 00 04 00 00    	mov    %eax,0x400(%rdx)

	ew32(TCTL, tctl);
	E1000_WRITE_FLUSH();
    ab8d:	48 8b 03             	mov    (%rbx),%rax
{ asm volatile("mov" size " %0,%1": :reg (val), \
"m" (*(volatile type __force *)addr) barrier); }

build_mmio_read(readb, "b", unsigned char, "=q", :"memory")
build_mmio_read(readw, "w", unsigned short, "=r", :"memory")
build_mmio_read(readl, "l", unsigned int, "=r", :"memory")
    ab90:	8b 40 08             	mov    0x8(%rax),%eax
		/* Configure Flow Control now that Auto-Neg has completed.
		 * First, we need to restore the desired flow control settings
		 * because we may have had to re-autoneg with a different link
		 * partner.
		 */
		ret_val = e1000_config_fc_after_link_up(hw);
    ab93:	48 89 df             	mov    %rbx,%rdi
    ab96:	e8 a5 f0 ff ff       	callq  9c40 <e1000_config_fc_after_link_up>
		if (ret_val) {
    ab9b:	85 c0                	test   %eax,%eax
		/* Configure Flow Control now that Auto-Neg has completed.
		 * First, we need to restore the desired flow control settings
		 * because we may have had to re-autoneg with a different link
		 * partner.
		 */
		ret_val = e1000_config_fc_after_link_up(hw);
    ab9d:	41 89 c5             	mov    %eax,%r13d
		if (ret_val) {
    aba0:	0f 84 3f fe ff ff    	je     a9e5 <e1000_check_for_link+0x55>
			e_dbg("Error configuring flow control\n");
    aba6:	f6 05 00 00 00 00 04 	testb  $0x4,0x0(%rip)        # abad <e1000_check_for_link+0x21d>
    abad:	0f 84 24 fe ff ff    	je     a9d7 <e1000_check_for_link+0x47>
    abb3:	48 89 df             	mov    %rbx,%rdi
    abb6:	e8 00 00 00 00       	callq  abbb <e1000_check_for_link+0x22b>
    abbb:	48 c7 c2 00 00 00 00 	mov    $0x0,%rdx
    abc2:	48 89 c6             	mov    %rax,%rsi
    abc5:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
    abcc:	31 c0                	xor    %eax,%eax
    abce:	e8 00 00 00 00       	callq  abd3 <e1000_check_for_link+0x243>
    abd3:	e9 ff fd ff ff       	jmpq   a9d7 <e1000_check_for_link+0x47>
		ret_val = e1000_config_fc_after_link_up(hw);
		if (ret_val) {
			e_dbg("Error configuring flow control\n");
			goto out;
		}
	} else if ((ctrl & E1000_CTRL_SLU) && (rxcw & E1000_RXCW_C)) {
    abd8:	41 f6 c4 40          	test   $0x40,%r12b
    abdc:	0f 84 91 00 00 00    	je     ac73 <e1000_check_for_link+0x2e3>
    abe2:	81 e2 00 00 00 20    	and    $0x20000000,%edx
    abe8:	0f 84 85 00 00 00    	je     ac73 <e1000_check_for_link+0x2e3>
		/* If we are forcing link and we are receiving /C/ ordered
		 * sets, re-enable auto-negotiation in the TXCW register
		 * and disable forced link in the Device Control register
		 * in an attempt to auto-negotiate with our link partner.
		 */
		e_dbg("RXing /C/, enable AutoNeg and stop forcing link.\n");
    abee:	f6 05 00 00 00 00 04 	testb  $0x4,0x0(%rip)        # abf5 <e1000_check_for_link+0x265>
    abf5:	0f 85 cd 03 00 00    	jne    afc8 <e1000_check_for_link+0x638>
		ew32(TXCW, hw->txcw);
    abfb:	48 8b 13             	mov    (%rbx),%rdx
    abfe:	8b 83 90 00 00 00    	mov    0x90(%rbx),%eax
build_mmio_read(__readw, "w", unsigned short, "=r", )
build_mmio_read(__readl, "l", unsigned int, "=r", )

build_mmio_write(writeb, "b", unsigned char, "q", :"memory")
build_mmio_write(writew, "w", unsigned short, "r", :"memory")
build_mmio_write(writel, "l", unsigned int, "r", :"memory")
    ac04:	89 82 78 01 00 00    	mov    %eax,0x178(%rdx)
		ew32(CTRL, (ctrl & ~E1000_CTRL_SLU));
    ac0a:	48 8b 03             	mov    (%rbx),%rax
    ac0d:	41 83 e4 bf          	and    $0xffffffbf,%r12d
    ac11:	44 89 20             	mov    %r12d,(%rax)

		hw->serdes_has_link = true;
    ac14:	c6 83 0d 01 00 00 01 	movb   $0x1,0x10d(%rbx)
			hw->serdes_has_link = false;
			e_dbg("SERDES: Link down - force failed.\n");
		}
	}

	if (E1000_TXCW_ANE & er32(TXCW)) {
    ac1b:	48 8b 03             	mov    (%rbx),%rax
{ asm volatile("mov" size " %0,%1": :reg (val), \
"m" (*(volatile type __force *)addr) barrier); }

build_mmio_read(readb, "b", unsigned char, "=q", :"memory")
build_mmio_read(readw, "w", unsigned short, "=r", :"memory")
build_mmio_read(readl, "l", unsigned int, "=r", :"memory")
    ac1e:	8b 80 78 01 00 00    	mov    0x178(%rax),%eax
    ac24:	85 c0                	test   %eax,%eax
    ac26:	0f 89 a8 fd ff ff    	jns    a9d4 <e1000_check_for_link+0x44>
		status = er32(STATUS);
    ac2c:	48 8b 03             	mov    (%rbx),%rax
    ac2f:	8b 40 08             	mov    0x8(%rax),%eax
		if (status & E1000_STATUS_LU) {
    ac32:	a8 02                	test   $0x2,%al
    ac34:	0f 85 ef 00 00 00    	jne    ad29 <e1000_check_for_link+0x399>
				hw->serdes_has_link = false;
				e_dbg("SERDES: Link down - no sync.\n");
			}
		} else {
			hw->serdes_has_link = false;
			e_dbg("SERDES: Link down - autoneg failed\n");
    ac3a:	f6 05 00 00 00 00 04 	testb  $0x4,0x0(%rip)        # ac41 <e1000_check_for_link+0x2b1>
			} else {
				hw->serdes_has_link = false;
				e_dbg("SERDES: Link down - no sync.\n");
			}
		} else {
			hw->serdes_has_link = false;
    ac41:	c6 83 0d 01 00 00 00 	movb   $0x0,0x10d(%rbx)
			e_dbg("SERDES: Link down - autoneg failed\n");
    ac48:	0f 84 86 fd ff ff    	je     a9d4 <e1000_check_for_link+0x44>
    ac4e:	48 89 df             	mov    %rbx,%rdi
    ac51:	e8 00 00 00 00       	callq  ac56 <e1000_check_for_link+0x2c6>
    ac56:	48 c7 c2 00 00 00 00 	mov    $0x0,%rdx
    ac5d:	48 89 c6             	mov    %rax,%rsi
    ac60:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
    ac67:	31 c0                	xor    %eax,%eax
    ac69:	e8 00 00 00 00       	callq  ac6e <e1000_check_for_link+0x2de>
    ac6e:	e9 61 fd ff ff       	jmpq   a9d4 <e1000_check_for_link+0x44>
		e_dbg("RXing /C/, enable AutoNeg and stop forcing link.\n");
		ew32(TXCW, hw->txcw);
		ew32(CTRL, (ctrl & ~E1000_CTRL_SLU));

		hw->serdes_has_link = true;
	} else if (!(E1000_TXCW_ANE & er32(TXCW))) {
    ac73:	48 8b 03             	mov    (%rbx),%rax
    ac76:	8b 80 78 01 00 00    	mov    0x178(%rax),%eax
    ac7c:	85 c0                	test   %eax,%eax
    ac7e:	78 9b                	js     ac1b <e1000_check_for_link+0x28b>
		/* If we force link for non-auto-negotiation switch, check
		 * link status based on MAC synchronization for internal
		 * serdes media type.
		 */
		/* SYNCH bit and IV bit are sticky. */
		udelay(10);
    ac80:	bf c6 a7 00 00       	mov    $0xa7c6,%edi
    ac85:	e8 00 00 00 00       	callq  ac8a <e1000_check_for_link+0x2fa>
		rxcw = er32(RXCW);
    ac8a:	48 8b 03             	mov    (%rbx),%rax
    ac8d:	8b 80 80 01 00 00    	mov    0x180(%rax),%eax
		if (rxcw & E1000_RXCW_SYNCH) {
    ac93:	a9 00 00 00 40       	test   $0x40000000,%eax
    ac98:	74 44                	je     acde <e1000_check_for_link+0x34e>
			if (!(rxcw & E1000_RXCW_IV)) {
    ac9a:	a9 00 00 00 08       	test   $0x8000000,%eax
    ac9f:	0f 85 76 ff ff ff    	jne    ac1b <e1000_check_for_link+0x28b>
				hw->serdes_has_link = true;
				e_dbg("SERDES: Link up - forced.\n");
    aca5:	f6 05 00 00 00 00 04 	testb  $0x4,0x0(%rip)        # acac <e1000_check_for_link+0x31c>
		/* SYNCH bit and IV bit are sticky. */
		udelay(10);
		rxcw = er32(RXCW);
		if (rxcw & E1000_RXCW_SYNCH) {
			if (!(rxcw & E1000_RXCW_IV)) {
				hw->serdes_has_link = true;
    acac:	c6 83 0d 01 00 00 01 	movb   $0x1,0x10d(%rbx)
				e_dbg("SERDES: Link up - forced.\n");
    acb3:	0f 84 62 ff ff ff    	je     ac1b <e1000_check_for_link+0x28b>
    acb9:	48 89 df             	mov    %rbx,%rdi
    acbc:	e8 00 00 00 00       	callq  acc1 <e1000_check_for_link+0x331>
    acc1:	48 c7 c2 00 00 00 00 	mov    $0x0,%rdx
    acc8:	48 89 c6             	mov    %rax,%rsi
    accb:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
    acd2:	31 c0                	xor    %eax,%eax
    acd4:	e8 00 00 00 00       	callq  acd9 <e1000_check_for_link+0x349>
    acd9:	e9 3d ff ff ff       	jmpq   ac1b <e1000_check_for_link+0x28b>
			}
		} else {
			hw->serdes_has_link = false;
			e_dbg("SERDES: Link down - force failed.\n");
    acde:	f6 05 00 00 00 00 04 	testb  $0x4,0x0(%rip)        # ace5 <e1000_check_for_link+0x355>
			if (!(rxcw & E1000_RXCW_IV)) {
				hw->serdes_has_link = true;
				e_dbg("SERDES: Link up - forced.\n");
			}
		} else {
			hw->serdes_has_link = false;
    ace5:	c6 83 0d 01 00 00 00 	movb   $0x0,0x10d(%rbx)
			e_dbg("SERDES: Link down - force failed.\n");
    acec:	0f 84 29 ff ff ff    	je     ac1b <e1000_check_for_link+0x28b>
    acf2:	48 89 df             	mov    %rbx,%rdi
    acf5:	e8 00 00 00 00       	callq  acfa <e1000_check_for_link+0x36a>
    acfa:	48 c7 c2 00 00 00 00 	mov    $0x0,%rdx
    ad01:	48 89 c6             	mov    %rax,%rsi
    ad04:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
    ad0b:	31 c0                	xor    %eax,%eax
    ad0d:	e8 00 00 00 00       	callq  ad12 <e1000_check_for_link+0x382>
    ad12:	e9 04 ff ff ff       	jmpq   ac1b <e1000_check_for_link+0x28b>
	 * time to complete.
	 */
	/* (ctrl & E1000_CTRL_SWDPIN1) == 1 == have signal */
	if ((!(status & E1000_STATUS_LU)) && (!(rxcw & E1000_RXCW_C))) {
		if (hw->autoneg_failed == 0) {
			hw->autoneg_failed = 1;
    ad17:	c7 83 94 00 00 00 01 	movl   $0x1,0x94(%rbx)
    ad1e:	00 00 00 

	if ((hw->media_type == e1000_media_type_fiber) ||
	    (hw->media_type == e1000_media_type_internal_serdes))
		e1000_check_for_serdes_link_generic(hw);

	return E1000_SUCCESS;
    ad21:	45 31 ed             	xor    %r13d,%r13d
    ad24:	e9 ae fc ff ff       	jmpq   a9d7 <e1000_check_for_link+0x47>

	if (E1000_TXCW_ANE & er32(TXCW)) {
		status = er32(STATUS);
		if (status & E1000_STATUS_LU) {
			/* SYNCH bit and IV bit are sticky, so reread rxcw. */
			udelay(10);
    ad29:	bf c6 a7 00 00       	mov    $0xa7c6,%edi
    ad2e:	e8 00 00 00 00       	callq  ad33 <e1000_check_for_link+0x3a3>
			rxcw = er32(RXCW);
    ad33:	48 8b 03             	mov    (%rbx),%rax
    ad36:	8b 80 80 01 00 00    	mov    0x180(%rax),%eax
			if (rxcw & E1000_RXCW_SYNCH) {
    ad3c:	a9 00 00 00 40       	test   $0x40000000,%eax
    ad41:	74 59                	je     ad9c <e1000_check_for_link+0x40c>
				if (!(rxcw & E1000_RXCW_IV)) {
    ad43:	a9 00 00 00 08       	test   $0x8000000,%eax
    ad48:	0f 85 e4 00 00 00    	jne    ae32 <e1000_check_for_link+0x4a2>
					hw->serdes_has_link = true;
					e_dbg("SERDES: Link up - autoneg "
    ad4e:	f6 05 00 00 00 00 04 	testb  $0x4,0x0(%rip)        # ad55 <e1000_check_for_link+0x3c5>
			/* SYNCH bit and IV bit are sticky, so reread rxcw. */
			udelay(10);
			rxcw = er32(RXCW);
			if (rxcw & E1000_RXCW_SYNCH) {
				if (!(rxcw & E1000_RXCW_IV)) {
					hw->serdes_has_link = true;
    ad55:	c6 83 0d 01 00 00 01 	movb   $0x1,0x10d(%rbx)
					e_dbg("SERDES: Link up - autoneg "
    ad5c:	0f 84 72 fc ff ff    	je     a9d4 <e1000_check_for_link+0x44>
    ad62:	48 89 df             	mov    %rbx,%rdi

	if ((hw->media_type == e1000_media_type_fiber) ||
	    (hw->media_type == e1000_media_type_internal_serdes))
		e1000_check_for_serdes_link_generic(hw);

	return E1000_SUCCESS;
    ad65:	45 31 ed             	xor    %r13d,%r13d
			udelay(10);
			rxcw = er32(RXCW);
			if (rxcw & E1000_RXCW_SYNCH) {
				if (!(rxcw & E1000_RXCW_IV)) {
					hw->serdes_has_link = true;
					e_dbg("SERDES: Link up - autoneg "
    ad68:	e8 00 00 00 00       	callq  ad6d <e1000_check_for_link+0x3dd>
    ad6d:	48 c7 c2 00 00 00 00 	mov    $0x0,%rdx
    ad74:	48 89 c6             	mov    %rax,%rsi
    ad77:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
    ad7e:	31 c0                	xor    %eax,%eax
    ad80:	e8 00 00 00 00       	callq  ad85 <e1000_check_for_link+0x3f5>
    ad85:	e9 4d fc ff ff       	jmpq   a9d7 <e1000_check_for_link+0x47>
				ew32(IMS, IMS_ENABLE_MASK);
			}

		} else {
			/* No link detected */
			e1000_config_dsp_after_link_change(hw, false);
    ad8a:	31 f6                	xor    %esi,%esi
    ad8c:	48 89 df             	mov    %rbx,%rdi
			return 0;
    ad8f:	45 89 e5             	mov    %r12d,%r13d
				ew32(IMS, IMS_ENABLE_MASK);
			}

		} else {
			/* No link detected */
			e1000_config_dsp_after_link_change(hw, false);
    ad92:	e8 89 f8 ff ff       	callq  a620 <e1000_config_dsp_after_link_change>
			return 0;
    ad97:	e9 3b fc ff ff       	jmpq   a9d7 <e1000_check_for_link+0x47>
					e_dbg("SERDES: Link down - invalid"
						 "codewords detected in autoneg.\n");
				}
			} else {
				hw->serdes_has_link = false;
				e_dbg("SERDES: Link down - no sync.\n");
    ad9c:	f6 05 00 00 00 00 04 	testb  $0x4,0x0(%rip)        # ada3 <e1000_check_for_link+0x413>
					hw->serdes_has_link = false;
					e_dbg("SERDES: Link down - invalid"
						 "codewords detected in autoneg.\n");
				}
			} else {
				hw->serdes_has_link = false;
    ada3:	c6 83 0d 01 00 00 00 	movb   $0x0,0x10d(%rbx)
				e_dbg("SERDES: Link down - no sync.\n");
    adaa:	0f 84 24 fc ff ff    	je     a9d4 <e1000_check_for_link+0x44>
    adb0:	48 89 df             	mov    %rbx,%rdi

	if ((hw->media_type == e1000_media_type_fiber) ||
	    (hw->media_type == e1000_media_type_internal_serdes))
		e1000_check_for_serdes_link_generic(hw);

	return E1000_SUCCESS;
    adb3:	45 31 ed             	xor    %r13d,%r13d
					e_dbg("SERDES: Link down - invalid"
						 "codewords detected in autoneg.\n");
				}
			} else {
				hw->serdes_has_link = false;
				e_dbg("SERDES: Link down - no sync.\n");
    adb6:	e8 00 00 00 00       	callq  adbb <e1000_check_for_link+0x42b>
    adbb:	48 c7 c2 00 00 00 00 	mov    $0x0,%rdx
    adc2:	48 89 c6             	mov    %rax,%rsi
    adc5:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
    adcc:	31 c0                	xor    %eax,%eax
    adce:	e8 00 00 00 00       	callq  add3 <e1000_check_for_link+0x443>
    add3:	e9 ff fb ff ff       	jmpq   a9d7 <e1000_check_for_link+0x47>
			return ret_val;

		hw->speed_downgraded =
		    (phy_data & IGP01E1000_PLHR_SS_DOWNGRADE) ? 1 : 0;
	} else if (hw->phy_type == e1000_phy_m88) {
		ret_val = e1000_read_phy_reg(hw, M88E1000_PHY_SPEC_STATUS,
    add8:	48 8d 55 e6          	lea    -0x1a(%rbp),%rdx
    addc:	be 11 00 00 00       	mov    $0x11,%esi
    ade1:	48 89 df             	mov    %rbx,%rdi
    ade4:	e8 00 00 00 00       	callq  ade9 <e1000_check_for_link+0x459>
					     &phy_data);
		if (ret_val)
    ade9:	85 c0                	test   %eax,%eax
    adeb:	0f 85 42 fd ff ff    	jne    ab33 <e1000_check_for_link+0x1a3>
			return ret_val;

		hw->speed_downgraded = (phy_data & M88E1000_PSSR_DOWNSHIFT) >>
    adf1:	0f b7 45 e6          	movzwl -0x1a(%rbp),%eax
    adf5:	c1 e8 05             	shr    $0x5,%eax
    adf8:	83 e0 01             	and    $0x1,%eax
    adfb:	88 83 01 01 00 00    	mov    %al,0x101(%rbx)
    ae01:	80 a3 01 01 00 00 01 	andb   $0x1,0x101(%rbx)
    ae08:	e9 26 fd ff ff       	jmpq   ab33 <e1000_check_for_link+0x1a3>
			 * link status change interrupt which will
			 * happen due to the execution of this workaround.
			 */

			if ((hw->mac_type == e1000_82544
			     || hw->mac_type == e1000_82543) && (!hw->autoneg)
    ae0d:	80 bb ef 00 00 00 00 	cmpb   $0x0,0xef(%rbx)
    ae14:	0f 85 35 fd ff ff    	jne    ab4f <e1000_check_for_link+0x1bf>
			    && (hw->forced_speed_duplex == e1000_10_full
    ae1a:	80 bb f1 00 00 00 01 	cmpb   $0x1,0xf1(%rbx)
    ae21:	0f 86 37 01 00 00    	jbe    af5e <e1000_check_for_link+0x5ce>

		/* If we are forcing speed/duplex, then we simply return since
		 * we have already determined whether we have link or not.
		 */
		if (!hw->autoneg)
			return -E1000_ERR_CONFIG;
    ae27:	41 bd fd ff ff ff    	mov    $0xfffffffd,%r13d
    ae2d:	e9 a5 fb ff ff       	jmpq   a9d7 <e1000_check_for_link+0x47>
					hw->serdes_has_link = true;
					e_dbg("SERDES: Link up - autoneg "
						 "completed successfully.\n");
				} else {
					hw->serdes_has_link = false;
					e_dbg("SERDES: Link down - invalid"
    ae32:	f6 05 00 00 00 00 04 	testb  $0x4,0x0(%rip)        # ae39 <e1000_check_for_link+0x4a9>
				if (!(rxcw & E1000_RXCW_IV)) {
					hw->serdes_has_link = true;
					e_dbg("SERDES: Link up - autoneg "
						 "completed successfully.\n");
				} else {
					hw->serdes_has_link = false;
    ae39:	c6 83 0d 01 00 00 00 	movb   $0x0,0x10d(%rbx)
					e_dbg("SERDES: Link down - invalid"
    ae40:	0f 84 8e fb ff ff    	je     a9d4 <e1000_check_for_link+0x44>
    ae46:	48 89 df             	mov    %rbx,%rdi

	if ((hw->media_type == e1000_media_type_fiber) ||
	    (hw->media_type == e1000_media_type_internal_serdes))
		e1000_check_for_serdes_link_generic(hw);

	return E1000_SUCCESS;
    ae49:	45 31 ed             	xor    %r13d,%r13d
					hw->serdes_has_link = true;
					e_dbg("SERDES: Link up - autoneg "
						 "completed successfully.\n");
				} else {
					hw->serdes_has_link = false;
					e_dbg("SERDES: Link down - invalid"
    ae4c:	e8 00 00 00 00       	callq  ae51 <e1000_check_for_link+0x4c1>
    ae51:	48 c7 c2 00 00 00 00 	mov    $0x0,%rdx
    ae58:	48 89 c6             	mov    %rax,%rsi
    ae5b:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
    ae62:	31 c0                	xor    %eax,%eax
    ae64:	e8 00 00 00 00       	callq  ae69 <e1000_check_for_link+0x4d9>
    ae69:	e9 69 fb ff ff       	jmpq   a9d7 <e1000_check_for_link+0x47>
    ae6e:	48 89 df             	mov    %rbx,%rdi
    ae71:	e8 9a e8 ff ff       	callq  9710 <e1000_config_mac_to_phy.part.10>
		if ((hw->mac_type >= e1000_82544) &&
		    (hw->mac_type != e1000_ce4100))
			e1000_config_collision_dist(hw);
		else {
			ret_val = e1000_config_mac_to_phy(hw);
			if (ret_val) {
    ae76:	85 c0                	test   %eax,%eax
    ae78:	41 89 c5             	mov    %eax,%r13d
    ae7b:	0f 84 12 fd ff ff    	je     ab93 <e1000_check_for_link+0x203>
				e_dbg
    ae81:	f6 05 00 00 00 00 04 	testb  $0x4,0x0(%rip)        # ae88 <e1000_check_for_link+0x4f8>
    ae88:	0f 84 49 fb ff ff    	je     a9d7 <e1000_check_for_link+0x47>
    ae8e:	48 89 df             	mov    %rbx,%rdi
    ae91:	e8 00 00 00 00       	callq  ae96 <e1000_check_for_link+0x506>
    ae96:	48 c7 c2 00 00 00 00 	mov    $0x0,%rdx
    ae9d:	48 89 c6             	mov    %rax,%rsi
    aea0:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
    aea7:	31 c0                	xor    %eax,%eax
    aea9:	e8 00 00 00 00       	callq  aeae <e1000_check_for_link+0x51e>
    aeae:	e9 24 fb ff ff       	jmpq   a9d7 <e1000_check_for_link+0x47>
{
	s32 ret_val;
	u16 phy_data;

	if (hw->phy_type == e1000_phy_igp) {
		ret_val = e1000_read_phy_reg(hw, IGP01E1000_PHY_LINK_HEALTH,
    aeb3:	48 8d 55 e6          	lea    -0x1a(%rbp),%rdx
    aeb7:	be 13 00 00 00       	mov    $0x13,%esi
    aebc:	48 89 df             	mov    %rbx,%rdi
    aebf:	e8 00 00 00 00       	callq  aec4 <e1000_check_for_link+0x534>
					     &phy_data);
		if (ret_val)
    aec4:	85 c0                	test   %eax,%eax
    aec6:	0f 85 67 fc ff ff    	jne    ab33 <e1000_check_for_link+0x1a3>
			return ret_val;

		hw->speed_downgraded =
		    (phy_data & IGP01E1000_PLHR_SS_DOWNGRADE) ? 1 : 0;
    aecc:	0f b7 45 e6          	movzwl -0x1a(%rbp),%eax
    aed0:	66 c1 e8 0f          	shr    $0xf,%ax
		ret_val = e1000_read_phy_reg(hw, IGP01E1000_PHY_LINK_HEALTH,
					     &phy_data);
		if (ret_val)
			return ret_val;

		hw->speed_downgraded =
    aed4:	88 83 01 01 00 00    	mov    %al,0x101(%rbx)
    aeda:	e9 54 fc ff ff       	jmpq   ab33 <e1000_check_for_link+0x1a3>
		 * is not needed.  If we are at gigabit speed, we turn on TBI
		 * compatibility.
		 */
		if (hw->tbi_compatibility_en) {
			u16 speed, duplex;
			ret_val =
    aedf:	48 8d 55 e6          	lea    -0x1a(%rbp),%rdx
    aee3:	48 8d 75 e4          	lea    -0x1c(%rbp),%rsi
    aee7:	48 89 df             	mov    %rbx,%rdi
    aeea:	e8 00 00 00 00       	callq  aeef <e1000_check_for_link+0x55f>
			    e1000_get_speed_and_duplex(hw, &speed, &duplex);
			if (ret_val) {
    aeef:	85 c0                	test   %eax,%eax
		 * is not needed.  If we are at gigabit speed, we turn on TBI
		 * compatibility.
		 */
		if (hw->tbi_compatibility_en) {
			u16 speed, duplex;
			ret_val =
    aef1:	41 89 c5             	mov    %eax,%r13d
			    e1000_get_speed_and_duplex(hw, &speed, &duplex);
			if (ret_val) {
    aef4:	74 32                	je     af28 <e1000_check_for_link+0x598>
				e_dbg
    aef6:	f6 05 00 00 00 00 04 	testb  $0x4,0x0(%rip)        # aefd <e1000_check_for_link+0x56d>
    aefd:	0f 84 d4 fa ff ff    	je     a9d7 <e1000_check_for_link+0x47>
    af03:	48 89 df             	mov    %rbx,%rdi
    af06:	e8 00 00 00 00       	callq  af0b <e1000_check_for_link+0x57b>
    af0b:	48 c7 c2 00 00 00 00 	mov    $0x0,%rdx
    af12:	48 89 c6             	mov    %rax,%rsi
    af15:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
    af1c:	31 c0                	xor    %eax,%eax
    af1e:	e8 00 00 00 00       	callq  af23 <e1000_check_for_link+0x593>
    af23:	e9 af fa ff ff       	jmpq   a9d7 <e1000_check_for_link+0x47>
				    ("Error getting link speed and duplex\n");
				return ret_val;
			}
			if (speed != SPEED_1000) {
    af28:	66 81 7d e4 e8 03    	cmpw   $0x3e8,-0x1c(%rbp)
    af2e:	74 6a                	je     af9a <e1000_check_for_link+0x60a>
				/* If link speed is not set to gigabit speed, we
				 * do not need to enable TBI compatibility.
				 */
				if (hw->tbi_compatibility_on) {
    af30:	80 bb 0f 01 00 00 00 	cmpb   $0x0,0x10f(%rbx)
    af37:	0f 84 b5 fa ff ff    	je     a9f2 <e1000_check_for_link+0x62>
					/* If we previously were in the mode,
					 * turn it off.
					 */
					rctl = er32(RCTL);
    af3d:	48 8b 03             	mov    (%rbx),%rax
    af40:	8b 80 00 01 00 00    	mov    0x100(%rax),%eax
					rctl &= ~E1000_RCTL_SBP;
    af46:	83 e0 fb             	and    $0xfffffffb,%eax
					ew32(RCTL, rctl);
    af49:	48 8b 13             	mov    (%rbx),%rdx
build_mmio_read(__readw, "w", unsigned short, "=r", )
build_mmio_read(__readl, "l", unsigned int, "=r", )

build_mmio_write(writeb, "b", unsigned char, "q", :"memory")
build_mmio_write(writew, "w", unsigned short, "r", :"memory")
build_mmio_write(writel, "l", unsigned int, "r", :"memory")
    af4c:	89 82 00 01 00 00    	mov    %eax,0x100(%rdx)
					hw->tbi_compatibility_on = false;
    af52:	c6 83 0f 01 00 00 00 	movb   $0x0,0x10f(%rbx)
    af59:	e9 94 fa ff ff       	jmpq   a9f2 <e1000_check_for_link+0x62>

			if ((hw->mac_type == e1000_82544
			     || hw->mac_type == e1000_82543) && (!hw->autoneg)
			    && (hw->forced_speed_duplex == e1000_10_full
				|| hw->forced_speed_duplex == e1000_10_half)) {
				ew32(IMC, 0xffffffff);
    af5e:	48 8b 13             	mov    (%rbx),%rdx
    af61:	83 c8 ff             	or     $0xffffffff,%eax
    af64:	89 82 d8 00 00 00    	mov    %eax,0xd8(%rdx)
				ret_val =
    af6a:	48 89 df             	mov    %rbx,%rdi
    af6d:	e8 00 00 00 00       	callq  af72 <e1000_check_for_link+0x5e2>
				    e1000_polarity_reversal_workaround(hw);
				icr = er32(ICR);
    af72:	48 8b 03             	mov    (%rbx),%rax
{ asm volatile("mov" size " %0,%1": :reg (val), \
"m" (*(volatile type __force *)addr) barrier); }

build_mmio_read(readb, "b", unsigned char, "=q", :"memory")
build_mmio_read(readw, "w", unsigned short, "=r", :"memory")
build_mmio_read(readl, "l", unsigned int, "=r", :"memory")
    af75:	8b 80 c0 00 00 00    	mov    0xc0(%rax),%eax
				ew32(ICS, (icr & ~E1000_ICS_LSC));
    af7b:	48 8b 13             	mov    (%rbx),%rdx
    af7e:	83 e0 fb             	and    $0xfffffffb,%eax
build_mmio_read(__readw, "w", unsigned short, "=r", )
build_mmio_read(__readl, "l", unsigned int, "=r", )

build_mmio_write(writeb, "b", unsigned char, "q", :"memory")
build_mmio_write(writew, "w", unsigned short, "r", :"memory")
build_mmio_write(writel, "l", unsigned int, "r", :"memory")
    af81:	89 82 c8 00 00 00    	mov    %eax,0xc8(%rdx)
    af87:	b8 9d 00 00 00       	mov    $0x9d,%eax
				ew32(IMS, IMS_ENABLE_MASK);
    af8c:	48 8b 13             	mov    (%rbx),%rdx
    af8f:	89 82 d0 00 00 00    	mov    %eax,0xd0(%rdx)
    af95:	e9 a8 fb ff ff       	jmpq   ab42 <e1000_check_for_link+0x1b2>
				 * turn it on. For compatibility with a TBI link
				 * partner, we will store bad packets. Some
				 * frames have an additional byte on the end and
				 * will look like CRC errors to to the hardware.
				 */
				if (!hw->tbi_compatibility_on) {
    af9a:	80 bb 0f 01 00 00 00 	cmpb   $0x0,0x10f(%rbx)
    afa1:	0f 85 4b fa ff ff    	jne    a9f2 <e1000_check_for_link+0x62>
					hw->tbi_compatibility_on = true;
    afa7:	c6 83 0f 01 00 00 01 	movb   $0x1,0x10f(%rbx)
					rctl = er32(RCTL);
    afae:	48 8b 03             	mov    (%rbx),%rax
{ asm volatile("mov" size " %0,%1": :reg (val), \
"m" (*(volatile type __force *)addr) barrier); }

build_mmio_read(readb, "b", unsigned char, "=q", :"memory")
build_mmio_read(readw, "w", unsigned short, "=r", :"memory")
build_mmio_read(readl, "l", unsigned int, "=r", :"memory")
    afb1:	8b 80 00 01 00 00    	mov    0x100(%rax),%eax
					rctl |= E1000_RCTL_SBP;
    afb7:	83 c8 04             	or     $0x4,%eax
					ew32(RCTL, rctl);
    afba:	48 8b 13             	mov    (%rbx),%rdx
build_mmio_read(__readw, "w", unsigned short, "=r", )
build_mmio_read(__readl, "l", unsigned int, "=r", )

build_mmio_write(writeb, "b", unsigned char, "q", :"memory")
build_mmio_write(writew, "w", unsigned short, "r", :"memory")
build_mmio_write(writel, "l", unsigned int, "r", :"memory")
    afbd:	89 82 00 01 00 00    	mov    %eax,0x100(%rdx)
    afc3:	e9 2a fa ff ff       	jmpq   a9f2 <e1000_check_for_link+0x62>
		/* If we are forcing link and we are receiving /C/ ordered
		 * sets, re-enable auto-negotiation in the TXCW register
		 * and disable forced link in the Device Control register
		 * in an attempt to auto-negotiate with our link partner.
		 */
		e_dbg("RXing /C/, enable AutoNeg and stop forcing link.\n");
    afc8:	48 89 df             	mov    %rbx,%rdi
    afcb:	e8 00 00 00 00       	callq  afd0 <e1000_check_for_link+0x640>
    afd0:	48 c7 c2 00 00 00 00 	mov    $0x0,%rdx
    afd7:	48 89 c6             	mov    %rax,%rsi
    afda:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
    afe1:	31 c0                	xor    %eax,%eax
    afe3:	e8 00 00 00 00       	callq  afe8 <e1000_check_for_link+0x658>
    afe8:	e9 0e fc ff ff       	jmpq   abfb <e1000_check_for_link+0x26b>
	if ((!(status & E1000_STATUS_LU)) && (!(rxcw & E1000_RXCW_C))) {
		if (hw->autoneg_failed == 0) {
			hw->autoneg_failed = 1;
			goto out;
		}
		e_dbg("NOT RXing /C/, disable AutoNeg and force link.\n");
    afed:	48 89 df             	mov    %rbx,%rdi
    aff0:	e8 00 00 00 00       	callq  aff5 <e1000_check_for_link+0x665>
    aff5:	48 c7 c2 00 00 00 00 	mov    $0x0,%rdx
    affc:	48 89 c6             	mov    %rax,%rsi
    afff:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
    b006:	31 c0                	xor    %eax,%eax
    b008:	e8 00 00 00 00       	callq  b00d <e1000_check_for_link+0x67d>
    b00d:	e9 32 fa ff ff       	jmpq   aa44 <e1000_check_for_link+0xb4>
    b012:	66 66 66 66 66 2e 0f 	data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
    b019:	1f 84 00 00 00 00 00 

000000000000b020 <e1000_phy_setup_autoneg>:
 * @hw: Struct containing variables accessed by shared code
 *
 * Configures PHY autoneg and flow control advertisement settings
 */
s32 e1000_phy_setup_autoneg(struct e1000_hw *hw)
{
    b020:	e8 00 00 00 00       	callq  b025 <e1000_phy_setup_autoneg+0x5>
    b025:	55                   	push   %rbp
	s32 ret_val;
	u16 mii_autoneg_adv_reg;
	u16 mii_1000t_ctrl_reg;

	/* Read the MII Auto-Neg Advertisement Register (Address 4). */
	ret_val = e1000_read_phy_reg(hw, PHY_AUTONEG_ADV, &mii_autoneg_adv_reg);
    b026:	be 04 00 00 00       	mov    $0x4,%esi
 * @hw: Struct containing variables accessed by shared code
 *
 * Configures PHY autoneg and flow control advertisement settings
 */
s32 e1000_phy_setup_autoneg(struct e1000_hw *hw)
{
    b02b:	48 89 e5             	mov    %rsp,%rbp
    b02e:	41 54                	push   %r12
	s32 ret_val;
	u16 mii_autoneg_adv_reg;
	u16 mii_1000t_ctrl_reg;

	/* Read the MII Auto-Neg Advertisement Register (Address 4). */
	ret_val = e1000_read_phy_reg(hw, PHY_AUTONEG_ADV, &mii_autoneg_adv_reg);
    b030:	48 8d 55 ec          	lea    -0x14(%rbp),%rdx
 * @hw: Struct containing variables accessed by shared code
 *
 * Configures PHY autoneg and flow control advertisement settings
 */
s32 e1000_phy_setup_autoneg(struct e1000_hw *hw)
{
    b034:	53                   	push   %rbx
    b035:	48 89 fb             	mov    %rdi,%rbx
    b038:	48 83 ec 08          	sub    $0x8,%rsp
	s32 ret_val;
	u16 mii_autoneg_adv_reg;
	u16 mii_1000t_ctrl_reg;

	/* Read the MII Auto-Neg Advertisement Register (Address 4). */
	ret_val = e1000_read_phy_reg(hw, PHY_AUTONEG_ADV, &mii_autoneg_adv_reg);
    b03c:	e8 00 00 00 00       	callq  b041 <e1000_phy_setup_autoneg+0x21>
	if (ret_val)
    b041:	85 c0                	test   %eax,%eax
    b043:	74 09                	je     b04e <e1000_phy_setup_autoneg+0x2e>
		if (ret_val)
			return ret_val;
	}

	return E1000_SUCCESS;
}
    b045:	48 83 c4 08          	add    $0x8,%rsp
    b049:	5b                   	pop    %rbx
    b04a:	41 5c                	pop    %r12
    b04c:	5d                   	pop    %rbp
    b04d:	c3                   	retq   
	ret_val = e1000_read_phy_reg(hw, PHY_AUTONEG_ADV, &mii_autoneg_adv_reg);
	if (ret_val)
		return ret_val;

	/* Read the MII 1000Base-T Control Register (Address 9). */
	ret_val = e1000_read_phy_reg(hw, PHY_1000T_CTRL, &mii_1000t_ctrl_reg);
    b04e:	48 8d 55 ee          	lea    -0x12(%rbp),%rdx
    b052:	be 09 00 00 00       	mov    $0x9,%esi
    b057:	48 89 df             	mov    %rbx,%rdi
    b05a:	e8 00 00 00 00       	callq  b05f <e1000_phy_setup_autoneg+0x3f>
	if (ret_val)
    b05f:	85 c0                	test   %eax,%eax
    b061:	75 e2                	jne    b045 <e1000_phy_setup_autoneg+0x25>
		return ret_val;
	else if (hw->phy_type == e1000_phy_8201)
    b063:	83 7b 1c 03          	cmpl   $0x3,0x1c(%rbx)
		mii_1000t_ctrl_reg &= ~REG9_SPEED_MASK;
    b067:	0f b7 45 ee          	movzwl -0x12(%rbp),%eax

	/* Read the MII 1000Base-T Control Register (Address 9). */
	ret_val = e1000_read_phy_reg(hw, PHY_1000T_CTRL, &mii_1000t_ctrl_reg);
	if (ret_val)
		return ret_val;
	else if (hw->phy_type == e1000_phy_8201)
    b06b:	0f 84 0d 01 00 00    	je     b17e <e1000_phy_setup_autoneg+0x15e>
	/* First we clear all the 10/100 mb speed bits in the Auto-Neg
	 * Advertisement Register (Address 4) and the 1000 mb speed bits in
	 * the  1000Base-T Control Register (Address 9).
	 */
	mii_autoneg_adv_reg &= ~REG4_SPEED_MASK;
	mii_1000t_ctrl_reg &= ~REG9_SPEED_MASK;
    b071:	80 e4 fc             	and    $0xfc,%ah

	/* First we clear all the 10/100 mb speed bits in the Auto-Neg
	 * Advertisement Register (Address 4) and the 1000 mb speed bits in
	 * the  1000Base-T Control Register (Address 9).
	 */
	mii_autoneg_adv_reg &= ~REG4_SPEED_MASK;
    b074:	66 81 65 ec 1f fe    	andw   $0xfe1f,-0x14(%rbp)
	mii_1000t_ctrl_reg &= ~REG9_SPEED_MASK;

	e_dbg("autoneg_advertised %x\n", hw->autoneg_advertised);
    b07a:	f6 05 00 00 00 00 04 	testb  $0x4,0x0(%rip)        # b081 <e1000_phy_setup_autoneg+0x61>
	/* First we clear all the 10/100 mb speed bits in the Auto-Neg
	 * Advertisement Register (Address 4) and the 1000 mb speed bits in
	 * the  1000Base-T Control Register (Address 9).
	 */
	mii_autoneg_adv_reg &= ~REG4_SPEED_MASK;
	mii_1000t_ctrl_reg &= ~REG9_SPEED_MASK;
    b081:	66 89 45 ee          	mov    %ax,-0x12(%rbp)

	e_dbg("autoneg_advertised %x\n", hw->autoneg_advertised);
    b085:	0f 85 2b 01 00 00    	jne    b1b6 <e1000_phy_setup_autoneg+0x196>
    b08b:	0f b7 83 d2 00 00 00 	movzwl 0xd2(%rbx),%eax

	/* Do we want to advertise 10 Mb Half Duplex? */
	if (hw->autoneg_advertised & ADVERTISE_10_HALF) {
    b092:	a8 01                	test   $0x1,%al
    b094:	74 12                	je     b0a8 <e1000_phy_setup_autoneg+0x88>
		e_dbg("Advertise 10mb Half duplex\n");
    b096:	f6 05 00 00 00 00 04 	testb  $0x4,0x0(%rip)        # b09d <e1000_phy_setup_autoneg+0x7d>
    b09d:	0f 85 9a 01 00 00    	jne    b23d <e1000_phy_setup_autoneg+0x21d>
		mii_autoneg_adv_reg |= NWAY_AR_10T_HD_CAPS;
    b0a3:	66 83 4d ec 20       	orw    $0x20,-0x14(%rbp)
	}

	/* Do we want to advertise 10 Mb Full Duplex? */
	if (hw->autoneg_advertised & ADVERTISE_10_FULL) {
    b0a8:	a8 02                	test   $0x2,%al
    b0aa:	74 12                	je     b0be <e1000_phy_setup_autoneg+0x9e>
		e_dbg("Advertise 10mb Full duplex\n");
    b0ac:	f6 05 00 00 00 00 04 	testb  $0x4,0x0(%rip)        # b0b3 <e1000_phy_setup_autoneg+0x93>
    b0b3:	0f 85 b0 01 00 00    	jne    b269 <e1000_phy_setup_autoneg+0x249>
		mii_autoneg_adv_reg |= NWAY_AR_10T_FD_CAPS;
    b0b9:	66 83 4d ec 40       	orw    $0x40,-0x14(%rbp)
	}

	/* Do we want to advertise 100 Mb Half Duplex? */
	if (hw->autoneg_advertised & ADVERTISE_100_HALF) {
    b0be:	a8 04                	test   $0x4,%al
    b0c0:	74 13                	je     b0d5 <e1000_phy_setup_autoneg+0xb5>
		e_dbg("Advertise 100mb Half duplex\n");
    b0c2:	f6 05 00 00 00 00 04 	testb  $0x4,0x0(%rip)        # b0c9 <e1000_phy_setup_autoneg+0xa9>
    b0c9:	0f 85 c6 01 00 00    	jne    b295 <e1000_phy_setup_autoneg+0x275>
		mii_autoneg_adv_reg |= NWAY_AR_100TX_HD_CAPS;
    b0cf:	66 81 4d ec 80 00    	orw    $0x80,-0x14(%rbp)
	}

	/* Do we want to advertise 100 Mb Full Duplex? */
	if (hw->autoneg_advertised & ADVERTISE_100_FULL) {
    b0d5:	a8 08                	test   $0x8,%al
    b0d7:	74 13                	je     b0ec <e1000_phy_setup_autoneg+0xcc>
		e_dbg("Advertise 100mb Full duplex\n");
    b0d9:	f6 05 00 00 00 00 04 	testb  $0x4,0x0(%rip)        # b0e0 <e1000_phy_setup_autoneg+0xc0>
    b0e0:	0f 85 db 01 00 00    	jne    b2c1 <e1000_phy_setup_autoneg+0x2a1>
		mii_autoneg_adv_reg |= NWAY_AR_100TX_FD_CAPS;
    b0e6:	66 81 4d ec 00 01    	orw    $0x100,-0x14(%rbp)
	}

	/* We do not allow the Phy to advertise 1000 Mb Half Duplex */
	if (hw->autoneg_advertised & ADVERTISE_1000_HALF) {
    b0ec:	a8 10                	test   $0x10,%al
    b0ee:	74 0d                	je     b0fd <e1000_phy_setup_autoneg+0xdd>
		e_dbg
    b0f0:	f6 05 00 00 00 00 04 	testb  $0x4,0x0(%rip)        # b0f7 <e1000_phy_setup_autoneg+0xd7>
    b0f7:	0f 85 f0 01 00 00    	jne    b2ed <e1000_phy_setup_autoneg+0x2cd>
		    ("Advertise 1000mb Half duplex requested, request denied!\n");
	}

	/* Do we want to advertise 1000 Mb Full Duplex? */
	if (hw->autoneg_advertised & ADVERTISE_1000_FULL) {
    b0fd:	a8 20                	test   $0x20,%al
    b0ff:	74 13                	je     b114 <e1000_phy_setup_autoneg+0xf4>
		e_dbg("Advertise 1000mb Full duplex\n");
    b101:	f6 05 00 00 00 00 04 	testb  $0x4,0x0(%rip)        # b108 <e1000_phy_setup_autoneg+0xe8>
    b108:	0f 85 0b 02 00 00    	jne    b319 <e1000_phy_setup_autoneg+0x2f9>
		mii_1000t_ctrl_reg |= CR_1000T_FD_CAPS;
    b10e:	66 81 4d ee 00 02    	orw    $0x200,-0x12(%rbp)
	 *          but we do not support receiving pause frames).
	 *      3:  Both Rx and TX flow control (symmetric) are enabled.
	 *  other:  No software override.  The flow control configuration
	 *          in the EEPROM is used.
	 */
	switch (hw->fc) {
    b114:	8b 43 40             	mov    0x40(%rbx),%eax
    b117:	83 f8 01             	cmp    $0x1,%eax
    b11a:	74 10                	je     b12c <e1000_phy_setup_autoneg+0x10c>
    b11c:	0f 82 87 00 00 00    	jb     b1a9 <e1000_phy_setup_autoneg+0x189>
    b122:	83 f8 02             	cmp    $0x2,%eax
    b125:	74 72                	je     b199 <e1000_phy_setup_autoneg+0x179>
    b127:	83 f8 03             	cmp    $0x3,%eax
    b12a:	75 5a                	jne    b186 <e1000_phy_setup_autoneg+0x166>
		break;
	case E1000_FC_FULL:	/* 3 */
		/* Flow control (both RX and TX) is enabled by a software
		 * over-ride.
		 */
		mii_autoneg_adv_reg |= (NWAY_AR_ASM_DIR | NWAY_AR_PAUSE);
    b12c:	0f b7 55 ec          	movzwl -0x14(%rbp),%edx
    b130:	80 ce 0c             	or     $0xc,%dh
    b133:	66 89 55 ec          	mov    %dx,-0x14(%rbp)
	default:
		e_dbg("Flow control param set incorrectly\n");
		return -E1000_ERR_CONFIG;
	}

	ret_val = e1000_write_phy_reg(hw, PHY_AUTONEG_ADV, mii_autoneg_adv_reg);
    b137:	0f b7 d2             	movzwl %dx,%edx
    b13a:	be 04 00 00 00       	mov    $0x4,%esi
    b13f:	48 89 df             	mov    %rbx,%rdi
    b142:	e8 00 00 00 00       	callq  b147 <e1000_phy_setup_autoneg+0x127>
	if (ret_val)
    b147:	85 c0                	test   %eax,%eax
    b149:	0f 85 f6 fe ff ff    	jne    b045 <e1000_phy_setup_autoneg+0x25>
		return ret_val;

	e_dbg("Auto-Neg Advertising %x\n", mii_autoneg_adv_reg);
    b14f:	f6 05 00 00 00 00 04 	testb  $0x4,0x0(%rip)        # b156 <e1000_phy_setup_autoneg+0x136>
    b156:	0f 85 b4 00 00 00    	jne    b210 <e1000_phy_setup_autoneg+0x1f0>
		                              mii_1000t_ctrl_reg);
		if (ret_val)
			return ret_val;
	}

	return E1000_SUCCESS;
    b15c:	31 c0                	xor    %eax,%eax
	if (ret_val)
		return ret_val;

	e_dbg("Auto-Neg Advertising %x\n", mii_autoneg_adv_reg);

	if (hw->phy_type == e1000_phy_8201) {
    b15e:	83 7b 1c 03          	cmpl   $0x3,0x1c(%rbx)
    b162:	0f 84 dd fe ff ff    	je     b045 <e1000_phy_setup_autoneg+0x25>
		mii_1000t_ctrl_reg = 0;
	} else {
		ret_val = e1000_write_phy_reg(hw, PHY_1000T_CTRL,
    b168:	0f b7 55 ee          	movzwl -0x12(%rbp),%edx
    b16c:	be 09 00 00 00       	mov    $0x9,%esi
    b171:	48 89 df             	mov    %rbx,%rdi
    b174:	e8 00 00 00 00       	callq  b179 <e1000_phy_setup_autoneg+0x159>
    b179:	e9 c7 fe ff ff       	jmpq   b045 <e1000_phy_setup_autoneg+0x25>
	/* Read the MII 1000Base-T Control Register (Address 9). */
	ret_val = e1000_read_phy_reg(hw, PHY_1000T_CTRL, &mii_1000t_ctrl_reg);
	if (ret_val)
		return ret_val;
	else if (hw->phy_type == e1000_phy_8201)
		mii_1000t_ctrl_reg &= ~REG9_SPEED_MASK;
    b17e:	80 e4 fc             	and    $0xfc,%ah
    b181:	e9 eb fe ff ff       	jmpq   b071 <e1000_phy_setup_autoneg+0x51>
		 * over-ride.
		 */
		mii_autoneg_adv_reg |= (NWAY_AR_ASM_DIR | NWAY_AR_PAUSE);
		break;
	default:
		e_dbg("Flow control param set incorrectly\n");
    b186:	f6 05 00 00 00 00 04 	testb  $0x4,0x0(%rip)        # b18d <e1000_phy_setup_autoneg+0x16d>
    b18d:	75 57                	jne    b1e6 <e1000_phy_setup_autoneg+0x1c6>
		return -E1000_ERR_CONFIG;
    b18f:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
    b194:	e9 ac fe ff ff       	jmpq   b045 <e1000_phy_setup_autoneg+0x25>
	case E1000_FC_TX_PAUSE:	/* 2 */
		/* TX Flow control is enabled, and RX Flow control is
		 * disabled, by a software over-ride.
		 */
		mii_autoneg_adv_reg |= NWAY_AR_ASM_DIR;
		mii_autoneg_adv_reg &= ~NWAY_AR_PAUSE;
    b199:	0f b7 55 ec          	movzwl -0x14(%rbp),%edx
    b19d:	80 e6 fb             	and    $0xfb,%dh
    b1a0:	80 ce 08             	or     $0x8,%dh
    b1a3:	66 89 55 ec          	mov    %dx,-0x14(%rbp)
		break;
    b1a7:	eb 8e                	jmp    b137 <e1000_phy_setup_autoneg+0x117>
	switch (hw->fc) {
	case E1000_FC_NONE:	/* 0 */
		/* Flow control (RX & TX) is completely disabled by a
		 * software over-ride.
		 */
		mii_autoneg_adv_reg &= ~(NWAY_AR_ASM_DIR | NWAY_AR_PAUSE);
    b1a9:	0f b7 55 ec          	movzwl -0x14(%rbp),%edx
    b1ad:	80 e6 f3             	and    $0xf3,%dh
    b1b0:	66 89 55 ec          	mov    %dx,-0x14(%rbp)
		break;
    b1b4:	eb 81                	jmp    b137 <e1000_phy_setup_autoneg+0x117>
	 * the  1000Base-T Control Register (Address 9).
	 */
	mii_autoneg_adv_reg &= ~REG4_SPEED_MASK;
	mii_1000t_ctrl_reg &= ~REG9_SPEED_MASK;

	e_dbg("autoneg_advertised %x\n", hw->autoneg_advertised);
    b1b6:	44 0f b7 a3 d2 00 00 	movzwl 0xd2(%rbx),%r12d
    b1bd:	00 
    b1be:	48 89 df             	mov    %rbx,%rdi
    b1c1:	e8 00 00 00 00       	callq  b1c6 <e1000_phy_setup_autoneg+0x1a6>
    b1c6:	48 c7 c2 00 00 00 00 	mov    $0x0,%rdx
    b1cd:	48 89 c6             	mov    %rax,%rsi
    b1d0:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
    b1d7:	31 c0                	xor    %eax,%eax
    b1d9:	44 89 e1             	mov    %r12d,%ecx
    b1dc:	e8 00 00 00 00       	callq  b1e1 <e1000_phy_setup_autoneg+0x1c1>
    b1e1:	e9 a5 fe ff ff       	jmpq   b08b <e1000_phy_setup_autoneg+0x6b>
		 * over-ride.
		 */
		mii_autoneg_adv_reg |= (NWAY_AR_ASM_DIR | NWAY_AR_PAUSE);
		break;
	default:
		e_dbg("Flow control param set incorrectly\n");
    b1e6:	48 89 df             	mov    %rbx,%rdi
    b1e9:	e8 00 00 00 00       	callq  b1ee <e1000_phy_setup_autoneg+0x1ce>
    b1ee:	48 c7 c2 00 00 00 00 	mov    $0x0,%rdx
    b1f5:	48 89 c6             	mov    %rax,%rsi
    b1f8:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
    b1ff:	31 c0                	xor    %eax,%eax
    b201:	e8 00 00 00 00       	callq  b206 <e1000_phy_setup_autoneg+0x1e6>
		return -E1000_ERR_CONFIG;
    b206:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
    b20b:	e9 35 fe ff ff       	jmpq   b045 <e1000_phy_setup_autoneg+0x25>

	ret_val = e1000_write_phy_reg(hw, PHY_AUTONEG_ADV, mii_autoneg_adv_reg);
	if (ret_val)
		return ret_val;

	e_dbg("Auto-Neg Advertising %x\n", mii_autoneg_adv_reg);
    b210:	44 0f b7 65 ec       	movzwl -0x14(%rbp),%r12d
    b215:	48 89 df             	mov    %rbx,%rdi
    b218:	e8 00 00 00 00       	callq  b21d <e1000_phy_setup_autoneg+0x1fd>
    b21d:	48 c7 c2 00 00 00 00 	mov    $0x0,%rdx
    b224:	48 89 c6             	mov    %rax,%rsi
    b227:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
    b22e:	31 c0                	xor    %eax,%eax
    b230:	44 89 e1             	mov    %r12d,%ecx
    b233:	e8 00 00 00 00       	callq  b238 <e1000_phy_setup_autoneg+0x218>
    b238:	e9 1f ff ff ff       	jmpq   b15c <e1000_phy_setup_autoneg+0x13c>

	e_dbg("autoneg_advertised %x\n", hw->autoneg_advertised);

	/* Do we want to advertise 10 Mb Half Duplex? */
	if (hw->autoneg_advertised & ADVERTISE_10_HALF) {
		e_dbg("Advertise 10mb Half duplex\n");
    b23d:	48 89 df             	mov    %rbx,%rdi
    b240:	e8 00 00 00 00       	callq  b245 <e1000_phy_setup_autoneg+0x225>
    b245:	48 c7 c2 00 00 00 00 	mov    $0x0,%rdx
    b24c:	48 89 c6             	mov    %rax,%rsi
    b24f:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
    b256:	31 c0                	xor    %eax,%eax
    b258:	e8 00 00 00 00       	callq  b25d <e1000_phy_setup_autoneg+0x23d>
    b25d:	0f b7 83 d2 00 00 00 	movzwl 0xd2(%rbx),%eax
    b264:	e9 3a fe ff ff       	jmpq   b0a3 <e1000_phy_setup_autoneg+0x83>
		mii_autoneg_adv_reg |= NWAY_AR_10T_HD_CAPS;
	}

	/* Do we want to advertise 10 Mb Full Duplex? */
	if (hw->autoneg_advertised & ADVERTISE_10_FULL) {
		e_dbg("Advertise 10mb Full duplex\n");
    b269:	48 89 df             	mov    %rbx,%rdi
    b26c:	e8 00 00 00 00       	callq  b271 <e1000_phy_setup_autoneg+0x251>
    b271:	48 c7 c2 00 00 00 00 	mov    $0x0,%rdx
    b278:	48 89 c6             	mov    %rax,%rsi
    b27b:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
    b282:	31 c0                	xor    %eax,%eax
    b284:	e8 00 00 00 00       	callq  b289 <e1000_phy_setup_autoneg+0x269>
    b289:	0f b7 83 d2 00 00 00 	movzwl 0xd2(%rbx),%eax
    b290:	e9 24 fe ff ff       	jmpq   b0b9 <e1000_phy_setup_autoneg+0x99>
		mii_autoneg_adv_reg |= NWAY_AR_10T_FD_CAPS;
	}

	/* Do we want to advertise 100 Mb Half Duplex? */
	if (hw->autoneg_advertised & ADVERTISE_100_HALF) {
		e_dbg("Advertise 100mb Half duplex\n");
    b295:	48 89 df             	mov    %rbx,%rdi
    b298:	e8 00 00 00 00       	callq  b29d <e1000_phy_setup_autoneg+0x27d>
    b29d:	48 c7 c2 00 00 00 00 	mov    $0x0,%rdx
    b2a4:	48 89 c6             	mov    %rax,%rsi
    b2a7:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
    b2ae:	31 c0                	xor    %eax,%eax
    b2b0:	e8 00 00 00 00       	callq  b2b5 <e1000_phy_setup_autoneg+0x295>
    b2b5:	0f b7 83 d2 00 00 00 	movzwl 0xd2(%rbx),%eax
    b2bc:	e9 0e fe ff ff       	jmpq   b0cf <e1000_phy_setup_autoneg+0xaf>
		mii_autoneg_adv_reg |= NWAY_AR_100TX_HD_CAPS;
	}

	/* Do we want to advertise 100 Mb Full Duplex? */
	if (hw->autoneg_advertised & ADVERTISE_100_FULL) {
		e_dbg("Advertise 100mb Full duplex\n");
    b2c1:	48 89 df             	mov    %rbx,%rdi
    b2c4:	e8 00 00 00 00       	callq  b2c9 <e1000_phy_setup_autoneg+0x2a9>
    b2c9:	48 c7 c2 00 00 00 00 	mov    $0x0,%rdx
    b2d0:	48 89 c6             	mov    %rax,%rsi
    b2d3:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
    b2da:	31 c0                	xor    %eax,%eax
    b2dc:	e8 00 00 00 00       	callq  b2e1 <e1000_phy_setup_autoneg+0x2c1>
    b2e1:	0f b7 83 d2 00 00 00 	movzwl 0xd2(%rbx),%eax
    b2e8:	e9 f9 fd ff ff       	jmpq   b0e6 <e1000_phy_setup_autoneg+0xc6>
		mii_autoneg_adv_reg |= NWAY_AR_100TX_FD_CAPS;
	}

	/* We do not allow the Phy to advertise 1000 Mb Half Duplex */
	if (hw->autoneg_advertised & ADVERTISE_1000_HALF) {
		e_dbg
    b2ed:	48 89 df             	mov    %rbx,%rdi
    b2f0:	e8 00 00 00 00       	callq  b2f5 <e1000_phy_setup_autoneg+0x2d5>
    b2f5:	48 c7 c2 00 00 00 00 	mov    $0x0,%rdx
    b2fc:	48 89 c6             	mov    %rax,%rsi
    b2ff:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
    b306:	31 c0                	xor    %eax,%eax
    b308:	e8 00 00 00 00       	callq  b30d <e1000_phy_setup_autoneg+0x2ed>
    b30d:	0f b7 83 d2 00 00 00 	movzwl 0xd2(%rbx),%eax
    b314:	e9 e4 fd ff ff       	jmpq   b0fd <e1000_phy_setup_autoneg+0xdd>
		    ("Advertise 1000mb Half duplex requested, request denied!\n");
	}

	/* Do we want to advertise 1000 Mb Full Duplex? */
	if (hw->autoneg_advertised & ADVERTISE_1000_FULL) {
		e_dbg("Advertise 1000mb Full duplex\n");
    b319:	48 89 df             	mov    %rbx,%rdi
    b31c:	e8 00 00 00 00       	callq  b321 <e1000_phy_setup_autoneg+0x301>
    b321:	48 c7 c2 00 00 00 00 	mov    $0x0,%rdx
    b328:	48 89 c6             	mov    %rax,%rsi
    b32b:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
    b332:	31 c0                	xor    %eax,%eax
    b334:	e8 00 00 00 00       	callq  b339 <e1000_phy_setup_autoneg+0x319>
    b339:	e9 d0 fd ff ff       	jmpq   b10e <e1000_phy_setup_autoneg+0xee>
    b33e:	66 90                	xchg   %ax,%ax

000000000000b340 <e1000_phy_hw_reset>:
 * @hw: Struct containing variables accessed by shared code
 *
 * Returns the PHY to the power-on reset state
 */
s32 e1000_phy_hw_reset(struct e1000_hw *hw)
{
    b340:	e8 00 00 00 00       	callq  b345 <e1000_phy_hw_reset+0x5>
    b345:	55                   	push   %rbp
	u32 ctrl, ctrl_ext;
	u32 led_ctrl;

	e_dbg("Resetting Phy...\n");
    b346:	f6 05 00 00 00 00 04 	testb  $0x4,0x0(%rip)        # b34d <e1000_phy_hw_reset+0xd>
 * @hw: Struct containing variables accessed by shared code
 *
 * Returns the PHY to the power-on reset state
 */
s32 e1000_phy_hw_reset(struct e1000_hw *hw)
{
    b34d:	48 89 e5             	mov    %rsp,%rbp
    b350:	41 54                	push   %r12
    b352:	53                   	push   %rbx
    b353:	48 89 fb             	mov    %rdi,%rbx
	u32 ctrl, ctrl_ext;
	u32 led_ctrl;

	e_dbg("Resetting Phy...\n");
    b356:	0f 85 b3 00 00 00    	jne    b40f <e1000_phy_hw_reset+0xcf>

	if (hw->mac_type > e1000_82543) {
    b35c:	83 7b 18 03          	cmpl   $0x3,0x18(%rbx)
		/* Read the device control register and assert the
		 * E1000_CTRL_PHY_RST bit. Then, take it out of reset.
		 * For e1000 hardware, we delay for 10ms between the assert
		 * and de-assert.
		 */
		ctrl = er32(CTRL);
    b360:	48 8b 03             	mov    (%rbx),%rax
	u32 ctrl, ctrl_ext;
	u32 led_ctrl;

	e_dbg("Resetting Phy...\n");

	if (hw->mac_type > e1000_82543) {
    b363:	76 69                	jbe    b3ce <e1000_phy_hw_reset+0x8e>
{ asm volatile("mov" size " %0,%1": :reg (val), \
"m" (*(volatile type __force *)addr) barrier); }

build_mmio_read(readb, "b", unsigned char, "=q", :"memory")
build_mmio_read(readw, "w", unsigned short, "=r", :"memory")
build_mmio_read(readl, "l", unsigned int, "=r", :"memory")
    b365:	44 8b 20             	mov    (%rax),%r12d
		 * E1000_CTRL_PHY_RST bit. Then, take it out of reset.
		 * For e1000 hardware, we delay for 10ms between the assert
		 * and de-assert.
		 */
		ctrl = er32(CTRL);
		ew32(CTRL, ctrl | E1000_CTRL_PHY_RST);
    b368:	44 89 e0             	mov    %r12d,%eax
    b36b:	48 8b 13             	mov    (%rbx),%rdx
    b36e:	0d 00 00 00 80       	or     $0x80000000,%eax
build_mmio_read(__readw, "w", unsigned short, "=r", )
build_mmio_read(__readl, "l", unsigned int, "=r", )

build_mmio_write(writeb, "b", unsigned char, "q", :"memory")
build_mmio_write(writew, "w", unsigned short, "r", :"memory")
build_mmio_write(writel, "l", unsigned int, "r", :"memory")
    b373:	89 02                	mov    %eax,(%rdx)
		E1000_WRITE_FLUSH();
    b375:	48 8b 03             	mov    (%rbx),%rax
{ asm volatile("mov" size " %0,%1": :reg (val), \
"m" (*(volatile type __force *)addr) barrier); }

build_mmio_read(readb, "b", unsigned char, "=q", :"memory")
build_mmio_read(readw, "w", unsigned short, "=r", :"memory")
build_mmio_read(readl, "l", unsigned int, "=r", :"memory")
    b378:	8b 40 08             	mov    0x8(%rax),%eax

		msleep(10);
    b37b:	bf 0a 00 00 00       	mov    $0xa,%edi
    b380:	e8 00 00 00 00       	callq  b385 <e1000_phy_hw_reset+0x45>

		ew32(CTRL, ctrl);
    b385:	48 8b 03             	mov    (%rbx),%rax
build_mmio_read(__readw, "w", unsigned short, "=r", )
build_mmio_read(__readl, "l", unsigned int, "=r", )

build_mmio_write(writeb, "b", unsigned char, "q", :"memory")
build_mmio_write(writew, "w", unsigned short, "r", :"memory")
build_mmio_write(writel, "l", unsigned int, "r", :"memory")
    b388:	44 89 20             	mov    %r12d,(%rax)
		E1000_WRITE_FLUSH();
    b38b:	48 8b 03             	mov    (%rbx),%rax
{ asm volatile("mov" size " %0,%1": :reg (val), \
"m" (*(volatile type __force *)addr) barrier); }

build_mmio_read(readb, "b", unsigned char, "=q", :"memory")
build_mmio_read(readw, "w", unsigned short, "=r", :"memory")
build_mmio_read(readl, "l", unsigned int, "=r", :"memory")
    b38e:	8b 40 08             	mov    0x8(%rax),%eax
		msleep(10);
		ctrl_ext |= E1000_CTRL_EXT_SDP4_DATA;
		ew32(CTRL_EXT, ctrl_ext);
		E1000_WRITE_FLUSH();
	}
	udelay(150);
    b391:	bf 9a d4 09 00       	mov    $0x9d49a,%edi
    b396:	e8 00 00 00 00       	callq  b39b <e1000_phy_hw_reset+0x5b>

	if ((hw->mac_type == e1000_82541) || (hw->mac_type == e1000_82547)) {
    b39b:	8b 43 18             	mov    0x18(%rbx),%eax
    b39e:	83 f8 0d             	cmp    $0xd,%eax
    b3a1:	75 65                	jne    b408 <e1000_phy_hw_reset+0xc8>
		/* Configure activity LED after PHY reset */
		led_ctrl = er32(LEDCTL);
    b3a3:	48 8b 03             	mov    (%rbx),%rax
    b3a6:	8b 80 00 0e 00 00    	mov    0xe00(%rax),%eax
		led_ctrl &= IGP_ACTIVITY_LED_MASK;
    b3ac:	80 e4 f0             	and    $0xf0,%ah
		led_ctrl |= (IGP_ACTIVITY_LED_ENABLE | IGP_LED3_MODE);
		ew32(LEDCTL, led_ctrl);
    b3af:	48 8b 13             	mov    (%rbx),%rdx

	if ((hw->mac_type == e1000_82541) || (hw->mac_type == e1000_82547)) {
		/* Configure activity LED after PHY reset */
		led_ctrl = er32(LEDCTL);
		led_ctrl &= IGP_ACTIVITY_LED_MASK;
		led_ctrl |= (IGP_ACTIVITY_LED_ENABLE | IGP_LED3_MODE);
    b3b2:	0d 00 03 00 07       	or     $0x7000300,%eax
build_mmio_read(__readw, "w", unsigned short, "=r", )
build_mmio_read(__readl, "l", unsigned int, "=r", )

build_mmio_write(writeb, "b", unsigned char, "q", :"memory")
build_mmio_write(writew, "w", unsigned short, "r", :"memory")
build_mmio_write(writel, "l", unsigned int, "r", :"memory")
    b3b7:	89 82 00 0e 00 00    	mov    %eax,0xe00(%rdx)
 * returns: - E1000_ERR_RESET if fail to reset MAC
 *            E1000_SUCCESS at any other case.
 */
static s32 e1000_get_phy_cfg_done(struct e1000_hw *hw)
{
	msleep(10);
    b3bd:	bf 0a 00 00 00       	mov    $0xa,%edi
    b3c2:	e8 00 00 00 00       	callq  b3c7 <e1000_phy_hw_reset+0x87>
		ew32(LEDCTL, led_ctrl);
	}

	/* Wait for FW to finish PHY configuration. */
	return e1000_get_phy_cfg_done(hw);
}
    b3c7:	5b                   	pop    %rbx
    b3c8:	41 5c                	pop    %r12
    b3ca:	31 c0                	xor    %eax,%eax
    b3cc:	5d                   	pop    %rbp
    b3cd:	c3                   	retq   
{ asm volatile("mov" size " %0,%1": :reg (val), \
"m" (*(volatile type __force *)addr) barrier); }

build_mmio_read(readb, "b", unsigned char, "=q", :"memory")
build_mmio_read(readw, "w", unsigned short, "=r", :"memory")
build_mmio_read(readl, "l", unsigned int, "=r", :"memory")
    b3ce:	44 8b 60 18          	mov    0x18(%rax),%r12d
		 * PHY_RESET_DIR bit to put the PHY into reset. Then, take it
		 * out of reset.
		 */
		ctrl_ext = er32(CTRL_EXT);
		ctrl_ext |= E1000_CTRL_EXT_SDP4_DIR;
		ctrl_ext &= ~E1000_CTRL_EXT_SDP4_DATA;
    b3d2:	41 83 e4 ef          	and    $0xffffffef,%r12d
		ew32(CTRL_EXT, ctrl_ext);
    b3d6:	48 8b 13             	mov    (%rbx),%rdx
		 * PHY_RESET_DIR bit to put the PHY into reset. Then, take it
		 * out of reset.
		 */
		ctrl_ext = er32(CTRL_EXT);
		ctrl_ext |= E1000_CTRL_EXT_SDP4_DIR;
		ctrl_ext &= ~E1000_CTRL_EXT_SDP4_DATA;
    b3d9:	44 89 e0             	mov    %r12d,%eax
    b3dc:	80 cc 01             	or     $0x1,%ah
build_mmio_read(__readw, "w", unsigned short, "=r", )
build_mmio_read(__readl, "l", unsigned int, "=r", )

build_mmio_write(writeb, "b", unsigned char, "q", :"memory")
build_mmio_write(writew, "w", unsigned short, "r", :"memory")
build_mmio_write(writel, "l", unsigned int, "r", :"memory")
    b3df:	89 42 18             	mov    %eax,0x18(%rdx)
		ew32(CTRL_EXT, ctrl_ext);
		E1000_WRITE_FLUSH();
    b3e2:	48 8b 03             	mov    (%rbx),%rax
{ asm volatile("mov" size " %0,%1": :reg (val), \
"m" (*(volatile type __force *)addr) barrier); }

build_mmio_read(readb, "b", unsigned char, "=q", :"memory")
build_mmio_read(readw, "w", unsigned short, "=r", :"memory")
build_mmio_read(readl, "l", unsigned int, "=r", :"memory")
    b3e5:	8b 40 08             	mov    0x8(%rax),%eax
		msleep(10);
    b3e8:	bf 0a 00 00 00       	mov    $0xa,%edi
		ctrl_ext |= E1000_CTRL_EXT_SDP4_DATA;
    b3ed:	41 81 cc 10 01 00 00 	or     $0x110,%r12d
		ctrl_ext = er32(CTRL_EXT);
		ctrl_ext |= E1000_CTRL_EXT_SDP4_DIR;
		ctrl_ext &= ~E1000_CTRL_EXT_SDP4_DATA;
		ew32(CTRL_EXT, ctrl_ext);
		E1000_WRITE_FLUSH();
		msleep(10);
    b3f4:	e8 00 00 00 00       	callq  b3f9 <e1000_phy_hw_reset+0xb9>
		ctrl_ext |= E1000_CTRL_EXT_SDP4_DATA;
		ew32(CTRL_EXT, ctrl_ext);
    b3f9:	48 8b 03             	mov    (%rbx),%rax
build_mmio_read(__readw, "w", unsigned short, "=r", )
build_mmio_read(__readl, "l", unsigned int, "=r", )

build_mmio_write(writeb, "b", unsigned char, "q", :"memory")
build_mmio_write(writew, "w", unsigned short, "r", :"memory")
build_mmio_write(writel, "l", unsigned int, "r", :"memory")
    b3fc:	44 89 60 18          	mov    %r12d,0x18(%rax)
		E1000_WRITE_FLUSH();
    b400:	48 8b 03             	mov    (%rbx),%rax
{ asm volatile("mov" size " %0,%1": :reg (val), \
"m" (*(volatile type __force *)addr) barrier); }

build_mmio_read(readb, "b", unsigned char, "=q", :"memory")
build_mmio_read(readw, "w", unsigned short, "=r", :"memory")
build_mmio_read(readl, "l", unsigned int, "=r", :"memory")
    b403:	8b 40 08             	mov    0x8(%rax),%eax
    b406:	eb 89                	jmp    b391 <e1000_phy_hw_reset+0x51>
	}
	udelay(150);

	if ((hw->mac_type == e1000_82541) || (hw->mac_type == e1000_82547)) {
    b408:	83 f8 0b             	cmp    $0xb,%eax
    b40b:	74 96                	je     b3a3 <e1000_phy_hw_reset+0x63>
    b40d:	eb ae                	jmp    b3bd <e1000_phy_hw_reset+0x7d>
    b40f:	90                   	nop
s32 e1000_phy_hw_reset(struct e1000_hw *hw)
{
	u32 ctrl, ctrl_ext;
	u32 led_ctrl;

	e_dbg("Resetting Phy...\n");
    b410:	e8 00 00 00 00       	callq  b415 <e1000_phy_hw_reset+0xd5>
    b415:	48 c7 c2 00 00 00 00 	mov    $0x0,%rdx
    b41c:	48 89 c6             	mov    %rax,%rsi
    b41f:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
    b426:	31 c0                	xor    %eax,%eax
    b428:	e8 00 00 00 00       	callq  b42d <e1000_phy_hw_reset+0xed>
    b42d:	e9 2a ff ff ff       	jmpq   b35c <e1000_phy_hw_reset+0x1c>
    b432:	66 66 66 66 66 2e 0f 	data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
    b439:	1f 84 00 00 00 00 00 

000000000000b440 <e1000_phy_reset>:
 *
 * Resets the PHY
 * Sets bit 15 of the MII Control register
 */
s32 e1000_phy_reset(struct e1000_hw *hw)
{
    b440:	e8 00 00 00 00       	callq  b445 <e1000_phy_reset+0x5>
    b445:	55                   	push   %rbp
    b446:	48 89 e5             	mov    %rsp,%rbp
    b449:	53                   	push   %rbx
    b44a:	48 89 fb             	mov    %rdi,%rbx
    b44d:	48 83 ec 10          	sub    $0x10,%rsp
	s32 ret_val;
	u16 phy_data;

	switch (hw->phy_type) {
    b451:	83 7f 1c 01          	cmpl   $0x1,0x1c(%rdi)
    b455:	75 18                	jne    b46f <e1000_phy_reset+0x2f>
	case e1000_phy_igp:
		ret_val = e1000_phy_hw_reset(hw);
    b457:	e8 00 00 00 00       	callq  b45c <e1000_phy_reset+0x1c>
		if (ret_val)
    b45c:	85 c0                	test   %eax,%eax
    b45e:	75 08                	jne    b468 <e1000_phy_reset+0x28>
	}

	if (hw->phy_type == e1000_phy_igp)
		e1000_phy_init_script(hw);

	return E1000_SUCCESS;
    b460:	31 c0                	xor    %eax,%eax

		udelay(1);
		break;
	}

	if (hw->phy_type == e1000_phy_igp)
    b462:	83 7b 1c 01          	cmpl   $0x1,0x1c(%rbx)
    b466:	74 40                	je     b4a8 <e1000_phy_reset+0x68>
		e1000_phy_init_script(hw);

	return E1000_SUCCESS;
}
    b468:	48 83 c4 10          	add    $0x10,%rsp
    b46c:	5b                   	pop    %rbx
    b46d:	5d                   	pop    %rbp
    b46e:	c3                   	retq   
		ret_val = e1000_phy_hw_reset(hw);
		if (ret_val)
			return ret_val;
		break;
	default:
		ret_val = e1000_read_phy_reg(hw, PHY_CTRL, &phy_data);
    b46f:	48 8d 55 f6          	lea    -0xa(%rbp),%rdx
    b473:	31 f6                	xor    %esi,%esi
    b475:	e8 00 00 00 00       	callq  b47a <e1000_phy_reset+0x3a>
		if (ret_val)
    b47a:	85 c0                	test   %eax,%eax
    b47c:	75 ea                	jne    b468 <e1000_phy_reset+0x28>
			return ret_val;

		phy_data |= MII_CR_RESET;
    b47e:	0f b7 55 f6          	movzwl -0xa(%rbp),%edx
		ret_val = e1000_write_phy_reg(hw, PHY_CTRL, phy_data);
    b482:	31 f6                	xor    %esi,%esi
    b484:	48 89 df             	mov    %rbx,%rdi
	default:
		ret_val = e1000_read_phy_reg(hw, PHY_CTRL, &phy_data);
		if (ret_val)
			return ret_val;

		phy_data |= MII_CR_RESET;
    b487:	66 81 ca 00 80       	or     $0x8000,%dx
    b48c:	66 89 55 f6          	mov    %dx,-0xa(%rbp)
		ret_val = e1000_write_phy_reg(hw, PHY_CTRL, phy_data);
    b490:	0f b7 d2             	movzwl %dx,%edx
    b493:	e8 00 00 00 00       	callq  b498 <e1000_phy_reset+0x58>
		if (ret_val)
    b498:	85 c0                	test   %eax,%eax
    b49a:	75 cc                	jne    b468 <e1000_phy_reset+0x28>
			return ret_val;

		udelay(1);
    b49c:	bf c7 10 00 00       	mov    $0x10c7,%edi
    b4a1:	e8 00 00 00 00       	callq  b4a6 <e1000_phy_reset+0x66>
    b4a6:	eb b8                	jmp    b460 <e1000_phy_reset+0x20>
static void e1000_phy_init_script(struct e1000_hw *hw)
{
	u32 ret_val;
	u16 phy_saved_data;

	if (hw->phy_init_script) {
    b4a8:	8b 53 20             	mov    0x20(%rbx),%edx
    b4ab:	85 d2                	test   %edx,%edx
    b4ad:	74 b9                	je     b468 <e1000_phy_reset+0x28>
    b4af:	48 89 df             	mov    %rbx,%rdi
    b4b2:	89 45 ec             	mov    %eax,-0x14(%rbp)
    b4b5:	e8 76 ec ff ff       	callq  a130 <e1000_phy_init_script.part.13>
    b4ba:	8b 45 ec             	mov    -0x14(%rbp),%eax
    b4bd:	eb a9                	jmp    b468 <e1000_phy_reset+0x28>
    b4bf:	90                   	nop

000000000000b4c0 <e1000_copper_link_rtl_setup>:
 * @hw: Struct containing variables accessed by shared code
 *
 * Commits changes to PHY configuration by calling e1000_phy_reset().
 */
static s32 e1000_copper_link_rtl_setup(struct e1000_hw *hw)
{
    b4c0:	e8 00 00 00 00       	callq  b4c5 <e1000_copper_link_rtl_setup+0x5>
    b4c5:	55                   	push   %rbp
    b4c6:	48 89 e5             	mov    %rsp,%rbp
    b4c9:	41 54                	push   %r12
    b4cb:	49 89 fc             	mov    %rdi,%r12
    b4ce:	53                   	push   %rbx
	s32 ret_val;

	/* SW reset the PHY so all changes take effect */
	ret_val = e1000_phy_reset(hw);
    b4cf:	e8 00 00 00 00       	callq  b4d4 <e1000_copper_link_rtl_setup+0x14>
    b4d4:	89 c3                	mov    %eax,%ebx
	if (ret_val) {
		e_dbg("Error Resetting the PHY\n");
		return ret_val;
	}

	return E1000_SUCCESS;
    b4d6:	31 c0                	xor    %eax,%eax
{
	s32 ret_val;

	/* SW reset the PHY so all changes take effect */
	ret_val = e1000_phy_reset(hw);
	if (ret_val) {
    b4d8:	85 db                	test   %ebx,%ebx
    b4da:	74 0b                	je     b4e7 <e1000_copper_link_rtl_setup+0x27>
		e_dbg("Error Resetting the PHY\n");
    b4dc:	f6 05 00 00 00 00 04 	testb  $0x4,0x0(%rip)        # b4e3 <e1000_copper_link_rtl_setup+0x23>
    b4e3:	75 07                	jne    b4ec <e1000_copper_link_rtl_setup+0x2c>
    b4e5:	89 d8                	mov    %ebx,%eax
		return ret_val;
	}

	return E1000_SUCCESS;
}
    b4e7:	5b                   	pop    %rbx
    b4e8:	41 5c                	pop    %r12
    b4ea:	5d                   	pop    %rbp
    b4eb:	c3                   	retq   
	s32 ret_val;

	/* SW reset the PHY so all changes take effect */
	ret_val = e1000_phy_reset(hw);
	if (ret_val) {
		e_dbg("Error Resetting the PHY\n");
    b4ec:	4c 89 e7             	mov    %r12,%rdi
    b4ef:	e8 00 00 00 00       	callq  b4f4 <e1000_copper_link_rtl_setup+0x34>
    b4f4:	48 c7 c2 00 00 00 00 	mov    $0x0,%rdx
    b4fb:	48 89 c6             	mov    %rax,%rsi
    b4fe:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
    b505:	31 c0                	xor    %eax,%eax
    b507:	e8 00 00 00 00       	callq  b50c <e1000_copper_link_rtl_setup+0x4c>
    b50c:	89 d8                	mov    %ebx,%eax
    b50e:	eb d7                	jmp    b4e7 <e1000_copper_link_rtl_setup+0x27>

000000000000b510 <e1000_phy_get_info>:
 * @phy_info: PHY information structure
 *
 * Get PHY information from various PHY registers
 */
s32 e1000_phy_get_info(struct e1000_hw *hw, struct e1000_phy_info *phy_info)
{
    b510:	e8 00 00 00 00       	callq  b515 <e1000_phy_get_info+0x5>
    b515:	55                   	push   %rbp
    b516:	48 89 e5             	mov    %rsp,%rbp
    b519:	41 54                	push   %r12
    b51b:	49 89 fc             	mov    %rdi,%r12
    b51e:	53                   	push   %rbx
    b51f:	48 89 f3             	mov    %rsi,%rbx
    b522:	48 83 ec 10          	sub    $0x10,%rsp
	s32 ret_val;
	u16 phy_data;

	phy_info->cable_length = e1000_cable_length_undefined;
    b526:	c7 06 ff 00 00 00    	movl   $0xff,(%rsi)
	phy_info->extended_10bt_distance = e1000_10bt_ext_dist_enable_undefined;
    b52c:	c7 46 04 ff 00 00 00 	movl   $0xff,0x4(%rsi)
	phy_info->cable_polarity = e1000_rev_polarity_undefined;
    b533:	c7 46 08 ff 00 00 00 	movl   $0xff,0x8(%rsi)
	phy_info->downshift = e1000_downshift_undefined;
    b53a:	c7 46 0c ff 00 00 00 	movl   $0xff,0xc(%rsi)
	phy_info->polarity_correction = e1000_polarity_reversal_undefined;
    b541:	c7 46 10 ff 00 00 00 	movl   $0xff,0x10(%rsi)
	phy_info->mdix_mode = e1000_auto_x_mode_undefined;
    b548:	c7 46 14 ff 00 00 00 	movl   $0xff,0x14(%rsi)
	phy_info->local_rx = e1000_1000t_rx_status_undefined;
    b54f:	c7 46 18 ff 00 00 00 	movl   $0xff,0x18(%rsi)
	phy_info->remote_rx = e1000_1000t_rx_status_undefined;
    b556:	c7 46 1c ff 00 00 00 	movl   $0xff,0x1c(%rsi)

	if (hw->media_type != e1000_media_type_copper) {
    b55d:	8b 47 24             	mov    0x24(%rdi),%eax
    b560:	85 c0                	test   %eax,%eax
    b562:	74 1b                	je     b57f <e1000_phy_get_info+0x6f>
		e_dbg("PHY info is only valid for copper media\n");
    b564:	f6 05 00 00 00 00 04 	testb  $0x4,0x0(%rip)        # b56b <e1000_phy_get_info+0x5b>
    b56b:	0f 85 40 02 00 00    	jne    b7b1 <e1000_phy_get_info+0x2a1>
		return -E1000_ERR_CONFIG;
    b571:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
	else if ((hw->phy_type == e1000_phy_8211) ||
	         (hw->phy_type == e1000_phy_8201))
		return E1000_SUCCESS;
	else
		return e1000_phy_m88_get_info(hw, phy_info);
}
    b576:	48 83 c4 10          	add    $0x10,%rsp
    b57a:	5b                   	pop    %rbx
    b57b:	41 5c                	pop    %r12
    b57d:	5d                   	pop    %rbp
    b57e:	c3                   	retq   
	if (hw->media_type != e1000_media_type_copper) {
		e_dbg("PHY info is only valid for copper media\n");
		return -E1000_ERR_CONFIG;
	}

	ret_val = e1000_read_phy_reg(hw, PHY_STATUS, &phy_data);
    b57f:	48 8d 55 e4          	lea    -0x1c(%rbp),%rdx
    b583:	be 01 00 00 00       	mov    $0x1,%esi
    b588:	e8 00 00 00 00       	callq  b58d <e1000_phy_get_info+0x7d>
	if (ret_val)
    b58d:	85 c0                	test   %eax,%eax
    b58f:	75 e5                	jne    b576 <e1000_phy_get_info+0x66>
		return ret_val;

	ret_val = e1000_read_phy_reg(hw, PHY_STATUS, &phy_data);
    b591:	48 8d 55 e4          	lea    -0x1c(%rbp),%rdx
    b595:	be 01 00 00 00       	mov    $0x1,%esi
    b59a:	4c 89 e7             	mov    %r12,%rdi
    b59d:	e8 00 00 00 00       	callq  b5a2 <e1000_phy_get_info+0x92>
	if (ret_val)
    b5a2:	85 c0                	test   %eax,%eax
    b5a4:	75 d0                	jne    b576 <e1000_phy_get_info+0x66>
		return ret_val;

	if ((phy_data & MII_SR_LINK_STATUS) != MII_SR_LINK_STATUS) {
    b5a6:	f6 45 e4 04          	testb  $0x4,-0x1c(%rbp)
    b5aa:	0f 84 e4 00 00 00    	je     b694 <e1000_phy_get_info+0x184>
		e_dbg("PHY info is only valid if link is up\n");
		return -E1000_ERR_CONFIG;
	}

	if (hw->phy_type == e1000_phy_igp)
    b5b0:	41 8b 54 24 1c       	mov    0x1c(%r12),%edx
    b5b5:	83 fa 01             	cmp    $0x1,%edx
    b5b8:	0f 84 0d 01 00 00    	je     b6cb <e1000_phy_get_info+0x1bb>
		return e1000_phy_igp_get_info(hw, phy_info);
	else if ((hw->phy_type == e1000_phy_8211) ||
    b5be:	83 ea 02             	sub    $0x2,%edx
    b5c1:	83 fa 01             	cmp    $0x1,%edx
    b5c4:	76 b0                	jbe    b576 <e1000_phy_get_info+0x66>
	e1000_rev_polarity polarity;

	/* The downshift status is checked only once, after link is established,
	 * and it stored in the hw->speed_downgraded parameter.
	 */
	phy_info->downshift = (e1000_downshift) hw->speed_downgraded;
    b5c6:	41 0f b6 84 24 01 01 	movzbl 0x101(%r12),%eax
    b5cd:	00 00 

	ret_val = e1000_read_phy_reg(hw, M88E1000_PHY_SPEC_CTRL, &phy_data);
    b5cf:	48 8d 55 ea          	lea    -0x16(%rbp),%rdx
    b5d3:	be 10 00 00 00       	mov    $0x10,%esi
    b5d8:	4c 89 e7             	mov    %r12,%rdi
	e1000_rev_polarity polarity;

	/* The downshift status is checked only once, after link is established,
	 * and it stored in the hw->speed_downgraded parameter.
	 */
	phy_info->downshift = (e1000_downshift) hw->speed_downgraded;
    b5db:	89 43 0c             	mov    %eax,0xc(%rbx)

	ret_val = e1000_read_phy_reg(hw, M88E1000_PHY_SPEC_CTRL, &phy_data);
    b5de:	e8 00 00 00 00       	callq  b5e3 <e1000_phy_get_info+0xd3>
	if (ret_val)
    b5e3:	85 c0                	test   %eax,%eax
    b5e5:	75 8f                	jne    b576 <e1000_phy_get_info+0x66>
		return ret_val;

	phy_info->extended_10bt_distance =
	    ((phy_data & M88E1000_PSCR_10BT_EXT_DIST_ENABLE) >>
    b5e7:	0f b7 45 ea          	movzwl -0x16(%rbp),%eax
	    ((phy_data & M88E1000_PSCR_POLARITY_REVERSAL) >>
	     M88E1000_PSCR_POLARITY_REVERSAL_SHIFT) ?
	    e1000_polarity_reversal_disabled : e1000_polarity_reversal_enabled;

	/* Check polarity status */
	ret_val = e1000_check_polarity(hw, &polarity);
    b5eb:	48 8d 75 ec          	lea    -0x14(%rbp),%rsi
    b5ef:	4c 89 e7             	mov    %r12,%rdi
	ret_val = e1000_read_phy_reg(hw, M88E1000_PHY_SPEC_CTRL, &phy_data);
	if (ret_val)
		return ret_val;

	phy_info->extended_10bt_distance =
	    ((phy_data & M88E1000_PSCR_10BT_EXT_DIST_ENABLE) >>
    b5f2:	89 c2                	mov    %eax,%edx
	     M88E1000_PSCR_10BT_EXT_DIST_ENABLE_SHIFT) ?
	    e1000_10bt_ext_dist_enable_lower :
	    e1000_10bt_ext_dist_enable_normal;

	phy_info->polarity_correction =
	    ((phy_data & M88E1000_PSCR_POLARITY_REVERSAL) >>
    b5f4:	d1 e8                	shr    %eax
	ret_val = e1000_read_phy_reg(hw, M88E1000_PHY_SPEC_CTRL, &phy_data);
	if (ret_val)
		return ret_val;

	phy_info->extended_10bt_distance =
	    ((phy_data & M88E1000_PSCR_10BT_EXT_DIST_ENABLE) >>
    b5f6:	c1 ea 07             	shr    $0x7,%edx
	     M88E1000_PSCR_10BT_EXT_DIST_ENABLE_SHIFT) ?
	    e1000_10bt_ext_dist_enable_lower :
	    e1000_10bt_ext_dist_enable_normal;

	phy_info->polarity_correction =
	    ((phy_data & M88E1000_PSCR_POLARITY_REVERSAL) >>
    b5f9:	83 e0 01             	and    $0x1,%eax
	ret_val = e1000_read_phy_reg(hw, M88E1000_PHY_SPEC_CTRL, &phy_data);
	if (ret_val)
		return ret_val;

	phy_info->extended_10bt_distance =
	    ((phy_data & M88E1000_PSCR_10BT_EXT_DIST_ENABLE) >>
    b5fc:	83 e2 01             	and    $0x1,%edx
	     M88E1000_PSCR_10BT_EXT_DIST_ENABLE_SHIFT) ?
	    e1000_10bt_ext_dist_enable_lower :
	    e1000_10bt_ext_dist_enable_normal;

	phy_info->polarity_correction =
	    ((phy_data & M88E1000_PSCR_POLARITY_REVERSAL) >>
    b5ff:	89 43 10             	mov    %eax,0x10(%rbx)
	ret_val = e1000_read_phy_reg(hw, M88E1000_PHY_SPEC_CTRL, &phy_data);
	if (ret_val)
		return ret_val;

	phy_info->extended_10bt_distance =
	    ((phy_data & M88E1000_PSCR_10BT_EXT_DIST_ENABLE) >>
    b602:	89 53 04             	mov    %edx,0x4(%rbx)
	    ((phy_data & M88E1000_PSCR_POLARITY_REVERSAL) >>
	     M88E1000_PSCR_POLARITY_REVERSAL_SHIFT) ?
	    e1000_polarity_reversal_disabled : e1000_polarity_reversal_enabled;

	/* Check polarity status */
	ret_val = e1000_check_polarity(hw, &polarity);
    b605:	e8 d6 e9 ff ff       	callq  9fe0 <e1000_check_polarity>
	if (ret_val)
    b60a:	85 c0                	test   %eax,%eax
    b60c:	0f 85 64 ff ff ff    	jne    b576 <e1000_phy_get_info+0x66>
		return ret_val;
	phy_info->cable_polarity = polarity;
    b612:	8b 45 ec             	mov    -0x14(%rbp),%eax

	ret_val = e1000_read_phy_reg(hw, M88E1000_PHY_SPEC_STATUS, &phy_data);
    b615:	48 8d 55 ea          	lea    -0x16(%rbp),%rdx
    b619:	be 11 00 00 00       	mov    $0x11,%esi
    b61e:	4c 89 e7             	mov    %r12,%rdi

	/* Check polarity status */
	ret_val = e1000_check_polarity(hw, &polarity);
	if (ret_val)
		return ret_val;
	phy_info->cable_polarity = polarity;
    b621:	89 43 08             	mov    %eax,0x8(%rbx)

	ret_val = e1000_read_phy_reg(hw, M88E1000_PHY_SPEC_STATUS, &phy_data);
    b624:	e8 00 00 00 00       	callq  b629 <e1000_phy_get_info+0x119>
	if (ret_val)
    b629:	85 c0                	test   %eax,%eax
    b62b:	0f 85 45 ff ff ff    	jne    b576 <e1000_phy_get_info+0x66>
		return ret_val;

	phy_info->mdix_mode =
	    (e1000_auto_x_mode) ((phy_data & M88E1000_PSSR_MDIX) >>
    b631:	0f b7 55 ea          	movzwl -0x16(%rbp),%edx
    b635:	89 d1                	mov    %edx,%ecx
    b637:	c1 e9 06             	shr    $0x6,%ecx
    b63a:	83 e1 01             	and    $0x1,%ecx
    b63d:	89 4b 14             	mov    %ecx,0x14(%rbx)
				 M88E1000_PSSR_MDIX_SHIFT);

	if ((phy_data & M88E1000_PSSR_SPEED) == M88E1000_PSSR_1000MBS) {
    b640:	89 d1                	mov    %edx,%ecx
    b642:	66 81 e1 00 c0       	and    $0xc000,%cx
    b647:	66 81 f9 00 80       	cmp    $0x8000,%cx
    b64c:	0f 85 24 ff ff ff    	jne    b576 <e1000_phy_get_info+0x66>
		/* Cable Length Estimation and Local/Remote Receiver Information
		 * are only valid at 1000 Mbps.
		 */
		phy_info->cable_length =
		    (e1000_cable_length) ((phy_data &
    b652:	89 d0                	mov    %edx,%eax
					   M88E1000_PSSR_CABLE_LENGTH) >>
					  M88E1000_PSSR_CABLE_LENGTH_SHIFT);

		ret_val = e1000_read_phy_reg(hw, PHY_1000T_STATUS, &phy_data);
    b654:	48 8d 55 ea          	lea    -0x16(%rbp),%rdx
    b658:	be 0a 00 00 00       	mov    $0xa,%esi
	if ((phy_data & M88E1000_PSSR_SPEED) == M88E1000_PSSR_1000MBS) {
		/* Cable Length Estimation and Local/Remote Receiver Information
		 * are only valid at 1000 Mbps.
		 */
		phy_info->cable_length =
		    (e1000_cable_length) ((phy_data &
    b65d:	25 80 03 00 00       	and    $0x380,%eax
					   M88E1000_PSSR_CABLE_LENGTH) >>
					  M88E1000_PSSR_CABLE_LENGTH_SHIFT);

		ret_val = e1000_read_phy_reg(hw, PHY_1000T_STATUS, &phy_data);
    b662:	4c 89 e7             	mov    %r12,%rdi
		/* Cable Length Estimation and Local/Remote Receiver Information
		 * are only valid at 1000 Mbps.
		 */
		phy_info->cable_length =
		    (e1000_cable_length) ((phy_data &
					   M88E1000_PSSR_CABLE_LENGTH) >>
    b665:	c1 f8 07             	sar    $0x7,%eax
    b668:	89 03                	mov    %eax,(%rbx)
					  M88E1000_PSSR_CABLE_LENGTH_SHIFT);

		ret_val = e1000_read_phy_reg(hw, PHY_1000T_STATUS, &phy_data);
    b66a:	e8 00 00 00 00       	callq  b66f <e1000_phy_get_info+0x15f>
		if (ret_val)
    b66f:	85 c0                	test   %eax,%eax
    b671:	0f 85 ff fe ff ff    	jne    b576 <e1000_phy_get_info+0x66>
			return ret_val;

		phy_info->local_rx = ((phy_data & SR_1000T_LOCAL_RX_STATUS) >>
    b677:	0f b7 55 ea          	movzwl -0x16(%rbp),%edx
    b67b:	89 d1                	mov    %edx,%ecx
				      SR_1000T_LOCAL_RX_STATUS_SHIFT) ?
		    e1000_1000t_rx_status_ok : e1000_1000t_rx_status_not_ok;
		phy_info->remote_rx = ((phy_data & SR_1000T_REMOTE_RX_STATUS) >>
    b67d:	c1 ea 0c             	shr    $0xc,%edx

		ret_val = e1000_read_phy_reg(hw, PHY_1000T_STATUS, &phy_data);
		if (ret_val)
			return ret_val;

		phy_info->local_rx = ((phy_data & SR_1000T_LOCAL_RX_STATUS) >>
    b680:	c1 e9 0d             	shr    $0xd,%ecx
				      SR_1000T_LOCAL_RX_STATUS_SHIFT) ?
		    e1000_1000t_rx_status_ok : e1000_1000t_rx_status_not_ok;
		phy_info->remote_rx = ((phy_data & SR_1000T_REMOTE_RX_STATUS) >>
    b683:	83 e2 01             	and    $0x1,%edx

		ret_val = e1000_read_phy_reg(hw, PHY_1000T_STATUS, &phy_data);
		if (ret_val)
			return ret_val;

		phy_info->local_rx = ((phy_data & SR_1000T_LOCAL_RX_STATUS) >>
    b686:	83 e1 01             	and    $0x1,%ecx
				      SR_1000T_LOCAL_RX_STATUS_SHIFT) ?
		    e1000_1000t_rx_status_ok : e1000_1000t_rx_status_not_ok;
		phy_info->remote_rx = ((phy_data & SR_1000T_REMOTE_RX_STATUS) >>
    b689:	89 53 1c             	mov    %edx,0x1c(%rbx)

		ret_val = e1000_read_phy_reg(hw, PHY_1000T_STATUS, &phy_data);
		if (ret_val)
			return ret_val;

		phy_info->local_rx = ((phy_data & SR_1000T_LOCAL_RX_STATUS) >>
    b68c:	89 4b 18             	mov    %ecx,0x18(%rbx)
    b68f:	e9 e2 fe ff ff       	jmpq   b576 <e1000_phy_get_info+0x66>
	ret_val = e1000_read_phy_reg(hw, PHY_STATUS, &phy_data);
	if (ret_val)
		return ret_val;

	if ((phy_data & MII_SR_LINK_STATUS) != MII_SR_LINK_STATUS) {
		e_dbg("PHY info is only valid if link is up\n");
    b694:	f6 05 00 00 00 00 04 	testb  $0x4,0x0(%rip)        # b69b <e1000_phy_get_info+0x18b>
    b69b:	0f 84 d0 fe ff ff    	je     b571 <e1000_phy_get_info+0x61>
    b6a1:	4c 89 e7             	mov    %r12,%rdi
    b6a4:	e8 00 00 00 00       	callq  b6a9 <e1000_phy_get_info+0x199>
    b6a9:	48 c7 c2 00 00 00 00 	mov    $0x0,%rdx
    b6b0:	48 89 c6             	mov    %rax,%rsi
    b6b3:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
    b6ba:	31 c0                	xor    %eax,%eax
    b6bc:	e8 00 00 00 00       	callq  b6c1 <e1000_phy_get_info+0x1b1>
		return -E1000_ERR_CONFIG;
    b6c1:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
    b6c6:	e9 ab fe ff ff       	jmpq   b576 <e1000_phy_get_info+0x66>
	e1000_rev_polarity polarity;

	/* The downshift status is checked only once, after link is established,
	 * and it stored in the hw->speed_downgraded parameter.
	 */
	phy_info->downshift = (e1000_downshift) hw->speed_downgraded;
    b6cb:	41 0f b6 84 24 01 01 	movzbl 0x101(%r12),%eax
    b6d2:	00 00 

	/* IGP01E1000 always correct polarity reversal */
	phy_info->polarity_correction = e1000_polarity_reversal_enabled;

	/* Check polarity status */
	ret_val = e1000_check_polarity(hw, &polarity);
    b6d4:	48 8d 75 ec          	lea    -0x14(%rbp),%rsi
	 * and it stored in the hw->speed_downgraded parameter.
	 */
	phy_info->downshift = (e1000_downshift) hw->speed_downgraded;

	/* IGP01E1000 does not need to support it. */
	phy_info->extended_10bt_distance = e1000_10bt_ext_dist_enable_normal;
    b6d8:	c7 43 04 00 00 00 00 	movl   $0x0,0x4(%rbx)

	/* IGP01E1000 always correct polarity reversal */
	phy_info->polarity_correction = e1000_polarity_reversal_enabled;
    b6df:	c7 43 10 00 00 00 00 	movl   $0x0,0x10(%rbx)

	/* Check polarity status */
	ret_val = e1000_check_polarity(hw, &polarity);
    b6e6:	4c 89 e7             	mov    %r12,%rdi
	e1000_rev_polarity polarity;

	/* The downshift status is checked only once, after link is established,
	 * and it stored in the hw->speed_downgraded parameter.
	 */
	phy_info->downshift = (e1000_downshift) hw->speed_downgraded;
    b6e9:	89 43 0c             	mov    %eax,0xc(%rbx)

	/* IGP01E1000 always correct polarity reversal */
	phy_info->polarity_correction = e1000_polarity_reversal_enabled;

	/* Check polarity status */
	ret_val = e1000_check_polarity(hw, &polarity);
    b6ec:	e8 ef e8 ff ff       	callq  9fe0 <e1000_check_polarity>
	if (ret_val)
    b6f1:	85 c0                	test   %eax,%eax
    b6f3:	0f 85 7d fe ff ff    	jne    b576 <e1000_phy_get_info+0x66>
		return ret_val;

	phy_info->cable_polarity = polarity;
    b6f9:	8b 45 ec             	mov    -0x14(%rbp),%eax

	ret_val = e1000_read_phy_reg(hw, IGP01E1000_PHY_PORT_STATUS, &phy_data);
    b6fc:	48 8d 55 e6          	lea    -0x1a(%rbp),%rdx
    b700:	be 11 00 00 00       	mov    $0x11,%esi
    b705:	4c 89 e7             	mov    %r12,%rdi
	/* Check polarity status */
	ret_val = e1000_check_polarity(hw, &polarity);
	if (ret_val)
		return ret_val;

	phy_info->cable_polarity = polarity;
    b708:	89 43 08             	mov    %eax,0x8(%rbx)

	ret_val = e1000_read_phy_reg(hw, IGP01E1000_PHY_PORT_STATUS, &phy_data);
    b70b:	e8 00 00 00 00       	callq  b710 <e1000_phy_get_info+0x200>
	if (ret_val)
    b710:	85 c0                	test   %eax,%eax
    b712:	0f 85 5e fe ff ff    	jne    b576 <e1000_phy_get_info+0x66>
		return ret_val;

	phy_info->mdix_mode =
	    (e1000_auto_x_mode) ((phy_data & IGP01E1000_PSSR_MDIX) >>
    b718:	0f b7 4d e6          	movzwl -0x1a(%rbp),%ecx
    b71c:	89 ca                	mov    %ecx,%edx
				 IGP01E1000_PSSR_MDIX_SHIFT);

	if ((phy_data & IGP01E1000_PSSR_SPEED_MASK) ==
    b71e:	66 81 e1 00 c0       	and    $0xc000,%cx
	ret_val = e1000_read_phy_reg(hw, IGP01E1000_PHY_PORT_STATUS, &phy_data);
	if (ret_val)
		return ret_val;

	phy_info->mdix_mode =
	    (e1000_auto_x_mode) ((phy_data & IGP01E1000_PSSR_MDIX) >>
    b723:	c1 ea 0b             	shr    $0xb,%edx
    b726:	83 e2 01             	and    $0x1,%edx
				 IGP01E1000_PSSR_MDIX_SHIFT);

	if ((phy_data & IGP01E1000_PSSR_SPEED_MASK) ==
    b729:	66 81 f9 00 c0       	cmp    $0xc000,%cx
	ret_val = e1000_read_phy_reg(hw, IGP01E1000_PHY_PORT_STATUS, &phy_data);
	if (ret_val)
		return ret_val;

	phy_info->mdix_mode =
	    (e1000_auto_x_mode) ((phy_data & IGP01E1000_PSSR_MDIX) >>
    b72e:	89 53 14             	mov    %edx,0x14(%rbx)
				 IGP01E1000_PSSR_MDIX_SHIFT);

	if ((phy_data & IGP01E1000_PSSR_SPEED_MASK) ==
    b731:	0f 85 3f fe ff ff    	jne    b576 <e1000_phy_get_info+0x66>
	    IGP01E1000_PSSR_SPEED_1000MBPS) {
		/* Local/Remote Receiver Information are only valid @ 1000
		 * Mbps
		 */
		ret_val = e1000_read_phy_reg(hw, PHY_1000T_STATUS, &phy_data);
    b737:	48 8d 55 e6          	lea    -0x1a(%rbp),%rdx
    b73b:	be 0a 00 00 00       	mov    $0xa,%esi
    b740:	4c 89 e7             	mov    %r12,%rdi
    b743:	e8 00 00 00 00       	callq  b748 <e1000_phy_get_info+0x238>
		if (ret_val)
    b748:	85 c0                	test   %eax,%eax
    b74a:	0f 85 26 fe ff ff    	jne    b576 <e1000_phy_get_info+0x66>
			return ret_val;

		phy_info->local_rx = ((phy_data & SR_1000T_LOCAL_RX_STATUS) >>
    b750:	0f b7 45 e6          	movzwl -0x1a(%rbp),%eax
		phy_info->remote_rx = ((phy_data & SR_1000T_REMOTE_RX_STATUS) >>
				       SR_1000T_REMOTE_RX_STATUS_SHIFT) ?
		    e1000_1000t_rx_status_ok : e1000_1000t_rx_status_not_ok;

		/* Get cable length */
		ret_val = e1000_get_cable_length(hw, &min_length, &max_length);
    b754:	48 8d 75 e8          	lea    -0x18(%rbp),%rsi
    b758:	4c 89 e7             	mov    %r12,%rdi
		 */
		ret_val = e1000_read_phy_reg(hw, PHY_1000T_STATUS, &phy_data);
		if (ret_val)
			return ret_val;

		phy_info->local_rx = ((phy_data & SR_1000T_LOCAL_RX_STATUS) >>
    b75b:	89 c2                	mov    %eax,%edx
				      SR_1000T_LOCAL_RX_STATUS_SHIFT) ?
		    e1000_1000t_rx_status_ok : e1000_1000t_rx_status_not_ok;
		phy_info->remote_rx = ((phy_data & SR_1000T_REMOTE_RX_STATUS) >>
    b75d:	c1 e8 0c             	shr    $0xc,%eax
		 */
		ret_val = e1000_read_phy_reg(hw, PHY_1000T_STATUS, &phy_data);
		if (ret_val)
			return ret_val;

		phy_info->local_rx = ((phy_data & SR_1000T_LOCAL_RX_STATUS) >>
    b760:	c1 ea 0d             	shr    $0xd,%edx
				      SR_1000T_LOCAL_RX_STATUS_SHIFT) ?
		    e1000_1000t_rx_status_ok : e1000_1000t_rx_status_not_ok;
		phy_info->remote_rx = ((phy_data & SR_1000T_REMOTE_RX_STATUS) >>
    b763:	83 e0 01             	and    $0x1,%eax
		 */
		ret_val = e1000_read_phy_reg(hw, PHY_1000T_STATUS, &phy_data);
		if (ret_val)
			return ret_val;

		phy_info->local_rx = ((phy_data & SR_1000T_LOCAL_RX_STATUS) >>
    b766:	83 e2 01             	and    $0x1,%edx
				      SR_1000T_LOCAL_RX_STATUS_SHIFT) ?
		    e1000_1000t_rx_status_ok : e1000_1000t_rx_status_not_ok;
		phy_info->remote_rx = ((phy_data & SR_1000T_REMOTE_RX_STATUS) >>
    b769:	89 43 1c             	mov    %eax,0x1c(%rbx)
		 */
		ret_val = e1000_read_phy_reg(hw, PHY_1000T_STATUS, &phy_data);
		if (ret_val)
			return ret_val;

		phy_info->local_rx = ((phy_data & SR_1000T_LOCAL_RX_STATUS) >>
    b76c:	89 53 18             	mov    %edx,0x18(%rbx)
		phy_info->remote_rx = ((phy_data & SR_1000T_REMOTE_RX_STATUS) >>
				       SR_1000T_REMOTE_RX_STATUS_SHIFT) ?
		    e1000_1000t_rx_status_ok : e1000_1000t_rx_status_not_ok;

		/* Get cable length */
		ret_val = e1000_get_cable_length(hw, &min_length, &max_length);
    b76f:	48 8d 55 ea          	lea    -0x16(%rbp),%rdx
    b773:	e8 c8 e0 ff ff       	callq  9840 <e1000_get_cable_length>
		if (ret_val)
    b778:	85 c0                	test   %eax,%eax
    b77a:	0f 85 f6 fd ff ff    	jne    b576 <e1000_phy_get_info+0x66>
			return ret_val;

		/* Translate to old method */
		average = (max_length + min_length) / 2;
    b780:	0f b7 55 ea          	movzwl -0x16(%rbp),%edx
    b784:	0f b7 45 e8          	movzwl -0x18(%rbp),%eax
    b788:	01 d0                	add    %edx,%eax
    b78a:	d1 f8                	sar    %eax

		if (average <= e1000_igp_cable_length_50)
    b78c:	66 83 f8 32          	cmp    $0x32,%ax
    b790:	76 68                	jbe    b7fa <e1000_phy_get_info+0x2ea>
			phy_info->cable_length = e1000_cable_length_50;
		else if (average <= e1000_igp_cable_length_80)
    b792:	66 83 f8 50          	cmp    $0x50,%ax
    b796:	76 55                	jbe    b7ed <e1000_phy_get_info+0x2dd>
			phy_info->cable_length = e1000_cable_length_50_80;
		else if (average <= e1000_igp_cable_length_110)
    b798:	66 83 f8 6e          	cmp    $0x6e,%ax
    b79c:	76 42                	jbe    b7e0 <e1000_phy_get_info+0x2d0>
			phy_info->cable_length = e1000_cable_length_80_110;
		else if (average <= e1000_igp_cable_length_140)
    b79e:	66 3d 8c 00          	cmp    $0x8c,%ax
    b7a2:	76 2f                	jbe    b7d3 <e1000_phy_get_info+0x2c3>
			phy_info->cable_length = e1000_cable_length_110_140;
		else
			phy_info->cable_length = e1000_cable_length_140;
    b7a4:	c7 03 04 00 00 00    	movl   $0x4,(%rbx)
	}

	return E1000_SUCCESS;
    b7aa:	31 c0                	xor    %eax,%eax
    b7ac:	e9 c5 fd ff ff       	jmpq   b576 <e1000_phy_get_info+0x66>
	phy_info->mdix_mode = e1000_auto_x_mode_undefined;
	phy_info->local_rx = e1000_1000t_rx_status_undefined;
	phy_info->remote_rx = e1000_1000t_rx_status_undefined;

	if (hw->media_type != e1000_media_type_copper) {
		e_dbg("PHY info is only valid for copper media\n");
    b7b1:	e8 00 00 00 00       	callq  b7b6 <e1000_phy_get_info+0x2a6>
    b7b6:	48 c7 c2 00 00 00 00 	mov    $0x0,%rdx
    b7bd:	48 89 c6             	mov    %rax,%rsi
    b7c0:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
    b7c7:	31 c0                	xor    %eax,%eax
    b7c9:	e8 00 00 00 00       	callq  b7ce <e1000_phy_get_info+0x2be>
    b7ce:	e9 9e fd ff ff       	jmpq   b571 <e1000_phy_get_info+0x61>
		else if (average <= e1000_igp_cable_length_80)
			phy_info->cable_length = e1000_cable_length_50_80;
		else if (average <= e1000_igp_cable_length_110)
			phy_info->cable_length = e1000_cable_length_80_110;
		else if (average <= e1000_igp_cable_length_140)
			phy_info->cable_length = e1000_cable_length_110_140;
    b7d3:	c7 03 03 00 00 00    	movl   $0x3,(%rbx)
		else
			phy_info->cable_length = e1000_cable_length_140;
	}

	return E1000_SUCCESS;
    b7d9:	31 c0                	xor    %eax,%eax
    b7db:	e9 96 fd ff ff       	jmpq   b576 <e1000_phy_get_info+0x66>
		if (average <= e1000_igp_cable_length_50)
			phy_info->cable_length = e1000_cable_length_50;
		else if (average <= e1000_igp_cable_length_80)
			phy_info->cable_length = e1000_cable_length_50_80;
		else if (average <= e1000_igp_cable_length_110)
			phy_info->cable_length = e1000_cable_length_80_110;
    b7e0:	c7 03 02 00 00 00    	movl   $0x2,(%rbx)
			phy_info->cable_length = e1000_cable_length_110_140;
		else
			phy_info->cable_length = e1000_cable_length_140;
	}

	return E1000_SUCCESS;
    b7e6:	31 c0                	xor    %eax,%eax
    b7e8:	e9 89 fd ff ff       	jmpq   b576 <e1000_phy_get_info+0x66>
		average = (max_length + min_length) / 2;

		if (average <= e1000_igp_cable_length_50)
			phy_info->cable_length = e1000_cable_length_50;
		else if (average <= e1000_igp_cable_length_80)
			phy_info->cable_length = e1000_cable_length_50_80;
    b7ed:	c7 03 01 00 00 00    	movl   $0x1,(%rbx)
			phy_info->cable_length = e1000_cable_length_110_140;
		else
			phy_info->cable_length = e1000_cable_length_140;
	}

	return E1000_SUCCESS;
    b7f3:	31 c0                	xor    %eax,%eax
    b7f5:	e9 7c fd ff ff       	jmpq   b576 <e1000_phy_get_info+0x66>

		/* Translate to old method */
		average = (max_length + min_length) / 2;

		if (average <= e1000_igp_cable_length_50)
			phy_info->cable_length = e1000_cable_length_50;
    b7fa:	c7 03 00 00 00 00    	movl   $0x0,(%rbx)
			phy_info->cable_length = e1000_cable_length_110_140;
		else
			phy_info->cable_length = e1000_cable_length_140;
	}

	return E1000_SUCCESS;
    b800:	31 c0                	xor    %eax,%eax
    b802:	e9 6f fd ff ff       	jmpq   b576 <e1000_phy_get_info+0x66>
    b807:	66 0f 1f 84 00 00 00 	nopw   0x0(%rax,%rax,1)
    b80e:	00 00 

000000000000b810 <e1000_validate_mdi_setting>:
	else
		return e1000_phy_m88_get_info(hw, phy_info);
}

s32 e1000_validate_mdi_setting(struct e1000_hw *hw)
{
    b810:	e8 00 00 00 00       	callq  b815 <e1000_validate_mdi_setting+0x5>
    b815:	55                   	push   %rbp
	if (!hw->autoneg && (hw->mdix == 0 || hw->mdix == 3)) {
		e_dbg("Invalid MDI setting detected\n");
		hw->mdix = 1;
		return -E1000_ERR_CONFIG;
	}
	return E1000_SUCCESS;
    b816:	31 c0                	xor    %eax,%eax
	else
		return e1000_phy_m88_get_info(hw, phy_info);
}

s32 e1000_validate_mdi_setting(struct e1000_hw *hw)
{
    b818:	48 89 e5             	mov    %rsp,%rbp
    b81b:	53                   	push   %rbx
	if (!hw->autoneg && (hw->mdix == 0 || hw->mdix == 3)) {
    b81c:	80 bf ef 00 00 00 00 	cmpb   $0x0,0xef(%rdi)
	else
		return e1000_phy_m88_get_info(hw, phy_info);
}

s32 e1000_validate_mdi_setting(struct e1000_hw *hw)
{
    b823:	48 89 fb             	mov    %rdi,%rbx
	if (!hw->autoneg && (hw->mdix == 0 || hw->mdix == 3)) {
    b826:	75 10                	jne    b838 <e1000_validate_mdi_setting+0x28>
    b828:	0f b6 97 f0 00 00 00 	movzbl 0xf0(%rdi),%edx
    b82f:	80 fa 03             	cmp    $0x3,%dl
    b832:	74 07                	je     b83b <e1000_validate_mdi_setting+0x2b>
    b834:	84 d2                	test   %dl,%dl
    b836:	74 03                	je     b83b <e1000_validate_mdi_setting+0x2b>
		e_dbg("Invalid MDI setting detected\n");
		hw->mdix = 1;
		return -E1000_ERR_CONFIG;
	}
	return E1000_SUCCESS;
}
    b838:	5b                   	pop    %rbx
    b839:	5d                   	pop    %rbp
    b83a:	c3                   	retq   
}

s32 e1000_validate_mdi_setting(struct e1000_hw *hw)
{
	if (!hw->autoneg && (hw->mdix == 0 || hw->mdix == 3)) {
		e_dbg("Invalid MDI setting detected\n");
    b83b:	f6 05 00 00 00 00 04 	testb  $0x4,0x0(%rip)        # b842 <e1000_validate_mdi_setting+0x32>
    b842:	75 0e                	jne    b852 <e1000_validate_mdi_setting+0x42>
		hw->mdix = 1;
    b844:	c6 83 f0 00 00 00 01 	movb   $0x1,0xf0(%rbx)
		return -E1000_ERR_CONFIG;
    b84b:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
    b850:	eb e6                	jmp    b838 <e1000_validate_mdi_setting+0x28>
}

s32 e1000_validate_mdi_setting(struct e1000_hw *hw)
{
	if (!hw->autoneg && (hw->mdix == 0 || hw->mdix == 3)) {
		e_dbg("Invalid MDI setting detected\n");
    b852:	48 89 df             	mov    %rbx,%rdi
    b855:	e8 00 00 00 00       	callq  b85a <e1000_validate_mdi_setting+0x4a>
    b85a:	48 c7 c2 00 00 00 00 	mov    $0x0,%rdx
    b861:	48 89 c6             	mov    %rax,%rsi
    b864:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
    b86b:	31 c0                	xor    %eax,%eax
    b86d:	e8 00 00 00 00       	callq  b872 <e1000_validate_mdi_setting+0x62>
    b872:	eb d0                	jmp    b844 <e1000_validate_mdi_setting+0x34>
    b874:	66 66 66 2e 0f 1f 84 	data32 data32 nopw %cs:0x0(%rax,%rax,1)
    b87b:	00 00 00 00 00 

000000000000b880 <e1000_read_eeprom>:
 * @offset: offset of  word in the EEPROM to read
 * @data: word read from the EEPROM
 * @words: number of words to read
 */
s32 e1000_read_eeprom(struct e1000_hw *hw, u16 offset, u16 words, u16 *data)
{
    b880:	e8 00 00 00 00       	callq  b885 <e1000_read_eeprom+0x5>
    b885:	55                   	push   %rbp
    b886:	48 89 e5             	mov    %rsp,%rbp
    b889:	41 57                	push   %r15
    b88b:	41 56                	push   %r14
    b88d:	41 89 d6             	mov    %edx,%r14d
    b890:	41 55                	push   %r13
    b892:	49 89 cd             	mov    %rcx,%r13
    b895:	41 54                	push   %r12
    b897:	41 89 f4             	mov    %esi,%r12d
    b89a:	53                   	push   %rbx
    b89b:	48 89 fb             	mov    %rdi,%rbx
	raw_spin_lock_init(&(_lock)->rlock);		\
} while (0)

static __always_inline void spin_lock(spinlock_t *lock)
{
	raw_spin_lock(&lock->rlock);
    b89e:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
    b8a5:	48 83 ec 08          	sub    $0x8,%rsp
    b8a9:	66 89 75 d4          	mov    %si,-0x2c(%rbp)
    b8ad:	e8 00 00 00 00       	callq  b8b2 <e1000_read_eeprom+0x32>
				u16 *data)
{
	struct e1000_eeprom_info *eeprom = &hw->eeprom;
	u32 i = 0;

	if (hw->mac_type == e1000_ce4100) {
    b8b2:	83 7b 18 09          	cmpl   $0x9,0x18(%rbx)
    b8b6:	0f 84 83 00 00 00    	je     b93f <e1000_read_eeprom+0xbf>
	}

	/* A check for invalid values:  offset too large, too many words, and
	 * not enough words.
	 */
	if ((offset >= eeprom->word_size)
    b8bc:	44 0f b7 7b 54       	movzwl 0x54(%rbx),%r15d
    b8c1:	66 45 39 fc          	cmp    %r15w,%r12w
    b8c5:	72 31                	jb     b8f8 <e1000_read_eeprom+0x78>
	    || (words > eeprom->word_size - offset) || (words == 0)) {
		e_dbg("\"words\" parameter out of bounds. Words = %d,"
    b8c7:	f6 05 00 00 00 00 04 	testb  $0x4,0x0(%rip)        # b8ce <e1000_read_eeprom+0x4e>
    b8ce:	0f 85 90 01 00 00    	jne    ba64 <e1000_read_eeprom+0x1e4>
		      "size = %d\n", offset, eeprom->word_size);
		return -E1000_ERR_EEPROM;
    b8d4:	ba ff ff ff ff       	mov    $0xffffffff,%edx
	PVOP_VCALL2(pv_lock_ops.queued_spin_lock_slowpath, lock, val);
}

static __always_inline void pv_queued_spin_unlock(struct qspinlock *lock)
{
	PVOP_VCALLEE1(pv_lock_ops.queued_spin_unlock, lock);
    b8d9:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
    b8e0:	ff 14 25 00 00 00 00 	callq  *0x0
	s32 ret;
	spin_lock(&e1000_eeprom_lock);
	ret = e1000_do_read_eeprom(hw, offset, words, data);
	spin_unlock(&e1000_eeprom_lock);
	return ret;
}
    b8e7:	48 83 c4 08          	add    $0x8,%rsp
    b8eb:	89 d0                	mov    %edx,%eax
    b8ed:	5b                   	pop    %rbx
    b8ee:	41 5c                	pop    %r12
    b8f0:	41 5d                	pop    %r13
    b8f2:	41 5e                	pop    %r14
    b8f4:	41 5f                	pop    %r15
    b8f6:	5d                   	pop    %rbp
    b8f7:	c3                   	retq   

	/* A check for invalid values:  offset too large, too many words, and
	 * not enough words.
	 */
	if ((offset >= eeprom->word_size)
	    || (words > eeprom->word_size - offset) || (words == 0)) {
    b8f8:	41 0f b7 c7          	movzwl %r15w,%eax
    b8fc:	41 0f b7 f4          	movzwl %r12w,%esi
    b900:	41 0f b7 ce          	movzwl %r14w,%ecx
    b904:	29 f0                	sub    %esi,%eax
    b906:	39 c1                	cmp    %eax,%ecx
    b908:	7f bd                	jg     b8c7 <e1000_read_eeprom+0x47>
    b90a:	66 45 85 f6          	test   %r14w,%r14w
    b90e:	74 b7                	je     b8c7 <e1000_read_eeprom+0x47>
	/* EEPROM's that don't use EERD to read require us to bit-bang the SPI
	 * directly. In this case, we need to acquire the EEPROM so that
	 * FW or other port software does not interrupt.
	 */
	/* Prepare the EEPROM for bit-bang reading */
	if (e1000_acquire_eeprom(hw) != E1000_SUCCESS)
    b910:	48 89 df             	mov    %rbx,%rdi
    b913:	89 4d d0             	mov    %ecx,-0x30(%rbp)
    b916:	e8 d5 d2 ff ff       	callq  8bf0 <e1000_acquire_eeprom>
    b91b:	85 c0                	test   %eax,%eax
    b91d:	75 b5                	jne    b8d4 <e1000_read_eeprom+0x54>
		return -E1000_ERR_EEPROM;

	/* Set up the SPI or Microwire EEPROM for bit-bang reading.  We have
	 * acquired the EEPROM at this point, so any returns should release it
	 */
	if (eeprom->type == e1000_eeprom_spi) {
    b91f:	8b 43 50             	mov    0x50(%rbx),%eax
    b922:	8b 4d d0             	mov    -0x30(%rbp),%ecx
    b925:	83 f8 01             	cmp    $0x1,%eax
    b928:	0f 84 95 00 00 00    	je     b9c3 <e1000_read_eeprom+0x143>
		 */
		for (i = 0; i < words; i++) {
			word_in = e1000_shift_in_ee_bits(hw, 16);
			data[i] = (word_in >> 8) | (word_in << 8);
		}
	} else if (eeprom->type == e1000_eeprom_microwire) {
    b92e:	83 f8 02             	cmp    $0x2,%eax
    b931:	74 36                	je     b969 <e1000_read_eeprom+0xe9>
			e1000_standby_eeprom(hw);
		}
	}

	/* End this read operation */
	e1000_release_eeprom(hw);
    b933:	48 89 df             	mov    %rbx,%rdi
    b936:	e8 75 d4 ff ff       	callq  8db0 <e1000_release_eeprom>

	return E1000_SUCCESS;
    b93b:	31 d2                	xor    %edx,%edx
    b93d:	eb 9a                	jmp    b8d9 <e1000_read_eeprom+0x59>
{
	struct e1000_eeprom_info *eeprom = &hw->eeprom;
	u32 i = 0;

	if (hw->mac_type == e1000_ce4100) {
		GBE_CONFIG_FLASH_READ(GBE_CONFIG_BASE_VIRT, offset, words,
    b93f:	4d 01 e4             	add    %r12,%r12
    b942:	48 bf 00 00 06 00 00 	movabs $0xffff880000060000,%rdi
    b949:	88 ff ff 
    b94c:	41 0f b7 d6          	movzwl %r14w,%edx
    b950:	41 81 e4 fe ff 01 00 	and    $0x1fffe,%r12d
    b957:	4c 89 ee             	mov    %r13,%rsi
    b95a:	4c 01 e7             	add    %r12,%rdi
    b95d:	e8 00 00 00 00       	callq  b962 <e1000_read_eeprom+0xe2>
		                      data);
		return E1000_SUCCESS;
    b962:	31 d2                	xor    %edx,%edx
    b964:	e9 70 ff ff ff       	jmpq   b8d9 <e1000_read_eeprom+0x59>
		for (i = 0; i < words; i++) {
			word_in = e1000_shift_in_ee_bits(hw, 16);
			data[i] = (word_in >> 8) | (word_in << 8);
		}
	} else if (eeprom->type == e1000_eeprom_microwire) {
		for (i = 0; i < words; i++) {
    b969:	45 31 e4             	xor    %r12d,%r12d
			/* Send the READ command (opcode + addr)  */
			e1000_shift_out_ee_bits(hw,
    b96c:	0f b7 53 56          	movzwl 0x56(%rbx),%edx
    b970:	be 06 00 00 00       	mov    $0x6,%esi
    b975:	48 89 df             	mov    %rbx,%rdi
    b978:	89 4d d0             	mov    %ecx,-0x30(%rbp)
    b97b:	e8 20 d5 ff ff       	callq  8ea0 <e1000_shift_out_ee_bits>
    b980:	0f b7 45 d4          	movzwl -0x2c(%rbp),%eax
						EEPROM_READ_OPCODE_MICROWIRE,
						eeprom->opcode_bits);
			e1000_shift_out_ee_bits(hw, (u16) (offset + i),
    b984:	0f b7 53 58          	movzwl 0x58(%rbx),%edx
    b988:	48 89 df             	mov    %rbx,%rdi
    b98b:	42 8d 34 20          	lea    (%rax,%r12,1),%esi
    b98f:	0f b7 f6             	movzwl %si,%esi
    b992:	e8 09 d5 ff ff       	callq  8ea0 <e1000_shift_out_ee_bits>
						eeprom->address_bits);

			/* Read the data.  For microwire, each word requires the
			 * overhead of eeprom setup and tear-down.
			 */
			data[i] = e1000_shift_in_ee_bits(hw, 16);
    b997:	be 10 00 00 00       	mov    $0x10,%esi
    b99c:	48 89 df             	mov    %rbx,%rdi
    b99f:	e8 ac d5 ff ff       	callq  8f50 <e1000_shift_in_ee_bits>
			e1000_standby_eeprom(hw);
    b9a4:	48 89 df             	mov    %rbx,%rdi
						eeprom->address_bits);

			/* Read the data.  For microwire, each word requires the
			 * overhead of eeprom setup and tear-down.
			 */
			data[i] = e1000_shift_in_ee_bits(hw, 16);
    b9a7:	66 43 89 44 65 00    	mov    %ax,0x0(%r13,%r12,2)
    b9ad:	49 83 c4 01          	add    $0x1,%r12
			e1000_standby_eeprom(hw);
    b9b1:	e8 3a d3 ff ff       	callq  8cf0 <e1000_standby_eeprom>
		for (i = 0; i < words; i++) {
			word_in = e1000_shift_in_ee_bits(hw, 16);
			data[i] = (word_in >> 8) | (word_in << 8);
		}
	} else if (eeprom->type == e1000_eeprom_microwire) {
		for (i = 0; i < words; i++) {
    b9b6:	8b 4d d0             	mov    -0x30(%rbp),%ecx
    b9b9:	44 39 e1             	cmp    %r12d,%ecx
    b9bc:	77 ae                	ja     b96c <e1000_read_eeprom+0xec>
    b9be:	e9 70 ff ff ff       	jmpq   b933 <e1000_read_eeprom+0xb3>
	 */
	if (eeprom->type == e1000_eeprom_spi) {
		u16 word_in;
		u8 read_opcode = EEPROM_READ_OPCODE_SPI;

		if (e1000_spi_eeprom_ready(hw)) {
    b9c3:	48 89 df             	mov    %rbx,%rdi
    b9c6:	89 4d d4             	mov    %ecx,-0x2c(%rbp)
    b9c9:	e8 12 d6 ff ff       	callq  8fe0 <e1000_spi_eeprom_ready>
    b9ce:	85 c0                	test   %eax,%eax
    b9d0:	8b 4d d4             	mov    -0x2c(%rbp),%ecx
    b9d3:	75 7f                	jne    ba54 <e1000_read_eeprom+0x1d4>
			e1000_release_eeprom(hw);
			return -E1000_ERR_EEPROM;
		}

		e1000_standby_eeprom(hw);
    b9d5:	48 89 df             	mov    %rbx,%rdi
    b9d8:	89 4d d4             	mov    %ecx,-0x2c(%rbp)
    b9db:	e8 10 d3 ff ff       	callq  8cf0 <e1000_standby_eeprom>

		/* Some SPI eeproms use the 8th address bit embedded in the
		 * opcode
		 */
		if ((eeprom->address_bits == 8) && (offset >= 128))
    b9e0:	66 83 7b 58 08       	cmpw   $0x8,0x58(%rbx)
    b9e5:	be 03 00 00 00       	mov    $0x3,%esi
    b9ea:	8b 4d d4             	mov    -0x2c(%rbp),%ecx
    b9ed:	74 55                	je     ba44 <e1000_read_eeprom+0x1c4>
			read_opcode |= EEPROM_A8_OPCODE_SPI;

		/* Send the READ command (opcode + addr)  */
		e1000_shift_out_ee_bits(hw, read_opcode, eeprom->opcode_bits);
    b9ef:	0f b7 53 56          	movzwl 0x56(%rbx),%edx
    b9f3:	48 89 df             	mov    %rbx,%rdi
    b9f6:	89 4d d4             	mov    %ecx,-0x2c(%rbp)
    b9f9:	e8 a2 d4 ff ff       	callq  8ea0 <e1000_shift_out_ee_bits>
		e1000_shift_out_ee_bits(hw, (u16) (offset * 2),
    b9fe:	0f b7 53 58          	movzwl 0x58(%rbx),%edx
    ba02:	43 8d 34 24          	lea    (%r12,%r12,1),%esi
    ba06:	48 89 df             	mov    %rbx,%rdi
		 * overhead of eeprom setup and tear-down.  The address counter
		 * will roll over if reading beyond the size of the eeprom, thus
		 * allowing the entire memory to be read starting from any
		 * offset.
		 */
		for (i = 0; i < words; i++) {
    ba09:	45 31 e4             	xor    %r12d,%r12d
		if ((eeprom->address_bits == 8) && (offset >= 128))
			read_opcode |= EEPROM_A8_OPCODE_SPI;

		/* Send the READ command (opcode + addr)  */
		e1000_shift_out_ee_bits(hw, read_opcode, eeprom->opcode_bits);
		e1000_shift_out_ee_bits(hw, (u16) (offset * 2),
    ba0c:	0f b7 f6             	movzwl %si,%esi
    ba0f:	e8 8c d4 ff ff       	callq  8ea0 <e1000_shift_out_ee_bits>
    ba14:	8b 4d d4             	mov    -0x2c(%rbp),%ecx
    ba17:	8d 41 ff             	lea    -0x1(%rcx),%eax
    ba1a:	4c 8d 74 00 02       	lea    0x2(%rax,%rax,1),%r14
		 * will roll over if reading beyond the size of the eeprom, thus
		 * allowing the entire memory to be read starting from any
		 * offset.
		 */
		for (i = 0; i < words; i++) {
			word_in = e1000_shift_in_ee_bits(hw, 16);
    ba1f:	be 10 00 00 00       	mov    $0x10,%esi
    ba24:	48 89 df             	mov    %rbx,%rdi
    ba27:	e8 24 d5 ff ff       	callq  8f50 <e1000_shift_in_ee_bits>
			data[i] = (word_in >> 8) | (word_in << 8);
    ba2c:	66 c1 c0 08          	rol    $0x8,%ax
    ba30:	66 43 89 44 25 00    	mov    %ax,0x0(%r13,%r12,1)
    ba36:	49 83 c4 02          	add    $0x2,%r12
		 * overhead of eeprom setup and tear-down.  The address counter
		 * will roll over if reading beyond the size of the eeprom, thus
		 * allowing the entire memory to be read starting from any
		 * offset.
		 */
		for (i = 0; i < words; i++) {
    ba3a:	4d 39 f4             	cmp    %r14,%r12
    ba3d:	75 e0                	jne    ba1f <e1000_read_eeprom+0x19f>
    ba3f:	e9 ef fe ff ff       	jmpq   b933 <e1000_read_eeprom+0xb3>
		e1000_standby_eeprom(hw);

		/* Some SPI eeproms use the 8th address bit embedded in the
		 * opcode
		 */
		if ((eeprom->address_bits == 8) && (offset >= 128))
    ba44:	66 41 81 fc 80 00    	cmp    $0x80,%r12w
    ba4a:	19 f6                	sbb    %esi,%esi
    ba4c:	83 e6 f8             	and    $0xfffffff8,%esi
    ba4f:	83 c6 0b             	add    $0xb,%esi
    ba52:	eb 9b                	jmp    b9ef <e1000_read_eeprom+0x16f>
	if (eeprom->type == e1000_eeprom_spi) {
		u16 word_in;
		u8 read_opcode = EEPROM_READ_OPCODE_SPI;

		if (e1000_spi_eeprom_ready(hw)) {
			e1000_release_eeprom(hw);
    ba54:	48 89 df             	mov    %rbx,%rdi
    ba57:	e8 54 d3 ff ff       	callq  8db0 <e1000_release_eeprom>
			return -E1000_ERR_EEPROM;
    ba5c:	83 ca ff             	or     $0xffffffff,%edx
    ba5f:	e9 75 fe ff ff       	jmpq   b8d9 <e1000_read_eeprom+0x59>
	/* A check for invalid values:  offset too large, too many words, and
	 * not enough words.
	 */
	if ((offset >= eeprom->word_size)
	    || (words > eeprom->word_size - offset) || (words == 0)) {
		e_dbg("\"words\" parameter out of bounds. Words = %d,"
    ba64:	48 89 df             	mov    %rbx,%rdi
    ba67:	e8 00 00 00 00       	callq  ba6c <e1000_read_eeprom+0x1ec>
    ba6c:	41 0f b7 cc          	movzwl %r12w,%ecx
    ba70:	48 89 c6             	mov    %rax,%rsi
    ba73:	45 0f b7 c7          	movzwl %r15w,%r8d
    ba77:	48 c7 c2 00 00 00 00 	mov    $0x0,%rdx
    ba7e:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
    ba85:	31 c0                	xor    %eax,%eax
    ba87:	e8 00 00 00 00       	callq  ba8c <e1000_read_eeprom+0x20c>
    ba8c:	e9 43 fe ff ff       	jmpq   b8d4 <e1000_read_eeprom+0x54>
    ba91:	66 66 66 66 66 66 2e 	data32 data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
    ba98:	0f 1f 84 00 00 00 00 
    ba9f:	00 

000000000000baa0 <e1000_setup_link>:
 * Assuming the adapter has a valid link partner, a valid link should be
 * established. Assumes the hardware has previously been reset and the
 * transmitter and receiver are not enabled.
 */
s32 e1000_setup_link(struct e1000_hw *hw)
{
    baa0:	e8 00 00 00 00       	callq  baa5 <e1000_setup_link+0x5>
    baa5:	55                   	push   %rbp
    baa6:	48 89 e5             	mov    %rsp,%rbp
    baa9:	41 56                	push   %r14
    baab:	41 55                	push   %r13
    baad:	41 54                	push   %r12
    baaf:	53                   	push   %rbx
    bab0:	48 89 fb             	mov    %rdi,%rbx
    bab3:	48 83 ec 08          	sub    $0x8,%rsp
	 * disabling auto-negotiation, and the direction of the
	 * SW defined pins. If there is no SW over-ride of the flow
	 * control setting, then the variable hw->fc will
	 * be initialized based on a value in the EEPROM.
	 */
	if (hw->fc == E1000_FC_DEFAULT) {
    bab7:	44 8b 67 40          	mov    0x40(%rdi),%r12d
    babb:	41 81 fc ff 00 00 00 	cmp    $0xff,%r12d
    bac2:	0f 84 70 06 00 00    	je     c138 <e1000_setup_link+0x698>

	/* We want to save off the original Flow Control configuration just
	 * in case we get disconnected and then reconnected into a different
	 * hub or switch with different Flow Control capabilities.
	 */
	if (hw->mac_type == e1000_82542_rev2_0)
    bac8:	8b 43 18             	mov    0x18(%rbx),%eax
    bacb:	83 f8 01             	cmp    $0x1,%eax
    bace:	0f 84 ca 04 00 00    	je     bf9e <e1000_setup_link+0x4fe>
		hw->fc &= (~E1000_FC_TX_PAUSE);

	if ((hw->mac_type < e1000_82543) && (hw->report_tx_early == 1))
    bad4:	83 f8 02             	cmp    $0x2,%eax
    bad7:	0f 86 c9 04 00 00    	jbe    bfa6 <e1000_setup_link+0x506>
		hw->fc &= (~E1000_FC_RX_PAUSE);

	hw->original_fc = hw->fc;

	e_dbg("After fix-ups FlowControl is now = %x\n", hw->fc);
    badd:	f6 05 00 00 00 00 04 	testb  $0x4,0x0(%rip)        # bae4 <e1000_setup_link+0x44>
		hw->fc &= (~E1000_FC_TX_PAUSE);

	if ((hw->mac_type < e1000_82543) && (hw->report_tx_early == 1))
		hw->fc &= (~E1000_FC_RX_PAUSE);

	hw->original_fc = hw->fc;
    bae4:	44 89 a3 8c 00 00 00 	mov    %r12d,0x8c(%rbx)

	e_dbg("After fix-ups FlowControl is now = %x\n", hw->fc);
    baeb:	0f 85 6e 15 00 00    	jne    d05f <e1000_setup_link+0x15bf>
	 * Extended Device Control reg with that info.
	 * This is needed because one of the SW controlled pins is used for
	 * signal detection.  So this should be done before e1000_setup_pcs_link()
	 * or e1000_phy_setup() is called.
	 */
	if (hw->mac_type == e1000_82543) {
    baf1:	83 f8 03             	cmp    $0x3,%eax
    baf4:	0f 84 78 06 00 00    	je     c172 <e1000_setup_link+0x6d2>
		ew32(CTRL_EXT, ctrl_ext);
	}

	/* Call the necessary subroutine to configure the link. */
	ret_val = (hw->media_type == e1000_media_type_copper) ?
	    e1000_setup_copper_link(hw) : e1000_setup_fiber_serdes_link(hw);
    bafa:	44 8b 5b 24          	mov    0x24(%rbx),%r11d
{
	u32 ctrl;
	s32 ret_val;
	u16 phy_data;

	ctrl = er32(CTRL);
    bafe:	48 8b 03             	mov    (%rbx),%rax
		ew32(CTRL_EXT, ctrl_ext);
	}

	/* Call the necessary subroutine to configure the link. */
	ret_val = (hw->media_type == e1000_media_type_copper) ?
	    e1000_setup_copper_link(hw) : e1000_setup_fiber_serdes_link(hw);
    bb01:	45 85 db             	test   %r11d,%r11d
    bb04:	0f 85 e1 03 00 00    	jne    beeb <e1000_setup_link+0x44b>
    bb0a:	8b 00                	mov    (%rax),%eax
	ctrl = er32(CTRL);
	/* With 82543, we need to force speed and duplex on the MAC equal to
	 * what the PHY speed and duplex configuration is. In addition, we need
	 * to perform a hardware reset on the PHY to take it out of reset.
	 */
	if (hw->mac_type > e1000_82543) {
    bb0c:	83 7b 18 03          	cmpl   $0x3,0x18(%rbx)
    bb10:	0f 86 ab 06 00 00    	jbe    c1c1 <e1000_setup_link+0x721>
		ctrl |= E1000_CTRL_SLU;
		ctrl &= ~(E1000_CTRL_FRCSPD | E1000_CTRL_FRCDPX);
    bb16:	80 e4 e7             	and    $0xe7,%ah
		ew32(CTRL, ctrl);
    bb19:	48 8b 13             	mov    (%rbx),%rdx
	 * what the PHY speed and duplex configuration is. In addition, we need
	 * to perform a hardware reset on the PHY to take it out of reset.
	 */
	if (hw->mac_type > e1000_82543) {
		ctrl |= E1000_CTRL_SLU;
		ctrl &= ~(E1000_CTRL_FRCSPD | E1000_CTRL_FRCDPX);
    bb1c:	83 c8 40             	or     $0x40,%eax
build_mmio_read(__readw, "w", unsigned short, "=r", )
build_mmio_read(__readl, "l", unsigned int, "=r", )

build_mmio_write(writeb, "b", unsigned char, "q", :"memory")
build_mmio_write(writew, "w", unsigned short, "r", :"memory")
build_mmio_write(writel, "l", unsigned int, "r", :"memory")
    bb1f:	89 02                	mov    %eax,(%rdx)
{
	s32 phy_init_status, ret_val;
	u16 phy_id_high, phy_id_low;
	bool match = false;

	if (hw->phy_id != 0)
    bb21:	44 8b 93 80 00 00 00 	mov    0x80(%rbx),%r10d
    bb28:	45 85 d2             	test   %r10d,%r10d
    bb2b:	0f 84 b6 05 00 00    	je     c0e7 <e1000_setup_link+0x647>
	ret_val = e1000_detect_gig_phy(hw);
	if (ret_val) {
		e_dbg("Error, did not detect valid phy.\n");
		return ret_val;
	}
	e_dbg("Phy ID = %x\n", hw->phy_id);
    bb31:	f6 05 00 00 00 00 04 	testb  $0x4,0x0(%rip)        # bb38 <e1000_setup_link+0x98>
    bb38:	0f 85 96 16 00 00    	jne    d1d4 <e1000_setup_link+0x1734>
static s32 e1000_set_phy_mode(struct e1000_hw *hw)
{
	s32 ret_val;
	u16 eeprom_data;

	if ((hw->mac_type == e1000_82545_rev_3) &&
    bb3e:	8b 43 18             	mov    0x18(%rbx),%eax
    bb41:	83 f8 07             	cmp    $0x7,%eax
    bb44:	0f 84 76 04 00 00    	je     bfc0 <e1000_setup_link+0x520>
	/* Set PHY to class A mode (if necessary) */
	ret_val = e1000_set_phy_mode(hw);
	if (ret_val)
		return ret_val;

	if ((hw->mac_type == e1000_82545_rev_3) ||
    bb4a:	83 f8 0a             	cmp    $0xa,%eax
    bb4d:	0f 84 7a 04 00 00    	je     bfcd <e1000_setup_link+0x52d>
    bb53:	83 f8 07             	cmp    $0x7,%eax
    bb56:	0f 84 71 04 00 00    	je     bfcd <e1000_setup_link+0x52d>
		phy_data |= 0x00000008;
		ret_val =
		    e1000_write_phy_reg(hw, M88E1000_PHY_SPEC_CTRL, phy_data);
	}

	if (hw->mac_type <= e1000_82543 ||
    bb5c:	8d 50 f5             	lea    -0xb(%rax),%edx
    bb5f:	83 fa 03             	cmp    $0x3,%edx
    bb62:	0f 86 f4 04 00 00    	jbe    c05c <e1000_setup_link+0x5bc>
    bb68:	83 f8 03             	cmp    $0x3,%eax
    bb6b:	0f 86 eb 04 00 00    	jbe    c05c <e1000_setup_link+0x5bc>
	/* Check if it is a valid PHY and set PHY mode if necessary. */
	ret_val = e1000_copper_link_preconfig(hw);
	if (ret_val)
		return ret_val;

	if (hw->phy_type == e1000_phy_igp) {
    bb71:	8b 43 1c             	mov    0x1c(%rbx),%eax
    bb74:	83 f8 01             	cmp    $0x1,%eax
    bb77:	0f 84 9f 0d 00 00    	je     c91c <e1000_setup_link+0xe7c>
		ret_val = e1000_copper_link_igp_setup(hw);
		if (ret_val)
			return ret_val;
	} else if (hw->phy_type == e1000_phy_m88) {
    bb7d:	85 c0                	test   %eax,%eax
    bb7f:	0f 85 76 06 00 00    	jne    c1fb <e1000_setup_link+0x75b>
static s32 e1000_copper_link_mgp_setup(struct e1000_hw *hw)
{
	s32 ret_val;
	u16 phy_data;

	if (hw->phy_reset_disable)
    bb85:	80 bb 11 01 00 00 00 	cmpb   $0x0,0x111(%rbx)
    bb8c:	0f 84 1c 0b 00 00    	je     c6ae <e1000_setup_link+0xc0e>
			e_dbg("gbe_dhg_phy_setup failed!\n");
			return ret_val;
		}
	}

	if (hw->autoneg) {
    bb92:	80 bb ef 00 00 00 00 	cmpb   $0x0,0xef(%rbx)
    bb99:	0f 85 50 0c 00 00    	jne    c7ef <e1000_setup_link+0xd4f>
			return ret_val;
	} else {
		/* PHY will be set to 10H, 10F, 100H,or 100F
		 * depending on value from forced_speed_duplex.
		 */
		e_dbg("Forcing speed and duplex\n");
    bb9f:	f6 05 00 00 00 00 04 	testb  $0x4,0x0(%rip)        # bba6 <e1000_setup_link+0x106>
    bba6:	0f 85 e4 18 00 00    	jne    d490 <e1000_setup_link+0x19f0>
	u16 mii_status_reg;
	u16 phy_data;
	u16 i;

	/* Turn off Flow control if we are forcing speed and duplex. */
	hw->fc = E1000_FC_NONE;
    bbac:	c7 43 40 00 00 00 00 	movl   $0x0,0x40(%rbx)

	e_dbg("hw->fc = %d\n", hw->fc);
    bbb3:	f6 05 00 00 00 00 04 	testb  $0x4,0x0(%rip)        # bbba <e1000_setup_link+0x11a>
    bbba:	0f 85 b7 17 00 00    	jne    d377 <e1000_setup_link+0x18d7>

	/* Read the Device Control Register. */
	ctrl = er32(CTRL);
    bbc0:	48 8b 03             	mov    (%rbx),%rax
{ asm volatile("mov" size " %0,%1": :reg (val), \
"m" (*(volatile type __force *)addr) barrier); }

build_mmio_read(readb, "b", unsigned char, "=q", :"memory")
build_mmio_read(readw, "w", unsigned short, "=r", :"memory")
build_mmio_read(readl, "l", unsigned int, "=r", :"memory")
    bbc3:	44 8b 20             	mov    (%rax),%r12d

	/* Clear the Auto Speed Detect Enable bit. */
	ctrl &= ~E1000_CTRL_ASDE;

	/* Read the MII Control Register. */
	ret_val = e1000_read_phy_reg(hw, PHY_CTRL, &mii_ctrl_reg);
    bbc6:	48 8d 55 da          	lea    -0x26(%rbp),%rdx
    bbca:	31 f6                	xor    %esi,%esi
    bbcc:	48 89 df             	mov    %rbx,%rdi
    bbcf:	e8 00 00 00 00       	callq  bbd4 <e1000_setup_link+0x134>
	if (ret_val)
    bbd4:	85 c0                	test   %eax,%eax
    bbd6:	0f 85 25 08 00 00    	jne    c401 <e1000_setup_link+0x961>
	/* We need to disable autoneg in order to force link and duplex. */

	mii_ctrl_reg &= ~MII_CR_AUTO_NEG_EN;

	/* Are we forcing Full or Half Duplex? */
	if (hw->forced_speed_duplex == e1000_100_full ||
    bbdc:	0f b6 83 f1 00 00 00 	movzbl 0xf1(%rbx),%eax
	if (ret_val)
		return ret_val;

	/* We need to disable autoneg in order to force link and duplex. */

	mii_ctrl_reg &= ~MII_CR_AUTO_NEG_EN;
    bbe3:	0f b7 55 da          	movzwl -0x26(%rbp),%edx

	/* Are we forcing Full or Half Duplex? */
	if (hw->forced_speed_duplex == e1000_100_full ||
    bbe7:	89 c6                	mov    %eax,%esi
	if (ret_val)
		return ret_val;

	/* We need to disable autoneg in order to force link and duplex. */

	mii_ctrl_reg &= ~MII_CR_AUTO_NEG_EN;
    bbe9:	89 d1                	mov    %edx,%ecx

	/* Are we forcing Full or Half Duplex? */
	if (hw->forced_speed_duplex == e1000_100_full ||
    bbeb:	83 e6 fd             	and    $0xfffffffd,%esi
	if (ret_val)
		return ret_val;

	/* We need to disable autoneg in order to force link and duplex. */

	mii_ctrl_reg &= ~MII_CR_AUTO_NEG_EN;
    bbee:	80 e5 ef             	and    $0xef,%ch

	/* Are we forcing Full or Half Duplex? */
	if (hw->forced_speed_duplex == e1000_100_full ||
    bbf1:	40 80 fe 01          	cmp    $0x1,%sil
	if (ret_val)
		return ret_val;

	/* We need to disable autoneg in order to force link and duplex. */

	mii_ctrl_reg &= ~MII_CR_AUTO_NEG_EN;
    bbf5:	66 89 4d da          	mov    %cx,-0x26(%rbp)

	/* Are we forcing Full or Half Duplex? */
	if (hw->forced_speed_duplex == e1000_100_full ||
    bbf9:	0f 84 c4 08 00 00    	je     c4c3 <e1000_setup_link+0xa23>
		e_dbg("Full Duplex\n");
	} else {
		/* We want to force half duplex so we CLEAR the full duplex bits
		 * in the Device and MII Control Registers.
		 */
		ctrl &= ~E1000_CTRL_FD;
    bbff:	41 81 e4 de fc ff ff 	and    $0xfffffcde,%r12d
		mii_ctrl_reg &= ~MII_CR_FULL_DUPLEX;
    bc06:	89 d1                	mov    %edx,%ecx
    bc08:	80 e5 ee             	and    $0xee,%ch
		e_dbg("Full Duplex\n");
	} else {
		/* We want to force half duplex so we CLEAR the full duplex bits
		 * in the Device and MII Control Registers.
		 */
		ctrl &= ~E1000_CTRL_FD;
    bc0b:	41 81 cc 00 18 00 00 	or     $0x1800,%r12d
		mii_ctrl_reg &= ~MII_CR_FULL_DUPLEX;
		e_dbg("Half Duplex\n");
    bc12:	f6 05 00 00 00 00 04 	testb  $0x4,0x0(%rip)        # bc19 <e1000_setup_link+0x179>
	} else {
		/* We want to force half duplex so we CLEAR the full duplex bits
		 * in the Device and MII Control Registers.
		 */
		ctrl &= ~E1000_CTRL_FD;
		mii_ctrl_reg &= ~MII_CR_FULL_DUPLEX;
    bc19:	66 89 4d da          	mov    %cx,-0x26(%rbp)
		e_dbg("Half Duplex\n");
    bc1d:	0f 85 79 19 00 00    	jne    d59c <e1000_setup_link+0x1afc>
	}

	/* Are we forcing 100Mbps??? */
	if (hw->forced_speed_duplex == e1000_100_full ||
    bc23:	83 e8 02             	sub    $0x2,%eax
    bc26:	3c 01                	cmp    $0x1,%al
    bc28:	0f 86 f5 0d 00 00    	jbe    ca23 <e1000_setup_link+0xf83>
		e_dbg("Forcing 100mb ");
	} else {
		/* Set the 10Mb bit and turn off the 1000Mb and 100Mb bits. */
		ctrl &= ~(E1000_CTRL_SPD_1000 | E1000_CTRL_SPD_100);
		mii_ctrl_reg |= MII_CR_SPEED_10;
		mii_ctrl_reg &= ~(MII_CR_SPEED_1000 | MII_CR_SPEED_100);
    bc2e:	66 81 e1 bf df       	and    $0xdfbf,%cx
		mii_ctrl_reg |= MII_CR_SPEED_100;
		mii_ctrl_reg &= ~(MII_CR_SPEED_1000 | MII_CR_SPEED_10);
		e_dbg("Forcing 100mb ");
	} else {
		/* Set the 10Mb bit and turn off the 1000Mb and 100Mb bits. */
		ctrl &= ~(E1000_CTRL_SPD_1000 | E1000_CTRL_SPD_100);
    bc33:	41 81 e4 ff fc ff ff 	and    $0xfffffcff,%r12d
		mii_ctrl_reg |= MII_CR_SPEED_10;
		mii_ctrl_reg &= ~(MII_CR_SPEED_1000 | MII_CR_SPEED_100);
		e_dbg("Forcing 10mb ");
    bc3a:	f6 05 00 00 00 00 04 	testb  $0x4,0x0(%rip)        # bc41 <e1000_setup_link+0x1a1>
		e_dbg("Forcing 100mb ");
	} else {
		/* Set the 10Mb bit and turn off the 1000Mb and 100Mb bits. */
		ctrl &= ~(E1000_CTRL_SPD_1000 | E1000_CTRL_SPD_100);
		mii_ctrl_reg |= MII_CR_SPEED_10;
		mii_ctrl_reg &= ~(MII_CR_SPEED_1000 | MII_CR_SPEED_100);
    bc41:	66 89 4d da          	mov    %cx,-0x26(%rbp)
		e_dbg("Forcing 10mb ");
    bc45:	0f 85 6a 18 00 00    	jne    d4b5 <e1000_setup_link+0x1a15>
 */
void e1000_config_collision_dist(struct e1000_hw *hw)
{
	u32 tctl, coll_dist;

	if (hw->mac_type < e1000_82543)
    bc4b:	83 7b 18 03          	cmpl   $0x3,0x18(%rbx)
		coll_dist = E1000_COLLISION_DISTANCE_82542;
	else
		coll_dist = E1000_COLLISION_DISTANCE;

	tctl = er32(TCTL);
    bc4f:	48 8b 03             	mov    (%rbx),%rax
 */
void e1000_config_collision_dist(struct e1000_hw *hw)
{
	u32 tctl, coll_dist;

	if (hw->mac_type < e1000_82543)
    bc52:	19 d2                	sbb    %edx,%edx
    bc54:	81 e2 00 10 00 00    	and    $0x1000,%edx
    bc5a:	81 c2 00 f0 03 00    	add    $0x3f000,%edx
    bc60:	8b 80 00 04 00 00    	mov    0x400(%rax),%eax
	else
		coll_dist = E1000_COLLISION_DISTANCE;

	tctl = er32(TCTL);

	tctl &= ~E1000_TCTL_COLD;
    bc66:	25 ff 0f c0 ff       	and    $0xffc00fff,%eax
	tctl |= coll_dist << E1000_COLD_SHIFT;
    bc6b:	09 d0                	or     %edx,%eax

	ew32(TCTL, tctl);
    bc6d:	48 8b 13             	mov    (%rbx),%rdx
build_mmio_read(__readw, "w", unsigned short, "=r", )
build_mmio_read(__readl, "l", unsigned int, "=r", )

build_mmio_write(writeb, "b", unsigned char, "q", :"memory")
build_mmio_write(writew, "w", unsigned short, "r", :"memory")
build_mmio_write(writel, "l", unsigned int, "r", :"memory")
    bc70:	89 82 00 04 00 00    	mov    %eax,0x400(%rdx)
	E1000_WRITE_FLUSH();
    bc76:	48 8b 03             	mov    (%rbx),%rax
{ asm volatile("mov" size " %0,%1": :reg (val), \
"m" (*(volatile type __force *)addr) barrier); }

build_mmio_read(readb, "b", unsigned char, "=q", :"memory")
build_mmio_read(readw, "w", unsigned short, "=r", :"memory")
build_mmio_read(readl, "l", unsigned int, "=r", :"memory")
    bc79:	8b 40 08             	mov    0x8(%rax),%eax
	}

	e1000_config_collision_dist(hw);

	/* Write the configured values back to the Device Control Reg. */
	ew32(CTRL, ctrl);
    bc7c:	48 8b 03             	mov    (%rbx),%rax
build_mmio_read(__readw, "w", unsigned short, "=r", )
build_mmio_read(__readl, "l", unsigned int, "=r", )

build_mmio_write(writeb, "b", unsigned char, "q", :"memory")
build_mmio_write(writew, "w", unsigned short, "r", :"memory")
build_mmio_write(writel, "l", unsigned int, "r", :"memory")
    bc7f:	44 89 20             	mov    %r12d,(%rax)

	if (hw->phy_type == e1000_phy_m88) {
    bc82:	44 8b 43 1c          	mov    0x1c(%rbx),%r8d
		ret_val =
    bc86:	4c 8d 6d de          	lea    -0x22(%rbp),%r13
    bc8a:	4c 89 ea             	mov    %r13,%rdx
	e1000_config_collision_dist(hw);

	/* Write the configured values back to the Device Control Reg. */
	ew32(CTRL, ctrl);

	if (hw->phy_type == e1000_phy_m88) {
    bc8d:	45 85 c0             	test   %r8d,%r8d
    bc90:	0f 85 d8 0c 00 00    	jne    c96e <e1000_setup_link+0xece>
		ret_val =
    bc96:	be 10 00 00 00       	mov    $0x10,%esi
    bc9b:	48 89 df             	mov    %rbx,%rdi
    bc9e:	e8 00 00 00 00       	callq  bca3 <e1000_setup_link+0x203>
		    e1000_read_phy_reg(hw, M88E1000_PHY_SPEC_CTRL, &phy_data);
		if (ret_val)
    bca3:	85 c0                	test   %eax,%eax

	/* Write the configured values back to the Device Control Reg. */
	ew32(CTRL, ctrl);

	if (hw->phy_type == e1000_phy_m88) {
		ret_val =
    bca5:	41 89 c4             	mov    %eax,%r12d
		    e1000_read_phy_reg(hw, M88E1000_PHY_SPEC_CTRL, &phy_data);
		if (ret_val)
    bca8:	0f 85 56 07 00 00    	jne    c404 <e1000_setup_link+0x964>
			return ret_val;

		/* Clear Auto-Crossover to force MDI manually. M88E1000 requires
		 * MDI forced whenever speed are duplex are forced.
		 */
		phy_data &= ~M88E1000_PSCR_AUTO_X_MODE;
    bcae:	0f b7 45 de          	movzwl -0x22(%rbp),%eax
		ret_val =
    bcb2:	be 10 00 00 00       	mov    $0x10,%esi
    bcb7:	48 89 df             	mov    %rbx,%rdi
			return ret_val;

		/* Clear Auto-Crossover to force MDI manually. M88E1000 requires
		 * MDI forced whenever speed are duplex are forced.
		 */
		phy_data &= ~M88E1000_PSCR_AUTO_X_MODE;
    bcba:	83 e0 9f             	and    $0xffffff9f,%eax
		ret_val =
		    e1000_write_phy_reg(hw, M88E1000_PHY_SPEC_CTRL, phy_data);
    bcbd:	0f b7 d0             	movzwl %ax,%edx
			return ret_val;

		/* Clear Auto-Crossover to force MDI manually. M88E1000 requires
		 * MDI forced whenever speed are duplex are forced.
		 */
		phy_data &= ~M88E1000_PSCR_AUTO_X_MODE;
    bcc0:	66 89 45 de          	mov    %ax,-0x22(%rbp)
		ret_val =
    bcc4:	e8 00 00 00 00       	callq  bcc9 <e1000_setup_link+0x229>
		    e1000_write_phy_reg(hw, M88E1000_PHY_SPEC_CTRL, phy_data);
		if (ret_val)
    bcc9:	85 c0                	test   %eax,%eax
    bccb:	0f 85 30 07 00 00    	jne    c401 <e1000_setup_link+0x961>
			return ret_val;

		e_dbg("M88E1000 PSCR: %x\n", phy_data);
    bcd1:	f6 05 00 00 00 00 04 	testb  $0x4,0x0(%rip)        # bcd8 <e1000_setup_link+0x238>
    bcd8:	0f 85 e5 16 00 00    	jne    d3c3 <e1000_setup_link+0x1923>

		/* Need to reset the PHY or these changes will be ignored */
		mii_ctrl_reg |= MII_CR_RESET;
    bcde:	0f b7 45 da          	movzwl -0x26(%rbp),%eax
    bce2:	66 0d 00 80          	or     $0x8000,%ax
    bce6:	66 89 45 da          	mov    %ax,-0x26(%rbp)
		if (ret_val)
			return ret_val;
	}

	/* Write back the modified PHY MII control register. */
	ret_val = e1000_write_phy_reg(hw, PHY_CTRL, mii_ctrl_reg);
    bcea:	31 f6                	xor    %esi,%esi
    bcec:	0f b7 d0             	movzwl %ax,%edx
    bcef:	48 89 df             	mov    %rbx,%rdi
    bcf2:	e8 00 00 00 00       	callq  bcf7 <e1000_setup_link+0x257>
	if (ret_val)
    bcf7:	85 c0                	test   %eax,%eax
    bcf9:	41 89 c4             	mov    %eax,%r12d
    bcfc:	0f 85 02 07 00 00    	jne    c404 <e1000_setup_link+0x964>
		return ret_val;

	udelay(1);
    bd02:	bf c7 10 00 00       	mov    $0x10c7,%edi
    bd07:	e8 00 00 00 00       	callq  bd0c <e1000_setup_link+0x26c>
	 * But we do want to delay for a period while forcing only so we
	 * don't generate false No Link messages.  So we will wait here
	 * only if the user has set wait_autoneg_complete to 1, which is
	 * the default.
	 */
	if (hw->wait_autoneg_complete) {
    bd0c:	80 bb f2 00 00 00 00 	cmpb   $0x0,0xf2(%rbx)
    bd13:	0f 84 c6 00 00 00    	je     bddf <e1000_setup_link+0x33f>
		/* We will wait for autoneg to complete. */
		e_dbg("Waiting for forced speed/duplex link.\n");
    bd19:	f6 05 00 00 00 00 04 	testb  $0x4,0x0(%rip)        # bd20 <e1000_setup_link+0x280>
    bd20:	0f 85 78 16 00 00    	jne    d39e <e1000_setup_link+0x18fe>
		mii_status_reg = 0;
    bd26:	31 f6                	xor    %esi,%esi
    bd28:	4c 8d 75 dc          	lea    -0x24(%rbp),%r14
    bd2c:	41 bc 14 00 00 00    	mov    $0x14,%r12d
    bd32:	66 89 75 dc          	mov    %si,-0x24(%rbp)
		/* Wait for autoneg to complete or 4.5 seconds to expire */
		for (i = PHY_FORCE_TIME; i > 0; i--) {
			/* Read the MII Status Register and wait for Auto-Neg
			 * Complete bit to be set.
			 */
			ret_val =
    bd36:	4c 89 f2             	mov    %r14,%rdx
    bd39:	be 01 00 00 00       	mov    $0x1,%esi
    bd3e:	48 89 df             	mov    %rbx,%rdi
    bd41:	e8 00 00 00 00       	callq  bd46 <e1000_setup_link+0x2a6>
			    e1000_read_phy_reg(hw, PHY_STATUS, &mii_status_reg);
			if (ret_val)
    bd46:	85 c0                	test   %eax,%eax
    bd48:	0f 85 b3 06 00 00    	jne    c401 <e1000_setup_link+0x961>
				return ret_val;

			ret_val =
    bd4e:	4c 89 f2             	mov    %r14,%rdx
    bd51:	be 01 00 00 00       	mov    $0x1,%esi
    bd56:	48 89 df             	mov    %rbx,%rdi
    bd59:	e8 00 00 00 00       	callq  bd5e <e1000_setup_link+0x2be>
			    e1000_read_phy_reg(hw, PHY_STATUS, &mii_status_reg);
			if (ret_val)
    bd5e:	85 c0                	test   %eax,%eax
    bd60:	0f 85 9b 06 00 00    	jne    c401 <e1000_setup_link+0x961>
				return ret_val;

			if (mii_status_reg & MII_SR_LINK_STATUS)
    bd66:	0f b7 45 dc          	movzwl -0x24(%rbp),%eax
    bd6a:	a8 04                	test   $0x4,%al
    bd6c:	75 20                	jne    bd8e <e1000_setup_link+0x2ee>
				break;
			msleep(100);
    bd6e:	bf 64 00 00 00       	mov    $0x64,%edi
    bd73:	e8 00 00 00 00       	callq  bd78 <e1000_setup_link+0x2d8>
		/* We will wait for autoneg to complete. */
		e_dbg("Waiting for forced speed/duplex link.\n");
		mii_status_reg = 0;

		/* Wait for autoneg to complete or 4.5 seconds to expire */
		for (i = PHY_FORCE_TIME; i > 0; i--) {
    bd78:	66 41 83 ec 01       	sub    $0x1,%r12w
    bd7d:	75 b7                	jne    bd36 <e1000_setup_link+0x296>

			if (mii_status_reg & MII_SR_LINK_STATUS)
				break;
			msleep(100);
		}
		if ((i == 0) && (hw->phy_type == e1000_phy_m88)) {
    bd7f:	8b 4b 1c             	mov    0x1c(%rbx),%ecx
    bd82:	85 c9                	test   %ecx,%ecx
    bd84:	0f 84 1a 13 00 00    	je     d0a4 <e1000_setup_link+0x1604>
    bd8a:	0f b7 45 dc          	movzwl -0x24(%rbp),%eax
	 * the default.
	 */
	if (hw->wait_autoneg_complete) {
		/* We will wait for autoneg to complete. */
		e_dbg("Waiting for forced speed/duplex link.\n");
		mii_status_reg = 0;
    bd8e:	41 bc 14 00 00 00    	mov    $0x14,%r12d
    bd94:	eb 04                	jmp    bd9a <e1000_setup_link+0x2fa>
    bd96:	0f b7 45 dc          	movzwl -0x24(%rbp),%eax
		}
		/* This loop will early-out if the link condition has been
		 * met
		 */
		for (i = PHY_FORCE_TIME; i > 0; i--) {
			if (mii_status_reg & MII_SR_LINK_STATUS)
    bd9a:	a8 04                	test   $0x4,%al
    bd9c:	75 41                	jne    bddf <e1000_setup_link+0x33f>
				break;
			msleep(100);
    bd9e:	bf 64 00 00 00       	mov    $0x64,%edi
    bda3:	e8 00 00 00 00       	callq  bda8 <e1000_setup_link+0x308>
			/* Read the MII Status Register and wait for Auto-Neg
			 * Complete bit to be set.
			 */
			ret_val =
    bda8:	4c 89 f2             	mov    %r14,%rdx
    bdab:	be 01 00 00 00       	mov    $0x1,%esi
    bdb0:	48 89 df             	mov    %rbx,%rdi
    bdb3:	e8 00 00 00 00       	callq  bdb8 <e1000_setup_link+0x318>
			    e1000_read_phy_reg(hw, PHY_STATUS, &mii_status_reg);
			if (ret_val)
    bdb8:	85 c0                	test   %eax,%eax
    bdba:	0f 85 41 06 00 00    	jne    c401 <e1000_setup_link+0x961>
				return ret_val;

			ret_val =
    bdc0:	4c 89 f2             	mov    %r14,%rdx
    bdc3:	be 01 00 00 00       	mov    $0x1,%esi
    bdc8:	48 89 df             	mov    %rbx,%rdi
    bdcb:	e8 00 00 00 00       	callq  bdd0 <e1000_setup_link+0x330>
			    e1000_read_phy_reg(hw, PHY_STATUS, &mii_status_reg);
			if (ret_val)
    bdd0:	85 c0                	test   %eax,%eax
    bdd2:	0f 85 29 06 00 00    	jne    c401 <e1000_setup_link+0x961>
			}
		}
		/* This loop will early-out if the link condition has been
		 * met
		 */
		for (i = PHY_FORCE_TIME; i > 0; i--) {
    bdd8:	66 41 83 ec 01       	sub    $0x1,%r12w
    bddd:	75 b7                	jne    bd96 <e1000_setup_link+0x2f6>
			if (ret_val)
				return ret_val;
		}
	}

	if (hw->phy_type == e1000_phy_m88) {
    bddf:	8b 7b 1c             	mov    0x1c(%rbx),%edi
    bde2:	85 ff                	test   %edi,%edi
    bde4:	0f 84 1a 10 00 00    	je     ce04 <e1000_setup_link+0x1364>
	 * the default.
	 */
	if (hw->wait_autoneg_complete) {
		/* We will wait for autoneg to complete. */
		e_dbg("Waiting for forced speed/duplex link.\n");
		mii_status_reg = 0;
    bdea:	41 be 0a 00 00 00    	mov    $0xa,%r14d

	/* Check link status. Wait up to 100 microseconds for link to become
	 * valid.
	 */
	for (i = 0; i < 10; i++) {
		ret_val = e1000_read_phy_reg(hw, PHY_STATUS, &phy_data);
    bdf0:	4c 89 ea             	mov    %r13,%rdx
    bdf3:	be 01 00 00 00       	mov    $0x1,%esi
    bdf8:	48 89 df             	mov    %rbx,%rdi
    bdfb:	e8 00 00 00 00       	callq  be00 <e1000_setup_link+0x360>
		if (ret_val)
    be00:	85 c0                	test   %eax,%eax

	/* Check link status. Wait up to 100 microseconds for link to become
	 * valid.
	 */
	for (i = 0; i < 10; i++) {
		ret_val = e1000_read_phy_reg(hw, PHY_STATUS, &phy_data);
    be02:	41 89 c4             	mov    %eax,%r12d
		if (ret_val)
    be05:	75 5b                	jne    be62 <e1000_setup_link+0x3c2>
			return ret_val;
		ret_val = e1000_read_phy_reg(hw, PHY_STATUS, &phy_data);
    be07:	4c 89 ea             	mov    %r13,%rdx
    be0a:	be 01 00 00 00       	mov    $0x1,%esi
    be0f:	48 89 df             	mov    %rbx,%rdi
    be12:	e8 00 00 00 00       	callq  be17 <e1000_setup_link+0x377>
		if (ret_val)
    be17:	85 c0                	test   %eax,%eax
	 */
	for (i = 0; i < 10; i++) {
		ret_val = e1000_read_phy_reg(hw, PHY_STATUS, &phy_data);
		if (ret_val)
			return ret_val;
		ret_val = e1000_read_phy_reg(hw, PHY_STATUS, &phy_data);
    be19:	41 89 c4             	mov    %eax,%r12d
		if (ret_val)
    be1c:	75 44                	jne    be62 <e1000_setup_link+0x3c2>
			return ret_val;

		if (phy_data & MII_SR_LINK_STATUS) {
    be1e:	f6 45 de 04          	testb  $0x4,-0x22(%rbp)
    be22:	0f 85 1a 0d 00 00    	jne    cb42 <e1000_setup_link+0x10a2>
				return ret_val;

			e_dbg("Valid link established!!!\n");
			return E1000_SUCCESS;
		}
		udelay(10);
    be28:	bf c6 a7 00 00       	mov    $0xa7c6,%edi
    be2d:	e8 00 00 00 00       	callq  be32 <e1000_setup_link+0x392>
	}

	/* Check link status. Wait up to 100 microseconds for link to become
	 * valid.
	 */
	for (i = 0; i < 10; i++) {
    be32:	66 41 83 ee 01       	sub    $0x1,%r14w
    be37:	75 b7                	jne    bdf0 <e1000_setup_link+0x350>
			return E1000_SUCCESS;
		}
		udelay(10);
	}

	e_dbg("Unable to establish link!!!\n");
    be39:	f6 05 00 00 00 00 04 	testb  $0x4,0x0(%rip)        # be40 <e1000_setup_link+0x3a0>
    be40:	74 20                	je     be62 <e1000_setup_link+0x3c2>
    be42:	48 89 df             	mov    %rbx,%rdi
    be45:	e8 00 00 00 00       	callq  be4a <e1000_setup_link+0x3aa>
    be4a:	48 c7 c2 00 00 00 00 	mov    $0x0,%rdx
    be51:	48 89 c6             	mov    %rax,%rsi
    be54:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
    be5b:	31 c0                	xor    %eax,%eax
    be5d:	e8 00 00 00 00       	callq  be62 <e1000_setup_link+0x3c2>
	/* Initialize the flow control address, type, and PAUSE timer
	 * registers to their default values.  This is done even if flow
	 * control is disabled, because it does not hurt anything to
	 * initialize these registers.
	 */
	e_dbg("Initializing the Flow Control address, type and timer regs\n");
    be62:	f6 05 00 00 00 00 04 	testb  $0x4,0x0(%rip)        # be69 <e1000_setup_link+0x3c9>
    be69:	0f 85 84 12 00 00    	jne    d0f3 <e1000_setup_link+0x1653>

	ew32(FCT, FLOW_CONTROL_TYPE);
    be6f:	48 8b 13             	mov    (%rbx),%rdx
    be72:	b8 08 88 00 00       	mov    $0x8808,%eax
    be77:	89 42 30             	mov    %eax,0x30(%rdx)
	ew32(FCAH, FLOW_CONTROL_ADDRESS_HIGH);
    be7a:	48 8b 13             	mov    (%rbx),%rdx
    be7d:	66 b8 00 01          	mov    $0x100,%ax
    be81:	89 42 2c             	mov    %eax,0x2c(%rdx)
    be84:	b8 01 80 c2 00       	mov    $0xc28001,%eax
	ew32(FCAL, FLOW_CONTROL_ADDRESS_LOW);
    be89:	48 8b 13             	mov    (%rbx),%rdx
    be8c:	89 42 28             	mov    %eax,0x28(%rdx)

	ew32(FCTTV, hw->fc_pause_time);
    be8f:	48 8b 13             	mov    (%rbx),%rdx
    be92:	0f b7 83 da 00 00 00 	movzwl 0xda(%rbx),%eax
    be99:	89 82 70 01 00 00    	mov    %eax,0x170(%rdx)
	 * these registers will be set to a default threshold that may be
	 * adjusted later by the driver's runtime code.  However, if the
	 * ability to transmit pause frames in not enabled, then these
	 * registers will be set to 0.
	 */
	if (!(hw->fc & E1000_FC_TX_PAUSE)) {
    be9f:	f6 43 40 02          	testb  $0x2,0x40(%rbx)
    bea3:	0f 85 bf 01 00 00    	jne    c068 <e1000_setup_link+0x5c8>
		ew32(FCRTL, 0);
    bea9:	83 7b 18 03          	cmpl   $0x3,0x18(%rbx)
    bead:	48 19 c0             	sbb    %rax,%rax
    beb0:	31 d2                	xor    %edx,%edx
    beb2:	48 25 08 e0 ff ff    	and    $0xffffffffffffe008,%rax
    beb8:	48 05 60 21 00 00    	add    $0x2160,%rax
    bebe:	48 03 03             	add    (%rbx),%rax
    bec1:	89 10                	mov    %edx,(%rax)
		ew32(FCRTH, 0);
    bec3:	83 7b 18 03          	cmpl   $0x3,0x18(%rbx)
    bec7:	48 19 c0             	sbb    %rax,%rax
    beca:	48 25 f8 df ff ff    	and    $0xffffffffffffdff8,%rax
    bed0:	48 05 68 21 00 00    	add    $0x2168,%rax
    bed6:	48 03 03             	add    (%rbx),%rax
    bed9:	89 10                	mov    %edx,(%rax)
		} else {
			ew32(FCRTL, hw->fc_low_water);
			ew32(FCRTH, hw->fc_high_water);
		}
	}
	return ret_val;
    bedb:	44 89 e0             	mov    %r12d,%eax
}
    bede:	48 83 c4 08          	add    $0x8,%rsp
    bee2:	5b                   	pop    %rbx
    bee3:	41 5c                	pop    %r12
    bee5:	41 5d                	pop    %r13
    bee7:	41 5e                	pop    %r14
    bee9:	5d                   	pop    %rbp
    beea:	c3                   	retq   
{ asm volatile("mov" size " %0,%1": :reg (val), \
"m" (*(volatile type __force *)addr) barrier); }

build_mmio_read(readb, "b", unsigned char, "=q", :"memory")
build_mmio_read(readw, "w", unsigned short, "=r", :"memory")
build_mmio_read(readl, "l", unsigned int, "=r", :"memory")
    beeb:	44 8b 30             	mov    (%rax),%r14d
	 * cleared when there is a signal.  This applies to fiber media only.
	 * If we're on serdes media, adjust the output amplitude to value
	 * set in the EEPROM.
	 */
	ctrl = er32(CTRL);
	if (hw->media_type == e1000_media_type_fiber)
    beee:	8b 43 24             	mov    0x24(%rbx),%eax
    bef1:	83 f8 01             	cmp    $0x1,%eax
    bef4:	0f 84 e9 02 00 00    	je     c1e3 <e1000_setup_link+0x743>
static s32 e1000_adjust_serdes_amplitude(struct e1000_hw *hw)
{
	u16 eeprom_data;
	s32 ret_val;

	if (hw->media_type != e1000_media_type_internal_serdes)
    befa:	83 f8 02             	cmp    $0x2,%eax
    befd:	8b 43 18             	mov    0x18(%rbx),%eax
    bf00:	75 12                	jne    bf14 <e1000_setup_link+0x474>
		return E1000_SUCCESS;

	switch (hw->mac_type) {
    bf02:	83 f8 07             	cmp    $0x7,%eax
    bf05:	0f 84 f9 00 00 00    	je     c004 <e1000_setup_link+0x564>
    bf0b:	83 f8 0a             	cmp    $0xa,%eax
    bf0e:	0f 84 f0 00 00 00    	je     c004 <e1000_setup_link+0x564>
{
	u32 ctrl;
	u32 status;
	u32 txcw = 0;
	u32 i;
	u32 signal = 0;
    bf14:	45 31 ed             	xor    %r13d,%r13d
 * Change VCO speed register to improve Bit Error Rate performance of SERDES.
 */
static s32 e1000_set_vco_speed(struct e1000_hw *hw)
{
	s32 ret_val;
	u16 default_page = 0;
    bf17:	31 d2                	xor    %edx,%edx
	u16 phy_data;

	switch (hw->mac_type) {
    bf19:	83 f8 07             	cmp    $0x7,%eax
 * Change VCO speed register to improve Bit Error Rate performance of SERDES.
 */
static s32 e1000_set_vco_speed(struct e1000_hw *hw)
{
	s32 ret_val;
	u16 default_page = 0;
    bf1c:	66 89 55 dc          	mov    %dx,-0x24(%rbp)
	u16 phy_data;

	switch (hw->mac_type) {
    bf20:	0f 84 56 03 00 00    	je     c27c <e1000_setup_link+0x7dc>
    bf26:	83 f8 0a             	cmp    $0xa,%eax
    bf29:	0f 84 4d 03 00 00    	je     c27c <e1000_setup_link+0x7dc>
 */
void e1000_config_collision_dist(struct e1000_hw *hw)
{
	u32 tctl, coll_dist;

	if (hw->mac_type < e1000_82543)
    bf2f:	83 f8 03             	cmp    $0x3,%eax
		coll_dist = E1000_COLLISION_DISTANCE_82542;
	else
		coll_dist = E1000_COLLISION_DISTANCE;

	tctl = er32(TCTL);
    bf32:	48 8b 03             	mov    (%rbx),%rax
 */
void e1000_config_collision_dist(struct e1000_hw *hw)
{
	u32 tctl, coll_dist;

	if (hw->mac_type < e1000_82543)
    bf35:	19 d2                	sbb    %edx,%edx
    bf37:	81 e2 00 10 00 00    	and    $0x1000,%edx
    bf3d:	81 c2 00 f0 03 00    	add    $0x3f000,%edx
    bf43:	8b 80 00 04 00 00    	mov    0x400(%rax),%eax
	else
		coll_dist = E1000_COLLISION_DISTANCE;

	tctl = er32(TCTL);

	tctl &= ~E1000_TCTL_COLD;
    bf49:	25 ff 0f c0 ff       	and    $0xffc00fff,%eax
	tctl |= coll_dist << E1000_COLD_SHIFT;
    bf4e:	09 d0                	or     %edx,%eax

	ew32(TCTL, tctl);
    bf50:	48 8b 13             	mov    (%rbx),%rdx
build_mmio_read(__readw, "w", unsigned short, "=r", )
build_mmio_read(__readl, "l", unsigned int, "=r", )

build_mmio_write(writeb, "b", unsigned char, "q", :"memory")
build_mmio_write(writew, "w", unsigned short, "r", :"memory")
build_mmio_write(writel, "l", unsigned int, "r", :"memory")
    bf53:	89 82 00 04 00 00    	mov    %eax,0x400(%rdx)
	E1000_WRITE_FLUSH();
    bf59:	48 8b 03             	mov    (%rbx),%rax
{ asm volatile("mov" size " %0,%1": :reg (val), \
"m" (*(volatile type __force *)addr) barrier); }

build_mmio_read(readb, "b", unsigned char, "=q", :"memory")
build_mmio_read(readw, "w", unsigned short, "=r", :"memory")
build_mmio_read(readl, "l", unsigned int, "=r", :"memory")
    bf5c:	8b 40 08             	mov    0x8(%rax),%eax
	 *      not send pause frames).
	 *  2:  Tx flow control is enabled (we can send pause frames but we do
	 *      not support receiving pause frames).
	 *  3:  Both Rx and TX flow control (symmetric) are enabled.
	 */
	switch (hw->fc) {
    bf5f:	8b 43 40             	mov    0x40(%rbx),%eax
    bf62:	83 f8 01             	cmp    $0x1,%eax
    bf65:	0f 84 ed 05 00 00    	je     c558 <e1000_setup_link+0xab8>
    bf6b:	0f 82 a7 0a 00 00    	jb     ca18 <e1000_setup_link+0xf78>
    bf71:	83 f8 02             	cmp    $0x2,%eax
    bf74:	0f 84 4e 06 00 00    	je     c5c8 <e1000_setup_link+0xb28>
    bf7a:	83 f8 03             	cmp    $0x3,%eax
    bf7d:	0f 1f 00             	nopl   (%rax)
    bf80:	0f 84 d2 05 00 00    	je     c558 <e1000_setup_link+0xab8>
		 * over-ride.
		 */
		txcw = (E1000_TXCW_ANE | E1000_TXCW_FD | E1000_TXCW_PAUSE_MASK);
		break;
	default:
		e_dbg("Flow control param set incorrectly\n");
    bf86:	f6 05 00 00 00 00 04 	testb  $0x4,0x0(%rip)        # bf8d <e1000_setup_link+0x4ed>
    bf8d:	0f 85 fa 12 00 00    	jne    d28d <e1000_setup_link+0x17ed>
		return -E1000_ERR_CONFIG;
    bf93:	41 bc fd ff ff ff    	mov    $0xfffffffd,%r12d
    bf99:	e9 c4 fe ff ff       	jmpq   be62 <e1000_setup_link+0x3c2>
	/* We want to save off the original Flow Control configuration just
	 * in case we get disconnected and then reconnected into a different
	 * hub or switch with different Flow Control capabilities.
	 */
	if (hw->mac_type == e1000_82542_rev2_0)
		hw->fc &= (~E1000_FC_TX_PAUSE);
    bf9e:	41 83 e4 fd          	and    $0xfffffffd,%r12d
    bfa2:	44 89 63 40          	mov    %r12d,0x40(%rbx)

	if ((hw->mac_type < e1000_82543) && (hw->report_tx_early == 1))
    bfa6:	80 bb 15 01 00 00 00 	cmpb   $0x0,0x115(%rbx)
    bfad:	0f 84 2a fb ff ff    	je     badd <e1000_setup_link+0x3d>
		hw->fc &= (~E1000_FC_RX_PAUSE);
    bfb3:	41 83 e4 fe          	and    $0xfffffffe,%r12d
    bfb7:	44 89 63 40          	mov    %r12d,0x40(%rbx)
    bfbb:	e9 1d fb ff ff       	jmpq   badd <e1000_setup_link+0x3d>
static s32 e1000_set_phy_mode(struct e1000_hw *hw)
{
	s32 ret_val;
	u16 eeprom_data;

	if ((hw->mac_type == e1000_82545_rev_3) &&
    bfc0:	44 8b 4b 24          	mov    0x24(%rbx),%r9d
    bfc4:	45 85 c9             	test   %r9d,%r9d
    bfc7:	0f 84 48 05 00 00    	je     c515 <e1000_setup_link+0xa75>
	if (ret_val)
		return ret_val;

	if ((hw->mac_type == e1000_82545_rev_3) ||
	    (hw->mac_type == e1000_82546_rev_3)) {
		ret_val =
    bfcd:	4c 8d 6d de          	lea    -0x22(%rbp),%r13
    bfd1:	be 10 00 00 00       	mov    $0x10,%esi
    bfd6:	48 89 df             	mov    %rbx,%rdi
    bfd9:	4c 89 ea             	mov    %r13,%rdx
    bfdc:	e8 00 00 00 00       	callq  bfe1 <e1000_setup_link+0x541>
		    e1000_read_phy_reg(hw, M88E1000_PHY_SPEC_CTRL, &phy_data);
		phy_data |= 0x00000008;
    bfe1:	0f b7 55 de          	movzwl -0x22(%rbp),%edx
		ret_val =
    bfe5:	be 10 00 00 00       	mov    $0x10,%esi
    bfea:	48 89 df             	mov    %rbx,%rdi

	if ((hw->mac_type == e1000_82545_rev_3) ||
	    (hw->mac_type == e1000_82546_rev_3)) {
		ret_val =
		    e1000_read_phy_reg(hw, M88E1000_PHY_SPEC_CTRL, &phy_data);
		phy_data |= 0x00000008;
    bfed:	83 ca 08             	or     $0x8,%edx
    bff0:	66 89 55 de          	mov    %dx,-0x22(%rbp)
		ret_val =
		    e1000_write_phy_reg(hw, M88E1000_PHY_SPEC_CTRL, phy_data);
    bff4:	0f b7 d2             	movzwl %dx,%edx
	if ((hw->mac_type == e1000_82545_rev_3) ||
	    (hw->mac_type == e1000_82546_rev_3)) {
		ret_val =
		    e1000_read_phy_reg(hw, M88E1000_PHY_SPEC_CTRL, &phy_data);
		phy_data |= 0x00000008;
		ret_val =
    bff7:	e8 00 00 00 00       	callq  bffc <e1000_setup_link+0x55c>
    bffc:	8b 43 18             	mov    0x18(%rbx),%eax
    bfff:	e9 58 fb ff ff       	jmpq   bb5c <e1000_setup_link+0xbc>
		break;
	default:
		return E1000_SUCCESS;
	}

	ret_val = e1000_read_eeprom(hw, EEPROM_SERDES_AMPLITUDE, 1,
    c004:	48 8d 4d de          	lea    -0x22(%rbp),%rcx
    c008:	ba 01 00 00 00       	mov    $0x1,%edx
    c00d:	be 06 00 00 00       	mov    $0x6,%esi
    c012:	48 89 df             	mov    %rbx,%rdi
    c015:	e8 00 00 00 00       	callq  c01a <e1000_setup_link+0x57a>
	                            &eeprom_data);
	if (ret_val) {
    c01a:	85 c0                	test   %eax,%eax
    c01c:	41 89 c4             	mov    %eax,%r12d
    c01f:	0f 85 3d fe ff ff    	jne    be62 <e1000_setup_link+0x3c2>
		return ret_val;
	}

	if (eeprom_data != EEPROM_RESERVED_WORD) {
    c025:	0f b7 45 de          	movzwl -0x22(%rbp),%eax
    c029:	66 83 f8 ff          	cmp    $0xffff,%ax
    c02d:	74 22                	je     c051 <e1000_setup_link+0x5b1>
		/* Adjust SERDES output amplitude only. */
		eeprom_data &= EEPROM_SERDES_AMPLITUDE_MASK;
    c02f:	83 e0 0f             	and    $0xf,%eax
		ret_val =
    c032:	be 1a 00 00 00       	mov    $0x1a,%esi
    c037:	48 89 df             	mov    %rbx,%rdi
		    e1000_write_phy_reg(hw, M88E1000_PHY_EXT_CTRL, eeprom_data);
    c03a:	0f b7 d0             	movzwl %ax,%edx
		return ret_val;
	}

	if (eeprom_data != EEPROM_RESERVED_WORD) {
		/* Adjust SERDES output amplitude only. */
		eeprom_data &= EEPROM_SERDES_AMPLITUDE_MASK;
    c03d:	66 89 45 de          	mov    %ax,-0x22(%rbp)
		ret_val =
    c041:	e8 00 00 00 00       	callq  c046 <e1000_setup_link+0x5a6>
		    e1000_write_phy_reg(hw, M88E1000_PHY_EXT_CTRL, eeprom_data);
		if (ret_val)
    c046:	85 c0                	test   %eax,%eax
    c048:	41 89 c4             	mov    %eax,%r12d
    c04b:	0f 85 11 fe ff ff    	jne    be62 <e1000_setup_link+0x3c2>
    c051:	8b 43 18             	mov    0x18(%rbx),%eax
{
	u32 ctrl;
	u32 status;
	u32 txcw = 0;
	u32 i;
	u32 signal = 0;
    c054:	45 31 ed             	xor    %r13d,%r13d
    c057:	e9 bb fe ff ff       	jmpq   bf17 <e1000_setup_link+0x477>

	if (hw->mac_type <= e1000_82543 ||
	    hw->mac_type == e1000_82541 || hw->mac_type == e1000_82547 ||
	    hw->mac_type == e1000_82541_rev_2
	    || hw->mac_type == e1000_82547_rev_2)
		hw->phy_reset_disable = false;
    c05c:	c6 83 11 01 00 00 00 	movb   $0x0,0x111(%rbx)
    c063:	e9 09 fb ff ff       	jmpq   bb71 <e1000_setup_link+0xd1>
	} else {
		/* We need to set up the Receive Threshold high and low water
		 * marks as well as (optionally) enabling the transmission of
		 * XON frames.
		 */
		if (hw->fc_send_xon) {
    c068:	80 bb 13 01 00 00 00 	cmpb   $0x0,0x113(%rbx)
    c06f:	74 55                	je     c0c6 <e1000_setup_link+0x626>
			ew32(FCRTL, (hw->fc_low_water | E1000_FCRTL_XONE));
    c071:	83 7b 18 03          	cmpl   $0x3,0x18(%rbx)
    c075:	0f b7 83 d8 00 00 00 	movzwl 0xd8(%rbx),%eax
    c07c:	48 19 d2             	sbb    %rdx,%rdx
    c07f:	0d 00 00 00 80       	or     $0x80000000,%eax
    c084:	48 81 e2 08 e0 ff ff 	and    $0xffffffffffffe008,%rdx
    c08b:	48 81 c2 60 21 00 00 	add    $0x2160,%rdx
    c092:	48 03 13             	add    (%rbx),%rdx
build_mmio_read(__readw, "w", unsigned short, "=r", )
build_mmio_read(__readl, "l", unsigned int, "=r", )

build_mmio_write(writeb, "b", unsigned char, "q", :"memory")
build_mmio_write(writew, "w", unsigned short, "r", :"memory")
build_mmio_write(writel, "l", unsigned int, "r", :"memory")
    c095:	89 02                	mov    %eax,(%rdx)
			ew32(FCRTH, hw->fc_high_water);
		} else {
			ew32(FCRTL, hw->fc_low_water);
			ew32(FCRTH, hw->fc_high_water);
    c097:	83 7b 18 03          	cmpl   $0x3,0x18(%rbx)
    c09b:	0f b7 93 d6 00 00 00 	movzwl 0xd6(%rbx),%edx
    c0a2:	48 19 c0             	sbb    %rax,%rax
    c0a5:	48 25 f8 df ff ff    	and    $0xffffffffffffdff8,%rax
    c0ab:	48 05 68 21 00 00    	add    $0x2168,%rax
    c0b1:	48 03 03             	add    (%rbx),%rax
    c0b4:	89 10                	mov    %edx,(%rax)
		}
	}
	return ret_val;
}
    c0b6:	48 83 c4 08          	add    $0x8,%rsp
		} else {
			ew32(FCRTL, hw->fc_low_water);
			ew32(FCRTH, hw->fc_high_water);
		}
	}
	return ret_val;
    c0ba:	44 89 e0             	mov    %r12d,%eax
}
    c0bd:	5b                   	pop    %rbx
    c0be:	41 5c                	pop    %r12
    c0c0:	41 5d                	pop    %r13
    c0c2:	41 5e                	pop    %r14
    c0c4:	5d                   	pop    %rbp
    c0c5:	c3                   	retq   
		 */
		if (hw->fc_send_xon) {
			ew32(FCRTL, (hw->fc_low_water | E1000_FCRTL_XONE));
			ew32(FCRTH, hw->fc_high_water);
		} else {
			ew32(FCRTL, hw->fc_low_water);
    c0c6:	83 7b 18 03          	cmpl   $0x3,0x18(%rbx)
    c0ca:	0f b7 93 d8 00 00 00 	movzwl 0xd8(%rbx),%edx
    c0d1:	48 19 c0             	sbb    %rax,%rax
    c0d4:	48 25 08 e0 ff ff    	and    $0xffffffffffffe008,%rax
    c0da:	48 05 60 21 00 00    	add    $0x2160,%rax
    c0e0:	48 03 03             	add    (%rbx),%rax
    c0e3:	89 10                	mov    %edx,(%rax)
    c0e5:	eb b0                	jmp    c097 <e1000_setup_link+0x5f7>

	if (hw->phy_id != 0)
		return E1000_SUCCESS;

	/* Read the PHY ID Registers to identify which PHY is onboard. */
	ret_val = e1000_read_phy_reg(hw, PHY_ID1, &phy_id_high);
    c0e7:	4c 8d 75 dc          	lea    -0x24(%rbp),%r14
    c0eb:	be 02 00 00 00       	mov    $0x2,%esi
    c0f0:	48 89 df             	mov    %rbx,%rdi
    c0f3:	4c 89 f2             	mov    %r14,%rdx
    c0f6:	e8 00 00 00 00       	callq  c0fb <e1000_setup_link+0x65b>
	if (ret_val)
    c0fb:	85 c0                	test   %eax,%eax

	if (hw->phy_id != 0)
		return E1000_SUCCESS;

	/* Read the PHY ID Registers to identify which PHY is onboard. */
	ret_val = e1000_read_phy_reg(hw, PHY_ID1, &phy_id_high);
    c0fd:	41 89 c4             	mov    %eax,%r12d
	if (ret_val)
    c100:	0f 84 8b 02 00 00    	je     c391 <e1000_setup_link+0x8f1>
	}

	/* Make sure we have a valid PHY */
	ret_val = e1000_detect_gig_phy(hw);
	if (ret_val) {
		e_dbg("Error, did not detect valid phy.\n");
    c106:	f6 05 00 00 00 00 04 	testb  $0x4,0x0(%rip)        # c10d <e1000_setup_link+0x66d>
    c10d:	0f 84 4f fd ff ff    	je     be62 <e1000_setup_link+0x3c2>
    c113:	48 89 df             	mov    %rbx,%rdi
    c116:	e8 00 00 00 00       	callq  c11b <e1000_setup_link+0x67b>
    c11b:	48 c7 c2 00 00 00 00 	mov    $0x0,%rdx
    c122:	48 89 c6             	mov    %rax,%rsi
    c125:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
    c12c:	31 c0                	xor    %eax,%eax
    c12e:	e8 00 00 00 00       	callq  c133 <e1000_setup_link+0x693>
    c133:	e9 2a fd ff ff       	jmpq   be62 <e1000_setup_link+0x3c2>
	 * SW defined pins. If there is no SW over-ride of the flow
	 * control setting, then the variable hw->fc will
	 * be initialized based on a value in the EEPROM.
	 */
	if (hw->fc == E1000_FC_DEFAULT) {
		ret_val = e1000_read_eeprom(hw, EEPROM_INIT_CONTROL2_REG,
    c138:	48 8d 4d d8          	lea    -0x28(%rbp),%rcx
    c13c:	ba 01 00 00 00       	mov    $0x1,%edx
    c141:	be 0f 00 00 00       	mov    $0xf,%esi
    c146:	e8 00 00 00 00       	callq  c14b <e1000_setup_link+0x6ab>
					    1, &eeprom_data);
		if (ret_val) {
    c14b:	85 c0                	test   %eax,%eax
    c14d:	0f 84 ff 00 00 00    	je     c252 <e1000_setup_link+0x7b2>
			e_dbg("EEPROM Read Error\n");
    c153:	f6 05 00 00 00 00 04 	testb  $0x4,0x0(%rip)        # c15a <e1000_setup_link+0x6ba>
    c15a:	0f 85 58 11 00 00    	jne    d2b8 <e1000_setup_link+0x1818>
			ew32(FCRTL, hw->fc_low_water);
			ew32(FCRTH, hw->fc_high_water);
		}
	}
	return ret_val;
}
    c160:	48 83 c4 08          	add    $0x8,%rsp
	if (hw->fc == E1000_FC_DEFAULT) {
		ret_val = e1000_read_eeprom(hw, EEPROM_INIT_CONTROL2_REG,
					    1, &eeprom_data);
		if (ret_val) {
			e_dbg("EEPROM Read Error\n");
			return -E1000_ERR_EEPROM;
    c164:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
			ew32(FCRTL, hw->fc_low_water);
			ew32(FCRTH, hw->fc_high_water);
		}
	}
	return ret_val;
}
    c169:	5b                   	pop    %rbx
    c16a:	41 5c                	pop    %r12
    c16c:	41 5d                	pop    %r13
    c16e:	41 5e                	pop    %r14
    c170:	5d                   	pop    %rbp
    c171:	c3                   	retq   
	 * This is needed because one of the SW controlled pins is used for
	 * signal detection.  So this should be done before e1000_setup_pcs_link()
	 * or e1000_phy_setup() is called.
	 */
	if (hw->mac_type == e1000_82543) {
		ret_val = e1000_read_eeprom(hw, EEPROM_INIT_CONTROL2_REG,
    c172:	48 8d 4d d8          	lea    -0x28(%rbp),%rcx
    c176:	ba 01 00 00 00       	mov    $0x1,%edx
    c17b:	be 0f 00 00 00       	mov    $0xf,%esi
    c180:	48 89 df             	mov    %rbx,%rdi
    c183:	e8 00 00 00 00       	callq  c188 <e1000_setup_link+0x6e8>
					    1, &eeprom_data);
		if (ret_val) {
    c188:	85 c0                	test   %eax,%eax
    c18a:	0f 84 ea 01 00 00    	je     c37a <e1000_setup_link+0x8da>
			e_dbg("EEPROM Read Error\n");
    c190:	f6 05 00 00 00 00 04 	testb  $0x4,0x0(%rip)        # c197 <e1000_setup_link+0x6f7>
    c197:	74 c7                	je     c160 <e1000_setup_link+0x6c0>
    c199:	48 89 df             	mov    %rbx,%rdi
    c19c:	e8 00 00 00 00       	callq  c1a1 <e1000_setup_link+0x701>
    c1a1:	48 c7 c2 00 00 00 00 	mov    $0x0,%rdx
    c1a8:	48 89 c6             	mov    %rax,%rsi
    c1ab:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
    c1b2:	31 c0                	xor    %eax,%eax
    c1b4:	e8 00 00 00 00       	callq  c1b9 <e1000_setup_link+0x719>
			return -E1000_ERR_EEPROM;
    c1b9:	83 c8 ff             	or     $0xffffffff,%eax
    c1bc:	e9 1d fd ff ff       	jmpq   bede <e1000_setup_link+0x43e>
	if (hw->mac_type > e1000_82543) {
		ctrl |= E1000_CTRL_SLU;
		ctrl &= ~(E1000_CTRL_FRCSPD | E1000_CTRL_FRCDPX);
		ew32(CTRL, ctrl);
	} else {
		ctrl |=
    c1c1:	0d 40 18 00 00       	or     $0x1840,%eax
		    (E1000_CTRL_FRCSPD | E1000_CTRL_FRCDPX | E1000_CTRL_SLU);
		ew32(CTRL, ctrl);
    c1c6:	48 8b 13             	mov    (%rbx),%rdx
    c1c9:	89 02                	mov    %eax,(%rdx)
		ret_val = e1000_phy_hw_reset(hw);
    c1cb:	48 89 df             	mov    %rbx,%rdi
    c1ce:	e8 00 00 00 00       	callq  c1d3 <e1000_setup_link+0x733>
		if (ret_val)
    c1d3:	85 c0                	test   %eax,%eax
		ew32(CTRL, ctrl);
	} else {
		ctrl |=
		    (E1000_CTRL_FRCSPD | E1000_CTRL_FRCDPX | E1000_CTRL_SLU);
		ew32(CTRL, ctrl);
		ret_val = e1000_phy_hw_reset(hw);
    c1d5:	41 89 c4             	mov    %eax,%r12d
		if (ret_val)
    c1d8:	0f 84 43 f9 ff ff    	je     bb21 <e1000_setup_link+0x81>
    c1de:	e9 7f fc ff ff       	jmpq   be62 <e1000_setup_link+0x3c2>
	 * If we're on serdes media, adjust the output amplitude to value
	 * set in the EEPROM.
	 */
	ctrl = er32(CTRL);
	if (hw->media_type == e1000_media_type_fiber)
		signal = (hw->mac_type > e1000_82544) ? E1000_CTRL_SWDPIN1 : 0;
    c1e3:	8b 43 18             	mov    0x18(%rbx),%eax
    c1e6:	83 f8 05             	cmp    $0x5,%eax
    c1e9:	45 19 ed             	sbb    %r13d,%r13d
    c1ec:	41 f7 d5             	not    %r13d
    c1ef:	41 81 e5 00 00 08 00 	and    $0x80000,%r13d
    c1f6:	e9 1c fd ff ff       	jmpq   bf17 <e1000_setup_link+0x477>
static s32 gbe_dhg_phy_setup(struct e1000_hw *hw)
{
	s32 ret_val;
	u32 ctrl_aux;

	switch (hw->phy_type) {
    c1fb:	83 f8 02             	cmp    $0x2,%eax
    c1fe:	0f 84 d3 06 00 00    	je     c8d7 <e1000_setup_link+0xe37>
    c204:	83 f8 03             	cmp    $0x3,%eax
    c207:	0f 84 29 02 00 00    	je     c436 <e1000_setup_link+0x996>
			e_dbg("e1000_copper_link_rtl_setup failed!\n");
			return ret_val;
		}
		break;
	default:
		e_dbg("Error Resetting the PHY\n");
    c20d:	f6 05 00 00 00 00 04 	testb  $0x4,0x0(%rip)        # c214 <e1000_setup_link+0x774>
    c214:	0f 85 0d 11 00 00    	jne    d327 <e1000_setup_link+0x1887>
		return E1000_ERR_PHY_TYPE;
    c21a:	41 bc 06 00 00 00    	mov    $0x6,%r12d
		if (ret_val)
			return ret_val;
	} else {
		ret_val = gbe_dhg_phy_setup(hw);
		if (ret_val) {
			e_dbg("gbe_dhg_phy_setup failed!\n");
    c220:	f6 05 00 00 00 00 04 	testb  $0x4,0x0(%rip)        # c227 <e1000_setup_link+0x787>
    c227:	0f 84 35 fc ff ff    	je     be62 <e1000_setup_link+0x3c2>
    c22d:	48 89 df             	mov    %rbx,%rdi
    c230:	e8 00 00 00 00       	callq  c235 <e1000_setup_link+0x795>
    c235:	48 c7 c2 00 00 00 00 	mov    $0x0,%rdx
    c23c:	48 89 c6             	mov    %rax,%rsi
    c23f:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
    c246:	31 c0                	xor    %eax,%eax
    c248:	e8 00 00 00 00       	callq  c24d <e1000_setup_link+0x7ad>
    c24d:	e9 10 fc ff ff       	jmpq   be62 <e1000_setup_link+0x3c2>
					    1, &eeprom_data);
		if (ret_val) {
			e_dbg("EEPROM Read Error\n");
			return -E1000_ERR_EEPROM;
		}
		if ((eeprom_data & EEPROM_WORD0F_PAUSE_MASK) == 0)
    c252:	0f b7 45 d8          	movzwl -0x28(%rbp),%eax
    c256:	66 25 00 30          	and    $0x3000,%ax
    c25a:	0f 84 54 02 00 00    	je     c4b4 <e1000_setup_link+0xa14>
			hw->fc = E1000_FC_NONE;
		else if ((eeprom_data & EEPROM_WORD0F_PAUSE_MASK) ==
    c260:	66 3d 00 20          	cmp    $0x2000,%ax
    c264:	0f 84 37 09 00 00    	je     cba1 <e1000_setup_link+0x1101>
			 EEPROM_WORD0F_ASM_DIR)
			hw->fc = E1000_FC_TX_PAUSE;
		else
			hw->fc = E1000_FC_FULL;
    c26a:	c7 43 40 03 00 00 00 	movl   $0x3,0x40(%rbx)
    c271:	41 bc 03 00 00 00    	mov    $0x3,%r12d
    c277:	e9 4c f8 ff ff       	jmpq   bac8 <e1000_setup_link+0x28>
		return E1000_SUCCESS;
	}

	/* Set PHY register 30, page 5, bit 8 to 0 */

	ret_val =
    c27c:	48 8d 55 dc          	lea    -0x24(%rbp),%rdx
    c280:	be 1d 00 00 00       	mov    $0x1d,%esi
    c285:	48 89 df             	mov    %rbx,%rdi
    c288:	e8 00 00 00 00       	callq  c28d <e1000_setup_link+0x7ed>
	    e1000_read_phy_reg(hw, M88E1000_PHY_PAGE_SELECT, &default_page);
	if (ret_val)
    c28d:	85 c0                	test   %eax,%eax
    c28f:	41 89 c4             	mov    %eax,%r12d
    c292:	0f 85 ca fb ff ff    	jne    be62 <e1000_setup_link+0x3c2>
		return ret_val;

	ret_val = e1000_write_phy_reg(hw, M88E1000_PHY_PAGE_SELECT, 0x0005);
    c298:	ba 05 00 00 00       	mov    $0x5,%edx
    c29d:	be 1d 00 00 00       	mov    $0x1d,%esi
    c2a2:	48 89 df             	mov    %rbx,%rdi
    c2a5:	e8 00 00 00 00       	callq  c2aa <e1000_setup_link+0x80a>
	if (ret_val)
    c2aa:	85 c0                	test   %eax,%eax
    c2ac:	41 89 c4             	mov    %eax,%r12d
    c2af:	0f 85 ad fb ff ff    	jne    be62 <e1000_setup_link+0x3c2>
		return ret_val;

	ret_val = e1000_read_phy_reg(hw, M88E1000_PHY_GEN_CONTROL, &phy_data);
    c2b5:	48 8d 55 de          	lea    -0x22(%rbp),%rdx
    c2b9:	be 1e 00 00 00       	mov    $0x1e,%esi
    c2be:	48 89 df             	mov    %rbx,%rdi
    c2c1:	e8 00 00 00 00       	callq  c2c6 <e1000_setup_link+0x826>
	if (ret_val)
    c2c6:	85 c0                	test   %eax,%eax
    c2c8:	41 89 c4             	mov    %eax,%r12d
    c2cb:	0f 85 91 fb ff ff    	jne    be62 <e1000_setup_link+0x3c2>
		return ret_val;

	phy_data &= ~M88E1000_PHY_VCO_REG_BIT8;
    c2d1:	0f b7 45 de          	movzwl -0x22(%rbp),%eax
	ret_val = e1000_write_phy_reg(hw, M88E1000_PHY_GEN_CONTROL, phy_data);
    c2d5:	be 1e 00 00 00       	mov    $0x1e,%esi
    c2da:	48 89 df             	mov    %rbx,%rdi

	ret_val = e1000_read_phy_reg(hw, M88E1000_PHY_GEN_CONTROL, &phy_data);
	if (ret_val)
		return ret_val;

	phy_data &= ~M88E1000_PHY_VCO_REG_BIT8;
    c2dd:	80 e4 fe             	and    $0xfe,%ah
	ret_val = e1000_write_phy_reg(hw, M88E1000_PHY_GEN_CONTROL, phy_data);
    c2e0:	0f b7 d0             	movzwl %ax,%edx

	ret_val = e1000_read_phy_reg(hw, M88E1000_PHY_GEN_CONTROL, &phy_data);
	if (ret_val)
		return ret_val;

	phy_data &= ~M88E1000_PHY_VCO_REG_BIT8;
    c2e3:	66 89 45 de          	mov    %ax,-0x22(%rbp)
	ret_val = e1000_write_phy_reg(hw, M88E1000_PHY_GEN_CONTROL, phy_data);
    c2e7:	e8 00 00 00 00       	callq  c2ec <e1000_setup_link+0x84c>
	if (ret_val)
    c2ec:	85 c0                	test   %eax,%eax
    c2ee:	41 89 c4             	mov    %eax,%r12d
    c2f1:	0f 85 6b fb ff ff    	jne    be62 <e1000_setup_link+0x3c2>
		return ret_val;

	/* Set PHY register 30, page 4, bit 11 to 1 */

	ret_val = e1000_write_phy_reg(hw, M88E1000_PHY_PAGE_SELECT, 0x0004);
    c2f7:	ba 04 00 00 00       	mov    $0x4,%edx
    c2fc:	be 1d 00 00 00       	mov    $0x1d,%esi
    c301:	48 89 df             	mov    %rbx,%rdi
    c304:	e8 00 00 00 00       	callq  c309 <e1000_setup_link+0x869>
	if (ret_val)
    c309:	85 c0                	test   %eax,%eax
    c30b:	41 89 c4             	mov    %eax,%r12d
    c30e:	0f 85 4e fb ff ff    	jne    be62 <e1000_setup_link+0x3c2>
		return ret_val;

	ret_val = e1000_read_phy_reg(hw, M88E1000_PHY_GEN_CONTROL, &phy_data);
    c314:	48 8d 55 de          	lea    -0x22(%rbp),%rdx
    c318:	be 1e 00 00 00       	mov    $0x1e,%esi
    c31d:	48 89 df             	mov    %rbx,%rdi
    c320:	e8 00 00 00 00       	callq  c325 <e1000_setup_link+0x885>
	if (ret_val)
    c325:	85 c0                	test   %eax,%eax
    c327:	41 89 c4             	mov    %eax,%r12d
    c32a:	0f 85 32 fb ff ff    	jne    be62 <e1000_setup_link+0x3c2>
		return ret_val;

	phy_data |= M88E1000_PHY_VCO_REG_BIT11;
    c330:	0f b7 45 de          	movzwl -0x22(%rbp),%eax
	ret_val = e1000_write_phy_reg(hw, M88E1000_PHY_GEN_CONTROL, phy_data);
    c334:	be 1e 00 00 00       	mov    $0x1e,%esi
    c339:	48 89 df             	mov    %rbx,%rdi

	ret_val = e1000_read_phy_reg(hw, M88E1000_PHY_GEN_CONTROL, &phy_data);
	if (ret_val)
		return ret_val;

	phy_data |= M88E1000_PHY_VCO_REG_BIT11;
    c33c:	80 cc 08             	or     $0x8,%ah
	ret_val = e1000_write_phy_reg(hw, M88E1000_PHY_GEN_CONTROL, phy_data);
    c33f:	0f b7 d0             	movzwl %ax,%edx

	ret_val = e1000_read_phy_reg(hw, M88E1000_PHY_GEN_CONTROL, &phy_data);
	if (ret_val)
		return ret_val;

	phy_data |= M88E1000_PHY_VCO_REG_BIT11;
    c342:	66 89 45 de          	mov    %ax,-0x22(%rbp)
	ret_val = e1000_write_phy_reg(hw, M88E1000_PHY_GEN_CONTROL, phy_data);
    c346:	e8 00 00 00 00       	callq  c34b <e1000_setup_link+0x8ab>
	if (ret_val)
    c34b:	85 c0                	test   %eax,%eax
    c34d:	41 89 c4             	mov    %eax,%r12d
    c350:	0f 85 0c fb ff ff    	jne    be62 <e1000_setup_link+0x3c2>
		return ret_val;

	ret_val =
	    e1000_write_phy_reg(hw, M88E1000_PHY_PAGE_SELECT, default_page);
    c356:	0f b7 55 dc          	movzwl -0x24(%rbp),%edx
	phy_data |= M88E1000_PHY_VCO_REG_BIT11;
	ret_val = e1000_write_phy_reg(hw, M88E1000_PHY_GEN_CONTROL, phy_data);
	if (ret_val)
		return ret_val;

	ret_val =
    c35a:	be 1d 00 00 00       	mov    $0x1d,%esi
    c35f:	48 89 df             	mov    %rbx,%rdi
    c362:	e8 00 00 00 00       	callq  c367 <e1000_setup_link+0x8c7>
	    e1000_write_phy_reg(hw, M88E1000_PHY_PAGE_SELECT, default_page);
	if (ret_val)
    c367:	85 c0                	test   %eax,%eax
    c369:	41 89 c4             	mov    %eax,%r12d
    c36c:	0f 85 f0 fa ff ff    	jne    be62 <e1000_setup_link+0x3c2>
    c372:	8b 43 18             	mov    0x18(%rbx),%eax
    c375:	e9 b5 fb ff ff       	jmpq   bf2f <e1000_setup_link+0x48f>
					    1, &eeprom_data);
		if (ret_val) {
			e_dbg("EEPROM Read Error\n");
			return -E1000_ERR_EEPROM;
		}
		ctrl_ext = ((eeprom_data & EEPROM_WORD0F_SWPDIO_EXT) <<
    c37a:	0f b7 45 d8          	movzwl -0x28(%rbp),%eax
			    SWDPIO__EXT_SHIFT);
		ew32(CTRL_EXT, ctrl_ext);
    c37e:	48 8b 13             	mov    (%rbx),%rdx
					    1, &eeprom_data);
		if (ret_val) {
			e_dbg("EEPROM Read Error\n");
			return -E1000_ERR_EEPROM;
		}
		ctrl_ext = ((eeprom_data & EEPROM_WORD0F_SWPDIO_EXT) <<
    c381:	25 f0 00 00 00       	and    $0xf0,%eax
    c386:	c1 e0 04             	shl    $0x4,%eax
    c389:	89 42 18             	mov    %eax,0x18(%rdx)
    c38c:	e9 69 f7 ff ff       	jmpq   bafa <e1000_setup_link+0x5a>
	/* Read the PHY ID Registers to identify which PHY is onboard. */
	ret_val = e1000_read_phy_reg(hw, PHY_ID1, &phy_id_high);
	if (ret_val)
		return ret_val;

	hw->phy_id = (u32) (phy_id_high << 16);
    c391:	0f b7 45 dc          	movzwl -0x24(%rbp),%eax
	udelay(20);
	ret_val = e1000_read_phy_reg(hw, PHY_ID2, &phy_id_low);
    c395:	4c 8d 6d de          	lea    -0x22(%rbp),%r13
	ret_val = e1000_read_phy_reg(hw, PHY_ID1, &phy_id_high);
	if (ret_val)
		return ret_val;

	hw->phy_id = (u32) (phy_id_high << 16);
	udelay(20);
    c399:	bf 8c 4f 01 00       	mov    $0x14f8c,%edi
	/* Read the PHY ID Registers to identify which PHY is onboard. */
	ret_val = e1000_read_phy_reg(hw, PHY_ID1, &phy_id_high);
	if (ret_val)
		return ret_val;

	hw->phy_id = (u32) (phy_id_high << 16);
    c39e:	c1 e0 10             	shl    $0x10,%eax
    c3a1:	89 83 80 00 00 00    	mov    %eax,0x80(%rbx)
	udelay(20);
    c3a7:	e8 00 00 00 00       	callq  c3ac <e1000_setup_link+0x90c>
	ret_val = e1000_read_phy_reg(hw, PHY_ID2, &phy_id_low);
    c3ac:	4c 89 ea             	mov    %r13,%rdx
    c3af:	be 03 00 00 00       	mov    $0x3,%esi
    c3b4:	48 89 df             	mov    %rbx,%rdi
    c3b7:	e8 00 00 00 00       	callq  c3bc <e1000_setup_link+0x91c>
	if (ret_val)
    c3bc:	85 c0                	test   %eax,%eax
    c3be:	0f 85 8c 01 00 00    	jne    c550 <e1000_setup_link+0xab0>
		return ret_val;

	hw->phy_id |= (u32) (phy_id_low & PHY_REVISION_MASK);
    c3c4:	0f b7 45 de          	movzwl -0x22(%rbp),%eax
	hw->phy_revision = (u32) phy_id_low & ~PHY_REVISION_MASK;

	switch (hw->mac_type) {
    c3c8:	44 8b 6b 18          	mov    0x18(%rbx),%r13d
	udelay(20);
	ret_val = e1000_read_phy_reg(hw, PHY_ID2, &phy_id_low);
	if (ret_val)
		return ret_val;

	hw->phy_id |= (u32) (phy_id_low & PHY_REVISION_MASK);
    c3cc:	41 89 c4             	mov    %eax,%r12d
	hw->phy_revision = (u32) phy_id_low & ~PHY_REVISION_MASK;
    c3cf:	83 e0 0f             	and    $0xf,%eax
	udelay(20);
	ret_val = e1000_read_phy_reg(hw, PHY_ID2, &phy_id_low);
	if (ret_val)
		return ret_val;

	hw->phy_id |= (u32) (phy_id_low & PHY_REVISION_MASK);
    c3d2:	41 81 e4 f0 ff 00 00 	and    $0xfff0,%r12d
    c3d9:	44 0b a3 80 00 00 00 	or     0x80(%rbx),%r12d
	hw->phy_revision = (u32) phy_id_low & ~PHY_REVISION_MASK;
    c3e0:	89 83 84 00 00 00    	mov    %eax,0x84(%rbx)

	switch (hw->mac_type) {
    c3e6:	41 8d 45 fd          	lea    -0x3(%r13),%eax
    c3ea:	83 f8 0b             	cmp    $0xb,%eax
	udelay(20);
	ret_val = e1000_read_phy_reg(hw, PHY_ID2, &phy_id_low);
	if (ret_val)
		return ret_val;

	hw->phy_id |= (u32) (phy_id_low & PHY_REVISION_MASK);
    c3ed:	44 89 a3 80 00 00 00 	mov    %r12d,0x80(%rbx)
	hw->phy_revision = (u32) phy_id_low & ~PHY_REVISION_MASK;

	switch (hw->mac_type) {
    c3f4:	0f 87 f9 07 00 00    	ja     cbf3 <e1000_setup_link+0x1153>
    c3fa:	ff 24 c5 00 00 00 00 	jmpq   *0x0(,%rax,8)
			return ret_val;

		phy_data |= M88E1000_PSCR_ASSERT_CRS_ON_TX;
		ret_val =
		    e1000_write_phy_reg(hw, M88E1000_PHY_SPEC_CTRL, phy_data);
		if (ret_val)
    c401:	41 89 c4             	mov    %eax,%r12d
		 * depending on value from forced_speed_duplex.
		 */
		e_dbg("Forcing speed and duplex\n");
		ret_val = e1000_phy_force_speed_duplex(hw);
		if (ret_val) {
			e_dbg("Error Forcing Speed and Duplex\n");
    c404:	f6 05 00 00 00 00 04 	testb  $0x4,0x0(%rip)        # c40b <e1000_setup_link+0x96b>
    c40b:	0f 84 51 fa ff ff    	je     be62 <e1000_setup_link+0x3c2>
    c411:	48 89 df             	mov    %rbx,%rdi
    c414:	e8 00 00 00 00       	callq  c419 <e1000_setup_link+0x979>
    c419:	48 c7 c2 00 00 00 00 	mov    $0x0,%rdx
    c420:	48 89 c6             	mov    %rax,%rsi
    c423:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
    c42a:	31 c0                	xor    %eax,%eax
    c42c:	e8 00 00 00 00       	callq  c431 <e1000_setup_link+0x991>
    c431:	e9 2c fa ff ff       	jmpq   be62 <e1000_setup_link+0x3c2>
			return ret_val;
		}
		break;
	case e1000_phy_8201:
		/* Set RMII mode */
		ctrl_aux = er32(CTL_AUX);
    c436:	48 8b 03             	mov    (%rbx),%rax
{ asm volatile("mov" size " %0,%1": :reg (val), \
"m" (*(volatile type __force *)addr) barrier); }

build_mmio_read(readb, "b", unsigned char, "=q", :"memory")
build_mmio_read(readw, "w", unsigned short, "=r", :"memory")
build_mmio_read(readl, "l", unsigned int, "=r", :"memory")
    c439:	8b 80 e0 00 00 00    	mov    0xe0(%rax),%eax
		ctrl_aux |= E1000_CTL_AUX_RMII;
    c43f:	83 c8 01             	or     $0x1,%eax
		ew32(CTL_AUX, ctrl_aux);
    c442:	48 8b 13             	mov    (%rbx),%rdx
build_mmio_read(__readw, "w", unsigned short, "=r", )
build_mmio_read(__readl, "l", unsigned int, "=r", )

build_mmio_write(writeb, "b", unsigned char, "q", :"memory")
build_mmio_write(writew, "w", unsigned short, "r", :"memory")
build_mmio_write(writel, "l", unsigned int, "r", :"memory")
    c445:	89 82 e0 00 00 00    	mov    %eax,0xe0(%rdx)
		E1000_WRITE_FLUSH();
    c44b:	48 8b 03             	mov    (%rbx),%rax
{ asm volatile("mov" size " %0,%1": :reg (val), \
"m" (*(volatile type __force *)addr) barrier); }

build_mmio_read(readb, "b", unsigned char, "=q", :"memory")
build_mmio_read(readw, "w", unsigned short, "=r", :"memory")
build_mmio_read(readl, "l", unsigned int, "=r", :"memory")
    c44e:	8b 40 08             	mov    0x8(%rax),%eax

		/* Disable the J/K bits required for receive */
		ctrl_aux = er32(CTL_AUX);
    c451:	48 8b 03             	mov    (%rbx),%rax
    c454:	8b 80 e0 00 00 00    	mov    0xe0(%rax),%eax
		ctrl_aux |= 0x4;
		ctrl_aux &= ~0x2;
    c45a:	83 e0 fd             	and    $0xfffffffd,%eax
		ew32(CTL_AUX, ctrl_aux);
    c45d:	48 8b 13             	mov    (%rbx),%rdx
		E1000_WRITE_FLUSH();

		/* Disable the J/K bits required for receive */
		ctrl_aux = er32(CTL_AUX);
		ctrl_aux |= 0x4;
		ctrl_aux &= ~0x2;
    c460:	83 c8 04             	or     $0x4,%eax
build_mmio_read(__readw, "w", unsigned short, "=r", )
build_mmio_read(__readl, "l", unsigned int, "=r", )

build_mmio_write(writeb, "b", unsigned char, "q", :"memory")
build_mmio_write(writew, "w", unsigned short, "r", :"memory")
build_mmio_write(writel, "l", unsigned int, "r", :"memory")
    c463:	89 82 e0 00 00 00    	mov    %eax,0xe0(%rdx)
		ew32(CTL_AUX, ctrl_aux);
		E1000_WRITE_FLUSH();
    c469:	48 8b 03             	mov    (%rbx),%rax
{ asm volatile("mov" size " %0,%1": :reg (val), \
"m" (*(volatile type __force *)addr) barrier); }

build_mmio_read(readb, "b", unsigned char, "=q", :"memory")
build_mmio_read(readw, "w", unsigned short, "=r", :"memory")
build_mmio_read(readl, "l", unsigned int, "=r", :"memory")
    c46c:	8b 40 08             	mov    0x8(%rax),%eax
		ret_val = e1000_copper_link_rtl_setup(hw);
    c46f:	48 89 df             	mov    %rbx,%rdi
    c472:	e8 49 f0 ff ff       	callq  b4c0 <e1000_copper_link_rtl_setup>

		if (ret_val) {
    c477:	85 c0                	test   %eax,%eax
		ctrl_aux = er32(CTL_AUX);
		ctrl_aux |= 0x4;
		ctrl_aux &= ~0x2;
		ew32(CTL_AUX, ctrl_aux);
		E1000_WRITE_FLUSH();
		ret_val = e1000_copper_link_rtl_setup(hw);
    c479:	41 89 c4             	mov    %eax,%r12d

		if (ret_val) {
    c47c:	0f 84 10 f7 ff ff    	je     bb92 <e1000_setup_link+0xf2>
			e_dbg("e1000_copper_link_rtl_setup failed!\n");
    c482:	f6 05 00 00 00 00 04 	testb  $0x4,0x0(%rip)        # c489 <e1000_setup_link+0x9e9>
    c489:	0f 84 91 fd ff ff    	je     c220 <e1000_setup_link+0x780>
    c48f:	48 89 df             	mov    %rbx,%rdi
    c492:	e8 00 00 00 00       	callq  c497 <e1000_setup_link+0x9f7>
    c497:	48 c7 c2 00 00 00 00 	mov    $0x0,%rdx
    c49e:	48 89 c6             	mov    %rax,%rsi
    c4a1:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
    c4a8:	31 c0                	xor    %eax,%eax
    c4aa:	e8 00 00 00 00       	callq  c4af <e1000_setup_link+0xa0f>
    c4af:	e9 6c fd ff ff       	jmpq   c220 <e1000_setup_link+0x780>
		if (ret_val) {
			e_dbg("EEPROM Read Error\n");
			return -E1000_ERR_EEPROM;
		}
		if ((eeprom_data & EEPROM_WORD0F_PAUSE_MASK) == 0)
			hw->fc = E1000_FC_NONE;
    c4b4:	c7 43 40 00 00 00 00 	movl   $0x0,0x40(%rbx)
    c4bb:	45 31 e4             	xor    %r12d,%r12d
    c4be:	e9 05 f6 ff ff       	jmpq   bac8 <e1000_setup_link+0x28>
	/* Set the bits to Force Speed and Duplex in the Device Ctrl Reg. */
	ctrl |= (E1000_CTRL_FRCSPD | E1000_CTRL_FRCDPX);
	ctrl &= ~(DEVICE_SPEED_MASK);

	/* Clear the Auto Speed Detect Enable bit. */
	ctrl &= ~E1000_CTRL_ASDE;
    c4c3:	41 81 e4 df fc ff ff 	and    $0xfffffcdf,%r12d
	    hw->forced_speed_duplex == e1000_10_full) {
		/* We want to force full duplex so we SET the full duplex bits
		 * in the Device and MII Control Registers.
		 */
		ctrl |= E1000_CTRL_FD;
		mii_ctrl_reg |= MII_CR_FULL_DUPLEX;
    c4ca:	80 cd 01             	or     $0x1,%ch
	if (hw->forced_speed_duplex == e1000_100_full ||
	    hw->forced_speed_duplex == e1000_10_full) {
		/* We want to force full duplex so we SET the full duplex bits
		 * in the Device and MII Control Registers.
		 */
		ctrl |= E1000_CTRL_FD;
    c4cd:	41 81 cc 01 18 00 00 	or     $0x1801,%r12d
		mii_ctrl_reg |= MII_CR_FULL_DUPLEX;
		e_dbg("Full Duplex\n");
    c4d4:	f6 05 00 00 00 00 04 	testb  $0x4,0x0(%rip)        # c4db <e1000_setup_link+0xa3b>
	    hw->forced_speed_duplex == e1000_10_full) {
		/* We want to force full duplex so we SET the full duplex bits
		 * in the Device and MII Control Registers.
		 */
		ctrl |= E1000_CTRL_FD;
		mii_ctrl_reg |= MII_CR_FULL_DUPLEX;
    c4db:	66 89 4d da          	mov    %cx,-0x26(%rbp)
		e_dbg("Full Duplex\n");
    c4df:	0f 84 3e f7 ff ff    	je     bc23 <e1000_setup_link+0x183>
    c4e5:	48 89 df             	mov    %rbx,%rdi
    c4e8:	e8 00 00 00 00       	callq  c4ed <e1000_setup_link+0xa4d>
    c4ed:	48 c7 c2 00 00 00 00 	mov    $0x0,%rdx
    c4f4:	48 89 c6             	mov    %rax,%rsi
    c4f7:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
    c4fe:	31 c0                	xor    %eax,%eax
    c500:	e8 00 00 00 00       	callq  c505 <e1000_setup_link+0xa65>
    c505:	0f b6 83 f1 00 00 00 	movzbl 0xf1(%rbx),%eax
    c50c:	0f b7 4d da          	movzwl -0x26(%rbp),%ecx
    c510:	e9 0e f7 ff ff       	jmpq   bc23 <e1000_setup_link+0x183>
	s32 ret_val;
	u16 eeprom_data;

	if ((hw->mac_type == e1000_82545_rev_3) &&
	    (hw->media_type == e1000_media_type_copper)) {
		ret_val =
    c515:	4c 8d 6d de          	lea    -0x22(%rbp),%r13
    c519:	ba 01 00 00 00       	mov    $0x1,%edx
    c51e:	be 07 00 00 00       	mov    $0x7,%esi
    c523:	48 89 df             	mov    %rbx,%rdi
    c526:	4c 89 e9             	mov    %r13,%rcx
    c529:	e8 00 00 00 00       	callq  c52e <e1000_setup_link+0xa8e>
		    e1000_read_eeprom(hw, EEPROM_PHY_CLASS_WORD, 1,
				      &eeprom_data);
		if (ret_val) {
    c52e:	85 c0                	test   %eax,%eax
    c530:	0f 85 30 05 00 00    	jne    ca66 <e1000_setup_link+0xfc6>
			return ret_val;
		}

		if ((eeprom_data != EEPROM_RESERVED_WORD) &&
    c536:	0f b7 45 de          	movzwl -0x22(%rbp),%eax
    c53a:	66 05 00 80          	add    $0x8000,%ax
    c53e:	66 3d fe 7f          	cmp    $0x7ffe,%ax
    c542:	0f 86 6b 06 00 00    	jbe    cbb3 <e1000_setup_link+0x1113>
    c548:	8b 43 18             	mov    0x18(%rbx),%eax
    c54b:	e9 fa f5 ff ff       	jmpq   bb4a <e1000_setup_link+0xaa>
		return ret_val;

	hw->phy_id = (u32) (phy_id_high << 16);
	udelay(20);
	ret_val = e1000_read_phy_reg(hw, PHY_ID2, &phy_id_low);
	if (ret_val)
    c550:	41 89 c4             	mov    %eax,%r12d
    c553:	e9 ae fb ff ff       	jmpq   c106 <e1000_setup_link+0x666>
		 * advertise that we are capable of Rx Pause ONLY, we will
		 * advertise that we support both symmetric and asymmetric Rx
		 * PAUSE. Later, we will disable the adapter's ability to send
		 * PAUSE frames.
		 */
		txcw = (E1000_TXCW_ANE | E1000_TXCW_FD | E1000_TXCW_PAUSE_MASK);
    c558:	41 bc a0 01 00 80    	mov    $0x800001a0,%r12d
	 * link will be in reset, because we previously reset the chip). This
	 * will restart auto-negotiation.  If auto-negotiation is successful
	 * then the link-up status bit will be set and the flow control enable
	 * bits (RFCE and TFCE) will be set according to their negotiated value.
	 */
	e_dbg("Auto-negotiation enabled\n");
    c55e:	f6 05 00 00 00 00 04 	testb  $0x4,0x0(%rip)        # c565 <e1000_setup_link+0xac5>
    c565:	0f 85 6f 0f 00 00    	jne    d4da <e1000_setup_link+0x1a3a>

	ew32(TXCW, txcw);
    c56b:	48 8b 03             	mov    (%rbx),%rax
build_mmio_read(__readw, "w", unsigned short, "=r", )
build_mmio_read(__readl, "l", unsigned int, "=r", )

build_mmio_write(writeb, "b", unsigned char, "q", :"memory")
build_mmio_write(writew, "w", unsigned short, "r", :"memory")
build_mmio_write(writel, "l", unsigned int, "r", :"memory")
    c56e:	44 89 a0 78 01 00 00 	mov    %r12d,0x178(%rax)
	ew32(CTRL, ctrl);
    c575:	48 8b 03             	mov    (%rbx),%rax
	ret_val = e1000_adjust_serdes_amplitude(hw);
	if (ret_val)
		return ret_val;

	/* Take the link out of reset */
	ctrl &= ~(E1000_CTRL_LRST);
    c578:	41 83 e6 f7          	and    $0xfffffff7,%r14d
    c57c:	44 89 30             	mov    %r14d,(%rax)
	 */
	e_dbg("Auto-negotiation enabled\n");

	ew32(TXCW, txcw);
	ew32(CTRL, ctrl);
	E1000_WRITE_FLUSH();
    c57f:	48 8b 03             	mov    (%rbx),%rax
{ asm volatile("mov" size " %0,%1": :reg (val), \
"m" (*(volatile type __force *)addr) barrier); }

build_mmio_read(readb, "b", unsigned char, "=q", :"memory")
build_mmio_read(readw, "w", unsigned short, "=r", :"memory")
build_mmio_read(readl, "l", unsigned int, "=r", :"memory")
    c582:	8b 40 08             	mov    0x8(%rax),%eax

	hw->txcw = txcw;
	msleep(1);
    c585:	bf 01 00 00 00       	mov    $0x1,%edi

	ew32(TXCW, txcw);
	ew32(CTRL, ctrl);
	E1000_WRITE_FLUSH();

	hw->txcw = txcw;
    c58a:	44 89 a3 90 00 00 00 	mov    %r12d,0x90(%rbx)
	msleep(1);
    c591:	e8 00 00 00 00       	callq  c596 <e1000_setup_link+0xaf6>
	 * link isn't seen in 500 milliseconds seconds (Auto-negotiation should
	 * complete in less than 500 milliseconds even if the other end is doing
	 * it in SW). For internal serdes, we just assume a signal is present,
	 * then poll.
	 */
	if (hw->media_type == e1000_media_type_internal_serdes ||
    c596:	83 7b 24 02          	cmpl   $0x2,0x24(%rbx)
    c59a:	0f 84 c5 02 00 00    	je     c865 <e1000_setup_link+0xdc5>
	    (er32(CTRL) & E1000_CTRL_SWDPIN1) == signal) {
    c5a0:	48 8b 03             	mov    (%rbx),%rax
    c5a3:	8b 00                	mov    (%rax),%eax
    c5a5:	25 00 00 08 00       	and    $0x80000,%eax
	 * link isn't seen in 500 milliseconds seconds (Auto-negotiation should
	 * complete in less than 500 milliseconds even if the other end is doing
	 * it in SW). For internal serdes, we just assume a signal is present,
	 * then poll.
	 */
	if (hw->media_type == e1000_media_type_internal_serdes ||
    c5aa:	44 39 e8             	cmp    %r13d,%eax
    c5ad:	0f 84 b2 02 00 00    	je     c865 <e1000_setup_link+0xdc5>
		} else {
			hw->autoneg_failed = 0;
			e_dbg("Valid Link Found\n");
		}
	} else {
		e_dbg("No Signal Detected\n");
    c5b3:	f6 05 00 00 00 00 04 	testb  $0x4,0x0(%rip)        # c5ba <e1000_setup_link+0xb1a>
    c5ba:	0f 85 3f 0f 00 00    	jne    d4ff <e1000_setup_link+0x1a5f>
	}
	return E1000_SUCCESS;
    c5c0:	45 31 e4             	xor    %r12d,%r12d
    c5c3:	e9 9a f8 ff ff       	jmpq   be62 <e1000_setup_link+0x3c2>
		break;
	case E1000_FC_TX_PAUSE:
		/* Tx Flow control is enabled, and Rx Flow control is disabled,
		 * by a software over-ride.
		 */
		txcw = (E1000_TXCW_ANE | E1000_TXCW_FD | E1000_TXCW_ASM_DIR);
    c5c8:	41 bc 20 01 00 80    	mov    $0x80000120,%r12d
    c5ce:	eb 8e                	jmp    c55e <e1000_setup_link+0xabe>
	case e1000_82543:
		if (hw->phy_id == M88E1000_E_PHY_ID)
			match = true;
		break;
	case e1000_82544:
		if (hw->phy_id == M88E1000_I_PHY_ID)
    c5d0:	41 81 fc 30 0c 41 01 	cmp    $0x1410c30,%r12d
    c5d7:	0f 94 c0             	sete   %al
static s32 e1000_set_phy_type(struct e1000_hw *hw)
{
	if (hw->mac_type == e1000_undefined)
		return -E1000_ERR_PHY_TYPE;

	switch (hw->phy_id) {
    c5da:	41 81 fc 30 0c 41 01 	cmp    $0x1410c30,%r12d
    c5e1:	0f 84 24 06 00 00    	je     cc0b <e1000_setup_link+0x116b>
    c5e7:	0f 87 ad 04 00 00    	ja     ca9a <e1000_setup_link+0xffa>
    c5ed:	41 81 fc 10 c9 1c 00 	cmp    $0x1cc910,%r12d
    c5f4:	0f 84 1d 06 00 00    	je     cc17 <e1000_setup_link+0x1177>
    c5fa:	41 81 fc 20 0c 41 01 	cmp    $0x1410c20,%r12d
    c601:	0f 84 04 06 00 00    	je     cc0b <e1000_setup_link+0x116b>
    c607:	41 81 fc 00 82 00 00 	cmp    $0x8200,%r12d
    c60e:	0f 85 67 04 00 00    	jne    ca7b <e1000_setup_link+0xfdb>
		break;
	case RTL8211B_PHY_ID:
		hw->phy_type = e1000_phy_8211;
		break;
	case RTL8201N_PHY_ID:
		hw->phy_type = e1000_phy_8201;
    c614:	c7 43 1c 03 00 00 00 	movl   $0x3,0x1c(%rbx)
		e_dbg("Invalid MAC type %d\n", hw->mac_type);
		return -E1000_ERR_CONFIG;
	}
	phy_init_status = e1000_set_phy_type(hw);

	if ((match) && (phy_init_status == E1000_SUCCESS)) {
    c61b:	84 c0                	test   %al,%al
    c61d:	0f 84 5f 04 00 00    	je     ca82 <e1000_setup_link+0xfe2>
		e_dbg("PHY ID 0x%X detected\n", hw->phy_id);
    c623:	f6 05 00 00 00 00 04 	testb  $0x4,0x0(%rip)        # c62a <e1000_setup_link+0xb8a>
    c62a:	0f 84 01 f5 ff ff    	je     bb31 <e1000_setup_link+0x91>
    c630:	48 89 df             	mov    %rbx,%rdi
    c633:	e8 00 00 00 00       	callq  c638 <e1000_setup_link+0xb98>
    c638:	44 89 e1             	mov    %r12d,%ecx
    c63b:	48 89 c6             	mov    %rax,%rsi
    c63e:	48 c7 c2 00 00 00 00 	mov    $0x0,%rdx
    c645:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
    c64c:	31 c0                	xor    %eax,%eax
    c64e:	e8 00 00 00 00       	callq  c653 <e1000_setup_link+0xbb3>
    c653:	e9 d9 f4 ff ff       	jmpq   bb31 <e1000_setup_link+0x91>
	hw->phy_id |= (u32) (phy_id_low & PHY_REVISION_MASK);
	hw->phy_revision = (u32) phy_id_low & ~PHY_REVISION_MASK;

	switch (hw->mac_type) {
	case e1000_82543:
		if (hw->phy_id == M88E1000_E_PHY_ID)
    c658:	41 81 fc 50 0c 41 01 	cmp    $0x1410c50,%r12d
    c65f:	0f 94 c0             	sete   %al
    c662:	e9 73 ff ff ff       	jmpq   c5da <e1000_setup_link+0xb3a>
	case e1000_82546_rev_3:
		if (hw->phy_id == M88E1011_I_PHY_ID)
			match = true;
		break;
	case e1000_ce4100:
		if ((hw->phy_id == RTL8211B_PHY_ID) ||
    c667:	41 81 fc 00 82 00 00 	cmp    $0x8200,%r12d
    c66e:	0f 84 3e 07 00 00    	je     cdb2 <e1000_setup_link+0x1312>
    c674:	41 81 fc 10 c9 1c 00 	cmp    $0x1cc910,%r12d
    c67b:	0f 84 31 07 00 00    	je     cdb2 <e1000_setup_link+0x1312>
		    (hw->phy_id == RTL8201N_PHY_ID) ||
    c681:	41 81 fc 40 0e 41 01 	cmp    $0x1410e40,%r12d
    c688:	0f 94 c0             	sete   %al
    c68b:	e9 4a ff ff ff       	jmpq   c5da <e1000_setup_link+0xb3a>
	case e1000_82540:
	case e1000_82545:
	case e1000_82545_rev_3:
	case e1000_82546:
	case e1000_82546_rev_3:
		if (hw->phy_id == M88E1011_I_PHY_ID)
    c690:	41 81 fc 20 0c 41 01 	cmp    $0x1410c20,%r12d
    c697:	0f 94 c0             	sete   %al
    c69a:	e9 3b ff ff ff       	jmpq   c5da <e1000_setup_link+0xb3a>
		break;
	case e1000_82541:
	case e1000_82541_rev_2:
	case e1000_82547:
	case e1000_82547_rev_2:
		if (hw->phy_id == IGP01E1000_I_PHY_ID)
    c69f:	41 81 fc 80 03 a8 02 	cmp    $0x2a80380,%r12d
    c6a6:	0f 94 c0             	sete   %al
    c6a9:	e9 2c ff ff ff       	jmpq   c5da <e1000_setup_link+0xb3a>

	if (hw->phy_reset_disable)
		return E1000_SUCCESS;

	/* Enable CRS on TX. This must be set for half-duplex operation. */
	ret_val = e1000_read_phy_reg(hw, M88E1000_PHY_SPEC_CTRL, &phy_data);
    c6ae:	4c 8d 6d de          	lea    -0x22(%rbp),%r13
    c6b2:	be 10 00 00 00       	mov    $0x10,%esi
    c6b7:	48 89 df             	mov    %rbx,%rdi
    c6ba:	4c 89 ea             	mov    %r13,%rdx
    c6bd:	e8 00 00 00 00       	callq  c6c2 <e1000_setup_link+0xc22>
	if (ret_val)
    c6c2:	85 c0                	test   %eax,%eax
    c6c4:	41 89 c4             	mov    %eax,%r12d
    c6c7:	0f 85 95 f7 ff ff    	jne    be62 <e1000_setup_link+0x3c2>
	 *   0 - Auto for all speeds
	 *   1 - MDI mode
	 *   2 - MDI-X mode
	 *   3 - Auto for 1000Base-T only (MDI-X for 10/100Base-T modes)
	 */
	phy_data &= ~M88E1000_PSCR_AUTO_X_MODE;
    c6cd:	0f b7 45 de          	movzwl -0x22(%rbp),%eax

	switch (hw->mdix) {
    c6d1:	0f b6 8b f0 00 00 00 	movzbl 0xf0(%rbx),%ecx
	 *   0 - Auto for all speeds
	 *   1 - MDI mode
	 *   2 - MDI-X mode
	 *   3 - Auto for 1000Base-T only (MDI-X for 10/100Base-T modes)
	 */
	phy_data &= ~M88E1000_PSCR_AUTO_X_MODE;
    c6d8:	83 e0 9f             	and    $0xffffff9f,%eax
    c6db:	89 c6                	mov    %eax,%esi
	switch (hw->mdix) {
	case 1:
		phy_data |= M88E1000_PSCR_MDI_MANUAL_MODE;
		break;
	case 2:
		phy_data |= M88E1000_PSCR_MDIX_MANUAL_MODE;
    c6dd:	89 c2                	mov    %eax,%edx
	 *   0 - Auto for all speeds
	 *   1 - MDI mode
	 *   2 - MDI-X mode
	 *   3 - Auto for 1000Base-T only (MDI-X for 10/100Base-T modes)
	 */
	phy_data &= ~M88E1000_PSCR_AUTO_X_MODE;
    c6df:	66 81 ce 00 08       	or     $0x800,%si
	switch (hw->mdix) {
	case 1:
		phy_data |= M88E1000_PSCR_MDI_MANUAL_MODE;
		break;
	case 2:
		phy_data |= M88E1000_PSCR_MDIX_MANUAL_MODE;
    c6e4:	66 81 ca 20 08       	or     $0x820,%dx
	 *   2 - MDI-X mode
	 *   3 - Auto for 1000Base-T only (MDI-X for 10/100Base-T modes)
	 */
	phy_data &= ~M88E1000_PSCR_AUTO_X_MODE;

	switch (hw->mdix) {
    c6e9:	80 f9 02             	cmp    $0x2,%cl
	 *   0 - Auto for all speeds
	 *   1 - MDI mode
	 *   2 - MDI-X mode
	 *   3 - Auto for 1000Base-T only (MDI-X for 10/100Base-T modes)
	 */
	phy_data &= ~M88E1000_PSCR_AUTO_X_MODE;
    c6ec:	66 89 75 de          	mov    %si,-0x22(%rbp)

	switch (hw->mdix) {
    c6f0:	74 18                	je     c70a <e1000_setup_link+0xc6a>
		break;
	case 2:
		phy_data |= M88E1000_PSCR_MDIX_MANUAL_MODE;
		break;
	case 3:
		phy_data |= M88E1000_PSCR_AUTO_X_1000T;
    c6f2:	89 c2                	mov    %eax,%edx
    c6f4:	66 81 ca 40 08       	or     $0x840,%dx
	 *   2 - MDI-X mode
	 *   3 - Auto for 1000Base-T only (MDI-X for 10/100Base-T modes)
	 */
	phy_data &= ~M88E1000_PSCR_AUTO_X_MODE;

	switch (hw->mdix) {
    c6f9:	80 f9 03             	cmp    $0x3,%cl
    c6fc:	74 0c                	je     c70a <e1000_setup_link+0xc6a>
	case 3:
		phy_data |= M88E1000_PSCR_AUTO_X_1000T;
		break;
	case 0:
	default:
		phy_data |= M88E1000_PSCR_AUTO_X_MODE;
    c6fe:	66 0d 60 08          	or     $0x860,%ax
    c702:	80 f9 01             	cmp    $0x1,%cl
    c705:	0f 45 f0             	cmovne %eax,%esi
    c708:	89 f2                	mov    %esi,%edx
	 *   disable_polarity_correction = 0 (default)
	 *       Automatic Correction for Reversed Cable Polarity
	 *   0 - Disabled
	 *   1 - Enabled
	 */
	phy_data &= ~M88E1000_PSCR_POLARITY_REVERSAL;
    c70a:	83 e2 fd             	and    $0xfffffffd,%edx
	if (hw->disable_polarity_correction == 1)
    c70d:	80 bb 00 01 00 00 00 	cmpb   $0x0,0x100(%rbx)
	 *   disable_polarity_correction = 0 (default)
	 *       Automatic Correction for Reversed Cable Polarity
	 *   0 - Disabled
	 *   1 - Enabled
	 */
	phy_data &= ~M88E1000_PSCR_POLARITY_REVERSAL;
    c714:	66 89 55 de          	mov    %dx,-0x22(%rbp)
	if (hw->disable_polarity_correction == 1)
    c718:	74 07                	je     c721 <e1000_setup_link+0xc81>
		phy_data |= M88E1000_PSCR_POLARITY_REVERSAL;
    c71a:	83 ca 02             	or     $0x2,%edx
    c71d:	66 89 55 de          	mov    %dx,-0x22(%rbp)
	ret_val = e1000_write_phy_reg(hw, M88E1000_PHY_SPEC_CTRL, phy_data);
    c721:	0f b7 d2             	movzwl %dx,%edx
    c724:	be 10 00 00 00       	mov    $0x10,%esi
    c729:	48 89 df             	mov    %rbx,%rdi
    c72c:	e8 00 00 00 00       	callq  c731 <e1000_setup_link+0xc91>
	if (ret_val)
    c731:	85 c0                	test   %eax,%eax
	 *   1 - Enabled
	 */
	phy_data &= ~M88E1000_PSCR_POLARITY_REVERSAL;
	if (hw->disable_polarity_correction == 1)
		phy_data |= M88E1000_PSCR_POLARITY_REVERSAL;
	ret_val = e1000_write_phy_reg(hw, M88E1000_PHY_SPEC_CTRL, phy_data);
    c733:	41 89 c4             	mov    %eax,%r12d
	if (ret_val)
    c736:	0f 85 26 f7 ff ff    	jne    be62 <e1000_setup_link+0x3c2>
		return ret_val;

	if (hw->phy_revision < M88E1011_I_REV_4) {
    c73c:	83 bb 84 00 00 00 03 	cmpl   $0x3,0x84(%rbx)
    c743:	77 65                	ja     c7aa <e1000_setup_link+0xd0a>
		/* Force TX_CLK in the Extended PHY Specific Control Register
		 * to 25MHz clock.
		 */
		ret_val =
    c745:	4c 89 ea             	mov    %r13,%rdx
    c748:	be 14 00 00 00       	mov    $0x14,%esi
    c74d:	48 89 df             	mov    %rbx,%rdi
    c750:	e8 00 00 00 00       	callq  c755 <e1000_setup_link+0xcb5>
		    e1000_read_phy_reg(hw, M88E1000_EXT_PHY_SPEC_CTRL,
				       &phy_data);
		if (ret_val)
    c755:	85 c0                	test   %eax,%eax

	if (hw->phy_revision < M88E1011_I_REV_4) {
		/* Force TX_CLK in the Extended PHY Specific Control Register
		 * to 25MHz clock.
		 */
		ret_val =
    c757:	41 89 c4             	mov    %eax,%r12d
		    e1000_read_phy_reg(hw, M88E1000_EXT_PHY_SPEC_CTRL,
				       &phy_data);
		if (ret_val)
    c75a:	0f 85 02 f7 ff ff    	jne    be62 <e1000_setup_link+0x3c2>
			return ret_val;

		phy_data |= M88E1000_EPSCR_TX_CLK_25;
    c760:	0f b7 45 de          	movzwl -0x22(%rbp),%eax
    c764:	89 c2                	mov    %eax,%edx
    c766:	83 ca 70             	or     $0x70,%edx
    c769:	66 89 55 de          	mov    %dx,-0x22(%rbp)

		if ((hw->phy_revision == E1000_REVISION_2) &&
    c76d:	48 ba c0 0c 41 01 02 	movabs $0x201410cc0,%rdx
    c774:	00 00 00 
    c777:	48 39 93 80 00 00 00 	cmp    %rdx,0x80(%rbx)
    c77e:	0f 84 d5 07 00 00    	je     cf59 <e1000_setup_link+0x14b9>
						      phy_data);
			if (ret_val)
				return ret_val;
		} else {
			/* Configure Master and Slave downshift values */
			phy_data &= ~(M88E1000_EPSCR_MASTER_DOWNSHIFT_MASK |
    c784:	80 e4 f0             	and    $0xf0,%ah
				      M88E1000_EPSCR_SLAVE_DOWNSHIFT_MASK);
			phy_data |= (M88E1000_EPSCR_MASTER_DOWNSHIFT_1X |
    c787:	66 0d 70 01          	or     $0x170,%ax
				     M88E1000_EPSCR_SLAVE_DOWNSHIFT_1X);
			ret_val = e1000_write_phy_reg(hw,
    c78b:	0f b7 d0             	movzwl %ax,%edx
    c78e:	be 14 00 00 00       	mov    $0x14,%esi
    c793:	48 89 df             	mov    %rbx,%rdi
				return ret_val;
		} else {
			/* Configure Master and Slave downshift values */
			phy_data &= ~(M88E1000_EPSCR_MASTER_DOWNSHIFT_MASK |
				      M88E1000_EPSCR_SLAVE_DOWNSHIFT_MASK);
			phy_data |= (M88E1000_EPSCR_MASTER_DOWNSHIFT_1X |
    c796:	66 89 45 de          	mov    %ax,-0x22(%rbp)
				     M88E1000_EPSCR_SLAVE_DOWNSHIFT_1X);
			ret_val = e1000_write_phy_reg(hw,
    c79a:	e8 00 00 00 00       	callq  c79f <e1000_setup_link+0xcff>
						      M88E1000_EXT_PHY_SPEC_CTRL,
						      phy_data);
			if (ret_val)
    c79f:	85 c0                	test   %eax,%eax
			/* Configure Master and Slave downshift values */
			phy_data &= ~(M88E1000_EPSCR_MASTER_DOWNSHIFT_MASK |
				      M88E1000_EPSCR_SLAVE_DOWNSHIFT_MASK);
			phy_data |= (M88E1000_EPSCR_MASTER_DOWNSHIFT_1X |
				     M88E1000_EPSCR_SLAVE_DOWNSHIFT_1X);
			ret_val = e1000_write_phy_reg(hw,
    c7a1:	41 89 c4             	mov    %eax,%r12d
						      M88E1000_EXT_PHY_SPEC_CTRL,
						      phy_data);
			if (ret_val)
    c7a4:	0f 85 b8 f6 ff ff    	jne    be62 <e1000_setup_link+0x3c2>
				return ret_val;
		}
	}

	/* SW Reset the PHY so all changes take effect */
	ret_val = e1000_phy_reset(hw);
    c7aa:	48 89 df             	mov    %rbx,%rdi
    c7ad:	e8 00 00 00 00       	callq  c7b2 <e1000_setup_link+0xd12>
	if (ret_val) {
    c7b2:	85 c0                	test   %eax,%eax
				return ret_val;
		}
	}

	/* SW Reset the PHY so all changes take effect */
	ret_val = e1000_phy_reset(hw);
    c7b4:	41 89 c4             	mov    %eax,%r12d
	if (ret_val) {
    c7b7:	0f 84 d5 f3 ff ff    	je     bb92 <e1000_setup_link+0xf2>
		e_dbg("Error Resetting the PHY\n");
    c7bd:	f6 05 00 00 00 00 04 	testb  $0x4,0x0(%rip)        # c7c4 <e1000_setup_link+0xd24>
    c7c4:	0f 84 98 f6 ff ff    	je     be62 <e1000_setup_link+0x3c2>
    c7ca:	48 89 df             	mov    %rbx,%rdi
    c7cd:	e8 00 00 00 00       	callq  c7d2 <e1000_setup_link+0xd32>
    c7d2:	48 c7 c2 00 00 00 00 	mov    $0x0,%rdx
    c7d9:	48 89 c6             	mov    %rax,%rsi
    c7dc:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
    c7e3:	31 c0                	xor    %eax,%eax
    c7e5:	e8 00 00 00 00       	callq  c7ea <e1000_setup_link+0xd4a>
    c7ea:	e9 73 f6 ff ff       	jmpq   be62 <e1000_setup_link+0x3c2>
	u16 phy_data;

	/* Perform some bounds checking on the hw->autoneg_advertised
	 * parameter.  If this variable is zero, then set it to the default.
	 */
	hw->autoneg_advertised &= AUTONEG_ADVERTISE_SPEED_DEFAULT;
    c7ef:	0f b7 93 d2 00 00 00 	movzwl 0xd2(%rbx),%edx
    c7f6:	b8 2f 00 00 00       	mov    $0x2f,%eax
    c7fb:	66 83 e2 2f          	and    $0x2f,%dx
    c7ff:	0f 45 c2             	cmovne %edx,%eax
	 */
	if (hw->autoneg_advertised == 0)
		hw->autoneg_advertised = AUTONEG_ADVERTISE_SPEED_DEFAULT;

	/* IFE/RTL8201N PHY only supports 10/100 */
	if (hw->phy_type == e1000_phy_8201)
    c802:	83 7b 1c 03          	cmpl   $0x3,0x1c(%rbx)
	u16 phy_data;

	/* Perform some bounds checking on the hw->autoneg_advertised
	 * parameter.  If this variable is zero, then set it to the default.
	 */
	hw->autoneg_advertised &= AUTONEG_ADVERTISE_SPEED_DEFAULT;
    c806:	66 89 83 d2 00 00 00 	mov    %ax,0xd2(%rbx)
	 */
	if (hw->autoneg_advertised == 0)
		hw->autoneg_advertised = AUTONEG_ADVERTISE_SPEED_DEFAULT;

	/* IFE/RTL8201N PHY only supports 10/100 */
	if (hw->phy_type == e1000_phy_8201)
    c80d:	0f 84 22 03 00 00    	je     cb35 <e1000_setup_link+0x1095>
		hw->autoneg_advertised &= AUTONEG_ADVERTISE_10_100_ALL;

	e_dbg("Reconfiguring auto-neg advertisement params\n");
    c813:	f6 05 00 00 00 00 04 	testb  $0x4,0x0(%rip)        # c81a <e1000_setup_link+0xd7a>
    c81a:	0f 85 32 0b 00 00    	jne    d352 <e1000_setup_link+0x18b2>
	ret_val = e1000_phy_setup_autoneg(hw);
    c820:	48 89 df             	mov    %rbx,%rdi
    c823:	e8 00 00 00 00       	callq  c828 <e1000_setup_link+0xd88>
	if (ret_val) {
    c828:	85 c0                	test   %eax,%eax
	/* IFE/RTL8201N PHY only supports 10/100 */
	if (hw->phy_type == e1000_phy_8201)
		hw->autoneg_advertised &= AUTONEG_ADVERTISE_10_100_ALL;

	e_dbg("Reconfiguring auto-neg advertisement params\n");
	ret_val = e1000_phy_setup_autoneg(hw);
    c82a:	41 89 c4             	mov    %eax,%r12d
	if (ret_val) {
    c82d:	0f 84 7f 01 00 00    	je     c9b2 <e1000_setup_link+0xf12>
		e_dbg("Error Setting up Auto-Negotiation\n");
    c833:	f6 05 00 00 00 00 04 	testb  $0x4,0x0(%rip)        # c83a <e1000_setup_link+0xd9a>
    c83a:	0f 84 22 f6 ff ff    	je     be62 <e1000_setup_link+0x3c2>
    c840:	48 89 df             	mov    %rbx,%rdi
    c843:	e8 00 00 00 00       	callq  c848 <e1000_setup_link+0xda8>
    c848:	48 c7 c2 00 00 00 00 	mov    $0x0,%rdx
    c84f:	48 89 c6             	mov    %rax,%rsi
    c852:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
    c859:	31 c0                	xor    %eax,%eax
    c85b:	e8 00 00 00 00       	callq  c860 <e1000_setup_link+0xdc0>
    c860:	e9 fd f5 ff ff       	jmpq   be62 <e1000_setup_link+0x3c2>
	 * it in SW). For internal serdes, we just assume a signal is present,
	 * then poll.
	 */
	if (hw->media_type == e1000_media_type_internal_serdes ||
	    (er32(CTRL) & E1000_CTRL_SWDPIN1) == signal) {
		e_dbg("Looking for Link\n");
    c865:	f6 05 00 00 00 00 04 	testb  $0x4,0x0(%rip)        # c86c <e1000_setup_link+0xdcc>
    c86c:	0f 85 f9 0b 00 00    	jne    d46b <e1000_setup_link+0x19cb>
		break;
	case E1000_FC_TX_PAUSE:
		/* Tx Flow control is enabled, and Rx Flow control is disabled,
		 * by a software over-ride.
		 */
		txcw = (E1000_TXCW_ANE | E1000_TXCW_FD | E1000_TXCW_ASM_DIR);
    c872:	41 bc 32 00 00 00    	mov    $0x32,%r12d
    c878:	eb 0a                	jmp    c884 <e1000_setup_link+0xde4>
	 * then poll.
	 */
	if (hw->media_type == e1000_media_type_internal_serdes ||
	    (er32(CTRL) & E1000_CTRL_SWDPIN1) == signal) {
		e_dbg("Looking for Link\n");
		for (i = 0; i < (LINK_UP_TIMEOUT / 10); i++) {
    c87a:	41 83 ec 01          	sub    $0x1,%r12d
    c87e:	0f 84 55 02 00 00    	je     cad9 <e1000_setup_link+0x1039>
			msleep(10);
    c884:	bf 0a 00 00 00       	mov    $0xa,%edi
    c889:	e8 00 00 00 00       	callq  c88e <e1000_setup_link+0xdee>
			status = er32(STATUS);
    c88e:	48 8b 03             	mov    (%rbx),%rax
    c891:	8b 40 08             	mov    0x8(%rax),%eax
			if (status & E1000_STATUS_LU)
    c894:	a8 02                	test   $0x2,%al
    c896:	74 e2                	je     c87a <e1000_setup_link+0xdda>
				return ret_val;
			}
			hw->autoneg_failed = 0;
		} else {
			hw->autoneg_failed = 0;
			e_dbg("Valid Link Found\n");
    c898:	f6 05 00 00 00 00 04 	testb  $0x4,0x0(%rip)        # c89f <e1000_setup_link+0xdff>
				e_dbg("Error while checking for link\n");
				return ret_val;
			}
			hw->autoneg_failed = 0;
		} else {
			hw->autoneg_failed = 0;
    c89f:	c7 83 94 00 00 00 00 	movl   $0x0,0x94(%rbx)
    c8a6:	00 00 00 
			e_dbg("Valid Link Found\n");
    c8a9:	0f 84 11 fd ff ff    	je     c5c0 <e1000_setup_link+0xb20>
    c8af:	48 89 df             	mov    %rbx,%rdi
		}
	} else {
		e_dbg("No Signal Detected\n");
	}
	return E1000_SUCCESS;
    c8b2:	45 31 e4             	xor    %r12d,%r12d
				return ret_val;
			}
			hw->autoneg_failed = 0;
		} else {
			hw->autoneg_failed = 0;
			e_dbg("Valid Link Found\n");
    c8b5:	e8 00 00 00 00       	callq  c8ba <e1000_setup_link+0xe1a>
    c8ba:	48 c7 c2 00 00 00 00 	mov    $0x0,%rdx
    c8c1:	48 89 c6             	mov    %rax,%rsi
    c8c4:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
    c8cb:	31 c0                	xor    %eax,%eax
    c8cd:	e8 00 00 00 00       	callq  c8d2 <e1000_setup_link+0xe32>
    c8d2:	e9 8b f5 ff ff       	jmpq   be62 <e1000_setup_link+0x3c2>
	s32 ret_val;
	u32 ctrl_aux;

	switch (hw->phy_type) {
	case e1000_phy_8211:
		ret_val = e1000_copper_link_rtl_setup(hw);
    c8d7:	48 89 df             	mov    %rbx,%rdi
    c8da:	e8 e1 eb ff ff       	callq  b4c0 <e1000_copper_link_rtl_setup>
		if (ret_val) {
    c8df:	85 c0                	test   %eax,%eax
	s32 ret_val;
	u32 ctrl_aux;

	switch (hw->phy_type) {
	case e1000_phy_8211:
		ret_val = e1000_copper_link_rtl_setup(hw);
    c8e1:	41 89 c4             	mov    %eax,%r12d
		if (ret_val) {
    c8e4:	0f 84 a8 f2 ff ff    	je     bb92 <e1000_setup_link+0xf2>
			e_dbg("e1000_copper_link_rtl_setup failed!\n");
    c8ea:	f6 05 00 00 00 00 04 	testb  $0x4,0x0(%rip)        # c8f1 <e1000_setup_link+0xe51>
    c8f1:	0f 84 29 f9 ff ff    	je     c220 <e1000_setup_link+0x780>
    c8f7:	48 89 df             	mov    %rbx,%rdi
    c8fa:	e8 00 00 00 00       	callq  c8ff <e1000_setup_link+0xe5f>
    c8ff:	48 c7 c2 00 00 00 00 	mov    $0x0,%rdx
    c906:	48 89 c6             	mov    %rax,%rsi
    c909:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
    c910:	31 c0                	xor    %eax,%eax
    c912:	e8 00 00 00 00       	callq  c917 <e1000_setup_link+0xe77>
    c917:	e9 04 f9 ff ff       	jmpq   c220 <e1000_setup_link+0x780>
{
	u32 led_ctrl;
	s32 ret_val;
	u16 phy_data;

	if (hw->phy_reset_disable)
    c91c:	80 bb 11 01 00 00 00 	cmpb   $0x0,0x111(%rbx)
    c923:	0f 85 69 f2 ff ff    	jne    bb92 <e1000_setup_link+0xf2>
		return E1000_SUCCESS;

	ret_val = e1000_phy_reset(hw);
    c929:	48 89 df             	mov    %rbx,%rdi
    c92c:	e8 00 00 00 00       	callq  c931 <e1000_setup_link+0xe91>
	if (ret_val) {
    c931:	85 c0                	test   %eax,%eax
	u16 phy_data;

	if (hw->phy_reset_disable)
		return E1000_SUCCESS;

	ret_val = e1000_phy_reset(hw);
    c933:	41 89 c4             	mov    %eax,%r12d
	if (ret_val) {
    c936:	0f 84 32 03 00 00    	je     cc6e <e1000_setup_link+0x11ce>
		e_dbg("Error Resetting the PHY\n");
    c93c:	f6 05 00 00 00 00 04 	testb  $0x4,0x0(%rip)        # c943 <e1000_setup_link+0xea3>
    c943:	0f 84 19 f5 ff ff    	je     be62 <e1000_setup_link+0x3c2>
    c949:	48 89 df             	mov    %rbx,%rdi
    c94c:	e8 00 00 00 00       	callq  c951 <e1000_setup_link+0xeb1>
    c951:	48 c7 c2 00 00 00 00 	mov    $0x0,%rdx
    c958:	48 89 c6             	mov    %rax,%rsi
    c95b:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
    c962:	31 c0                	xor    %eax,%eax
    c964:	e8 00 00 00 00       	callq  c969 <e1000_setup_link+0xec9>
    c969:	e9 f4 f4 ff ff       	jmpq   be62 <e1000_setup_link+0x3c2>
		/* Disable MDI-X support for 10/100 */
	} else {
		/* Clear Auto-Crossover to force MDI manually.  IGP requires MDI
		 * forced whenever speed or duplex are forced.
		 */
		ret_val =
    c96e:	be 12 00 00 00       	mov    $0x12,%esi
    c973:	48 89 df             	mov    %rbx,%rdi
    c976:	e8 00 00 00 00       	callq  c97b <e1000_setup_link+0xedb>
		    e1000_read_phy_reg(hw, IGP01E1000_PHY_PORT_CTRL, &phy_data);
		if (ret_val)
    c97b:	85 c0                	test   %eax,%eax
		/* Disable MDI-X support for 10/100 */
	} else {
		/* Clear Auto-Crossover to force MDI manually.  IGP requires MDI
		 * forced whenever speed or duplex are forced.
		 */
		ret_val =
    c97d:	41 89 c4             	mov    %eax,%r12d
		    e1000_read_phy_reg(hw, IGP01E1000_PHY_PORT_CTRL, &phy_data);
		if (ret_val)
    c980:	0f 85 7e fa ff ff    	jne    c404 <e1000_setup_link+0x964>
			return ret_val;

		phy_data &= ~IGP01E1000_PSCR_AUTO_MDIX;
		phy_data &= ~IGP01E1000_PSCR_FORCE_MDI_MDIX;
    c986:	0f b7 45 de          	movzwl -0x22(%rbp),%eax

		ret_val =
    c98a:	be 12 00 00 00       	mov    $0x12,%esi
    c98f:	48 89 df             	mov    %rbx,%rdi
		    e1000_read_phy_reg(hw, IGP01E1000_PHY_PORT_CTRL, &phy_data);
		if (ret_val)
			return ret_val;

		phy_data &= ~IGP01E1000_PSCR_AUTO_MDIX;
		phy_data &= ~IGP01E1000_PSCR_FORCE_MDI_MDIX;
    c992:	80 e4 cf             	and    $0xcf,%ah

		ret_val =
		    e1000_write_phy_reg(hw, IGP01E1000_PHY_PORT_CTRL, phy_data);
    c995:	0f b7 d0             	movzwl %ax,%edx
		    e1000_read_phy_reg(hw, IGP01E1000_PHY_PORT_CTRL, &phy_data);
		if (ret_val)
			return ret_val;

		phy_data &= ~IGP01E1000_PSCR_AUTO_MDIX;
		phy_data &= ~IGP01E1000_PSCR_FORCE_MDI_MDIX;
    c998:	66 89 45 de          	mov    %ax,-0x22(%rbp)

		ret_val =
    c99c:	e8 00 00 00 00       	callq  c9a1 <e1000_setup_link+0xf01>
		    e1000_write_phy_reg(hw, IGP01E1000_PHY_PORT_CTRL, phy_data);
		if (ret_val)
    c9a1:	85 c0                	test   %eax,%eax
    c9a3:	0f 85 58 fa ff ff    	jne    c401 <e1000_setup_link+0x961>
    c9a9:	0f b7 45 da          	movzwl -0x26(%rbp),%eax
    c9ad:	e9 38 f3 ff ff       	jmpq   bcea <e1000_setup_link+0x24a>
	ret_val = e1000_phy_setup_autoneg(hw);
	if (ret_val) {
		e_dbg("Error Setting up Auto-Negotiation\n");
		return ret_val;
	}
	e_dbg("Restarting Auto-Neg\n");
    c9b2:	f6 05 00 00 00 00 04 	testb  $0x4,0x0(%rip)        # c9b9 <e1000_setup_link+0xf19>
    c9b9:	0f 85 8a 0b 00 00    	jne    d549 <e1000_setup_link+0x1aa9>

	/* Restart auto-negotiation by setting the Auto Neg Enable bit and
	 * the Auto Neg Restart bit in the PHY control register.
	 */
	ret_val = e1000_read_phy_reg(hw, PHY_CTRL, &phy_data);
    c9bf:	48 8d 55 dc          	lea    -0x24(%rbp),%rdx
    c9c3:	31 f6                	xor    %esi,%esi
    c9c5:	48 89 df             	mov    %rbx,%rdi
    c9c8:	e8 00 00 00 00       	callq  c9cd <e1000_setup_link+0xf2d>
	if (ret_val)
    c9cd:	85 c0                	test   %eax,%eax
    c9cf:	41 89 c4             	mov    %eax,%r12d
    c9d2:	0f 85 8a f4 ff ff    	jne    be62 <e1000_setup_link+0x3c2>
		return ret_val;

	phy_data |= (MII_CR_AUTO_NEG_EN | MII_CR_RESTART_AUTO_NEG);
    c9d8:	0f b7 45 dc          	movzwl -0x24(%rbp),%eax
	ret_val = e1000_write_phy_reg(hw, PHY_CTRL, phy_data);
    c9dc:	31 f6                	xor    %esi,%esi
    c9de:	48 89 df             	mov    %rbx,%rdi
	 */
	ret_val = e1000_read_phy_reg(hw, PHY_CTRL, &phy_data);
	if (ret_val)
		return ret_val;

	phy_data |= (MII_CR_AUTO_NEG_EN | MII_CR_RESTART_AUTO_NEG);
    c9e1:	80 cc 12             	or     $0x12,%ah
	ret_val = e1000_write_phy_reg(hw, PHY_CTRL, phy_data);
    c9e4:	0f b7 d0             	movzwl %ax,%edx
	 */
	ret_val = e1000_read_phy_reg(hw, PHY_CTRL, &phy_data);
	if (ret_val)
		return ret_val;

	phy_data |= (MII_CR_AUTO_NEG_EN | MII_CR_RESTART_AUTO_NEG);
    c9e7:	66 89 45 dc          	mov    %ax,-0x24(%rbp)
	ret_val = e1000_write_phy_reg(hw, PHY_CTRL, phy_data);
    c9eb:	e8 00 00 00 00       	callq  c9f0 <e1000_setup_link+0xf50>
	if (ret_val)
    c9f0:	85 c0                	test   %eax,%eax
    c9f2:	41 89 c4             	mov    %eax,%r12d
    c9f5:	0f 85 67 f4 ff ff    	jne    be62 <e1000_setup_link+0x3c2>
		return ret_val;

	/* Does the user want to wait for Auto-Neg to complete here, or
	 * check at a later time (for example, callback routine).
	 */
	if (hw->wait_autoneg_complete) {
    c9fb:	80 bb f2 00 00 00 00 	cmpb   $0x0,0xf2(%rbx)
    ca02:	4c 8d 6d de          	lea    -0x22(%rbp),%r13
    ca06:	0f 85 b8 04 00 00    	jne    cec4 <e1000_setup_link+0x1424>
			    ("Error while waiting for autoneg to complete\n");
			return ret_val;
		}
	}

	hw->get_link_status = true;
    ca0c:	c6 83 0c 01 00 00 01 	movb   $0x1,0x10c(%rbx)
    ca13:	e9 d2 f3 ff ff       	jmpq   bdea <e1000_setup_link+0x34a>
	 *  3:  Both Rx and TX flow control (symmetric) are enabled.
	 */
	switch (hw->fc) {
	case E1000_FC_NONE:
		/* Flow ctrl is completely disabled by a software over-ride */
		txcw = (E1000_TXCW_ANE | E1000_TXCW_FD);
    ca18:	41 bc 20 00 00 80    	mov    $0x80000020,%r12d
    ca1e:	e9 3b fb ff ff       	jmpq   c55e <e1000_setup_link+0xabe>
	if (hw->forced_speed_duplex == e1000_100_full ||
	    hw->forced_speed_duplex == e1000_100_half) {
		/* Set the 100Mb bit and turn off the 1000Mb and 10Mb bits. */
		ctrl |= E1000_CTRL_SPD_100;
		mii_ctrl_reg |= MII_CR_SPEED_100;
		mii_ctrl_reg &= ~(MII_CR_SPEED_1000 | MII_CR_SPEED_10);
    ca23:	83 e1 bf             	and    $0xffffffbf,%ecx

	/* Are we forcing 100Mbps??? */
	if (hw->forced_speed_duplex == e1000_100_full ||
	    hw->forced_speed_duplex == e1000_100_half) {
		/* Set the 100Mb bit and turn off the 1000Mb and 10Mb bits. */
		ctrl |= E1000_CTRL_SPD_100;
    ca26:	41 81 cc 00 01 00 00 	or     $0x100,%r12d
		mii_ctrl_reg |= MII_CR_SPEED_100;
		mii_ctrl_reg &= ~(MII_CR_SPEED_1000 | MII_CR_SPEED_10);
    ca2d:	80 cd 20             	or     $0x20,%ch
		e_dbg("Forcing 100mb ");
    ca30:	f6 05 00 00 00 00 04 	testb  $0x4,0x0(%rip)        # ca37 <e1000_setup_link+0xf97>
	if (hw->forced_speed_duplex == e1000_100_full ||
	    hw->forced_speed_duplex == e1000_100_half) {
		/* Set the 100Mb bit and turn off the 1000Mb and 10Mb bits. */
		ctrl |= E1000_CTRL_SPD_100;
		mii_ctrl_reg |= MII_CR_SPEED_100;
		mii_ctrl_reg &= ~(MII_CR_SPEED_1000 | MII_CR_SPEED_10);
    ca37:	66 89 4d da          	mov    %cx,-0x26(%rbp)
		e_dbg("Forcing 100mb ");
    ca3b:	0f 84 0a f2 ff ff    	je     bc4b <e1000_setup_link+0x1ab>
    ca41:	48 89 df             	mov    %rbx,%rdi
    ca44:	e8 00 00 00 00       	callq  ca49 <e1000_setup_link+0xfa9>
    ca49:	48 c7 c2 00 00 00 00 	mov    $0x0,%rdx
    ca50:	48 89 c6             	mov    %rax,%rsi
    ca53:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
    ca5a:	31 c0                	xor    %eax,%eax
    ca5c:	e8 00 00 00 00       	callq  ca61 <e1000_setup_link+0xfc1>
    ca61:	e9 e5 f1 ff ff       	jmpq   bc4b <e1000_setup_link+0x1ab>
    ca66:	41 89 c4             	mov    %eax,%r12d
    ca69:	e9 f4 f3 ff ff       	jmpq   be62 <e1000_setup_link+0x3c2>
static s32 e1000_set_phy_type(struct e1000_hw *hw)
{
	if (hw->mac_type == e1000_undefined)
		return -E1000_ERR_PHY_TYPE;

	switch (hw->phy_id) {
    ca6e:	41 81 fc 50 0c 41 01 	cmp    $0x1410c50,%r12d
    ca75:	0f 84 90 01 00 00    	je     cc0b <e1000_setup_link+0x116b>
	case RTL8201N_PHY_ID:
		hw->phy_type = e1000_phy_8201;
		break;
	default:
		/* Should never have loaded on this device */
		hw->phy_type = e1000_phy_undefined;
    ca7b:	c7 43 1c ff 00 00 00 	movl   $0xff,0x1c(%rbx)

	if ((match) && (phy_init_status == E1000_SUCCESS)) {
		e_dbg("PHY ID 0x%X detected\n", hw->phy_id);
		return E1000_SUCCESS;
	}
	e_dbg("Invalid PHY ID 0x%X\n", hw->phy_id);
    ca82:	f6 05 00 00 00 00 04 	testb  $0x4,0x0(%rip)        # ca89 <e1000_setup_link+0xfe9>
    ca89:	0f 85 ae 09 00 00    	jne    d43d <e1000_setup_link+0x199d>
	return -E1000_ERR_PHY;
    ca8f:	41 bc fe ff ff ff    	mov    $0xfffffffe,%r12d
    ca95:	e9 6c f6 ff ff       	jmpq   c106 <e1000_setup_link+0x666>
static s32 e1000_set_phy_type(struct e1000_hw *hw)
{
	if (hw->mac_type == e1000_undefined)
		return -E1000_ERR_PHY_TYPE;

	switch (hw->phy_id) {
    ca9a:	41 81 fc c0 0c 41 01 	cmp    $0x1410cc0,%r12d
    caa1:	0f 84 64 01 00 00    	je     cc0b <e1000_setup_link+0x116b>
    caa7:	76 c5                	jbe    ca6e <e1000_setup_link+0xfce>
    caa9:	41 81 fc 40 0e 41 01 	cmp    $0x1410e40,%r12d
    cab0:	0f 84 55 01 00 00    	je     cc0b <e1000_setup_link+0x116b>
    cab6:	41 81 fc 80 03 a8 02 	cmp    $0x2a80380,%r12d
    cabd:	75 bc                	jne    ca7b <e1000_setup_link+0xfdb>
		hw->phy_type = e1000_phy_m88;
		break;
	case IGP01E1000_I_PHY_ID:
		if (hw->mac_type == e1000_82541 ||
		    hw->mac_type == e1000_82541_rev_2 ||
		    hw->mac_type == e1000_82547 ||
    cabf:	41 83 ed 0b          	sub    $0xb,%r13d
	case M88E1111_I_PHY_ID:
	case M88E1118_E_PHY_ID:
		hw->phy_type = e1000_phy_m88;
		break;
	case IGP01E1000_I_PHY_ID:
		if (hw->mac_type == e1000_82541 ||
    cac3:	41 83 fd 03          	cmp    $0x3,%r13d
    cac7:	0f 87 4e fb ff ff    	ja     c61b <e1000_setup_link+0xb7b>
		    hw->mac_type == e1000_82541_rev_2 ||
		    hw->mac_type == e1000_82547 ||
		    hw->mac_type == e1000_82547_rev_2)
			hw->phy_type = e1000_phy_igp;
    cacd:	c7 43 1c 01 00 00 00 	movl   $0x1,0x1c(%rbx)
    cad4:	e9 42 fb ff ff       	jmpq   c61b <e1000_setup_link+0xb7b>
			status = er32(STATUS);
			if (status & E1000_STATUS_LU)
				break;
		}
		if (i == (LINK_UP_TIMEOUT / 10)) {
			e_dbg("Never got a valid link from auto-neg!!!\n");
    cad9:	f6 05 00 00 00 00 04 	testb  $0x4,0x0(%rip)        # cae0 <e1000_setup_link+0x1040>
    cae0:	0f 85 0a 09 00 00    	jne    d3f0 <e1000_setup_link+0x1950>
			hw->autoneg_failed = 1;
    cae6:	c7 83 94 00 00 00 01 	movl   $0x1,0x94(%rbx)
    caed:	00 00 00 
			/* AutoNeg failed to achieve a link, so we'll call
			 * e1000_check_for_link. This routine will force the
			 * link up if we detect a signal. This will allow us to
			 * communicate with non-autonegotiating link partners.
			 */
			ret_val = e1000_check_for_link(hw);
    caf0:	48 89 df             	mov    %rbx,%rdi
    caf3:	e8 00 00 00 00       	callq  caf8 <e1000_setup_link+0x1058>
			if (ret_val) {
    caf8:	85 c0                	test   %eax,%eax
			/* AutoNeg failed to achieve a link, so we'll call
			 * e1000_check_for_link. This routine will force the
			 * link up if we detect a signal. This will allow us to
			 * communicate with non-autonegotiating link partners.
			 */
			ret_val = e1000_check_for_link(hw);
    cafa:	41 89 c4             	mov    %eax,%r12d
			if (ret_val) {
    cafd:	0f 84 5c 01 00 00    	je     cc5f <e1000_setup_link+0x11bf>
				e_dbg("Error while checking for link\n");
    cb03:	f6 05 00 00 00 00 04 	testb  $0x4,0x0(%rip)        # cb0a <e1000_setup_link+0x106a>
    cb0a:	0f 84 52 f3 ff ff    	je     be62 <e1000_setup_link+0x3c2>
    cb10:	48 89 df             	mov    %rbx,%rdi
    cb13:	e8 00 00 00 00       	callq  cb18 <e1000_setup_link+0x1078>
    cb18:	48 c7 c2 00 00 00 00 	mov    $0x0,%rdx
    cb1f:	48 89 c6             	mov    %rax,%rsi
    cb22:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
    cb29:	31 c0                	xor    %eax,%eax
    cb2b:	e8 00 00 00 00       	callq  cb30 <e1000_setup_link+0x1090>
    cb30:	e9 2d f3 ff ff       	jmpq   be62 <e1000_setup_link+0x3c2>
	if (hw->autoneg_advertised == 0)
		hw->autoneg_advertised = AUTONEG_ADVERTISE_SPEED_DEFAULT;

	/* IFE/RTL8201N PHY only supports 10/100 */
	if (hw->phy_type == e1000_phy_8201)
		hw->autoneg_advertised &= AUTONEG_ADVERTISE_10_100_ALL;
    cb35:	66 83 a3 d2 00 00 00 	andw   $0xf,0xd2(%rbx)
    cb3c:	0f 
    cb3d:	e9 d1 fc ff ff       	jmpq   c813 <e1000_setup_link+0xd73>
 */
static s32 e1000_copper_link_postconfig(struct e1000_hw *hw)
{
	s32 ret_val;

	if ((hw->mac_type >= e1000_82544) && (hw->mac_type != e1000_ce4100)) {
    cb42:	8b 43 18             	mov    0x18(%rbx),%eax
    cb45:	83 f8 09             	cmp    $0x9,%eax
    cb48:	0f 84 6e 02 00 00    	je     cdbc <e1000_setup_link+0x131c>
    cb4e:	83 f8 03             	cmp    $0x3,%eax
    cb51:	0f 86 65 02 00 00    	jbe    cdbc <e1000_setup_link+0x131c>
	if (hw->mac_type < e1000_82543)
		coll_dist = E1000_COLLISION_DISTANCE_82542;
	else
		coll_dist = E1000_COLLISION_DISTANCE;

	tctl = er32(TCTL);
    cb57:	48 8b 03             	mov    (%rbx),%rax
    cb5a:	8b 80 00 04 00 00    	mov    0x400(%rax),%eax

	tctl &= ~E1000_TCTL_COLD;
    cb60:	25 ff 0f c0 ff       	and    $0xffc00fff,%eax
	tctl |= coll_dist << E1000_COLD_SHIFT;

	ew32(TCTL, tctl);
    cb65:	48 8b 13             	mov    (%rbx),%rdx
		coll_dist = E1000_COLLISION_DISTANCE;

	tctl = er32(TCTL);

	tctl &= ~E1000_TCTL_COLD;
	tctl |= coll_dist << E1000_COLD_SHIFT;
    cb68:	0d 00 f0 03 00       	or     $0x3f000,%eax
build_mmio_read(__readw, "w", unsigned short, "=r", )
build_mmio_read(__readl, "l", unsigned int, "=r", )

build_mmio_write(writeb, "b", unsigned char, "q", :"memory")
build_mmio_write(writew, "w", unsigned short, "r", :"memory")
build_mmio_write(writel, "l", unsigned int, "r", :"memory")
    cb6d:	89 82 00 04 00 00    	mov    %eax,0x400(%rdx)

	ew32(TCTL, tctl);
	E1000_WRITE_FLUSH();
    cb73:	48 8b 03             	mov    (%rbx),%rax
{ asm volatile("mov" size " %0,%1": :reg (val), \
"m" (*(volatile type __force *)addr) barrier); }

build_mmio_read(readb, "b", unsigned char, "=q", :"memory")
build_mmio_read(readw, "w", unsigned short, "=r", :"memory")
build_mmio_read(readl, "l", unsigned int, "=r", :"memory")
    cb76:	8b 40 08             	mov    0x8(%rax),%eax
		if (ret_val) {
			e_dbg("Error configuring MAC to PHY settings\n");
			return ret_val;
		}
	}
	ret_val = e1000_config_fc_after_link_up(hw);
    cb79:	48 89 df             	mov    %rbx,%rdi
    cb7c:	e8 bf d0 ff ff       	callq  9c40 <e1000_config_fc_after_link_up>
	if (ret_val) {
    cb81:	85 c0                	test   %eax,%eax
		if (ret_val) {
			e_dbg("Error configuring MAC to PHY settings\n");
			return ret_val;
		}
	}
	ret_val = e1000_config_fc_after_link_up(hw);
    cb83:	41 89 c5             	mov    %eax,%r13d
	if (ret_val) {
    cb86:	0f 84 97 00 00 00    	je     cc23 <e1000_setup_link+0x1183>
		e_dbg("Error Configuring Flow Control\n");
    cb8c:	f6 05 00 00 00 00 04 	testb  $0x4,0x0(%rip)        # cb93 <e1000_setup_link+0x10f3>
    cb93:	0f 85 7c 08 00 00    	jne    d415 <e1000_setup_link+0x1975>
    cb99:	45 89 ec             	mov    %r13d,%r12d
    cb9c:	e9 c1 f2 ff ff       	jmpq   be62 <e1000_setup_link+0x3c2>
		}
		if ((eeprom_data & EEPROM_WORD0F_PAUSE_MASK) == 0)
			hw->fc = E1000_FC_NONE;
		else if ((eeprom_data & EEPROM_WORD0F_PAUSE_MASK) ==
			 EEPROM_WORD0F_ASM_DIR)
			hw->fc = E1000_FC_TX_PAUSE;
    cba1:	c7 43 40 02 00 00 00 	movl   $0x2,0x40(%rbx)
    cba8:	41 bc 02 00 00 00    	mov    $0x2,%r12d
    cbae:	e9 15 ef ff ff       	jmpq   bac8 <e1000_setup_link+0x28>
			return ret_val;
		}

		if ((eeprom_data != EEPROM_RESERVED_WORD) &&
		    (eeprom_data & EEPROM_PHY_CLASS_A)) {
			ret_val =
    cbb3:	ba 0b 00 00 00       	mov    $0xb,%edx
    cbb8:	be 1d 00 00 00       	mov    $0x1d,%esi
    cbbd:	48 89 df             	mov    %rbx,%rdi
    cbc0:	e8 00 00 00 00       	callq  cbc5 <e1000_setup_link+0x1125>
			    e1000_write_phy_reg(hw, M88E1000_PHY_PAGE_SELECT,
						0x000B);
			if (ret_val)
    cbc5:	85 c0                	test   %eax,%eax
    cbc7:	0f 85 99 fe ff ff    	jne    ca66 <e1000_setup_link+0xfc6>
				return ret_val;
			ret_val =
    cbcd:	ba 04 81 00 00       	mov    $0x8104,%edx
    cbd2:	be 1e 00 00 00       	mov    $0x1e,%esi
    cbd7:	48 89 df             	mov    %rbx,%rdi
    cbda:	e8 00 00 00 00       	callq  cbdf <e1000_setup_link+0x113f>
			    e1000_write_phy_reg(hw, M88E1000_PHY_GEN_CONTROL,
						0x8104);
			if (ret_val)
    cbdf:	85 c0                	test   %eax,%eax
    cbe1:	0f 85 7f fe ff ff    	jne    ca66 <e1000_setup_link+0xfc6>
				return ret_val;

			hw->phy_reset_disable = false;
    cbe7:	c6 83 11 01 00 00 00 	movb   $0x0,0x111(%rbx)
    cbee:	e9 55 f9 ff ff       	jmpq   c548 <e1000_setup_link+0xaa8>
	case e1000_82547_rev_2:
		if (hw->phy_id == IGP01E1000_I_PHY_ID)
			match = true;
		break;
	default:
		e_dbg("Invalid MAC type %d\n", hw->mac_type);
    cbf3:	f6 05 00 00 00 00 04 	testb  $0x4,0x0(%rip)        # cbfa <e1000_setup_link+0x115a>
    cbfa:	0f 85 6e 09 00 00    	jne    d56e <e1000_setup_link+0x1ace>
		return -E1000_ERR_CONFIG;
    cc00:	41 bc fd ff ff ff    	mov    $0xfffffffd,%r12d
    cc06:	e9 fb f4 ff ff       	jmpq   c106 <e1000_setup_link+0x666>
	case M88E1000_E_PHY_ID:
	case M88E1000_I_PHY_ID:
	case M88E1011_I_PHY_ID:
	case M88E1111_I_PHY_ID:
	case M88E1118_E_PHY_ID:
		hw->phy_type = e1000_phy_m88;
    cc0b:	c7 43 1c 00 00 00 00 	movl   $0x0,0x1c(%rbx)
    cc12:	e9 04 fa ff ff       	jmpq   c61b <e1000_setup_link+0xb7b>
		    hw->mac_type == e1000_82547 ||
		    hw->mac_type == e1000_82547_rev_2)
			hw->phy_type = e1000_phy_igp;
		break;
	case RTL8211B_PHY_ID:
		hw->phy_type = e1000_phy_8211;
    cc17:	c7 43 1c 02 00 00 00 	movl   $0x2,0x1c(%rbx)
    cc1e:	e9 f8 f9 ff ff       	jmpq   c61b <e1000_setup_link+0xb7b>
		e_dbg("Error Configuring Flow Control\n");
		return ret_val;
	}

	/* Config DSP to improve Giga link quality */
	if (hw->phy_type == e1000_phy_igp) {
    cc23:	83 7b 1c 01          	cmpl   $0x1,0x1c(%rbx)
    cc27:	0f 84 74 03 00 00    	je     cfa1 <e1000_setup_link+0x1501>
			/* Config the MAC and PHY after link is up */
			ret_val = e1000_copper_link_postconfig(hw);
			if (ret_val)
				return ret_val;

			e_dbg("Valid link established!!!\n");
    cc2d:	f6 05 00 00 00 00 04 	testb  $0x4,0x0(%rip)        # cc34 <e1000_setup_link+0x1194>
    cc34:	0f 84 28 f2 ff ff    	je     be62 <e1000_setup_link+0x3c2>
    cc3a:	48 89 df             	mov    %rbx,%rdi
    cc3d:	e8 00 00 00 00       	callq  cc42 <e1000_setup_link+0x11a2>
    cc42:	48 c7 c2 00 00 00 00 	mov    $0x0,%rdx
    cc49:	48 89 c6             	mov    %rax,%rsi
    cc4c:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
    cc53:	31 c0                	xor    %eax,%eax
    cc55:	e8 00 00 00 00       	callq  cc5a <e1000_setup_link+0x11ba>
    cc5a:	e9 03 f2 ff ff       	jmpq   be62 <e1000_setup_link+0x3c2>
			ret_val = e1000_check_for_link(hw);
			if (ret_val) {
				e_dbg("Error while checking for link\n");
				return ret_val;
			}
			hw->autoneg_failed = 0;
    cc5f:	c7 83 94 00 00 00 00 	movl   $0x0,0x94(%rbx)
    cc66:	00 00 00 
    cc69:	e9 f4 f1 ff ff       	jmpq   be62 <e1000_setup_link+0x3c2>
		e_dbg("Error Resetting the PHY\n");
		return ret_val;
	}

	/* Wait 15ms for MAC to configure PHY from eeprom settings */
	msleep(15);
    cc6e:	bf 0f 00 00 00       	mov    $0xf,%edi
    cc73:	e8 00 00 00 00       	callq  cc78 <e1000_setup_link+0x11d8>
	/* Configure activity LED after PHY reset */
	led_ctrl = er32(LEDCTL);
    cc78:	48 8b 03             	mov    (%rbx),%rax
    cc7b:	8b 80 00 0e 00 00    	mov    0xe00(%rax),%eax
	led_ctrl &= IGP_ACTIVITY_LED_MASK;
    cc81:	80 e4 f0             	and    $0xf0,%ah
	led_ctrl |= (IGP_ACTIVITY_LED_ENABLE | IGP_LED3_MODE);
	ew32(LEDCTL, led_ctrl);
    cc84:	48 8b 13             	mov    (%rbx),%rdx
	/* Wait 15ms for MAC to configure PHY from eeprom settings */
	msleep(15);
	/* Configure activity LED after PHY reset */
	led_ctrl = er32(LEDCTL);
	led_ctrl &= IGP_ACTIVITY_LED_MASK;
	led_ctrl |= (IGP_ACTIVITY_LED_ENABLE | IGP_LED3_MODE);
    cc87:	0d 00 03 00 07       	or     $0x7000300,%eax
build_mmio_read(__readw, "w", unsigned short, "=r", )
build_mmio_read(__readl, "l", unsigned int, "=r", )

build_mmio_write(writeb, "b", unsigned char, "q", :"memory")
build_mmio_write(writew, "w", unsigned short, "r", :"memory")
build_mmio_write(writel, "l", unsigned int, "r", :"memory")
    cc8c:	89 82 00 0e 00 00    	mov    %eax,0xe00(%rdx)
	ew32(LEDCTL, led_ctrl);

	/* The NVM settings will configure LPLU in D3 for IGP2 and IGP3 PHYs */
	if (hw->phy_type == e1000_phy_igp) {
    cc92:	83 7b 1c 01          	cmpl   $0x1,0x1c(%rbx)
    cc96:	4c 8d 6d de          	lea    -0x22(%rbp),%r13
    cc9a:	0f 84 4b 03 00 00    	je     cfeb <e1000_setup_link+0x154b>
			return ret_val;
		}
	}

	/* Configure mdi-mdix settings */
	ret_val = e1000_read_phy_reg(hw, IGP01E1000_PHY_PORT_CTRL, &phy_data);
    cca0:	4c 89 ea             	mov    %r13,%rdx
    cca3:	be 12 00 00 00       	mov    $0x12,%esi
    cca8:	48 89 df             	mov    %rbx,%rdi
    ccab:	e8 00 00 00 00       	callq  ccb0 <e1000_setup_link+0x1210>
	if (ret_val)
    ccb0:	85 c0                	test   %eax,%eax
    ccb2:	41 89 c4             	mov    %eax,%r12d
    ccb5:	0f 85 a7 f1 ff ff    	jne    be62 <e1000_setup_link+0x3c2>
		return ret_val;

	if ((hw->mac_type == e1000_82541) || (hw->mac_type == e1000_82547)) {
    ccbb:	8b 43 18             	mov    0x18(%rbx),%eax
    ccbe:	83 f8 0d             	cmp    $0xd,%eax
    ccc1:	74 09                	je     cccc <e1000_setup_link+0x122c>
    ccc3:	83 f8 0b             	cmp    $0xb,%eax
    ccc6:	0f 85 99 02 00 00    	jne    cf65 <e1000_setup_link+0x14c5>
		hw->dsp_config_state = e1000_dsp_config_disabled;
		/* Force MDI for earlier revs of the IGP PHY */
		phy_data &=
    cccc:	0f b7 45 de          	movzwl -0x22(%rbp),%eax
	ret_val = e1000_read_phy_reg(hw, IGP01E1000_PHY_PORT_CTRL, &phy_data);
	if (ret_val)
		return ret_val;

	if ((hw->mac_type == e1000_82541) || (hw->mac_type == e1000_82547)) {
		hw->dsp_config_state = e1000_dsp_config_disabled;
    ccd0:	c7 83 08 01 00 00 00 	movl   $0x0,0x108(%rbx)
    ccd7:	00 00 00 
		/* Force MDI for earlier revs of the IGP PHY */
		phy_data &=
		    ~(IGP01E1000_PSCR_AUTO_MDIX |
		      IGP01E1000_PSCR_FORCE_MDI_MDIX);
		hw->mdix = 1;
    ccda:	c6 83 f0 00 00 00 01 	movb   $0x1,0xf0(%rbx)
		return ret_val;

	if ((hw->mac_type == e1000_82541) || (hw->mac_type == e1000_82547)) {
		hw->dsp_config_state = e1000_dsp_config_disabled;
		/* Force MDI for earlier revs of the IGP PHY */
		phy_data &=
    cce1:	80 e4 cf             	and    $0xcf,%ah
    cce4:	66 89 45 de          	mov    %ax,-0x22(%rbp)
		default:
			phy_data |= IGP01E1000_PSCR_AUTO_MDIX;
			break;
		}
	}
	ret_val = e1000_write_phy_reg(hw, IGP01E1000_PHY_PORT_CTRL, phy_data);
    cce8:	0f b7 d0             	movzwl %ax,%edx
    cceb:	be 12 00 00 00       	mov    $0x12,%esi
    ccf0:	48 89 df             	mov    %rbx,%rdi
    ccf3:	e8 00 00 00 00       	callq  ccf8 <e1000_setup_link+0x1258>
	if (ret_val)
    ccf8:	85 c0                	test   %eax,%eax
    ccfa:	41 89 c4             	mov    %eax,%r12d
    ccfd:	0f 85 5f f1 ff ff    	jne    be62 <e1000_setup_link+0x3c2>
		return ret_val;

	/* set auto-master slave resolution settings */
	if (hw->autoneg) {
    cd03:	80 bb ef 00 00 00 00 	cmpb   $0x0,0xef(%rbx)
    cd0a:	0f 84 82 ee ff ff    	je     bb92 <e1000_setup_link+0xf2>
		e1000_ms_type phy_ms_setting = hw->master_slave;

		if (hw->ffe_config_state == e1000_ffe_config_active)
    cd10:	83 7b 68 01          	cmpl   $0x1,0x68(%rbx)
	if (ret_val)
		return ret_val;

	/* set auto-master slave resolution settings */
	if (hw->autoneg) {
		e1000_ms_type phy_ms_setting = hw->master_slave;
    cd14:	44 8b 73 60          	mov    0x60(%rbx),%r14d

		if (hw->ffe_config_state == e1000_ffe_config_active)
    cd18:	0f 84 fa 03 00 00    	je     d118 <e1000_setup_link+0x1678>
			hw->ffe_config_state = e1000_ffe_config_enabled;

		if (hw->dsp_config_state == e1000_dsp_config_activated)
    cd1e:	83 bb 08 01 00 00 02 	cmpl   $0x2,0x108(%rbx)
    cd25:	0f 84 7f 04 00 00    	je     d1aa <e1000_setup_link+0x170a>

		/* when autonegotiation advertisement is only 1000Mbps then we
		 * should disable SmartSpeed and enable Auto MasterSlave
		 * resolution as hardware default.
		 */
		if (hw->autoneg_advertised == ADVERTISE_1000_FULL) {
    cd2b:	66 83 bb d2 00 00 00 	cmpw   $0x20,0xd2(%rbx)
    cd32:	20 
    cd33:	0f 84 eb 03 00 00    	je     d124 <e1000_setup_link+0x1684>
			    e1000_write_phy_reg(hw, PHY_1000T_CTRL, phy_data);
			if (ret_val)
				return ret_val;
		}

		ret_val = e1000_read_phy_reg(hw, PHY_1000T_CTRL, &phy_data);
    cd39:	4c 89 ea             	mov    %r13,%rdx
    cd3c:	be 09 00 00 00       	mov    $0x9,%esi
    cd41:	48 89 df             	mov    %rbx,%rdi
    cd44:	e8 00 00 00 00       	callq  cd49 <e1000_setup_link+0x12a9>
		if (ret_val)
    cd49:	85 c0                	test   %eax,%eax
    cd4b:	41 89 c4             	mov    %eax,%r12d
    cd4e:	0f 85 0e f1 ff ff    	jne    be62 <e1000_setup_link+0x3c2>
			return ret_val;

		/* load defaults for future use */
		hw->original_master_slave = (phy_data & CR_1000T_MS_ENABLE) ?
    cd54:	0f b7 55 de          	movzwl -0x22(%rbp),%edx
    cd58:	b8 03 00 00 00       	mov    $0x3,%eax
    cd5d:	f6 c6 10             	test   $0x10,%dh
    cd60:	74 0b                	je     cd6d <e1000_setup_link+0x12cd>
    cd62:	89 d0                	mov    %edx,%eax
    cd64:	c1 e0 14             	shl    $0x14,%eax
    cd67:	c1 f8 1f             	sar    $0x1f,%eax
    cd6a:	83 c0 02             	add    $0x2,%eax
		    ((phy_data & CR_1000T_MS_VALUE) ?
		     e1000_ms_force_master :
		     e1000_ms_force_slave) : e1000_ms_auto;

		switch (phy_ms_setting) {
    cd6d:	41 83 fe 02          	cmp    $0x2,%r14d
		ret_val = e1000_read_phy_reg(hw, PHY_1000T_CTRL, &phy_data);
		if (ret_val)
			return ret_val;

		/* load defaults for future use */
		hw->original_master_slave = (phy_data & CR_1000T_MS_ENABLE) ?
    cd71:	89 43 64             	mov    %eax,0x64(%rbx)
		    ((phy_data & CR_1000T_MS_VALUE) ?
		     e1000_ms_force_master :
		     e1000_ms_force_slave) : e1000_ms_auto;

		switch (phy_ms_setting) {
    cd74:	0f 84 4b 04 00 00    	je     d1c5 <e1000_setup_link+0x1725>
    cd7a:	41 83 fe 03          	cmp    $0x3,%r14d
    cd7e:	0f 84 35 04 00 00    	je     d1b9 <e1000_setup_link+0x1719>
    cd84:	41 83 ee 01          	sub    $0x1,%r14d
    cd88:	75 07                	jne    cd91 <e1000_setup_link+0x12f1>
		case e1000_ms_force_master:
			phy_data |= (CR_1000T_MS_ENABLE | CR_1000T_MS_VALUE);
    cd8a:	80 ce 18             	or     $0x18,%dh
    cd8d:	66 89 55 de          	mov    %dx,-0x22(%rbp)
		case e1000_ms_auto:
			phy_data &= ~CR_1000T_MS_ENABLE;
		default:
			break;
		}
		ret_val = e1000_write_phy_reg(hw, PHY_1000T_CTRL, phy_data);
    cd91:	0f b7 55 de          	movzwl -0x22(%rbp),%edx
    cd95:	be 09 00 00 00       	mov    $0x9,%esi
    cd9a:	48 89 df             	mov    %rbx,%rdi
    cd9d:	e8 00 00 00 00       	callq  cda2 <e1000_setup_link+0x1302>
		if (ret_val)
    cda2:	85 c0                	test   %eax,%eax
		case e1000_ms_auto:
			phy_data &= ~CR_1000T_MS_ENABLE;
		default:
			break;
		}
		ret_val = e1000_write_phy_reg(hw, PHY_1000T_CTRL, phy_data);
    cda4:	41 89 c4             	mov    %eax,%r12d
		if (ret_val)
    cda7:	0f 85 b5 f0 ff ff    	jne    be62 <e1000_setup_link+0x3c2>
    cdad:	e9 e0 ed ff ff       	jmpq   bb92 <e1000_setup_link+0xf2>
		break;
	case e1000_ce4100:
		if ((hw->phy_id == RTL8211B_PHY_ID) ||
		    (hw->phy_id == RTL8201N_PHY_ID) ||
		    (hw->phy_id == M88E1118_E_PHY_ID))
			match = true;
    cdb2:	b8 01 00 00 00       	mov    $0x1,%eax
    cdb7:	e9 1e f8 ff ff       	jmpq   c5da <e1000_setup_link+0xb3a>
    cdbc:	48 89 df             	mov    %rbx,%rdi
    cdbf:	e8 4c c9 ff ff       	callq  9710 <e1000_config_mac_to_phy.part.10>

	if ((hw->mac_type >= e1000_82544) && (hw->mac_type != e1000_ce4100)) {
		e1000_config_collision_dist(hw);
	} else {
		ret_val = e1000_config_mac_to_phy(hw);
		if (ret_val) {
    cdc4:	85 c0                	test   %eax,%eax
    cdc6:	41 89 c5             	mov    %eax,%r13d
    cdc9:	0f 84 aa fd ff ff    	je     cb79 <e1000_setup_link+0x10d9>
			e_dbg("Error configuring MAC to PHY settings\n");
    cdcf:	f6 05 00 00 00 00 04 	testb  $0x4,0x0(%rip)        # cdd6 <e1000_setup_link+0x1336>
    cdd6:	0f 84 bd fd ff ff    	je     cb99 <e1000_setup_link+0x10f9>
    cddc:	48 89 df             	mov    %rbx,%rdi
    cddf:	45 89 ec             	mov    %r13d,%r12d
    cde2:	e8 00 00 00 00       	callq  cde7 <e1000_setup_link+0x1347>
    cde7:	48 c7 c2 00 00 00 00 	mov    $0x0,%rdx
    cdee:	48 89 c6             	mov    %rax,%rsi
    cdf1:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
    cdf8:	31 c0                	xor    %eax,%eax
    cdfa:	e8 00 00 00 00       	callq  cdff <e1000_setup_link+0x135f>
    cdff:	e9 5e f0 ff ff       	jmpq   be62 <e1000_setup_link+0x3c2>
		/* Because we reset the PHY above, we need to re-force TX_CLK in
		 * the Extended PHY Specific Control Register to 25MHz clock.
		 * This value defaults back to a 2.5MHz clock when the PHY is
		 * reset.
		 */
		ret_val =
    ce04:	4c 89 ea             	mov    %r13,%rdx
    ce07:	be 14 00 00 00       	mov    $0x14,%esi
    ce0c:	48 89 df             	mov    %rbx,%rdi
    ce0f:	e8 00 00 00 00       	callq  ce14 <e1000_setup_link+0x1374>
		    e1000_read_phy_reg(hw, M88E1000_EXT_PHY_SPEC_CTRL,
				       &phy_data);
		if (ret_val)
    ce14:	85 c0                	test   %eax,%eax
		/* Because we reset the PHY above, we need to re-force TX_CLK in
		 * the Extended PHY Specific Control Register to 25MHz clock.
		 * This value defaults back to a 2.5MHz clock when the PHY is
		 * reset.
		 */
		ret_val =
    ce16:	41 89 c4             	mov    %eax,%r12d
		    e1000_read_phy_reg(hw, M88E1000_EXT_PHY_SPEC_CTRL,
				       &phy_data);
		if (ret_val)
    ce19:	0f 85 e5 f5 ff ff    	jne    c404 <e1000_setup_link+0x964>
			return ret_val;

		phy_data |= M88E1000_EPSCR_TX_CLK_25;
    ce1f:	0f b7 45 de          	movzwl -0x22(%rbp),%eax
		ret_val =
    ce23:	be 14 00 00 00       	mov    $0x14,%esi
    ce28:	48 89 df             	mov    %rbx,%rdi
		    e1000_read_phy_reg(hw, M88E1000_EXT_PHY_SPEC_CTRL,
				       &phy_data);
		if (ret_val)
			return ret_val;

		phy_data |= M88E1000_EPSCR_TX_CLK_25;
    ce2b:	83 c8 70             	or     $0x70,%eax
		ret_val =
		    e1000_write_phy_reg(hw, M88E1000_EXT_PHY_SPEC_CTRL,
    ce2e:	0f b7 d0             	movzwl %ax,%edx
		    e1000_read_phy_reg(hw, M88E1000_EXT_PHY_SPEC_CTRL,
				       &phy_data);
		if (ret_val)
			return ret_val;

		phy_data |= M88E1000_EPSCR_TX_CLK_25;
    ce31:	66 89 45 de          	mov    %ax,-0x22(%rbp)
		ret_val =
    ce35:	e8 00 00 00 00       	callq  ce3a <e1000_setup_link+0x139a>
		    e1000_write_phy_reg(hw, M88E1000_EXT_PHY_SPEC_CTRL,
					phy_data);
		if (ret_val)
    ce3a:	85 c0                	test   %eax,%eax
				       &phy_data);
		if (ret_val)
			return ret_val;

		phy_data |= M88E1000_EPSCR_TX_CLK_25;
		ret_val =
    ce3c:	41 89 c4             	mov    %eax,%r12d
		    e1000_write_phy_reg(hw, M88E1000_EXT_PHY_SPEC_CTRL,
					phy_data);
		if (ret_val)
    ce3f:	0f 85 bf f5 ff ff    	jne    c404 <e1000_setup_link+0x964>

		/* In addition, because of the s/w reset above, we need to
		 * enable CRS on Tx.  This must be set for both full and half
		 * duplex operation.
		 */
		ret_val =
    ce45:	4c 89 ea             	mov    %r13,%rdx
    ce48:	be 10 00 00 00       	mov    $0x10,%esi
    ce4d:	48 89 df             	mov    %rbx,%rdi
    ce50:	e8 00 00 00 00       	callq  ce55 <e1000_setup_link+0x13b5>
		    e1000_read_phy_reg(hw, M88E1000_PHY_SPEC_CTRL, &phy_data);
		if (ret_val)
    ce55:	85 c0                	test   %eax,%eax

		/* In addition, because of the s/w reset above, we need to
		 * enable CRS on Tx.  This must be set for both full and half
		 * duplex operation.
		 */
		ret_val =
    ce57:	41 89 c4             	mov    %eax,%r12d
		    e1000_read_phy_reg(hw, M88E1000_PHY_SPEC_CTRL, &phy_data);
		if (ret_val)
    ce5a:	0f 85 a4 f5 ff ff    	jne    c404 <e1000_setup_link+0x964>
			return ret_val;

		phy_data |= M88E1000_PSCR_ASSERT_CRS_ON_TX;
    ce60:	0f b7 45 de          	movzwl -0x22(%rbp),%eax
		ret_val =
    ce64:	be 10 00 00 00       	mov    $0x10,%esi
    ce69:	48 89 df             	mov    %rbx,%rdi
		ret_val =
		    e1000_read_phy_reg(hw, M88E1000_PHY_SPEC_CTRL, &phy_data);
		if (ret_val)
			return ret_val;

		phy_data |= M88E1000_PSCR_ASSERT_CRS_ON_TX;
    ce6c:	80 cc 08             	or     $0x8,%ah
		ret_val =
		    e1000_write_phy_reg(hw, M88E1000_PHY_SPEC_CTRL, phy_data);
    ce6f:	0f b7 d0             	movzwl %ax,%edx
		ret_val =
		    e1000_read_phy_reg(hw, M88E1000_PHY_SPEC_CTRL, &phy_data);
		if (ret_val)
			return ret_val;

		phy_data |= M88E1000_PSCR_ASSERT_CRS_ON_TX;
    ce72:	66 89 45 de          	mov    %ax,-0x22(%rbp)
		ret_val =
    ce76:	e8 00 00 00 00       	callq  ce7b <e1000_setup_link+0x13db>
		    e1000_write_phy_reg(hw, M88E1000_PHY_SPEC_CTRL, phy_data);
		if (ret_val)
    ce7b:	85 c0                	test   %eax,%eax
    ce7d:	0f 85 7e f5 ff ff    	jne    c401 <e1000_setup_link+0x961>
			return ret_val;

		if ((hw->mac_type == e1000_82544 || hw->mac_type == e1000_82543)
    ce83:	8b 43 18             	mov    0x18(%rbx),%eax
    ce86:	83 e8 03             	sub    $0x3,%eax
    ce89:	83 f8 01             	cmp    $0x1,%eax
    ce8c:	0f 87 58 ef ff ff    	ja     bdea <e1000_setup_link+0x34a>
		    && (!hw->autoneg)
    ce92:	80 bb ef 00 00 00 00 	cmpb   $0x0,0xef(%rbx)
    ce99:	0f 85 4b ef ff ff    	jne    bdea <e1000_setup_link+0x34a>
		    && (hw->forced_speed_duplex == e1000_10_full
    ce9f:	80 bb f1 00 00 00 01 	cmpb   $0x1,0xf1(%rbx)
    cea6:	0f 87 3e ef ff ff    	ja     bdea <e1000_setup_link+0x34a>
			|| hw->forced_speed_duplex == e1000_10_half)) {
			ret_val = e1000_polarity_reversal_workaround(hw);
    ceac:	48 89 df             	mov    %rbx,%rdi
    ceaf:	e8 00 00 00 00       	callq  ceb4 <e1000_setup_link+0x1414>
			if (ret_val)
    ceb4:	85 c0                	test   %eax,%eax

		if ((hw->mac_type == e1000_82544 || hw->mac_type == e1000_82543)
		    && (!hw->autoneg)
		    && (hw->forced_speed_duplex == e1000_10_full
			|| hw->forced_speed_duplex == e1000_10_half)) {
			ret_val = e1000_polarity_reversal_workaround(hw);
    ceb6:	41 89 c4             	mov    %eax,%r12d
			if (ret_val)
    ceb9:	0f 85 45 f5 ff ff    	jne    c404 <e1000_setup_link+0x964>
    cebf:	e9 26 ef ff ff       	jmpq   bdea <e1000_setup_link+0x34a>
{
	s32 ret_val;
	u16 i;
	u16 phy_data;

	e_dbg("Waiting for Auto-Neg to complete.\n");
    cec4:	f6 05 00 00 00 00 04 	testb  $0x4,0x0(%rip)        # cecb <e1000_setup_link+0x142b>
    cecb:	0f 85 53 06 00 00    	jne    d524 <e1000_setup_link+0x1a84>
	 *   0 - Disabled
	 *   1 - Enabled
	 */
	phy_data &= ~M88E1000_PSCR_POLARITY_REVERSAL;
	if (hw->disable_polarity_correction == 1)
		phy_data |= M88E1000_PSCR_POLARITY_REVERSAL;
    ced1:	41 bc 2d 00 00 00    	mov    $0x2d,%r12d
    ced7:	4c 8d 6d de          	lea    -0x22(%rbp),%r13
    cedb:	eb 33                	jmp    cf10 <e1000_setup_link+0x1470>
		 * Complete bit to be set.
		 */
		ret_val = e1000_read_phy_reg(hw, PHY_STATUS, &phy_data);
		if (ret_val)
			return ret_val;
		ret_val = e1000_read_phy_reg(hw, PHY_STATUS, &phy_data);
    cedd:	4c 89 ea             	mov    %r13,%rdx
    cee0:	be 01 00 00 00       	mov    $0x1,%esi
    cee5:	48 89 df             	mov    %rbx,%rdi
    cee8:	e8 00 00 00 00       	callq  ceed <e1000_setup_link+0x144d>
		if (ret_val)
    ceed:	85 c0                	test   %eax,%eax
    ceef:	75 33                	jne    cf24 <e1000_setup_link+0x1484>
			return ret_val;
		if (phy_data & MII_SR_AUTONEG_COMPLETE) {
    cef1:	f6 45 de 20          	testb  $0x20,-0x22(%rbp)
    cef5:	0f 85 11 fb ff ff    	jne    ca0c <e1000_setup_link+0xf6c>
			return E1000_SUCCESS;
		}
		msleep(100);
    cefb:	bf 64 00 00 00       	mov    $0x64,%edi
    cf00:	e8 00 00 00 00       	callq  cf05 <e1000_setup_link+0x1465>
	u16 phy_data;

	e_dbg("Waiting for Auto-Neg to complete.\n");

	/* We will wait for autoneg to complete or 4.5 seconds to expire. */
	for (i = PHY_AUTO_NEG_TIME; i > 0; i--) {
    cf05:	66 41 83 ec 01       	sub    $0x1,%r12w
    cf0a:	0f 84 fc fa ff ff    	je     ca0c <e1000_setup_link+0xf6c>
		/* Read the MII Status Register and wait for Auto-Neg
		 * Complete bit to be set.
		 */
		ret_val = e1000_read_phy_reg(hw, PHY_STATUS, &phy_data);
    cf10:	4c 89 ea             	mov    %r13,%rdx
    cf13:	be 01 00 00 00       	mov    $0x1,%esi
    cf18:	48 89 df             	mov    %rbx,%rdi
    cf1b:	e8 00 00 00 00       	callq  cf20 <e1000_setup_link+0x1480>
		if (ret_val)
    cf20:	85 c0                	test   %eax,%eax
    cf22:	74 b9                	je     cedd <e1000_setup_link+0x143d>
	 * check at a later time (for example, callback routine).
	 */
	if (hw->wait_autoneg_complete) {
		ret_val = e1000_wait_autoneg(hw);
		if (ret_val) {
			e_dbg
    cf24:	f6 05 00 00 00 00 04 	testb  $0x4,0x0(%rip)        # cf2b <e1000_setup_link+0x148b>
		 * Complete bit to be set.
		 */
		ret_val = e1000_read_phy_reg(hw, PHY_STATUS, &phy_data);
		if (ret_val)
			return ret_val;
		ret_val = e1000_read_phy_reg(hw, PHY_STATUS, &phy_data);
    cf2b:	41 89 c4             	mov    %eax,%r12d
	 * check at a later time (for example, callback routine).
	 */
	if (hw->wait_autoneg_complete) {
		ret_val = e1000_wait_autoneg(hw);
		if (ret_val) {
			e_dbg
    cf2e:	0f 84 2e ef ff ff    	je     be62 <e1000_setup_link+0x3c2>
    cf34:	48 89 df             	mov    %rbx,%rdi
    cf37:	e8 00 00 00 00       	callq  cf3c <e1000_setup_link+0x149c>
    cf3c:	48 c7 c2 00 00 00 00 	mov    $0x0,%rdx
    cf43:	48 89 c6             	mov    %rax,%rsi
    cf46:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
    cf4d:	31 c0                	xor    %eax,%eax
    cf4f:	e8 00 00 00 00       	callq  cf54 <e1000_setup_link+0x14b4>
    cf54:	e9 09 ef ff ff       	jmpq   be62 <e1000_setup_link+0x3c2>
		phy_data |= M88E1000_EPSCR_TX_CLK_25;

		if ((hw->phy_revision == E1000_REVISION_2) &&
		    (hw->phy_id == M88E1111_I_PHY_ID)) {
			/* Vidalia Phy, set the downshift counter to 5x */
			phy_data &= ~(M88EC018_EPSCR_DOWNSHIFT_COUNTER_MASK);
    cf59:	80 e4 f1             	and    $0xf1,%ah
			phy_data |= M88EC018_EPSCR_DOWNSHIFT_COUNTER_5X;
    cf5c:	66 0d 70 08          	or     $0x870,%ax
    cf60:	e9 26 f8 ff ff       	jmpq   c78b <e1000_setup_link+0xceb>
		      IGP01E1000_PSCR_FORCE_MDI_MDIX);
		hw->mdix = 1;

	} else {
		hw->dsp_config_state = e1000_dsp_config_enabled;
		phy_data &= ~IGP01E1000_PSCR_AUTO_MDIX;
    cf65:	0f b7 55 de          	movzwl -0x22(%rbp),%edx

		switch (hw->mdix) {
    cf69:	0f b6 8b f0 00 00 00 	movzbl 0xf0(%rbx),%ecx
		    ~(IGP01E1000_PSCR_AUTO_MDIX |
		      IGP01E1000_PSCR_FORCE_MDI_MDIX);
		hw->mdix = 1;

	} else {
		hw->dsp_config_state = e1000_dsp_config_enabled;
    cf70:	c7 83 08 01 00 00 01 	movl   $0x1,0x108(%rbx)
    cf77:	00 00 00 
		phy_data &= ~IGP01E1000_PSCR_AUTO_MDIX;
    cf7a:	89 d0                	mov    %edx,%eax
    cf7c:	80 e4 ef             	and    $0xef,%ah

		switch (hw->mdix) {
    cf7f:	80 f9 01             	cmp    $0x1,%cl
		      IGP01E1000_PSCR_FORCE_MDI_MDIX);
		hw->mdix = 1;

	} else {
		hw->dsp_config_state = e1000_dsp_config_enabled;
		phy_data &= ~IGP01E1000_PSCR_AUTO_MDIX;
    cf82:	66 89 45 de          	mov    %ax,-0x22(%rbp)

		switch (hw->mdix) {
    cf86:	0f 84 0a 01 00 00    	je     d096 <e1000_setup_link+0x15f6>
    cf8c:	80 f9 02             	cmp    $0x2,%cl
    cf8f:	0f 85 f5 00 00 00    	jne    d08a <e1000_setup_link+0x15ea>
		case 1:
			phy_data &= ~IGP01E1000_PSCR_FORCE_MDI_MDIX;
			break;
		case 2:
			phy_data |= IGP01E1000_PSCR_FORCE_MDI_MDIX;
    cf95:	80 cc 20             	or     $0x20,%ah
    cf98:	66 89 45 de          	mov    %ax,-0x22(%rbp)
    cf9c:	e9 47 fd ff ff       	jmpq   cce8 <e1000_setup_link+0x1248>
		return ret_val;
	}

	/* Config DSP to improve Giga link quality */
	if (hw->phy_type == e1000_phy_igp) {
		ret_val = e1000_config_dsp_after_link_change(hw, true);
    cfa1:	be 01 00 00 00       	mov    $0x1,%esi
    cfa6:	48 89 df             	mov    %rbx,%rdi
    cfa9:	e8 72 d6 ff ff       	callq  a620 <e1000_config_dsp_after_link_change>
		if (ret_val) {
    cfae:	85 c0                	test   %eax,%eax
    cfb0:	0f 84 77 fc ff ff    	je     cc2d <e1000_setup_link+0x118d>
			e_dbg("Error Configuring DSP after link up\n");
    cfb6:	f6 05 00 00 00 00 04 	testb  $0x4,0x0(%rip)        # cfbd <e1000_setup_link+0x151d>
    cfbd:	41 89 c4             	mov    %eax,%r12d
    cfc0:	0f 84 9c ee ff ff    	je     be62 <e1000_setup_link+0x3c2>
    cfc6:	48 89 df             	mov    %rbx,%rdi
    cfc9:	e8 00 00 00 00       	callq  cfce <e1000_setup_link+0x152e>
    cfce:	48 c7 c2 00 00 00 00 	mov    $0x0,%rdx
    cfd5:	48 89 c6             	mov    %rax,%rsi
    cfd8:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
    cfdf:	31 c0                	xor    %eax,%eax
    cfe1:	e8 00 00 00 00       	callq  cfe6 <e1000_setup_link+0x1546>
    cfe6:	e9 77 ee ff ff       	jmpq   be62 <e1000_setup_link+0x3c2>
	/* During driver activity LPLU should not be used or it will attain link
	 * from the lowest speeds starting from 10Mbps. The capability is used
	 * for Dx transitions and states
	 */
	if (hw->mac_type == e1000_82541_rev_2
	    || hw->mac_type == e1000_82547_rev_2) {
    cfeb:	8b 43 18             	mov    0x18(%rbx),%eax
    cfee:	83 e0 fd             	and    $0xfffffffd,%eax

	/* During driver activity LPLU should not be used or it will attain link
	 * from the lowest speeds starting from 10Mbps. The capability is used
	 * for Dx transitions and states
	 */
	if (hw->mac_type == e1000_82541_rev_2
    cff1:	83 f8 0c             	cmp    $0xc,%eax
    cff4:	0f 84 09 02 00 00    	je     d203 <e1000_setup_link+0x1763>
		/* LPLU and SmartSpeed are mutually exclusive.  LPLU is used
		 * during Dx states where the power conservation is most
		 * important.  During driver activity we should enable
		 * SmartSpeed, so performance is maintained.
		 */
		if (hw->smart_speed == e1000_smart_speed_on) {
    cffa:	8b 83 04 01 00 00    	mov    0x104(%rbx),%eax
    d000:	83 f8 01             	cmp    $0x1,%eax
    d003:	0f 84 fb 02 00 00    	je     d304 <e1000_setup_link+0x1864>
			ret_val =
			    e1000_write_phy_reg(hw, IGP01E1000_PHY_PORT_CONFIG,
						phy_data);
			if (ret_val)
				return ret_val;
		} else if (hw->smart_speed == e1000_smart_speed_off) {
    d009:	83 f8 02             	cmp    $0x2,%eax
    d00c:	0f 85 8e fc ff ff    	jne    cca0 <e1000_setup_link+0x1200>
			ret_val =
    d012:	4c 89 ea             	mov    %r13,%rdx
    d015:	be 10 00 00 00       	mov    $0x10,%esi
    d01a:	48 89 df             	mov    %rbx,%rdi
    d01d:	e8 00 00 00 00       	callq  d022 <e1000_setup_link+0x1582>
			    e1000_read_phy_reg(hw, IGP01E1000_PHY_PORT_CONFIG,
					       &phy_data);
			if (ret_val)
    d022:	85 c0                	test   %eax,%eax
			    e1000_write_phy_reg(hw, IGP01E1000_PHY_PORT_CONFIG,
						phy_data);
			if (ret_val)
				return ret_val;
		} else if (hw->smart_speed == e1000_smart_speed_off) {
			ret_val =
    d024:	41 89 c4             	mov    %eax,%r12d
			    e1000_read_phy_reg(hw, IGP01E1000_PHY_PORT_CONFIG,
					       &phy_data);
			if (ret_val)
    d027:	0f 84 b0 02 00 00    	je     d2dd <e1000_setup_link+0x183d>
	/* The NVM settings will configure LPLU in D3 for IGP2 and IGP3 PHYs */
	if (hw->phy_type == e1000_phy_igp) {
		/* disable lplu d3 during driver init */
		ret_val = e1000_set_d3_lplu_state(hw, false);
		if (ret_val) {
			e_dbg("Error Disabling LPLU D3\n");
    d02d:	f6 05 00 00 00 00 04 	testb  $0x4,0x0(%rip)        # d034 <e1000_setup_link+0x1594>
    d034:	0f 84 28 ee ff ff    	je     be62 <e1000_setup_link+0x3c2>
    d03a:	48 89 df             	mov    %rbx,%rdi
    d03d:	e8 00 00 00 00       	callq  d042 <e1000_setup_link+0x15a2>
    d042:	48 c7 c2 00 00 00 00 	mov    $0x0,%rdx
    d049:	48 89 c6             	mov    %rax,%rsi
    d04c:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
    d053:	31 c0                	xor    %eax,%eax
    d055:	e8 00 00 00 00       	callq  d05a <e1000_setup_link+0x15ba>
    d05a:	e9 03 ee ff ff       	jmpq   be62 <e1000_setup_link+0x3c2>
	if ((hw->mac_type < e1000_82543) && (hw->report_tx_early == 1))
		hw->fc &= (~E1000_FC_RX_PAUSE);

	hw->original_fc = hw->fc;

	e_dbg("After fix-ups FlowControl is now = %x\n", hw->fc);
    d05f:	48 89 df             	mov    %rbx,%rdi
    d062:	e8 00 00 00 00       	callq  d067 <e1000_setup_link+0x15c7>
    d067:	44 89 e1             	mov    %r12d,%ecx
    d06a:	48 89 c6             	mov    %rax,%rsi
    d06d:	48 c7 c2 00 00 00 00 	mov    $0x0,%rdx
    d074:	31 c0                	xor    %eax,%eax
    d076:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
    d07d:	e8 00 00 00 00       	callq  d082 <e1000_setup_link+0x15e2>
    d082:	8b 43 18             	mov    0x18(%rbx),%eax
    d085:	e9 67 ea ff ff       	jmpq   baf1 <e1000_setup_link+0x51>
		case 2:
			phy_data |= IGP01E1000_PSCR_FORCE_MDI_MDIX;
			break;
		case 0:
		default:
			phy_data |= IGP01E1000_PSCR_AUTO_MDIX;
    d08a:	80 cc 10             	or     $0x10,%ah
    d08d:	66 89 45 de          	mov    %ax,-0x22(%rbp)
    d091:	e9 52 fc ff ff       	jmpq   cce8 <e1000_setup_link+0x1248>
		hw->dsp_config_state = e1000_dsp_config_enabled;
		phy_data &= ~IGP01E1000_PSCR_AUTO_MDIX;

		switch (hw->mdix) {
		case 1:
			phy_data &= ~IGP01E1000_PSCR_FORCE_MDI_MDIX;
    d096:	89 d0                	mov    %edx,%eax
    d098:	80 e4 cf             	and    $0xcf,%ah
    d09b:	66 89 45 de          	mov    %ax,-0x22(%rbp)
    d09f:	e9 44 fc ff ff       	jmpq   cce8 <e1000_setup_link+0x1248>
static s32 e1000_phy_reset_dsp(struct e1000_hw *hw)
{
	s32 ret_val;

	do {
		ret_val = e1000_write_phy_reg(hw, 29, 0x001d);
    d0a4:	ba 1d 00 00 00       	mov    $0x1d,%edx
    d0a9:	be 1d 00 00 00       	mov    $0x1d,%esi
    d0ae:	48 89 df             	mov    %rbx,%rdi
    d0b1:	e8 00 00 00 00       	callq  d0b6 <e1000_setup_link+0x1616>
		if (ret_val)
    d0b6:	85 c0                	test   %eax,%eax
static s32 e1000_phy_reset_dsp(struct e1000_hw *hw)
{
	s32 ret_val;

	do {
		ret_val = e1000_write_phy_reg(hw, 29, 0x001d);
    d0b8:	41 89 c4             	mov    %eax,%r12d
		if (ret_val)
    d0bb:	0f 84 90 01 00 00    	je     d251 <e1000_setup_link+0x17b1>
			/* We didn't get link.  Reset the DSP and wait again
			 * for link.
			 */
			ret_val = e1000_phy_reset_dsp(hw);
			if (ret_val) {
				e_dbg("Error Resetting PHY DSP\n");
    d0c1:	f6 05 00 00 00 00 04 	testb  $0x4,0x0(%rip)        # d0c8 <e1000_setup_link+0x1628>
    d0c8:	0f 84 36 f3 ff ff    	je     c404 <e1000_setup_link+0x964>
    d0ce:	48 89 df             	mov    %rbx,%rdi
    d0d1:	e8 00 00 00 00       	callq  d0d6 <e1000_setup_link+0x1636>
    d0d6:	48 c7 c2 00 00 00 00 	mov    $0x0,%rdx
    d0dd:	48 89 c6             	mov    %rax,%rsi
    d0e0:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
    d0e7:	31 c0                	xor    %eax,%eax
    d0e9:	e8 00 00 00 00       	callq  d0ee <e1000_setup_link+0x164e>
    d0ee:	e9 11 f3 ff ff       	jmpq   c404 <e1000_setup_link+0x964>
	/* Initialize the flow control address, type, and PAUSE timer
	 * registers to their default values.  This is done even if flow
	 * control is disabled, because it does not hurt anything to
	 * initialize these registers.
	 */
	e_dbg("Initializing the Flow Control address, type and timer regs\n");
    d0f3:	48 89 df             	mov    %rbx,%rdi
    d0f6:	e8 00 00 00 00       	callq  d0fb <e1000_setup_link+0x165b>
    d0fb:	48 c7 c2 00 00 00 00 	mov    $0x0,%rdx
    d102:	48 89 c6             	mov    %rax,%rsi
    d105:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
    d10c:	31 c0                	xor    %eax,%eax
    d10e:	e8 00 00 00 00       	callq  d113 <e1000_setup_link+0x1673>
    d113:	e9 57 ed ff ff       	jmpq   be6f <e1000_setup_link+0x3cf>
	/* set auto-master slave resolution settings */
	if (hw->autoneg) {
		e1000_ms_type phy_ms_setting = hw->master_slave;

		if (hw->ffe_config_state == e1000_ffe_config_active)
			hw->ffe_config_state = e1000_ffe_config_enabled;
    d118:	c7 43 68 00 00 00 00 	movl   $0x0,0x68(%rbx)
    d11f:	e9 fa fb ff ff       	jmpq   cd1e <e1000_setup_link+0x127e>
		 * should disable SmartSpeed and enable Auto MasterSlave
		 * resolution as hardware default.
		 */
		if (hw->autoneg_advertised == ADVERTISE_1000_FULL) {
			/* Disable SmartSpeed */
			ret_val =
    d124:	4c 89 ea             	mov    %r13,%rdx
    d127:	be 10 00 00 00       	mov    $0x10,%esi
    d12c:	48 89 df             	mov    %rbx,%rdi
    d12f:	e8 00 00 00 00       	callq  d134 <e1000_setup_link+0x1694>
			    e1000_read_phy_reg(hw, IGP01E1000_PHY_PORT_CONFIG,
					       &phy_data);
			if (ret_val)
    d134:	85 c0                	test   %eax,%eax
		 * should disable SmartSpeed and enable Auto MasterSlave
		 * resolution as hardware default.
		 */
		if (hw->autoneg_advertised == ADVERTISE_1000_FULL) {
			/* Disable SmartSpeed */
			ret_val =
    d136:	41 89 c4             	mov    %eax,%r12d
			    e1000_read_phy_reg(hw, IGP01E1000_PHY_PORT_CONFIG,
					       &phy_data);
			if (ret_val)
    d139:	0f 85 23 ed ff ff    	jne    be62 <e1000_setup_link+0x3c2>
				return ret_val;
			phy_data &= ~IGP01E1000_PSCFR_SMART_SPEED;
    d13f:	0f b7 45 de          	movzwl -0x22(%rbp),%eax
			ret_val =
    d143:	be 10 00 00 00       	mov    $0x10,%esi
    d148:	48 89 df             	mov    %rbx,%rdi
			ret_val =
			    e1000_read_phy_reg(hw, IGP01E1000_PHY_PORT_CONFIG,
					       &phy_data);
			if (ret_val)
				return ret_val;
			phy_data &= ~IGP01E1000_PSCFR_SMART_SPEED;
    d14b:	24 7f                	and    $0x7f,%al
			ret_val =
			    e1000_write_phy_reg(hw, IGP01E1000_PHY_PORT_CONFIG,
    d14d:	0f b7 d0             	movzwl %ax,%edx
			ret_val =
			    e1000_read_phy_reg(hw, IGP01E1000_PHY_PORT_CONFIG,
					       &phy_data);
			if (ret_val)
				return ret_val;
			phy_data &= ~IGP01E1000_PSCFR_SMART_SPEED;
    d150:	66 89 45 de          	mov    %ax,-0x22(%rbp)
			ret_val =
    d154:	e8 00 00 00 00       	callq  d159 <e1000_setup_link+0x16b9>
			    e1000_write_phy_reg(hw, IGP01E1000_PHY_PORT_CONFIG,
						phy_data);
			if (ret_val)
    d159:	85 c0                	test   %eax,%eax
			    e1000_read_phy_reg(hw, IGP01E1000_PHY_PORT_CONFIG,
					       &phy_data);
			if (ret_val)
				return ret_val;
			phy_data &= ~IGP01E1000_PSCFR_SMART_SPEED;
			ret_val =
    d15b:	41 89 c4             	mov    %eax,%r12d
			    e1000_write_phy_reg(hw, IGP01E1000_PHY_PORT_CONFIG,
						phy_data);
			if (ret_val)
    d15e:	0f 85 fe ec ff ff    	jne    be62 <e1000_setup_link+0x3c2>
				return ret_val;
			/* Set auto Master/Slave resolution process */
			ret_val =
    d164:	4c 89 ea             	mov    %r13,%rdx
    d167:	be 09 00 00 00       	mov    $0x9,%esi
    d16c:	48 89 df             	mov    %rbx,%rdi
    d16f:	e8 00 00 00 00       	callq  d174 <e1000_setup_link+0x16d4>
			    e1000_read_phy_reg(hw, PHY_1000T_CTRL, &phy_data);
			if (ret_val)
    d174:	85 c0                	test   %eax,%eax
			    e1000_write_phy_reg(hw, IGP01E1000_PHY_PORT_CONFIG,
						phy_data);
			if (ret_val)
				return ret_val;
			/* Set auto Master/Slave resolution process */
			ret_val =
    d176:	41 89 c4             	mov    %eax,%r12d
			    e1000_read_phy_reg(hw, PHY_1000T_CTRL, &phy_data);
			if (ret_val)
    d179:	0f 85 e3 ec ff ff    	jne    be62 <e1000_setup_link+0x3c2>
				return ret_val;
			phy_data &= ~CR_1000T_MS_ENABLE;
    d17f:	0f b7 45 de          	movzwl -0x22(%rbp),%eax
			ret_val =
    d183:	be 09 00 00 00       	mov    $0x9,%esi
    d188:	48 89 df             	mov    %rbx,%rdi
			/* Set auto Master/Slave resolution process */
			ret_val =
			    e1000_read_phy_reg(hw, PHY_1000T_CTRL, &phy_data);
			if (ret_val)
				return ret_val;
			phy_data &= ~CR_1000T_MS_ENABLE;
    d18b:	80 e4 ef             	and    $0xef,%ah
			ret_val =
			    e1000_write_phy_reg(hw, PHY_1000T_CTRL, phy_data);
    d18e:	0f b7 d0             	movzwl %ax,%edx
			/* Set auto Master/Slave resolution process */
			ret_val =
			    e1000_read_phy_reg(hw, PHY_1000T_CTRL, &phy_data);
			if (ret_val)
				return ret_val;
			phy_data &= ~CR_1000T_MS_ENABLE;
    d191:	66 89 45 de          	mov    %ax,-0x22(%rbp)
			ret_val =
    d195:	e8 00 00 00 00       	callq  d19a <e1000_setup_link+0x16fa>
			    e1000_write_phy_reg(hw, PHY_1000T_CTRL, phy_data);
			if (ret_val)
    d19a:	85 c0                	test   %eax,%eax
			ret_val =
			    e1000_read_phy_reg(hw, PHY_1000T_CTRL, &phy_data);
			if (ret_val)
				return ret_val;
			phy_data &= ~CR_1000T_MS_ENABLE;
			ret_val =
    d19c:	41 89 c4             	mov    %eax,%r12d
			    e1000_write_phy_reg(hw, PHY_1000T_CTRL, phy_data);
			if (ret_val)
    d19f:	0f 84 94 fb ff ff    	je     cd39 <e1000_setup_link+0x1299>
    d1a5:	e9 b8 ec ff ff       	jmpq   be62 <e1000_setup_link+0x3c2>

		if (hw->ffe_config_state == e1000_ffe_config_active)
			hw->ffe_config_state = e1000_ffe_config_enabled;

		if (hw->dsp_config_state == e1000_dsp_config_activated)
			hw->dsp_config_state = e1000_dsp_config_enabled;
    d1aa:	c7 83 08 01 00 00 01 	movl   $0x1,0x108(%rbx)
    d1b1:	00 00 00 
    d1b4:	e9 72 fb ff ff       	jmpq   cd2b <e1000_setup_link+0x128b>
		case e1000_ms_force_slave:
			phy_data |= CR_1000T_MS_ENABLE;
			phy_data &= ~(CR_1000T_MS_VALUE);
			break;
		case e1000_ms_auto:
			phy_data &= ~CR_1000T_MS_ENABLE;
    d1b9:	80 e6 ef             	and    $0xef,%dh
    d1bc:	66 89 55 de          	mov    %dx,-0x22(%rbp)
    d1c0:	e9 cc fb ff ff       	jmpq   cd91 <e1000_setup_link+0x12f1>
		case e1000_ms_force_master:
			phy_data |= (CR_1000T_MS_ENABLE | CR_1000T_MS_VALUE);
			break;
		case e1000_ms_force_slave:
			phy_data |= CR_1000T_MS_ENABLE;
			phy_data &= ~(CR_1000T_MS_VALUE);
    d1c5:	80 e6 f7             	and    $0xf7,%dh
    d1c8:	80 ce 10             	or     $0x10,%dh
    d1cb:	66 89 55 de          	mov    %dx,-0x22(%rbp)
    d1cf:	e9 bd fb ff ff       	jmpq   cd91 <e1000_setup_link+0x12f1>
	ret_val = e1000_detect_gig_phy(hw);
	if (ret_val) {
		e_dbg("Error, did not detect valid phy.\n");
		return ret_val;
	}
	e_dbg("Phy ID = %x\n", hw->phy_id);
    d1d4:	44 8b a3 80 00 00 00 	mov    0x80(%rbx),%r12d
    d1db:	48 89 df             	mov    %rbx,%rdi
    d1de:	e8 00 00 00 00       	callq  d1e3 <e1000_setup_link+0x1743>
    d1e3:	48 c7 c2 00 00 00 00 	mov    $0x0,%rdx
    d1ea:	48 89 c6             	mov    %rax,%rsi
    d1ed:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
    d1f4:	44 89 e1             	mov    %r12d,%ecx
    d1f7:	31 c0                	xor    %eax,%eax
    d1f9:	e8 00 00 00 00       	callq  d1fe <e1000_setup_link+0x175e>
    d1fe:	e9 3b e9 ff ff       	jmpq   bb3e <e1000_setup_link+0x9e>
	 * from the lowest speeds starting from 10Mbps. The capability is used
	 * for Dx transitions and states
	 */
	if (hw->mac_type == e1000_82541_rev_2
	    || hw->mac_type == e1000_82547_rev_2) {
		ret_val =
    d203:	4c 89 ea             	mov    %r13,%rdx
    d206:	be 14 00 00 00       	mov    $0x14,%esi
    d20b:	48 89 df             	mov    %rbx,%rdi
    d20e:	e8 00 00 00 00       	callq  d213 <e1000_setup_link+0x1773>
		    e1000_read_phy_reg(hw, IGP01E1000_GMII_FIFO, &phy_data);
		if (ret_val)
    d213:	85 c0                	test   %eax,%eax
    d215:	75 32                	jne    d249 <e1000_setup_link+0x17a9>
			return ret_val;
	}

	if (!active) {
		if (hw->mac_type == e1000_82541_rev_2 ||
    d217:	8b 43 18             	mov    0x18(%rbx),%eax
    d21a:	83 e0 fd             	and    $0xfffffffd,%eax
    d21d:	83 f8 0c             	cmp    $0xc,%eax
    d220:	0f 85 d4 fd ff ff    	jne    cffa <e1000_setup_link+0x155a>
		    hw->mac_type == e1000_82547_rev_2) {
			phy_data &= ~IGP01E1000_GMII_FLEX_SPD;
    d226:	0f b7 45 de          	movzwl -0x22(%rbp),%eax
			ret_val =
    d22a:	be 14 00 00 00       	mov    $0x14,%esi
    d22f:	48 89 df             	mov    %rbx,%rdi
	}

	if (!active) {
		if (hw->mac_type == e1000_82541_rev_2 ||
		    hw->mac_type == e1000_82547_rev_2) {
			phy_data &= ~IGP01E1000_GMII_FLEX_SPD;
    d232:	83 e0 ef             	and    $0xffffffef,%eax
			ret_val =
			    e1000_write_phy_reg(hw, IGP01E1000_GMII_FIFO,
    d235:	0f b7 d0             	movzwl %ax,%edx
	}

	if (!active) {
		if (hw->mac_type == e1000_82541_rev_2 ||
		    hw->mac_type == e1000_82547_rev_2) {
			phy_data &= ~IGP01E1000_GMII_FLEX_SPD;
    d238:	66 89 45 de          	mov    %ax,-0x22(%rbp)
			ret_val =
    d23c:	e8 00 00 00 00       	callq  d241 <e1000_setup_link+0x17a1>
			    e1000_write_phy_reg(hw, IGP01E1000_GMII_FIFO,
						phy_data);
			if (ret_val)
    d241:	85 c0                	test   %eax,%eax
    d243:	0f 84 b1 fd ff ff    	je     cffa <e1000_setup_link+0x155a>

			phy_data &= ~IGP01E1000_PSCFR_SMART_SPEED;
			ret_val =
			    e1000_write_phy_reg(hw, IGP01E1000_PHY_PORT_CONFIG,
						phy_data);
			if (ret_val)
    d249:	41 89 c4             	mov    %eax,%r12d
    d24c:	e9 dc fd ff ff       	jmpq   d02d <e1000_setup_link+0x158d>

	do {
		ret_val = e1000_write_phy_reg(hw, 29, 0x001d);
		if (ret_val)
			break;
		ret_val = e1000_write_phy_reg(hw, 30, 0x00c1);
    d251:	ba c1 00 00 00       	mov    $0xc1,%edx
    d256:	be 1e 00 00 00       	mov    $0x1e,%esi
    d25b:	48 89 df             	mov    %rbx,%rdi
    d25e:	e8 00 00 00 00       	callq  d263 <e1000_setup_link+0x17c3>
		if (ret_val)
    d263:	85 c0                	test   %eax,%eax

	do {
		ret_val = e1000_write_phy_reg(hw, 29, 0x001d);
		if (ret_val)
			break;
		ret_val = e1000_write_phy_reg(hw, 30, 0x00c1);
    d265:	41 89 c4             	mov    %eax,%r12d
		if (ret_val)
    d268:	0f 85 53 fe ff ff    	jne    d0c1 <e1000_setup_link+0x1621>
			break;
		ret_val = e1000_write_phy_reg(hw, 30, 0x0000);
    d26e:	31 d2                	xor    %edx,%edx
    d270:	be 1e 00 00 00       	mov    $0x1e,%esi
    d275:	48 89 df             	mov    %rbx,%rdi
    d278:	e8 00 00 00 00       	callq  d27d <e1000_setup_link+0x17dd>
		if (ret_val)
    d27d:	85 c0                	test   %eax,%eax
		if (ret_val)
			break;
		ret_val = e1000_write_phy_reg(hw, 30, 0x00c1);
		if (ret_val)
			break;
		ret_val = e1000_write_phy_reg(hw, 30, 0x0000);
    d27f:	41 89 c4             	mov    %eax,%r12d
		if (ret_val)
    d282:	0f 84 02 eb ff ff    	je     bd8a <e1000_setup_link+0x2ea>
    d288:	e9 34 fe ff ff       	jmpq   d0c1 <e1000_setup_link+0x1621>
		 * over-ride.
		 */
		txcw = (E1000_TXCW_ANE | E1000_TXCW_FD | E1000_TXCW_PAUSE_MASK);
		break;
	default:
		e_dbg("Flow control param set incorrectly\n");
    d28d:	48 89 df             	mov    %rbx,%rdi
		return -E1000_ERR_CONFIG;
    d290:	41 bc fd ff ff ff    	mov    $0xfffffffd,%r12d
		 * over-ride.
		 */
		txcw = (E1000_TXCW_ANE | E1000_TXCW_FD | E1000_TXCW_PAUSE_MASK);
		break;
	default:
		e_dbg("Flow control param set incorrectly\n");
    d296:	e8 00 00 00 00       	callq  d29b <e1000_setup_link+0x17fb>
    d29b:	48 c7 c2 00 00 00 00 	mov    $0x0,%rdx
    d2a2:	48 89 c6             	mov    %rax,%rsi
    d2a5:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
    d2ac:	31 c0                	xor    %eax,%eax
    d2ae:	e8 00 00 00 00       	callq  d2b3 <e1000_setup_link+0x1813>
    d2b3:	e9 aa eb ff ff       	jmpq   be62 <e1000_setup_link+0x3c2>
	 */
	if (hw->fc == E1000_FC_DEFAULT) {
		ret_val = e1000_read_eeprom(hw, EEPROM_INIT_CONTROL2_REG,
					    1, &eeprom_data);
		if (ret_val) {
			e_dbg("EEPROM Read Error\n");
    d2b8:	48 89 df             	mov    %rbx,%rdi
    d2bb:	e8 00 00 00 00       	callq  d2c0 <e1000_setup_link+0x1820>
    d2c0:	48 c7 c2 00 00 00 00 	mov    $0x0,%rdx
    d2c7:	48 89 c6             	mov    %rax,%rsi
    d2ca:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
    d2d1:	31 c0                	xor    %eax,%eax
    d2d3:	e8 00 00 00 00       	callq  d2d8 <e1000_setup_link+0x1838>
    d2d8:	e9 83 ee ff ff       	jmpq   c160 <e1000_setup_link+0x6c0>
			    e1000_read_phy_reg(hw, IGP01E1000_PHY_PORT_CONFIG,
					       &phy_data);
			if (ret_val)
				return ret_val;

			phy_data &= ~IGP01E1000_PSCFR_SMART_SPEED;
    d2dd:	0f b7 45 de          	movzwl -0x22(%rbp),%eax
    d2e1:	24 7f                	and    $0x7f,%al
			ret_val =
			    e1000_write_phy_reg(hw, IGP01E1000_PHY_PORT_CONFIG,
    d2e3:	0f b7 d0             	movzwl %ax,%edx
					       &phy_data);
			if (ret_val)
				return ret_val;

			phy_data &= ~IGP01E1000_PSCFR_SMART_SPEED;
			ret_val =
    d2e6:	be 10 00 00 00       	mov    $0x10,%esi
    d2eb:	48 89 df             	mov    %rbx,%rdi
			    e1000_read_phy_reg(hw, IGP01E1000_PHY_PORT_CONFIG,
					       &phy_data);
			if (ret_val)
				return ret_val;

			phy_data &= ~IGP01E1000_PSCFR_SMART_SPEED;
    d2ee:	66 89 45 de          	mov    %ax,-0x22(%rbp)
			ret_val =
    d2f2:	e8 00 00 00 00       	callq  d2f7 <e1000_setup_link+0x1857>
			    e1000_write_phy_reg(hw, IGP01E1000_PHY_PORT_CONFIG,
						phy_data);
			if (ret_val)
    d2f7:	85 c0                	test   %eax,%eax
    d2f9:	0f 85 4a ff ff ff    	jne    d249 <e1000_setup_link+0x17a9>
    d2ff:	e9 9c f9 ff ff       	jmpq   cca0 <e1000_setup_link+0x1200>
		 * during Dx states where the power conservation is most
		 * important.  During driver activity we should enable
		 * SmartSpeed, so performance is maintained.
		 */
		if (hw->smart_speed == e1000_smart_speed_on) {
			ret_val =
    d304:	4c 89 ea             	mov    %r13,%rdx
    d307:	be 10 00 00 00       	mov    $0x10,%esi
    d30c:	48 89 df             	mov    %rbx,%rdi
    d30f:	e8 00 00 00 00       	callq  d314 <e1000_setup_link+0x1874>
			    e1000_read_phy_reg(hw, IGP01E1000_PHY_PORT_CONFIG,
					       &phy_data);
			if (ret_val)
    d314:	85 c0                	test   %eax,%eax
		 * during Dx states where the power conservation is most
		 * important.  During driver activity we should enable
		 * SmartSpeed, so performance is maintained.
		 */
		if (hw->smart_speed == e1000_smart_speed_on) {
			ret_val =
    d316:	41 89 c4             	mov    %eax,%r12d
			    e1000_read_phy_reg(hw, IGP01E1000_PHY_PORT_CONFIG,
					       &phy_data);
			if (ret_val)
    d319:	0f 85 0e fd ff ff    	jne    d02d <e1000_setup_link+0x158d>
				return ret_val;

			phy_data |= IGP01E1000_PSCFR_SMART_SPEED;
    d31f:	0f b7 45 de          	movzwl -0x22(%rbp),%eax
    d323:	0c 80                	or     $0x80,%al
    d325:	eb bc                	jmp    d2e3 <e1000_setup_link+0x1843>
			e_dbg("e1000_copper_link_rtl_setup failed!\n");
			return ret_val;
		}
		break;
	default:
		e_dbg("Error Resetting the PHY\n");
    d327:	48 89 df             	mov    %rbx,%rdi
		return E1000_ERR_PHY_TYPE;
    d32a:	41 bc 06 00 00 00    	mov    $0x6,%r12d
			e_dbg("e1000_copper_link_rtl_setup failed!\n");
			return ret_val;
		}
		break;
	default:
		e_dbg("Error Resetting the PHY\n");
    d330:	e8 00 00 00 00       	callq  d335 <e1000_setup_link+0x1895>
    d335:	48 c7 c2 00 00 00 00 	mov    $0x0,%rdx
    d33c:	48 89 c6             	mov    %rax,%rsi
    d33f:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
    d346:	31 c0                	xor    %eax,%eax
    d348:	e8 00 00 00 00       	callq  d34d <e1000_setup_link+0x18ad>
    d34d:	e9 ce ee ff ff       	jmpq   c220 <e1000_setup_link+0x780>

	/* IFE/RTL8201N PHY only supports 10/100 */
	if (hw->phy_type == e1000_phy_8201)
		hw->autoneg_advertised &= AUTONEG_ADVERTISE_10_100_ALL;

	e_dbg("Reconfiguring auto-neg advertisement params\n");
    d352:	48 89 df             	mov    %rbx,%rdi
    d355:	e8 00 00 00 00       	callq  d35a <e1000_setup_link+0x18ba>
    d35a:	48 c7 c2 00 00 00 00 	mov    $0x0,%rdx
    d361:	48 89 c6             	mov    %rax,%rsi
    d364:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
    d36b:	31 c0                	xor    %eax,%eax
    d36d:	e8 00 00 00 00       	callq  d372 <e1000_setup_link+0x18d2>
    d372:	e9 a9 f4 ff ff       	jmpq   c820 <e1000_setup_link+0xd80>
	u16 i;

	/* Turn off Flow control if we are forcing speed and duplex. */
	hw->fc = E1000_FC_NONE;

	e_dbg("hw->fc = %d\n", hw->fc);
    d377:	48 89 df             	mov    %rbx,%rdi
    d37a:	e8 00 00 00 00       	callq  d37f <e1000_setup_link+0x18df>
    d37f:	31 c9                	xor    %ecx,%ecx
    d381:	48 89 c6             	mov    %rax,%rsi
    d384:	48 c7 c2 00 00 00 00 	mov    $0x0,%rdx
    d38b:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
    d392:	31 c0                	xor    %eax,%eax
    d394:	e8 00 00 00 00       	callq  d399 <e1000_setup_link+0x18f9>
    d399:	e9 22 e8 ff ff       	jmpq   bbc0 <e1000_setup_link+0x120>
	 * only if the user has set wait_autoneg_complete to 1, which is
	 * the default.
	 */
	if (hw->wait_autoneg_complete) {
		/* We will wait for autoneg to complete. */
		e_dbg("Waiting for forced speed/duplex link.\n");
    d39e:	48 89 df             	mov    %rbx,%rdi
    d3a1:	e8 00 00 00 00       	callq  d3a6 <e1000_setup_link+0x1906>
    d3a6:	48 c7 c2 00 00 00 00 	mov    $0x0,%rdx
    d3ad:	48 89 c6             	mov    %rax,%rsi
    d3b0:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
    d3b7:	31 c0                	xor    %eax,%eax
    d3b9:	e8 00 00 00 00       	callq  d3be <e1000_setup_link+0x191e>
    d3be:	e9 63 e9 ff ff       	jmpq   bd26 <e1000_setup_link+0x286>
		ret_val =
		    e1000_write_phy_reg(hw, M88E1000_PHY_SPEC_CTRL, phy_data);
		if (ret_val)
			return ret_val;

		e_dbg("M88E1000 PSCR: %x\n", phy_data);
    d3c3:	44 0f b7 65 de       	movzwl -0x22(%rbp),%r12d
    d3c8:	48 89 df             	mov    %rbx,%rdi
    d3cb:	e8 00 00 00 00       	callq  d3d0 <e1000_setup_link+0x1930>
    d3d0:	48 c7 c2 00 00 00 00 	mov    $0x0,%rdx
    d3d7:	48 89 c6             	mov    %rax,%rsi
    d3da:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
    d3e1:	31 c0                	xor    %eax,%eax
    d3e3:	44 89 e1             	mov    %r12d,%ecx
    d3e6:	e8 00 00 00 00       	callq  d3eb <e1000_setup_link+0x194b>
    d3eb:	e9 ee e8 ff ff       	jmpq   bcde <e1000_setup_link+0x23e>
			status = er32(STATUS);
			if (status & E1000_STATUS_LU)
				break;
		}
		if (i == (LINK_UP_TIMEOUT / 10)) {
			e_dbg("Never got a valid link from auto-neg!!!\n");
    d3f0:	48 89 df             	mov    %rbx,%rdi
    d3f3:	e8 00 00 00 00       	callq  d3f8 <e1000_setup_link+0x1958>
    d3f8:	48 c7 c2 00 00 00 00 	mov    $0x0,%rdx
    d3ff:	48 89 c6             	mov    %rax,%rsi
    d402:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
    d409:	31 c0                	xor    %eax,%eax
    d40b:	e8 00 00 00 00       	callq  d410 <e1000_setup_link+0x1970>
    d410:	e9 d1 f6 ff ff       	jmpq   cae6 <e1000_setup_link+0x1046>
			return ret_val;
		}
	}
	ret_val = e1000_config_fc_after_link_up(hw);
	if (ret_val) {
		e_dbg("Error Configuring Flow Control\n");
    d415:	48 89 df             	mov    %rbx,%rdi
    d418:	45 89 ec             	mov    %r13d,%r12d
    d41b:	e8 00 00 00 00       	callq  d420 <e1000_setup_link+0x1980>
    d420:	48 c7 c2 00 00 00 00 	mov    $0x0,%rdx
    d427:	48 89 c6             	mov    %rax,%rsi
    d42a:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
    d431:	31 c0                	xor    %eax,%eax
    d433:	e8 00 00 00 00       	callq  d438 <e1000_setup_link+0x1998>
    d438:	e9 25 ea ff ff       	jmpq   be62 <e1000_setup_link+0x3c2>

	if ((match) && (phy_init_status == E1000_SUCCESS)) {
		e_dbg("PHY ID 0x%X detected\n", hw->phy_id);
		return E1000_SUCCESS;
	}
	e_dbg("Invalid PHY ID 0x%X\n", hw->phy_id);
    d43d:	48 89 df             	mov    %rbx,%rdi
    d440:	e8 00 00 00 00       	callq  d445 <e1000_setup_link+0x19a5>
    d445:	44 89 e1             	mov    %r12d,%ecx
    d448:	48 89 c6             	mov    %rax,%rsi
    d44b:	48 c7 c2 00 00 00 00 	mov    $0x0,%rdx
    d452:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
    d459:	31 c0                	xor    %eax,%eax
	return -E1000_ERR_PHY;
    d45b:	41 bc fe ff ff ff    	mov    $0xfffffffe,%r12d

	if ((match) && (phy_init_status == E1000_SUCCESS)) {
		e_dbg("PHY ID 0x%X detected\n", hw->phy_id);
		return E1000_SUCCESS;
	}
	e_dbg("Invalid PHY ID 0x%X\n", hw->phy_id);
    d461:	e8 00 00 00 00       	callq  d466 <e1000_setup_link+0x19c6>
    d466:	e9 9b ec ff ff       	jmpq   c106 <e1000_setup_link+0x666>
	 * it in SW). For internal serdes, we just assume a signal is present,
	 * then poll.
	 */
	if (hw->media_type == e1000_media_type_internal_serdes ||
	    (er32(CTRL) & E1000_CTRL_SWDPIN1) == signal) {
		e_dbg("Looking for Link\n");
    d46b:	48 89 df             	mov    %rbx,%rdi
    d46e:	e8 00 00 00 00       	callq  d473 <e1000_setup_link+0x19d3>
    d473:	48 c7 c2 00 00 00 00 	mov    $0x0,%rdx
    d47a:	48 89 c6             	mov    %rax,%rsi
    d47d:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
    d484:	31 c0                	xor    %eax,%eax
    d486:	e8 00 00 00 00       	callq  d48b <e1000_setup_link+0x19eb>
    d48b:	e9 e2 f3 ff ff       	jmpq   c872 <e1000_setup_link+0xdd2>
			return ret_val;
	} else {
		/* PHY will be set to 10H, 10F, 100H,or 100F
		 * depending on value from forced_speed_duplex.
		 */
		e_dbg("Forcing speed and duplex\n");
    d490:	48 89 df             	mov    %rbx,%rdi
    d493:	e8 00 00 00 00       	callq  d498 <e1000_setup_link+0x19f8>
    d498:	48 c7 c2 00 00 00 00 	mov    $0x0,%rdx
    d49f:	48 89 c6             	mov    %rax,%rsi
    d4a2:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
    d4a9:	31 c0                	xor    %eax,%eax
    d4ab:	e8 00 00 00 00       	callq  d4b0 <e1000_setup_link+0x1a10>
    d4b0:	e9 f7 e6 ff ff       	jmpq   bbac <e1000_setup_link+0x10c>
	} else {
		/* Set the 10Mb bit and turn off the 1000Mb and 100Mb bits. */
		ctrl &= ~(E1000_CTRL_SPD_1000 | E1000_CTRL_SPD_100);
		mii_ctrl_reg |= MII_CR_SPEED_10;
		mii_ctrl_reg &= ~(MII_CR_SPEED_1000 | MII_CR_SPEED_100);
		e_dbg("Forcing 10mb ");
    d4b5:	48 89 df             	mov    %rbx,%rdi
    d4b8:	e8 00 00 00 00       	callq  d4bd <e1000_setup_link+0x1a1d>
    d4bd:	48 c7 c2 00 00 00 00 	mov    $0x0,%rdx
    d4c4:	48 89 c6             	mov    %rax,%rsi
    d4c7:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
    d4ce:	31 c0                	xor    %eax,%eax
    d4d0:	e8 00 00 00 00       	callq  d4d5 <e1000_setup_link+0x1a35>
    d4d5:	e9 71 e7 ff ff       	jmpq   bc4b <e1000_setup_link+0x1ab>
	 * link will be in reset, because we previously reset the chip). This
	 * will restart auto-negotiation.  If auto-negotiation is successful
	 * then the link-up status bit will be set and the flow control enable
	 * bits (RFCE and TFCE) will be set according to their negotiated value.
	 */
	e_dbg("Auto-negotiation enabled\n");
    d4da:	48 89 df             	mov    %rbx,%rdi
    d4dd:	e8 00 00 00 00       	callq  d4e2 <e1000_setup_link+0x1a42>
    d4e2:	48 c7 c2 00 00 00 00 	mov    $0x0,%rdx
    d4e9:	48 89 c6             	mov    %rax,%rsi
    d4ec:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
    d4f3:	31 c0                	xor    %eax,%eax
    d4f5:	e8 00 00 00 00       	callq  d4fa <e1000_setup_link+0x1a5a>
    d4fa:	e9 6c f0 ff ff       	jmpq   c56b <e1000_setup_link+0xacb>
		} else {
			hw->autoneg_failed = 0;
			e_dbg("Valid Link Found\n");
		}
	} else {
		e_dbg("No Signal Detected\n");
    d4ff:	48 89 df             	mov    %rbx,%rdi
    d502:	e8 00 00 00 00       	callq  d507 <e1000_setup_link+0x1a67>
    d507:	48 c7 c2 00 00 00 00 	mov    $0x0,%rdx
    d50e:	48 89 c6             	mov    %rax,%rsi
    d511:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
    d518:	31 c0                	xor    %eax,%eax
    d51a:	e8 00 00 00 00       	callq  d51f <e1000_setup_link+0x1a7f>
    d51f:	e9 9c f0 ff ff       	jmpq   c5c0 <e1000_setup_link+0xb20>
{
	s32 ret_val;
	u16 i;
	u16 phy_data;

	e_dbg("Waiting for Auto-Neg to complete.\n");
    d524:	48 89 df             	mov    %rbx,%rdi
    d527:	e8 00 00 00 00       	callq  d52c <e1000_setup_link+0x1a8c>
    d52c:	48 c7 c2 00 00 00 00 	mov    $0x0,%rdx
    d533:	48 89 c6             	mov    %rax,%rsi
    d536:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
    d53d:	31 c0                	xor    %eax,%eax
    d53f:	e8 00 00 00 00       	callq  d544 <e1000_setup_link+0x1aa4>
    d544:	e9 88 f9 ff ff       	jmpq   ced1 <e1000_setup_link+0x1431>
	ret_val = e1000_phy_setup_autoneg(hw);
	if (ret_val) {
		e_dbg("Error Setting up Auto-Negotiation\n");
		return ret_val;
	}
	e_dbg("Restarting Auto-Neg\n");
    d549:	48 89 df             	mov    %rbx,%rdi
    d54c:	e8 00 00 00 00       	callq  d551 <e1000_setup_link+0x1ab1>
    d551:	48 c7 c2 00 00 00 00 	mov    $0x0,%rdx
    d558:	48 89 c6             	mov    %rax,%rsi
    d55b:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
    d562:	31 c0                	xor    %eax,%eax
    d564:	e8 00 00 00 00       	callq  d569 <e1000_setup_link+0x1ac9>
    d569:	e9 51 f4 ff ff       	jmpq   c9bf <e1000_setup_link+0xf1f>
	case e1000_82547_rev_2:
		if (hw->phy_id == IGP01E1000_I_PHY_ID)
			match = true;
		break;
	default:
		e_dbg("Invalid MAC type %d\n", hw->mac_type);
    d56e:	48 89 df             	mov    %rbx,%rdi
		return -E1000_ERR_CONFIG;
    d571:	41 bc fd ff ff ff    	mov    $0xfffffffd,%r12d
	case e1000_82547_rev_2:
		if (hw->phy_id == IGP01E1000_I_PHY_ID)
			match = true;
		break;
	default:
		e_dbg("Invalid MAC type %d\n", hw->mac_type);
    d577:	e8 00 00 00 00       	callq  d57c <e1000_setup_link+0x1adc>
    d57c:	44 89 e9             	mov    %r13d,%ecx
    d57f:	48 89 c6             	mov    %rax,%rsi
    d582:	48 c7 c2 00 00 00 00 	mov    $0x0,%rdx
    d589:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
    d590:	31 c0                	xor    %eax,%eax
    d592:	e8 00 00 00 00       	callq  d597 <e1000_setup_link+0x1af7>
    d597:	e9 6a eb ff ff       	jmpq   c106 <e1000_setup_link+0x666>
		/* We want to force half duplex so we CLEAR the full duplex bits
		 * in the Device and MII Control Registers.
		 */
		ctrl &= ~E1000_CTRL_FD;
		mii_ctrl_reg &= ~MII_CR_FULL_DUPLEX;
		e_dbg("Half Duplex\n");
    d59c:	48 89 df             	mov    %rbx,%rdi
    d59f:	e8 00 00 00 00       	callq  d5a4 <e1000_setup_link+0x1b04>
    d5a4:	48 c7 c2 00 00 00 00 	mov    $0x0,%rdx
    d5ab:	48 89 c6             	mov    %rax,%rsi
    d5ae:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
    d5b5:	31 c0                	xor    %eax,%eax
    d5b7:	e8 00 00 00 00       	callq  d5bc <e1000_setup_link+0x1b1c>
    d5bc:	0f b6 83 f1 00 00 00 	movzbl 0xf1(%rbx),%eax
    d5c3:	0f b7 4d da          	movzwl -0x26(%rbp),%ecx
    d5c7:	e9 57 e6 ff ff       	jmpq   bc23 <e1000_setup_link+0x183>
    d5cc:	0f 1f 40 00          	nopl   0x0(%rax)

000000000000d5d0 <e1000_init_eeprom_params>:
 *
 * Sets up eeprom variables in the hw struct.  Must be called after mac_type
 * is configured.
 */
s32 e1000_init_eeprom_params(struct e1000_hw *hw)
{
    d5d0:	e8 00 00 00 00       	callq  d5d5 <e1000_init_eeprom_params+0x5>
    d5d5:	55                   	push   %rbp
    d5d6:	48 89 e5             	mov    %rsp,%rbp
    d5d9:	53                   	push   %rbx
    d5da:	48 89 fb             	mov    %rdi,%rbx
    d5dd:	48 83 ec 08          	sub    $0x8,%rsp
	struct e1000_eeprom_info *eeprom = &hw->eeprom;
	u32 eecd = er32(EECD);
    d5e1:	48 8b 07             	mov    (%rdi),%rax
{ asm volatile("mov" size " %0,%1": :reg (val), \
"m" (*(volatile type __force *)addr) barrier); }

build_mmio_read(readb, "b", unsigned char, "=q", :"memory")
build_mmio_read(readw, "w", unsigned short, "=r", :"memory")
build_mmio_read(readl, "l", unsigned int, "=r", :"memory")
    d5e4:	8b 50 10             	mov    0x10(%rax),%edx
    d5e7:	8b 47 18             	mov    0x18(%rdi),%eax
    d5ea:	8d 48 ff             	lea    -0x1(%rax),%ecx
    d5ed:	83 f9 0d             	cmp    $0xd,%ecx
    d5f0:	77 58                	ja     d64a <e1000_init_eeprom_params+0x7a>
    d5f2:	b8 01 00 00 00       	mov    $0x1,%eax
    d5f7:	48 d3 e0             	shl    %cl,%rax
    d5fa:	a9 f0 02 00 00       	test   $0x2f0,%eax
    d5ff:	0f 85 99 00 00 00    	jne    d69e <e1000_init_eeprom_params+0xce>
    d605:	f6 c4 3c             	test   $0x3c,%ah
    d608:	0f 85 fa 00 00 00    	jne    d708 <e1000_init_eeprom_params+0x138>
    d60e:	a8 0f                	test   $0xf,%al
    d610:	74 38                	je     d64a <e1000_init_eeprom_params+0x7a>
	case e1000_82542_rev2_0:
	case e1000_82542_rev2_1:
	case e1000_82543:
	case e1000_82544:
		eeprom->type = e1000_eeprom_microwire;
		eeprom->word_size = 64;
    d612:	be 40 00 00 00       	mov    $0x40,%esi
	switch (hw->mac_type) {
	case e1000_82542_rev2_0:
	case e1000_82542_rev2_1:
	case e1000_82543:
	case e1000_82544:
		eeprom->type = e1000_eeprom_microwire;
    d617:	c7 47 50 02 00 00 00 	movl   $0x2,0x50(%rdi)
		eeprom->word_size = 64;
		eeprom->opcode_bits = 3;
		eeprom->address_bits = 6;
    d61e:	41 b8 06 00 00 00    	mov    $0x6,%r8d
	case e1000_82542_rev2_0:
	case e1000_82542_rev2_1:
	case e1000_82543:
	case e1000_82544:
		eeprom->type = e1000_eeprom_microwire;
		eeprom->word_size = 64;
    d624:	66 89 77 54          	mov    %si,0x54(%rdi)
		eeprom->opcode_bits = 3;
		eeprom->address_bits = 6;
		eeprom->delay_usec = 50;
    d628:	41 b9 32 00 00 00    	mov    $0x32,%r9d
	case e1000_82542_rev2_1:
	case e1000_82543:
	case e1000_82544:
		eeprom->type = e1000_eeprom_microwire;
		eeprom->word_size = 64;
		eeprom->opcode_bits = 3;
    d62e:	bf 03 00 00 00       	mov    $0x3,%edi
    d633:	66 89 7b 56          	mov    %di,0x56(%rbx)
		eeprom->address_bits = 6;
    d637:	66 44 89 43 58       	mov    %r8w,0x58(%rbx)
		eeprom->delay_usec = 50;
    d63c:	66 44 89 4b 5a       	mov    %r9w,0x5a(%rbx)
 */
s32 e1000_init_eeprom_params(struct e1000_hw *hw)
{
	struct e1000_eeprom_info *eeprom = &hw->eeprom;
	u32 eecd = er32(EECD);
	s32 ret_val = E1000_SUCCESS;
    d641:	31 c0                	xor    %eax,%eax
			eeprom_size++;

		eeprom->word_size = 1 << (eeprom_size + EEPROM_WORD_SIZE_SHIFT);
	}
	return ret_val;
}
    d643:	48 83 c4 08          	add    $0x8,%rsp
    d647:	5b                   	pop    %rbx
    d648:	5d                   	pop    %rbp
    d649:	c3                   	retq   
		break;
	default:
		break;
	}

	if (eeprom->type == e1000_eeprom_spi) {
    d64a:	83 7b 50 01          	cmpl   $0x1,0x50(%rbx)
    d64e:	75 f1                	jne    d641 <e1000_init_eeprom_params+0x71>
		/* eeprom_size will be an enum [0..8] that maps to eeprom sizes
		 * 128B to 32KB (incremented by powers of 2).
		 */
		/* Set to default value for initial eeprom read. */
		eeprom->word_size = 64;
    d650:	b8 40 00 00 00       	mov    $0x40,%eax
		ret_val = e1000_read_eeprom(hw, EEPROM_CFG, 1, &eeprom_size);
    d655:	48 8d 4d f6          	lea    -0xa(%rbp),%rcx
    d659:	ba 01 00 00 00       	mov    $0x1,%edx
	if (eeprom->type == e1000_eeprom_spi) {
		/* eeprom_size will be an enum [0..8] that maps to eeprom sizes
		 * 128B to 32KB (incremented by powers of 2).
		 */
		/* Set to default value for initial eeprom read. */
		eeprom->word_size = 64;
    d65e:	66 89 43 54          	mov    %ax,0x54(%rbx)
		ret_val = e1000_read_eeprom(hw, EEPROM_CFG, 1, &eeprom_size);
    d662:	be 12 00 00 00       	mov    $0x12,%esi
    d667:	48 89 df             	mov    %rbx,%rdi
    d66a:	e8 00 00 00 00       	callq  d66f <e1000_init_eeprom_params+0x9f>
		if (ret_val)
    d66f:	85 c0                	test   %eax,%eax
    d671:	75 d0                	jne    d643 <e1000_init_eeprom_params+0x73>
			return ret_val;
		eeprom_size =
		    (eeprom_size & EEPROM_SIZE_MASK) >> EEPROM_SIZE_SHIFT;
    d673:	0f b7 55 f6          	movzwl -0xa(%rbp),%edx
    d677:	31 c9                	xor    %ecx,%ecx
    d679:	81 e2 00 1c 00 00    	and    $0x1c00,%edx
    d67f:	c1 fa 0a             	sar    $0xa,%edx
		/* 256B eeprom size was not supported in earlier hardware, so we
		 * bump eeprom_size up one to ensure that "1" (which maps to
		 * 256B) is never the result used in the shifting logic below.
		 */
		if (eeprom_size)
			eeprom_size++;
    d682:	8d 72 01             	lea    0x1(%rdx),%esi
    d685:	66 85 d2             	test   %dx,%dx

		eeprom->word_size = 1 << (eeprom_size + EEPROM_WORD_SIZE_SHIFT);
    d688:	ba 01 00 00 00       	mov    $0x1,%edx
		/* 256B eeprom size was not supported in earlier hardware, so we
		 * bump eeprom_size up one to ensure that "1" (which maps to
		 * 256B) is never the result used in the shifting logic below.
		 */
		if (eeprom_size)
			eeprom_size++;
    d68d:	0f 45 ce             	cmovne %esi,%ecx

		eeprom->word_size = 1 << (eeprom_size + EEPROM_WORD_SIZE_SHIFT);
    d690:	0f b7 c9             	movzwl %cx,%ecx
    d693:	83 c1 06             	add    $0x6,%ecx
    d696:	d3 e2                	shl    %cl,%edx
    d698:	66 89 53 54          	mov    %dx,0x54(%rbx)
    d69c:	eb a5                	jmp    d643 <e1000_init_eeprom_params+0x73>
	case e1000_82545:
	case e1000_82545_rev_3:
	case e1000_82546:
	case e1000_82546_rev_3:
		eeprom->type = e1000_eeprom_microwire;
		eeprom->opcode_bits = 3;
    d69e:	b8 03 00 00 00       	mov    $0x3,%eax
		eeprom->delay_usec = 50;
    d6a3:	b9 32 00 00 00       	mov    $0x32,%ecx
		if (eecd & E1000_EECD_SIZE) {
    d6a8:	80 e6 02             	and    $0x2,%dh
	case e1000_82540:
	case e1000_82545:
	case e1000_82545_rev_3:
	case e1000_82546:
	case e1000_82546_rev_3:
		eeprom->type = e1000_eeprom_microwire;
    d6ab:	c7 47 50 02 00 00 00 	movl   $0x2,0x50(%rdi)
		eeprom->opcode_bits = 3;
    d6b2:	66 89 47 56          	mov    %ax,0x56(%rdi)
		eeprom->delay_usec = 50;
    d6b6:	66 89 4f 5a          	mov    %cx,0x5a(%rdi)
		if (eecd & E1000_EECD_SIZE) {
    d6ba:	74 35                	je     d6f1 <e1000_init_eeprom_params+0x121>
			eeprom->word_size = 256;
    d6bc:	b8 00 01 00 00       	mov    $0x100,%eax
    d6c1:	66 89 43 54          	mov    %ax,0x54(%rbx)
			eeprom->address_bits = 8;
    d6c5:	b8 08 00 00 00       	mov    $0x8,%eax
    d6ca:	66 89 43 58          	mov    %ax,0x58(%rbx)
    d6ce:	e9 6e ff ff ff       	jmpq   d641 <e1000_init_eeprom_params+0x71>
				eeprom->page_size = 8;
				eeprom->address_bits = 8;
			}
		} else {
			eeprom->type = e1000_eeprom_microwire;
			eeprom->opcode_bits = 3;
    d6d3:	b9 03 00 00 00       	mov    $0x3,%ecx
			eeprom->delay_usec = 50;
    d6d8:	be 32 00 00 00       	mov    $0x32,%esi
			if (eecd & E1000_EECD_ADDR_BITS) {
    d6dd:	80 e6 04             	and    $0x4,%dh
			} else {
				eeprom->page_size = 8;
				eeprom->address_bits = 8;
			}
		} else {
			eeprom->type = e1000_eeprom_microwire;
    d6e0:	c7 47 50 02 00 00 00 	movl   $0x2,0x50(%rdi)
			eeprom->opcode_bits = 3;
    d6e7:	66 89 4f 56          	mov    %cx,0x56(%rdi)
			eeprom->delay_usec = 50;
    d6eb:	66 89 77 5a          	mov    %si,0x5a(%rdi)
			if (eecd & E1000_EECD_ADDR_BITS) {
    d6ef:	75 cb                	jne    d6bc <e1000_init_eeprom_params+0xec>
		eeprom->delay_usec = 50;
		if (eecd & E1000_EECD_SIZE) {
			eeprom->word_size = 256;
			eeprom->address_bits = 8;
		} else {
			eeprom->word_size = 64;
    d6f1:	b8 40 00 00 00       	mov    $0x40,%eax
    d6f6:	66 89 43 54          	mov    %ax,0x54(%rbx)
			eeprom->address_bits = 6;
    d6fa:	b8 06 00 00 00       	mov    $0x6,%eax
    d6ff:	66 89 43 58          	mov    %ax,0x58(%rbx)
    d703:	e9 39 ff ff ff       	jmpq   d641 <e1000_init_eeprom_params+0x71>
		break;
	case e1000_82541:
	case e1000_82541_rev_2:
	case e1000_82547:
	case e1000_82547_rev_2:
		if (eecd & E1000_EECD_TYPE) {
    d708:	f6 c6 20             	test   $0x20,%dh
    d70b:	74 c6                	je     d6d3 <e1000_init_eeprom_params+0x103>
			eeprom->type = e1000_eeprom_spi;
			eeprom->opcode_bits = 8;
    d70d:	41 bb 08 00 00 00    	mov    $0x8,%r11d
			eeprom->delay_usec = 1;
    d713:	b8 01 00 00 00       	mov    $0x1,%eax
			if (eecd & E1000_EECD_ADDR_BITS) {
    d718:	80 e6 04             	and    $0x4,%dh
	case e1000_82541:
	case e1000_82541_rev_2:
	case e1000_82547:
	case e1000_82547_rev_2:
		if (eecd & E1000_EECD_TYPE) {
			eeprom->type = e1000_eeprom_spi;
    d71b:	c7 47 50 01 00 00 00 	movl   $0x1,0x50(%rdi)
			eeprom->opcode_bits = 8;
    d722:	66 44 89 5f 56       	mov    %r11w,0x56(%rdi)
			eeprom->delay_usec = 1;
    d727:	66 89 47 5a          	mov    %ax,0x5a(%rdi)
			if (eecd & E1000_EECD_ADDR_BITS) {
    d72b:	74 1b                	je     d748 <e1000_init_eeprom_params+0x178>
				eeprom->page_size = 32;
    d72d:	41 b9 20 00 00 00    	mov    $0x20,%r9d
				eeprom->address_bits = 16;
    d733:	41 ba 10 00 00 00    	mov    $0x10,%r10d
		if (eecd & E1000_EECD_TYPE) {
			eeprom->type = e1000_eeprom_spi;
			eeprom->opcode_bits = 8;
			eeprom->delay_usec = 1;
			if (eecd & E1000_EECD_ADDR_BITS) {
				eeprom->page_size = 32;
    d739:	66 44 89 4f 5c       	mov    %r9w,0x5c(%rdi)
				eeprom->address_bits = 16;
    d73e:	66 44 89 57 58       	mov    %r10w,0x58(%rdi)
    d743:	e9 08 ff ff ff       	jmpq   d650 <e1000_init_eeprom_params+0x80>
			} else {
				eeprom->page_size = 8;
    d748:	bf 08 00 00 00       	mov    $0x8,%edi
				eeprom->address_bits = 8;
    d74d:	41 b8 08 00 00 00    	mov    $0x8,%r8d
			eeprom->delay_usec = 1;
			if (eecd & E1000_EECD_ADDR_BITS) {
				eeprom->page_size = 32;
				eeprom->address_bits = 16;
			} else {
				eeprom->page_size = 8;
    d753:	66 89 7b 5c          	mov    %di,0x5c(%rbx)
				eeprom->address_bits = 8;
    d757:	66 44 89 43 58       	mov    %r8w,0x58(%rbx)
    d75c:	e9 ef fe ff ff       	jmpq   d650 <e1000_init_eeprom_params+0x80>
    d761:	66 66 66 66 66 66 2e 	data32 data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
    d768:	0f 1f 84 00 00 00 00 
    d76f:	00 

000000000000d770 <e1000_validate_eeprom_checksum>:
 * Reads the first 64 16 bit words of the EEPROM and sums the values read.
 * If the the sum of the 64 16 bit words is 0xBABA, the EEPROM's checksum is
 * valid.
 */
s32 e1000_validate_eeprom_checksum(struct e1000_hw *hw)
{
    d770:	e8 00 00 00 00       	callq  d775 <e1000_validate_eeprom_checksum+0x5>
    d775:	55                   	push   %rbp
    d776:	48 89 e5             	mov    %rsp,%rbp
    d779:	41 55                	push   %r13
    d77b:	49 89 fd             	mov    %rdi,%r13
    d77e:	41 54                	push   %r12
	u16 checksum = 0;
    d780:	45 31 e4             	xor    %r12d,%r12d
 * Reads the first 64 16 bit words of the EEPROM and sums the values read.
 * If the the sum of the 64 16 bit words is 0xBABA, the EEPROM's checksum is
 * valid.
 */
s32 e1000_validate_eeprom_checksum(struct e1000_hw *hw)
{
    d783:	53                   	push   %rbx
    d784:	31 db                	xor    %ebx,%ebx
    d786:	48 83 ec 08          	sub    $0x8,%rsp
    d78a:	eb 0d                	jmp    d799 <e1000_validate_eeprom_checksum+0x29>
    d78c:	83 c3 01             	add    $0x1,%ebx
	for (i = 0; i < (EEPROM_CHECKSUM_REG + 1); i++) {
		if (e1000_read_eeprom(hw, i, 1, &eeprom_data) < 0) {
			e_dbg("EEPROM Read Error\n");
			return -E1000_ERR_EEPROM;
		}
		checksum += eeprom_data;
    d78f:	66 44 03 65 e6       	add    -0x1a(%rbp),%r12w
s32 e1000_validate_eeprom_checksum(struct e1000_hw *hw)
{
	u16 checksum = 0;
	u16 i, eeprom_data;

	for (i = 0; i < (EEPROM_CHECKSUM_REG + 1); i++) {
    d794:	83 fb 40             	cmp    $0x40,%ebx
    d797:	74 30                	je     d7c9 <e1000_validate_eeprom_checksum+0x59>
		if (e1000_read_eeprom(hw, i, 1, &eeprom_data) < 0) {
    d799:	48 8d 4d e6          	lea    -0x1a(%rbp),%rcx
    d79d:	ba 01 00 00 00       	mov    $0x1,%edx
    d7a2:	89 de                	mov    %ebx,%esi
    d7a4:	4c 89 ef             	mov    %r13,%rdi
    d7a7:	e8 00 00 00 00       	callq  d7ac <e1000_validate_eeprom_checksum+0x3c>
    d7ac:	85 c0                	test   %eax,%eax
    d7ae:	79 dc                	jns    d78c <e1000_validate_eeprom_checksum+0x1c>
			e_dbg("EEPROM Read Error\n");
    d7b0:	f6 05 00 00 00 00 04 	testb  $0x4,0x0(%rip)        # d7b7 <e1000_validate_eeprom_checksum+0x47>
    d7b7:	75 4c                	jne    d805 <e1000_validate_eeprom_checksum+0x95>
			return -E1000_ERR_EEPROM;
    d7b9:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
		return E1000_SUCCESS;
	else {
		e_dbg("EEPROM Checksum Invalid\n");
		return -E1000_ERR_EEPROM;
	}
}
    d7be:	48 83 c4 08          	add    $0x8,%rsp
    d7c2:	5b                   	pop    %rbx
    d7c3:	41 5c                	pop    %r12
    d7c5:	41 5d                	pop    %r13
    d7c7:	5d                   	pop    %rbp
    d7c8:	c3                   	retq   
	/* This is a signature and not a checksum on HP c8000 */
	if ((hw->subsystem_vendor_id == 0x103C) && (eeprom_data == 0x16d6))
		return E1000_SUCCESS;

#endif
	if (checksum == (u16) EEPROM_SUM)
    d7c9:	66 41 81 fc ba ba    	cmp    $0xbaba,%r12w
    d7cf:	74 30                	je     d801 <e1000_validate_eeprom_checksum+0x91>
		return E1000_SUCCESS;
	else {
		e_dbg("EEPROM Checksum Invalid\n");
    d7d1:	f6 05 00 00 00 00 04 	testb  $0x4,0x0(%rip)        # d7d8 <e1000_validate_eeprom_checksum+0x68>
    d7d8:	74 df                	je     d7b9 <e1000_validate_eeprom_checksum+0x49>
    d7da:	4c 89 ef             	mov    %r13,%rdi
    d7dd:	e8 00 00 00 00       	callq  d7e2 <e1000_validate_eeprom_checksum+0x72>
    d7e2:	48 c7 c2 00 00 00 00 	mov    $0x0,%rdx
    d7e9:	48 89 c6             	mov    %rax,%rsi
    d7ec:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
    d7f3:	31 c0                	xor    %eax,%eax
    d7f5:	e8 00 00 00 00       	callq  d7fa <e1000_validate_eeprom_checksum+0x8a>
		return -E1000_ERR_EEPROM;
    d7fa:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
    d7ff:	eb bd                	jmp    d7be <e1000_validate_eeprom_checksum+0x4e>
	if ((hw->subsystem_vendor_id == 0x103C) && (eeprom_data == 0x16d6))
		return E1000_SUCCESS;

#endif
	if (checksum == (u16) EEPROM_SUM)
		return E1000_SUCCESS;
    d801:	31 c0                	xor    %eax,%eax
    d803:	eb b9                	jmp    d7be <e1000_validate_eeprom_checksum+0x4e>
	u16 checksum = 0;
	u16 i, eeprom_data;

	for (i = 0; i < (EEPROM_CHECKSUM_REG + 1); i++) {
		if (e1000_read_eeprom(hw, i, 1, &eeprom_data) < 0) {
			e_dbg("EEPROM Read Error\n");
    d805:	4c 89 ef             	mov    %r13,%rdi
    d808:	e8 00 00 00 00       	callq  d80d <e1000_validate_eeprom_checksum+0x9d>
    d80d:	48 c7 c2 00 00 00 00 	mov    $0x0,%rdx
    d814:	48 89 c6             	mov    %rax,%rsi
    d817:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
    d81e:	31 c0                	xor    %eax,%eax
    d820:	e8 00 00 00 00       	callq  d825 <e1000_validate_eeprom_checksum+0xb5>
			return -E1000_ERR_EEPROM;
    d825:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
    d82a:	eb 92                	jmp    d7be <e1000_validate_eeprom_checksum+0x4e>
    d82c:	0f 1f 40 00          	nopl   0x0(%rax)

000000000000d830 <e1000_write_eeprom>:
 *
 * If e1000_update_eeprom_checksum is not called after this function, the
 * EEPROM will most likely contain an invalid checksum.
 */
s32 e1000_write_eeprom(struct e1000_hw *hw, u16 offset, u16 words, u16 *data)
{
    d830:	e8 00 00 00 00       	callq  d835 <e1000_write_eeprom+0x5>
    d835:	55                   	push   %rbp
    d836:	48 89 e5             	mov    %rsp,%rbp
    d839:	41 57                	push   %r15
    d83b:	41 56                	push   %r14
    d83d:	49 89 ce             	mov    %rcx,%r14
    d840:	41 55                	push   %r13
    d842:	41 89 d5             	mov    %edx,%r13d
    d845:	41 54                	push   %r12
    d847:	53                   	push   %rbx
    d848:	48 89 fb             	mov    %rdi,%rbx
    d84b:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
    d852:	48 83 ec 10          	sub    $0x10,%rsp
    d856:	66 89 75 ce          	mov    %si,-0x32(%rbp)
    d85a:	89 75 d0             	mov    %esi,-0x30(%rbp)
    d85d:	89 55 d4             	mov    %edx,-0x2c(%rbp)
    d860:	e8 00 00 00 00       	callq  d865 <e1000_write_eeprom+0x35>
				 u16 *data)
{
	struct e1000_eeprom_info *eeprom = &hw->eeprom;
	s32 status = 0;

	if (hw->mac_type == e1000_ce4100) {
    d865:	83 7b 18 09          	cmpl   $0x9,0x18(%rbx)
    d869:	44 8b 4d d4          	mov    -0x2c(%rbp),%r9d
    d86d:	44 8b 45 d0          	mov    -0x30(%rbp),%r8d
    d871:	0f 84 57 01 00 00    	je     d9ce <e1000_write_eeprom+0x19e>
	}

	/* A check for invalid values:  offset too large, too many words, and
	 * not enough words.
	 */
	if ((offset >= eeprom->word_size)
    d877:	0f b7 43 54          	movzwl 0x54(%rbx),%eax
    d87b:	66 41 39 c0          	cmp    %ax,%r8w
    d87f:	72 31                	jb     d8b2 <e1000_write_eeprom+0x82>
	    || (words > eeprom->word_size - offset) || (words == 0)) {
		e_dbg("\"words\" parameter out of bounds\n");
    d881:	f6 05 00 00 00 00 04 	testb  $0x4,0x0(%rip)        # d888 <e1000_write_eeprom+0x58>
    d888:	0f 85 6b 02 00 00    	jne    daf9 <e1000_write_eeprom+0x2c9>
		return -E1000_ERR_EEPROM;
    d88e:	ba ff ff ff ff       	mov    $0xffffffff,%edx
    d893:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
    d89a:	ff 14 25 00 00 00 00 	callq  *0x0
	s32 ret;
	spin_lock(&e1000_eeprom_lock);
	ret = e1000_do_write_eeprom(hw, offset, words, data);
	spin_unlock(&e1000_eeprom_lock);
	return ret;
}
    d8a1:	48 83 c4 10          	add    $0x10,%rsp
    d8a5:	89 d0                	mov    %edx,%eax
    d8a7:	5b                   	pop    %rbx
    d8a8:	41 5c                	pop    %r12
    d8aa:	41 5d                	pop    %r13
    d8ac:	41 5e                	pop    %r14
    d8ae:	41 5f                	pop    %r15
    d8b0:	5d                   	pop    %rbp
    d8b1:	c3                   	retq   

	/* A check for invalid values:  offset too large, too many words, and
	 * not enough words.
	 */
	if ((offset >= eeprom->word_size)
	    || (words > eeprom->word_size - offset) || (words == 0)) {
    d8b2:	45 0f b7 e0          	movzwl %r8w,%r12d
    d8b6:	41 0f b7 d1          	movzwl %r9w,%edx
    d8ba:	44 29 e0             	sub    %r12d,%eax
    d8bd:	39 c2                	cmp    %eax,%edx
    d8bf:	7f c0                	jg     d881 <e1000_write_eeprom+0x51>
    d8c1:	66 45 85 c9          	test   %r9w,%r9w
    d8c5:	74 ba                	je     d881 <e1000_write_eeprom+0x51>
		e_dbg("\"words\" parameter out of bounds\n");
		return -E1000_ERR_EEPROM;
	}

	/* Prepare the EEPROM for writing  */
	if (e1000_acquire_eeprom(hw) != E1000_SUCCESS)
    d8c7:	48 89 df             	mov    %rbx,%rdi
    d8ca:	44 89 4d d0          	mov    %r9d,-0x30(%rbp)
    d8ce:	44 89 45 d4          	mov    %r8d,-0x2c(%rbp)
    d8d2:	e8 19 b3 ff ff       	callq  8bf0 <e1000_acquire_eeprom>
    d8d7:	85 c0                	test   %eax,%eax
    d8d9:	75 b3                	jne    d88e <e1000_write_eeprom+0x5e>
		return -E1000_ERR_EEPROM;

	if (eeprom->type == e1000_eeprom_microwire) {
    d8db:	45 31 ff             	xor    %r15d,%r15d
    d8de:	83 7b 50 02          	cmpl   $0x2,0x50(%rbx)
    d8e2:	0f 84 0a 01 00 00    	je     d9f2 <e1000_write_eeprom+0x1c2>
				  u16 *data)
{
	struct e1000_eeprom_info *eeprom = &hw->eeprom;
	u16 widx = 0;

	while (widx < words) {
    d8e8:	66 45 39 fd          	cmp    %r15w,%r13w
    d8ec:	0f 86 ac 00 00 00    	jbe    d99e <e1000_write_eeprom+0x16e>
		u8 write_opcode = EEPROM_WRITE_OPCODE_SPI;

		if (e1000_spi_eeprom_ready(hw))
    d8f2:	48 89 df             	mov    %rbx,%rdi
    d8f5:	e8 e6 b6 ff ff       	callq  8fe0 <e1000_spi_eeprom_ready>
    d8fa:	85 c0                	test   %eax,%eax
    d8fc:	0f 85 ec 01 00 00    	jne    daee <e1000_write_eeprom+0x2be>
			return -E1000_ERR_EEPROM;

		e1000_standby_eeprom(hw);
    d902:	48 89 df             	mov    %rbx,%rdi
    d905:	e8 e6 b3 ff ff       	callq  8cf0 <e1000_standby_eeprom>

		/*  Send the WRITE ENABLE command (8 bit opcode )  */
		e1000_shift_out_ee_bits(hw, EEPROM_WREN_OPCODE_SPI,
    d90a:	0f b7 53 56          	movzwl 0x56(%rbx),%edx
    d90e:	be 06 00 00 00       	mov    $0x6,%esi
    d913:	48 89 df             	mov    %rbx,%rdi
    d916:	e8 85 b5 ff ff       	callq  8ea0 <e1000_shift_out_ee_bits>
					eeprom->opcode_bits);

		e1000_standby_eeprom(hw);
    d91b:	48 89 df             	mov    %rbx,%rdi
    d91e:	e8 cd b3 ff ff       	callq  8cf0 <e1000_standby_eeprom>

		/* Some SPI eeproms use the 8th address bit embedded in the
		 * opcode
		 */
		if ((eeprom->address_bits == 8) && (offset >= 128))
    d923:	66 83 7b 58 08       	cmpw   $0x8,0x58(%rbx)
    d928:	be 02 00 00 00       	mov    $0x2,%esi
    d92d:	0f 84 88 00 00 00    	je     d9bb <e1000_write_eeprom+0x18b>
			write_opcode |= EEPROM_A8_OPCODE_SPI;

		/* Send the Write command (8-bit opcode + addr) */
		e1000_shift_out_ee_bits(hw, write_opcode, eeprom->opcode_bits);
    d933:	0f b7 53 56          	movzwl 0x56(%rbx),%edx
    d937:	48 89 df             	mov    %rbx,%rdi
    d93a:	e8 61 b5 ff ff       	callq  8ea0 <e1000_shift_out_ee_bits>

		e1000_shift_out_ee_bits(hw, (u16) ((offset + widx) * 2),
    d93f:	43 8d 34 27          	lea    (%r15,%r12,1),%esi
    d943:	0f b7 53 58          	movzwl 0x58(%rbx),%edx
    d947:	48 89 df             	mov    %rbx,%rdi
    d94a:	01 f6                	add    %esi,%esi
    d94c:	0f b7 f6             	movzwl %si,%esi
    d94f:	e8 4c b5 ff ff       	callq  8ea0 <e1000_shift_out_ee_bits>
    d954:	eb 06                	jmp    d95c <e1000_write_eeprom+0x12c>
		/* Send the data */

		/* Loop to allow for up to whole page write (32 bytes) of
		 * eeprom
		 */
		while (widx < words) {
    d956:	66 45 39 fd          	cmp    %r15w,%r13w
    d95a:	76 42                	jbe    d99e <e1000_write_eeprom+0x16e>
			u16 word_out = data[widx];
    d95c:	41 0f b7 c7          	movzwl %r15w,%eax
			word_out = (word_out >> 8) | (word_out << 8);
			e1000_shift_out_ee_bits(hw, word_out, 16);
    d960:	ba 10 00 00 00       	mov    $0x10,%edx
			widx++;
    d965:	41 83 c7 01          	add    $0x1,%r15d

		/* Loop to allow for up to whole page write (32 bytes) of
		 * eeprom
		 */
		while (widx < words) {
			u16 word_out = data[widx];
    d969:	41 0f b7 34 46       	movzwl (%r14,%rax,2),%esi
			word_out = (word_out >> 8) | (word_out << 8);
			e1000_shift_out_ee_bits(hw, word_out, 16);
    d96e:	48 89 df             	mov    %rbx,%rdi
		/* Loop to allow for up to whole page write (32 bytes) of
		 * eeprom
		 */
		while (widx < words) {
			u16 word_out = data[widx];
			word_out = (word_out >> 8) | (word_out << 8);
    d971:	66 c1 c6 08          	rol    $0x8,%si
			e1000_shift_out_ee_bits(hw, word_out, 16);
    d975:	0f b7 f6             	movzwl %si,%esi
    d978:	e8 23 b5 ff ff       	callq  8ea0 <e1000_shift_out_ee_bits>
			/* Some larger eeprom sizes are capable of a 32-byte
			 * PAGE WRITE operation, while the smaller eeproms are
			 * capable of an 8-byte PAGE WRITE operation.  Break the
			 * inner loop to pass new address
			 */
			if ((((offset + widx) * 2) % eeprom->page_size) == 0) {
    d97d:	41 0f b7 c7          	movzwl %r15w,%eax
    d981:	0f b7 73 5c          	movzwl 0x5c(%rbx),%esi
    d985:	44 01 e0             	add    %r12d,%eax
    d988:	01 c0                	add    %eax,%eax
    d98a:	99                   	cltd   
    d98b:	f7 fe                	idiv   %esi
    d98d:	85 d2                	test   %edx,%edx
    d98f:	75 c5                	jne    d956 <e1000_write_eeprom+0x126>
				e1000_standby_eeprom(hw);
    d991:	48 89 df             	mov    %rbx,%rdi
    d994:	e8 57 b3 ff ff       	callq  8cf0 <e1000_standby_eeprom>
    d999:	e9 4a ff ff ff       	jmpq   d8e8 <e1000_write_eeprom+0xb8>
				break;
			}
		}
	}

	return E1000_SUCCESS;
    d99e:	45 31 e4             	xor    %r12d,%r12d

	if (eeprom->type == e1000_eeprom_microwire) {
		status = e1000_write_eeprom_microwire(hw, offset, words, data);
	} else {
		status = e1000_write_eeprom_spi(hw, offset, words, data);
		msleep(10);
    d9a1:	bf 0a 00 00 00       	mov    $0xa,%edi
    d9a6:	e8 00 00 00 00       	callq  d9ab <e1000_write_eeprom+0x17b>
	}

	/* Done with writing */
	e1000_release_eeprom(hw);
    d9ab:	48 89 df             	mov    %rbx,%rdi
    d9ae:	e8 fd b3 ff ff       	callq  8db0 <e1000_release_eeprom>

	return status;
    d9b3:	44 89 e2             	mov    %r12d,%edx
    d9b6:	e9 d8 fe ff ff       	jmpq   d893 <e1000_write_eeprom+0x63>
		e1000_standby_eeprom(hw);

		/* Some SPI eeproms use the 8th address bit embedded in the
		 * opcode
		 */
		if ((eeprom->address_bits == 8) && (offset >= 128))
    d9bb:	66 81 7d ce 80 00    	cmpw   $0x80,-0x32(%rbp)
    d9c1:	19 f6                	sbb    %esi,%esi
    d9c3:	83 e6 f8             	and    $0xfffffff8,%esi
    d9c6:	83 c6 0a             	add    $0xa,%esi
    d9c9:	e9 65 ff ff ff       	jmpq   d933 <e1000_write_eeprom+0x103>
{
	struct e1000_eeprom_info *eeprom = &hw->eeprom;
	s32 status = 0;

	if (hw->mac_type == e1000_ce4100) {
		GBE_CONFIG_FLASH_WRITE(GBE_CONFIG_BASE_VIRT, offset, words,
    d9ce:	0f b7 7d ce          	movzwl -0x32(%rbp),%edi
    d9d2:	48 b8 00 00 06 00 00 	movabs $0xffff880000060000,%rax
    d9d9:	88 ff ff 
    d9dc:	41 0f b7 d5          	movzwl %r13w,%edx
    d9e0:	4c 89 f6             	mov    %r14,%rsi
    d9e3:	48 01 c7             	add    %rax,%rdi
    d9e6:	e8 00 00 00 00       	callq  d9eb <e1000_write_eeprom+0x1bb>
		                       data);
		return E1000_SUCCESS;
    d9eb:	31 d2                	xor    %edx,%edx
    d9ed:	e9 a1 fe ff ff       	jmpq   d893 <e1000_write_eeprom+0x63>
	 * the 11 of the dummy address as part of the opcode than it is to shift
	 * it over the correct number of bits for the address.  This puts the
	 * EEPROM into write/erase mode.
	 */
	e1000_shift_out_ee_bits(hw, EEPROM_EWEN_OPCODE_MICROWIRE,
				(u16) (eeprom->opcode_bits + 2));
    d9f2:	0f b7 43 56          	movzwl 0x56(%rbx),%eax
	 * 6/8-bit dummy address beginning with 11).  It's less work to include
	 * the 11 of the dummy address as part of the opcode than it is to shift
	 * it over the correct number of bits for the address.  This puts the
	 * EEPROM into write/erase mode.
	 */
	e1000_shift_out_ee_bits(hw, EEPROM_EWEN_OPCODE_MICROWIRE,
    d9f6:	be 13 00 00 00       	mov    $0x13,%esi
    d9fb:	48 89 df             	mov    %rbx,%rdi
				(u16) (eeprom->opcode_bits + 2));
    d9fe:	8d 50 02             	lea    0x2(%rax),%edx
	 * 6/8-bit dummy address beginning with 11).  It's less work to include
	 * the 11 of the dummy address as part of the opcode than it is to shift
	 * it over the correct number of bits for the address.  This puts the
	 * EEPROM into write/erase mode.
	 */
	e1000_shift_out_ee_bits(hw, EEPROM_EWEN_OPCODE_MICROWIRE,
    da01:	0f b7 d2             	movzwl %dx,%edx
    da04:	e8 97 b4 ff ff       	callq  8ea0 <e1000_shift_out_ee_bits>
				(u16) (eeprom->opcode_bits + 2));

	e1000_shift_out_ee_bits(hw, 0, (u16) (eeprom->address_bits - 2));
    da09:	0f b7 43 58          	movzwl 0x58(%rbx),%eax
    da0d:	31 f6                	xor    %esi,%esi
    da0f:	48 89 df             	mov    %rbx,%rdi
    da12:	8d 50 fe             	lea    -0x2(%rax),%edx
    da15:	0f b7 d2             	movzwl %dx,%edx
    da18:	e8 83 b4 ff ff       	callq  8ea0 <e1000_shift_out_ee_bits>

	/* Prepare the EEPROM */
	e1000_standby_eeprom(hw);
    da1d:	48 89 df             	mov    %rbx,%rdi
    da20:	e8 cb b2 ff ff       	callq  8cf0 <e1000_standby_eeprom>
    da25:	44 8b 45 d4          	mov    -0x2c(%rbp),%r8d
    da29:	44 8b 4d d0          	mov    -0x30(%rbp),%r9d
    da2d:	47 8d 3c 01          	lea    (%r9,%r8,1),%r15d
    da31:	45 89 c5             	mov    %r8d,%r13d

	while (words_written < words) {
		/* Send the Write command (3-bit opcode + addr) */
		e1000_shift_out_ee_bits(hw, EEPROM_WRITE_OPCODE_MICROWIRE,
    da34:	0f b7 53 56          	movzwl 0x56(%rbx),%edx
    da38:	be 05 00 00 00       	mov    $0x5,%esi
    da3d:	48 89 df             	mov    %rbx,%rdi
		e1000_shift_out_ee_bits(hw, data[words_written], 16);

		/* Toggle the CS line.  This in effect tells the EEPROM to
		 * execute the previous command.
		 */
		e1000_standby_eeprom(hw);
    da40:	41 bc c8 00 00 00    	mov    $0xc8,%r12d
	/* Prepare the EEPROM */
	e1000_standby_eeprom(hw);

	while (words_written < words) {
		/* Send the Write command (3-bit opcode + addr) */
		e1000_shift_out_ee_bits(hw, EEPROM_WRITE_OPCODE_MICROWIRE,
    da46:	e8 55 b4 ff ff       	callq  8ea0 <e1000_shift_out_ee_bits>
					eeprom->opcode_bits);

		e1000_shift_out_ee_bits(hw, (u16) (offset + words_written),
    da4b:	0f b7 53 58          	movzwl 0x58(%rbx),%edx
    da4f:	41 0f b7 f5          	movzwl %r13w,%esi
    da53:	48 89 df             	mov    %rbx,%rdi
    da56:	e8 45 b4 ff ff       	callq  8ea0 <e1000_shift_out_ee_bits>
					eeprom->address_bits);

		/* Send the data */
		e1000_shift_out_ee_bits(hw, data[words_written], 16);
    da5b:	41 0f b7 36          	movzwl (%r14),%esi
    da5f:	ba 10 00 00 00       	mov    $0x10,%edx
    da64:	48 89 df             	mov    %rbx,%rdi
    da67:	e8 34 b4 ff ff       	callq  8ea0 <e1000_shift_out_ee_bits>

		/* Toggle the CS line.  This in effect tells the EEPROM to
		 * execute the previous command.
		 */
		e1000_standby_eeprom(hw);
    da6c:	48 89 df             	mov    %rbx,%rdi
    da6f:	e8 7c b2 ff ff       	callq  8cf0 <e1000_standby_eeprom>
    da74:	eb 11                	jmp    da87 <e1000_write_eeprom+0x257>
		 */
		for (i = 0; i < 200; i++) {
			eecd = er32(EECD);
			if (eecd & E1000_EECD_DO)
				break;
			udelay(50);
    da76:	bf de 46 03 00       	mov    $0x346de,%edi
    da7b:	e8 00 00 00 00       	callq  da80 <e1000_write_eeprom+0x250>
		/* Read DO repeatedly until it is high (equal to '1').  The
		 * EEPROM will signal that the command has been completed by
		 * raising the DO signal. If DO does not go high in 10
		 * milliseconds, then error out.
		 */
		for (i = 0; i < 200; i++) {
    da80:	66 41 83 ec 01       	sub    $0x1,%r12w
    da85:	74 53                	je     dada <e1000_write_eeprom+0x2aa>
			eecd = er32(EECD);
    da87:	48 8b 03             	mov    (%rbx),%rax
    da8a:	8b 40 10             	mov    0x10(%rax),%eax
			if (eecd & E1000_EECD_DO)
    da8d:	a8 08                	test   $0x8,%al
    da8f:	74 e5                	je     da76 <e1000_write_eeprom+0x246>
			e_dbg("EEPROM Write did not complete\n");
			return -E1000_ERR_EEPROM;
		}

		/* Recover from write */
		e1000_standby_eeprom(hw);
    da91:	48 89 df             	mov    %rbx,%rdi
    da94:	41 83 c5 01          	add    $0x1,%r13d
    da98:	49 83 c6 02          	add    $0x2,%r14
    da9c:	e8 4f b2 ff ff       	callq  8cf0 <e1000_standby_eeprom>
	e1000_shift_out_ee_bits(hw, 0, (u16) (eeprom->address_bits - 2));

	/* Prepare the EEPROM */
	e1000_standby_eeprom(hw);

	while (words_written < words) {
    daa1:	66 45 39 fd          	cmp    %r15w,%r13w
    daa5:	75 8d                	jne    da34 <e1000_write_eeprom+0x204>
	 * the 10 of the dummy address as part of the opcode than it is to shift
	 * it over the correct number of bits for the address.  This takes the
	 * EEPROM out of write/erase mode.
	 */
	e1000_shift_out_ee_bits(hw, EEPROM_EWDS_OPCODE_MICROWIRE,
				(u16) (eeprom->opcode_bits + 2));
    daa7:	0f b7 43 56          	movzwl 0x56(%rbx),%eax
	 * 6/8-bit dummy address beginning with 10).  It's less work to include
	 * the 10 of the dummy address as part of the opcode than it is to shift
	 * it over the correct number of bits for the address.  This takes the
	 * EEPROM out of write/erase mode.
	 */
	e1000_shift_out_ee_bits(hw, EEPROM_EWDS_OPCODE_MICROWIRE,
    daab:	be 10 00 00 00       	mov    $0x10,%esi
    dab0:	48 89 df             	mov    %rbx,%rdi
				(u16) (eeprom->opcode_bits + 2));

	e1000_shift_out_ee_bits(hw, 0, (u16) (eeprom->address_bits - 2));

	return E1000_SUCCESS;
    dab3:	45 31 e4             	xor    %r12d,%r12d
	 * the 10 of the dummy address as part of the opcode than it is to shift
	 * it over the correct number of bits for the address.  This takes the
	 * EEPROM out of write/erase mode.
	 */
	e1000_shift_out_ee_bits(hw, EEPROM_EWDS_OPCODE_MICROWIRE,
				(u16) (eeprom->opcode_bits + 2));
    dab6:	8d 50 02             	lea    0x2(%rax),%edx
	 * 6/8-bit dummy address beginning with 10).  It's less work to include
	 * the 10 of the dummy address as part of the opcode than it is to shift
	 * it over the correct number of bits for the address.  This takes the
	 * EEPROM out of write/erase mode.
	 */
	e1000_shift_out_ee_bits(hw, EEPROM_EWDS_OPCODE_MICROWIRE,
    dab9:	0f b7 d2             	movzwl %dx,%edx
    dabc:	e8 df b3 ff ff       	callq  8ea0 <e1000_shift_out_ee_bits>
				(u16) (eeprom->opcode_bits + 2));

	e1000_shift_out_ee_bits(hw, 0, (u16) (eeprom->address_bits - 2));
    dac1:	0f b7 43 58          	movzwl 0x58(%rbx),%eax
    dac5:	31 f6                	xor    %esi,%esi
    dac7:	48 89 df             	mov    %rbx,%rdi
    daca:	8d 50 fe             	lea    -0x2(%rax),%edx
    dacd:	0f b7 d2             	movzwl %dx,%edx
    dad0:	e8 cb b3 ff ff       	callq  8ea0 <e1000_shift_out_ee_bits>
    dad5:	e9 d1 fe ff ff       	jmpq   d9ab <e1000_write_eeprom+0x17b>
			if (eecd & E1000_EECD_DO)
				break;
			udelay(50);
		}
		if (i == 200) {
			e_dbg("EEPROM Write did not complete\n");
    dada:	f6 05 00 00 00 00 04 	testb  $0x4,0x0(%rip)        # dae1 <e1000_write_eeprom+0x2b1>
    dae1:	75 3b                	jne    db1e <e1000_write_eeprom+0x2ee>
			return -E1000_ERR_EEPROM;
    dae3:	41 bc ff ff ff ff    	mov    $0xffffffff,%r12d
    dae9:	e9 bd fe ff ff       	jmpq   d9ab <e1000_write_eeprom+0x17b>

	while (widx < words) {
		u8 write_opcode = EEPROM_WRITE_OPCODE_SPI;

		if (e1000_spi_eeprom_ready(hw))
			return -E1000_ERR_EEPROM;
    daee:	41 bc ff ff ff ff    	mov    $0xffffffff,%r12d
    daf4:	e9 a8 fe ff ff       	jmpq   d9a1 <e1000_write_eeprom+0x171>
	/* A check for invalid values:  offset too large, too many words, and
	 * not enough words.
	 */
	if ((offset >= eeprom->word_size)
	    || (words > eeprom->word_size - offset) || (words == 0)) {
		e_dbg("\"words\" parameter out of bounds\n");
    daf9:	48 89 df             	mov    %rbx,%rdi
    dafc:	e8 00 00 00 00       	callq  db01 <e1000_write_eeprom+0x2d1>
    db01:	48 c7 c2 00 00 00 00 	mov    $0x0,%rdx
    db08:	48 89 c6             	mov    %rax,%rsi
    db0b:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
    db12:	31 c0                	xor    %eax,%eax
    db14:	e8 00 00 00 00       	callq  db19 <e1000_write_eeprom+0x2e9>
    db19:	e9 70 fd ff ff       	jmpq   d88e <e1000_write_eeprom+0x5e>
			if (eecd & E1000_EECD_DO)
				break;
			udelay(50);
		}
		if (i == 200) {
			e_dbg("EEPROM Write did not complete\n");
    db1e:	48 89 df             	mov    %rbx,%rdi
			return -E1000_ERR_EEPROM;
    db21:	41 83 cc ff          	or     $0xffffffff,%r12d
			if (eecd & E1000_EECD_DO)
				break;
			udelay(50);
		}
		if (i == 200) {
			e_dbg("EEPROM Write did not complete\n");
    db25:	e8 00 00 00 00       	callq  db2a <e1000_write_eeprom+0x2fa>
    db2a:	48 c7 c2 00 00 00 00 	mov    $0x0,%rdx
    db31:	48 89 c6             	mov    %rax,%rsi
    db34:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
    db3b:	31 c0                	xor    %eax,%eax
    db3d:	e8 00 00 00 00       	callq  db42 <e1000_write_eeprom+0x312>
    db42:	e9 64 fe ff ff       	jmpq   d9ab <e1000_write_eeprom+0x17b>
    db47:	66 0f 1f 84 00 00 00 	nopw   0x0(%rax,%rax,1)
    db4e:	00 00 

000000000000db50 <e1000_update_eeprom_checksum>:
 *
 * Sums the first 63 16 bit words of the EEPROM. Subtracts the sum from 0xBABA.
 * Writes the difference to word offset 63 of the EEPROM.
 */
s32 e1000_update_eeprom_checksum(struct e1000_hw *hw)
{
    db50:	e8 00 00 00 00       	callq  db55 <e1000_update_eeprom_checksum+0x5>
    db55:	55                   	push   %rbp
	u16 checksum = 0;
    db56:	31 c0                	xor    %eax,%eax
 *
 * Sums the first 63 16 bit words of the EEPROM. Subtracts the sum from 0xBABA.
 * Writes the difference to word offset 63 of the EEPROM.
 */
s32 e1000_update_eeprom_checksum(struct e1000_hw *hw)
{
    db58:	48 89 e5             	mov    %rsp,%rbp
    db5b:	41 54                	push   %r12
    db5d:	49 89 fc             	mov    %rdi,%r12
    db60:	53                   	push   %rbx
	u16 checksum = 0;
    db61:	31 db                	xor    %ebx,%ebx
 *
 * Sums the first 63 16 bit words of the EEPROM. Subtracts the sum from 0xBABA.
 * Writes the difference to word offset 63 of the EEPROM.
 */
s32 e1000_update_eeprom_checksum(struct e1000_hw *hw)
{
    db63:	48 83 ec 08          	sub    $0x8,%rsp
	u16 checksum = 0;
    db67:	66 89 45 ec          	mov    %ax,-0x14(%rbp)
    db6b:	eb 14                	jmp    db81 <e1000_update_eeprom_checksum+0x31>
	for (i = 0; i < EEPROM_CHECKSUM_REG; i++) {
		if (e1000_read_eeprom(hw, i, 1, &eeprom_data) < 0) {
			e_dbg("EEPROM Read Error\n");
			return -E1000_ERR_EEPROM;
		}
		checksum += eeprom_data;
    db6d:	0f b7 45 ee          	movzwl -0x12(%rbp),%eax
    db71:	83 c3 01             	add    $0x1,%ebx
    db74:	66 03 45 ec          	add    -0x14(%rbp),%ax
s32 e1000_update_eeprom_checksum(struct e1000_hw *hw)
{
	u16 checksum = 0;
	u16 i, eeprom_data;

	for (i = 0; i < EEPROM_CHECKSUM_REG; i++) {
    db78:	83 fb 3f             	cmp    $0x3f,%ebx
		if (e1000_read_eeprom(hw, i, 1, &eeprom_data) < 0) {
			e_dbg("EEPROM Read Error\n");
			return -E1000_ERR_EEPROM;
		}
		checksum += eeprom_data;
    db7b:	66 89 45 ec          	mov    %ax,-0x14(%rbp)
s32 e1000_update_eeprom_checksum(struct e1000_hw *hw)
{
	u16 checksum = 0;
	u16 i, eeprom_data;

	for (i = 0; i < EEPROM_CHECKSUM_REG; i++) {
    db7f:	74 2e                	je     dbaf <e1000_update_eeprom_checksum+0x5f>
		if (e1000_read_eeprom(hw, i, 1, &eeprom_data) < 0) {
    db81:	48 8d 4d ee          	lea    -0x12(%rbp),%rcx
    db85:	ba 01 00 00 00       	mov    $0x1,%edx
    db8a:	89 de                	mov    %ebx,%esi
    db8c:	4c 89 e7             	mov    %r12,%rdi
    db8f:	e8 00 00 00 00       	callq  db94 <e1000_update_eeprom_checksum+0x44>
    db94:	85 c0                	test   %eax,%eax
    db96:	79 d5                	jns    db6d <e1000_update_eeprom_checksum+0x1d>
			e_dbg("EEPROM Read Error\n");
    db98:	f6 05 00 00 00 00 04 	testb  $0x4,0x0(%rip)        # db9f <e1000_update_eeprom_checksum+0x4f>
    db9f:	75 62                	jne    dc03 <e1000_update_eeprom_checksum+0xb3>
		checksum += eeprom_data;
	}
	checksum = (u16) EEPROM_SUM - checksum;
	if (e1000_write_eeprom(hw, EEPROM_CHECKSUM_REG, 1, &checksum) < 0) {
		e_dbg("EEPROM Write Error\n");
		return -E1000_ERR_EEPROM;
    dba1:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
	}
	return E1000_SUCCESS;
}
    dba6:	48 83 c4 08          	add    $0x8,%rsp
    dbaa:	5b                   	pop    %rbx
    dbab:	41 5c                	pop    %r12
    dbad:	5d                   	pop    %rbp
    dbae:	c3                   	retq   
			e_dbg("EEPROM Read Error\n");
			return -E1000_ERR_EEPROM;
		}
		checksum += eeprom_data;
	}
	checksum = (u16) EEPROM_SUM - checksum;
    dbaf:	ba ba ba ff ff       	mov    $0xffffbaba,%edx
	if (e1000_write_eeprom(hw, EEPROM_CHECKSUM_REG, 1, &checksum) < 0) {
    dbb4:	48 8d 4d ec          	lea    -0x14(%rbp),%rcx
    dbb8:	be 3f 00 00 00       	mov    $0x3f,%esi
			e_dbg("EEPROM Read Error\n");
			return -E1000_ERR_EEPROM;
		}
		checksum += eeprom_data;
	}
	checksum = (u16) EEPROM_SUM - checksum;
    dbbd:	29 c2                	sub    %eax,%edx
	if (e1000_write_eeprom(hw, EEPROM_CHECKSUM_REG, 1, &checksum) < 0) {
    dbbf:	4c 89 e7             	mov    %r12,%rdi
			e_dbg("EEPROM Read Error\n");
			return -E1000_ERR_EEPROM;
		}
		checksum += eeprom_data;
	}
	checksum = (u16) EEPROM_SUM - checksum;
    dbc2:	66 89 55 ec          	mov    %dx,-0x14(%rbp)
	if (e1000_write_eeprom(hw, EEPROM_CHECKSUM_REG, 1, &checksum) < 0) {
    dbc6:	ba 01 00 00 00       	mov    $0x1,%edx
    dbcb:	e8 00 00 00 00       	callq  dbd0 <e1000_update_eeprom_checksum+0x80>
    dbd0:	89 c2                	mov    %eax,%edx
		e_dbg("EEPROM Write Error\n");
		return -E1000_ERR_EEPROM;
	}
	return E1000_SUCCESS;
    dbd2:	31 c0                	xor    %eax,%eax
			return -E1000_ERR_EEPROM;
		}
		checksum += eeprom_data;
	}
	checksum = (u16) EEPROM_SUM - checksum;
	if (e1000_write_eeprom(hw, EEPROM_CHECKSUM_REG, 1, &checksum) < 0) {
    dbd4:	85 d2                	test   %edx,%edx
    dbd6:	79 ce                	jns    dba6 <e1000_update_eeprom_checksum+0x56>
		e_dbg("EEPROM Write Error\n");
    dbd8:	f6 05 00 00 00 00 04 	testb  $0x4,0x0(%rip)        # dbdf <e1000_update_eeprom_checksum+0x8f>
    dbdf:	74 c0                	je     dba1 <e1000_update_eeprom_checksum+0x51>
    dbe1:	4c 89 e7             	mov    %r12,%rdi
    dbe4:	e8 00 00 00 00       	callq  dbe9 <e1000_update_eeprom_checksum+0x99>
    dbe9:	48 c7 c2 00 00 00 00 	mov    $0x0,%rdx
    dbf0:	48 89 c6             	mov    %rax,%rsi
    dbf3:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
    dbfa:	31 c0                	xor    %eax,%eax
    dbfc:	e8 00 00 00 00       	callq  dc01 <e1000_update_eeprom_checksum+0xb1>
    dc01:	eb 9e                	jmp    dba1 <e1000_update_eeprom_checksum+0x51>
	u16 checksum = 0;
	u16 i, eeprom_data;

	for (i = 0; i < EEPROM_CHECKSUM_REG; i++) {
		if (e1000_read_eeprom(hw, i, 1, &eeprom_data) < 0) {
			e_dbg("EEPROM Read Error\n");
    dc03:	4c 89 e7             	mov    %r12,%rdi
    dc06:	e8 00 00 00 00       	callq  dc0b <e1000_update_eeprom_checksum+0xbb>
    dc0b:	48 c7 c2 00 00 00 00 	mov    $0x0,%rdx
    dc12:	48 89 c6             	mov    %rax,%rsi
    dc15:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
    dc1c:	31 c0                	xor    %eax,%eax
    dc1e:	e8 00 00 00 00       	callq  dc23 <e1000_update_eeprom_checksum+0xd3>
			return -E1000_ERR_EEPROM;
    dc23:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
    dc28:	e9 79 ff ff ff       	jmpq   dba6 <e1000_update_eeprom_checksum+0x56>
    dc2d:	0f 1f 00             	nopl   (%rax)

000000000000dc30 <e1000_read_mac_addr>:
 *
 * Reads the adapter's MAC address from the EEPROM and inverts the LSB for the
 * second function of dual function devices
 */
s32 e1000_read_mac_addr(struct e1000_hw *hw)
{
    dc30:	e8 00 00 00 00       	callq  dc35 <e1000_read_mac_addr+0x5>
    dc35:	55                   	push   %rbp
    dc36:	48 89 e5             	mov    %rsp,%rbp
    dc39:	41 55                	push   %r13
    dc3b:	4c 8d 6f 06          	lea    0x6(%rdi),%r13
    dc3f:	41 54                	push   %r12
    dc41:	49 89 fc             	mov    %rdi,%r12
    dc44:	53                   	push   %rbx
    dc45:	48 89 fb             	mov    %rdi,%rbx
    dc48:	48 83 ec 08          	sub    $0x8,%rsp
    dc4c:	44 89 e6             	mov    %r12d,%esi
	u16 offset;
	u16 eeprom_data, i;

	for (i = 0; i < NODE_ADDRESS_SIZE; i += 2) {
		offset = i >> 1;
		if (e1000_read_eeprom(hw, offset, 1, &eeprom_data) < 0) {
    dc4f:	48 8d 4d e6          	lea    -0x1a(%rbp),%rcx
    dc53:	ba 01 00 00 00       	mov    $0x1,%edx
    dc58:	29 de                	sub    %ebx,%esi
    dc5a:	48 89 df             	mov    %rbx,%rdi
{
	u16 offset;
	u16 eeprom_data, i;

	for (i = 0; i < NODE_ADDRESS_SIZE; i += 2) {
		offset = i >> 1;
    dc5d:	66 d1 ee             	shr    %si
		if (e1000_read_eeprom(hw, offset, 1, &eeprom_data) < 0) {
    dc60:	0f b7 f6             	movzwl %si,%esi
    dc63:	e8 00 00 00 00       	callq  dc68 <e1000_read_mac_addr+0x38>
    dc68:	85 c0                	test   %eax,%eax
    dc6a:	78 69                	js     dcd5 <e1000_read_mac_addr+0xa5>
			e_dbg("EEPROM Read Error\n");
			return -E1000_ERR_EEPROM;
		}
		hw->perm_mac_addr[i] = (u8) (eeprom_data & 0x00FF);
    dc6c:	0f b7 45 e6          	movzwl -0x1a(%rbp),%eax
    dc70:	49 83 c4 02          	add    $0x2,%r12
    dc74:	41 88 84 24 f8 00 00 	mov    %al,0xf8(%r12)
    dc7b:	00 
		hw->perm_mac_addr[i + 1] = (u8) (eeprom_data >> 8);
    dc7c:	66 c1 e8 08          	shr    $0x8,%ax
    dc80:	41 88 84 24 f9 00 00 	mov    %al,0xf9(%r12)
    dc87:	00 
s32 e1000_read_mac_addr(struct e1000_hw *hw)
{
	u16 offset;
	u16 eeprom_data, i;

	for (i = 0; i < NODE_ADDRESS_SIZE; i += 2) {
    dc88:	4d 39 ec             	cmp    %r13,%r12
    dc8b:	75 bf                	jne    dc4c <e1000_read_mac_addr+0x1c>
		}
		hw->perm_mac_addr[i] = (u8) (eeprom_data & 0x00FF);
		hw->perm_mac_addr[i + 1] = (u8) (eeprom_data >> 8);
	}

	switch (hw->mac_type) {
    dc8d:	8b 43 18             	mov    0x18(%rbx),%eax
    dc90:	83 f8 08             	cmp    $0x8,%eax
    dc93:	74 2d                	je     dcc2 <e1000_read_mac_addr+0x92>
    dc95:	83 f8 0a             	cmp    $0xa,%eax
    dc98:	74 28                	je     dcc2 <e1000_read_mac_addr+0x92>
 *
 * Reads the adapter's MAC address from the EEPROM and inverts the LSB for the
 * second function of dual function devices
 */
s32 e1000_read_mac_addr(struct e1000_hw *hw)
{
    dc9a:	31 c0                	xor    %eax,%eax
			hw->perm_mac_addr[5] ^= 0x01;
		break;
	}

	for (i = 0; i < NODE_ADDRESS_SIZE; i++)
		hw->mac_addr[i] = hw->perm_mac_addr[i];
    dc9c:	0f b6 94 03 fa 00 00 	movzbl 0xfa(%rbx,%rax,1),%edx
    dca3:	00 
    dca4:	88 94 03 f4 00 00 00 	mov    %dl,0xf4(%rbx,%rax,1)
    dcab:	48 83 c0 01          	add    $0x1,%rax
		if (er32(STATUS) & E1000_STATUS_FUNC_1)
			hw->perm_mac_addr[5] ^= 0x01;
		break;
	}

	for (i = 0; i < NODE_ADDRESS_SIZE; i++)
    dcaf:	48 83 f8 06          	cmp    $0x6,%rax
    dcb3:	75 e7                	jne    dc9c <e1000_read_mac_addr+0x6c>
		hw->mac_addr[i] = hw->perm_mac_addr[i];
	return E1000_SUCCESS;
    dcb5:	31 c0                	xor    %eax,%eax
}
    dcb7:	48 83 c4 08          	add    $0x8,%rsp
    dcbb:	5b                   	pop    %rbx
    dcbc:	41 5c                	pop    %r12
    dcbe:	41 5d                	pop    %r13
    dcc0:	5d                   	pop    %rbp
    dcc1:	c3                   	retq   
	switch (hw->mac_type) {
	default:
		break;
	case e1000_82546:
	case e1000_82546_rev_3:
		if (er32(STATUS) & E1000_STATUS_FUNC_1)
    dcc2:	48 8b 03             	mov    (%rbx),%rax
    dcc5:	8b 40 08             	mov    0x8(%rax),%eax
    dcc8:	a8 04                	test   $0x4,%al
    dcca:	74 ce                	je     dc9a <e1000_read_mac_addr+0x6a>
			hw->perm_mac_addr[5] ^= 0x01;
    dccc:	80 b3 ff 00 00 00 01 	xorb   $0x1,0xff(%rbx)
    dcd3:	eb c5                	jmp    dc9a <e1000_read_mac_addr+0x6a>
	u16 eeprom_data, i;

	for (i = 0; i < NODE_ADDRESS_SIZE; i += 2) {
		offset = i >> 1;
		if (e1000_read_eeprom(hw, offset, 1, &eeprom_data) < 0) {
			e_dbg("EEPROM Read Error\n");
    dcd5:	f6 05 00 00 00 00 04 	testb  $0x4,0x0(%rip)        # dcdc <e1000_read_mac_addr+0xac>
    dcdc:	75 10                	jne    dcee <e1000_read_mac_addr+0xbe>
	}

	for (i = 0; i < NODE_ADDRESS_SIZE; i++)
		hw->mac_addr[i] = hw->perm_mac_addr[i];
	return E1000_SUCCESS;
}
    dcde:	48 83 c4 08          	add    $0x8,%rsp

	for (i = 0; i < NODE_ADDRESS_SIZE; i += 2) {
		offset = i >> 1;
		if (e1000_read_eeprom(hw, offset, 1, &eeprom_data) < 0) {
			e_dbg("EEPROM Read Error\n");
			return -E1000_ERR_EEPROM;
    dce2:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
	}

	for (i = 0; i < NODE_ADDRESS_SIZE; i++)
		hw->mac_addr[i] = hw->perm_mac_addr[i];
	return E1000_SUCCESS;
}
    dce7:	5b                   	pop    %rbx
    dce8:	41 5c                	pop    %r12
    dcea:	41 5d                	pop    %r13
    dcec:	5d                   	pop    %rbp
    dced:	c3                   	retq   
	u16 eeprom_data, i;

	for (i = 0; i < NODE_ADDRESS_SIZE; i += 2) {
		offset = i >> 1;
		if (e1000_read_eeprom(hw, offset, 1, &eeprom_data) < 0) {
			e_dbg("EEPROM Read Error\n");
    dcee:	48 89 df             	mov    %rbx,%rdi
    dcf1:	e8 00 00 00 00       	callq  dcf6 <e1000_read_mac_addr+0xc6>
    dcf6:	48 c7 c2 00 00 00 00 	mov    $0x0,%rdx
    dcfd:	48 89 c6             	mov    %rax,%rsi
    dd00:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
    dd07:	31 c0                	xor    %eax,%eax
    dd09:	e8 00 00 00 00       	callq  dd0e <e1000_read_mac_addr+0xde>
			return -E1000_ERR_EEPROM;
    dd0e:	83 c8 ff             	or     $0xffffffff,%eax
    dd11:	eb a4                	jmp    dcb7 <e1000_read_mac_addr+0x87>
    dd13:	66 66 66 66 2e 0f 1f 	data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
    dd1a:	84 00 00 00 00 00 

000000000000dd20 <e1000_hash_mc_addr>:
 * e1000_hash_mc_addr - Hashes an address to determine its location in the multicast table
 * @hw: Struct containing variables accessed by shared code
 * @mc_addr: the multicast address to hash
 */
u32 e1000_hash_mc_addr(struct e1000_hw *hw, u8 *mc_addr)
{
    dd20:	e8 00 00 00 00       	callq  dd25 <e1000_hash_mc_addr+0x5>
    dd25:	55                   	push   %rbp
	u32 hash_value = 0;

	/* The portion of the address that is used for the hash table is
	 * determined by the mc_filter_type setting.
	 */
	switch (hw->mc_filter_type) {
    dd26:	8b 87 a0 00 00 00    	mov    0xa0(%rdi),%eax
 * e1000_hash_mc_addr - Hashes an address to determine its location in the multicast table
 * @hw: Struct containing variables accessed by shared code
 * @mc_addr: the multicast address to hash
 */
u32 e1000_hash_mc_addr(struct e1000_hw *hw, u8 *mc_addr)
{
    dd2c:	48 89 e5             	mov    %rsp,%rbp
	u32 hash_value = 0;

	/* The portion of the address that is used for the hash table is
	 * determined by the mc_filter_type setting.
	 */
	switch (hw->mc_filter_type) {
    dd2f:	83 f8 01             	cmp    $0x1,%eax
    dd32:	74 55                	je     dd89 <e1000_hash_mc_addr+0x69>
    dd34:	72 3e                	jb     dd74 <e1000_hash_mc_addr+0x54>
    dd36:	83 f8 02             	cmp    $0x2,%eax
    dd39:	74 1b                	je     dd56 <e1000_hash_mc_addr+0x36>
    dd3b:	83 f8 03             	cmp    $0x3,%eax
    dd3e:	66 90                	xchg   %ax,%ax
    dd40:	75 2e                	jne    dd70 <e1000_hash_mc_addr+0x50>
		/* [45:34] i.e. 0x5D8 for above example address */
		hash_value = ((mc_addr[4] >> 2) | (((u16) mc_addr[5]) << 6));
		break;
	case 3:
		/* [43:32] i.e. 0x634 for above example address */
		hash_value = ((mc_addr[4]) | (((u16) mc_addr[5]) << 8));
    dd42:	0f b6 46 05          	movzbl 0x5(%rsi),%eax
    dd46:	0f b6 56 04          	movzbl 0x4(%rsi),%edx
		break;
	}

	hash_value &= 0xFFF;
	return hash_value;
}
    dd4a:	5d                   	pop    %rbp
		/* [45:34] i.e. 0x5D8 for above example address */
		hash_value = ((mc_addr[4] >> 2) | (((u16) mc_addr[5]) << 6));
		break;
	case 3:
		/* [43:32] i.e. 0x634 for above example address */
		hash_value = ((mc_addr[4]) | (((u16) mc_addr[5]) << 8));
    dd4b:	c1 e0 08             	shl    $0x8,%eax
    dd4e:	09 d0                	or     %edx,%eax
    dd50:	25 ff 0f 00 00       	and    $0xfff,%eax
		break;
	}

	hash_value &= 0xFFF;
	return hash_value;
}
    dd55:	c3                   	retq   
		/* [46:35] i.e. 0xAC6 for above example address */
		hash_value = ((mc_addr[4] >> 3) | (((u16) mc_addr[5]) << 5));
		break;
	case 2:
		/* [45:34] i.e. 0x5D8 for above example address */
		hash_value = ((mc_addr[4] >> 2) | (((u16) mc_addr[5]) << 6));
    dd56:	0f b6 56 04          	movzbl 0x4(%rsi),%edx
    dd5a:	0f b6 46 05          	movzbl 0x5(%rsi),%eax
		break;
	}

	hash_value &= 0xFFF;
	return hash_value;
}
    dd5e:	5d                   	pop    %rbp
		/* [46:35] i.e. 0xAC6 for above example address */
		hash_value = ((mc_addr[4] >> 3) | (((u16) mc_addr[5]) << 5));
		break;
	case 2:
		/* [45:34] i.e. 0x5D8 for above example address */
		hash_value = ((mc_addr[4] >> 2) | (((u16) mc_addr[5]) << 6));
    dd5f:	c0 ea 02             	shr    $0x2,%dl
    dd62:	c1 e0 06             	shl    $0x6,%eax
    dd65:	0f b6 d2             	movzbl %dl,%edx
    dd68:	09 d0                	or     %edx,%eax
    dd6a:	25 ff 0f 00 00       	and    $0xfff,%eax
		break;
	}

	hash_value &= 0xFFF;
	return hash_value;
}
    dd6f:	c3                   	retq   
	u32 hash_value = 0;

	/* The portion of the address that is used for the hash table is
	 * determined by the mc_filter_type setting.
	 */
	switch (hw->mc_filter_type) {
    dd70:	31 c0                	xor    %eax,%eax
		break;
	}

	hash_value &= 0xFFF;
	return hash_value;
}
    dd72:	5d                   	pop    %rbp
    dd73:	c3                   	retq   
		 * 01  AA  00  12  34  56
		 * LSB                 MSB
		 */
	case 0:
		/* [47:36] i.e. 0x563 for above example address */
		hash_value = ((mc_addr[4] >> 4) | (((u16) mc_addr[5]) << 4));
    dd74:	0f b6 56 04          	movzbl 0x4(%rsi),%edx
    dd78:	0f b6 46 05          	movzbl 0x5(%rsi),%eax
		break;
	}

	hash_value &= 0xFFF;
	return hash_value;
}
    dd7c:	5d                   	pop    %rbp
		 * 01  AA  00  12  34  56
		 * LSB                 MSB
		 */
	case 0:
		/* [47:36] i.e. 0x563 for above example address */
		hash_value = ((mc_addr[4] >> 4) | (((u16) mc_addr[5]) << 4));
    dd7d:	c0 ea 04             	shr    $0x4,%dl
    dd80:	c1 e0 04             	shl    $0x4,%eax
    dd83:	0f b6 d2             	movzbl %dl,%edx
		break;
    dd86:	09 d0                	or     %edx,%eax
		break;
	}

	hash_value &= 0xFFF;
	return hash_value;
}
    dd88:	c3                   	retq   
		/* [47:36] i.e. 0x563 for above example address */
		hash_value = ((mc_addr[4] >> 4) | (((u16) mc_addr[5]) << 4));
		break;
	case 1:
		/* [46:35] i.e. 0xAC6 for above example address */
		hash_value = ((mc_addr[4] >> 3) | (((u16) mc_addr[5]) << 5));
    dd89:	0f b6 56 04          	movzbl 0x4(%rsi),%edx
    dd8d:	0f b6 46 05          	movzbl 0x5(%rsi),%eax
		break;
	}

	hash_value &= 0xFFF;
	return hash_value;
}
    dd91:	5d                   	pop    %rbp
		/* [47:36] i.e. 0x563 for above example address */
		hash_value = ((mc_addr[4] >> 4) | (((u16) mc_addr[5]) << 4));
		break;
	case 1:
		/* [46:35] i.e. 0xAC6 for above example address */
		hash_value = ((mc_addr[4] >> 3) | (((u16) mc_addr[5]) << 5));
    dd92:	c0 ea 03             	shr    $0x3,%dl
    dd95:	c1 e0 05             	shl    $0x5,%eax
    dd98:	0f b6 d2             	movzbl %dl,%edx
    dd9b:	09 d0                	or     %edx,%eax
    dd9d:	25 ff 0f 00 00       	and    $0xfff,%eax
		break;
	}

	hash_value &= 0xFFF;
	return hash_value;
}
    dda2:	c3                   	retq   
    dda3:	66 66 66 66 2e 0f 1f 	data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
    ddaa:	84 00 00 00 00 00 

000000000000ddb0 <e1000_rar_set>:
 * @hw: Struct containing variables accessed by shared code
 * @addr: Address to put into receive address register
 * @index: Receive address register to write
 */
void e1000_rar_set(struct e1000_hw *hw, u8 *addr, u32 index)
{
    ddb0:	e8 00 00 00 00       	callq  ddb5 <e1000_rar_set+0x5>
    ddb5:	55                   	push   %rbp
	u32 rar_low, rar_high;

	/* HW expects these in little endian so we reverse the byte order
	 * from network order (big endian) to little endian
	 */
	rar_low = ((u32) addr[0] | ((u32) addr[1] << 8) |
    ddb6:	0f b6 46 01          	movzbl 0x1(%rsi),%eax
		/* Indicate to hardware the Address is Valid. */
		rar_high |= E1000_RAH_AV;
		break;
	}

	E1000_WRITE_REG_ARRAY(hw, RA, (index << 1), rar_low);
    ddba:	44 8d 04 d5 00 00 00 	lea    0x0(,%rdx,8),%r8d
    ddc1:	00 

	/* HW expects these in little endian so we reverse the byte order
	 * from network order (big endian) to little endian
	 */
	rar_low = ((u32) addr[0] | ((u32) addr[1] << 8) |
		   ((u32) addr[2] << 16) | ((u32) addr[3] << 24));
    ddc2:	0f b6 4e 02          	movzbl 0x2(%rsi),%ecx
 * @hw: Struct containing variables accessed by shared code
 * @addr: Address to put into receive address register
 * @index: Receive address register to write
 */
void e1000_rar_set(struct e1000_hw *hw, u8 *addr, u32 index)
{
    ddc6:	48 89 e5             	mov    %rsp,%rbp
	u32 rar_low, rar_high;

	/* HW expects these in little endian so we reverse the byte order
	 * from network order (big endian) to little endian
	 */
	rar_low = ((u32) addr[0] | ((u32) addr[1] << 8) |
    ddc9:	c1 e0 08             	shl    $0x8,%eax
		   ((u32) addr[2] << 16) | ((u32) addr[3] << 24));
    ddcc:	c1 e1 10             	shl    $0x10,%ecx
	u32 rar_low, rar_high;

	/* HW expects these in little endian so we reverse the byte order
	 * from network order (big endian) to little endian
	 */
	rar_low = ((u32) addr[0] | ((u32) addr[1] << 8) |
    ddcf:	09 c8                	or     %ecx,%eax
    ddd1:	0f b6 0e             	movzbl (%rsi),%ecx
    ddd4:	09 c8                	or     %ecx,%eax
		   ((u32) addr[2] << 16) | ((u32) addr[3] << 24));
    ddd6:	0f b6 4e 03          	movzbl 0x3(%rsi),%ecx
    ddda:	c1 e1 18             	shl    $0x18,%ecx
	u32 rar_low, rar_high;

	/* HW expects these in little endian so we reverse the byte order
	 * from network order (big endian) to little endian
	 */
	rar_low = ((u32) addr[0] | ((u32) addr[1] << 8) |
    dddd:	09 c8                	or     %ecx,%eax
		   ((u32) addr[2] << 16) | ((u32) addr[3] << 24));
	rar_high = ((u32) addr[4] | ((u32) addr[5] << 8));
    dddf:	0f b6 4e 04          	movzbl 0x4(%rsi),%ecx
    dde3:	0f b6 76 05          	movzbl 0x5(%rsi),%esi
    dde7:	81 c9 00 00 00 80    	or     $0x80000000,%ecx
    dded:	c1 e6 08             	shl    $0x8,%esi
	 * on our merry way.
	 */
	switch (hw->mac_type) {
	default:
		/* Indicate to hardware the Address is Valid. */
		rar_high |= E1000_RAH_AV;
    ddf0:	09 f1                	or     %esi,%ecx
		break;
	}

	E1000_WRITE_REG_ARRAY(hw, RA, (index << 1), rar_low);
    ddf2:	83 7f 18 03          	cmpl   $0x3,0x18(%rdi)
    ddf6:	48 19 f6             	sbb    %rsi,%rsi
    ddf9:	48 81 e6 40 ac ff ff 	and    $0xffffffffffffac40,%rsi
    de00:	4a 8d b4 06 00 54 00 	lea    0x5400(%rsi,%r8,1),%rsi
    de07:	00 
    de08:	48 03 37             	add    (%rdi),%rsi
build_mmio_read(__readw, "w", unsigned short, "=r", )
build_mmio_read(__readl, "l", unsigned int, "=r", )

build_mmio_write(writeb, "b", unsigned char, "q", :"memory")
build_mmio_write(writew, "w", unsigned short, "r", :"memory")
build_mmio_write(writel, "l", unsigned int, "r", :"memory")
    de0b:	89 06                	mov    %eax,(%rsi)
	E1000_WRITE_FLUSH();
    de0d:	48 8b 07             	mov    (%rdi),%rax
{ asm volatile("mov" size " %0,%1": :reg (val), \
"m" (*(volatile type __force *)addr) barrier); }

build_mmio_read(readb, "b", unsigned char, "=q", :"memory")
build_mmio_read(readw, "w", unsigned short, "=r", :"memory")
build_mmio_read(readl, "l", unsigned int, "=r", :"memory")
    de10:	8b 40 08             	mov    0x8(%rax),%eax
	E1000_WRITE_REG_ARRAY(hw, RA, ((index << 1) + 1), rar_high);
    de13:	83 7f 18 03          	cmpl   $0x3,0x18(%rdi)
    de17:	8d 14 d5 04 00 00 00 	lea    0x4(,%rdx,8),%edx
    de1e:	48 19 c0             	sbb    %rax,%rax
    de21:	48 25 40 ac ff ff    	and    $0xffffffffffffac40,%rax
    de27:	48 8d 84 10 00 54 00 	lea    0x5400(%rax,%rdx,1),%rax
    de2e:	00 
    de2f:	48 03 07             	add    (%rdi),%rax
build_mmio_read(__readw, "w", unsigned short, "=r", )
build_mmio_read(__readl, "l", unsigned int, "=r", )

build_mmio_write(writeb, "b", unsigned char, "q", :"memory")
build_mmio_write(writew, "w", unsigned short, "r", :"memory")
build_mmio_write(writel, "l", unsigned int, "r", :"memory")
    de32:	89 08                	mov    %ecx,(%rax)
	E1000_WRITE_FLUSH();
    de34:	48 8b 07             	mov    (%rdi),%rax
{ asm volatile("mov" size " %0,%1": :reg (val), \
"m" (*(volatile type __force *)addr) barrier); }

build_mmio_read(readb, "b", unsigned char, "=q", :"memory")
build_mmio_read(readw, "w", unsigned short, "=r", :"memory")
build_mmio_read(readl, "l", unsigned int, "=r", :"memory")
    de37:	8b 40 08             	mov    0x8(%rax),%eax
}
    de3a:	5d                   	pop    %rbp
    de3b:	c3                   	retq   
    de3c:	0f 1f 40 00          	nopl   0x0(%rax)

000000000000de40 <e1000_init_hw>:
 * multicast table, and VLAN filter table. Calls routines to setup link
 * configuration and flow control settings. Clears all on-chip counters. Leaves
 * the transmit and receive units disabled and uninitialized.
 */
s32 e1000_init_hw(struct e1000_hw *hw)
{
    de40:	e8 00 00 00 00       	callq  de45 <e1000_init_hw+0x5>
    de45:	55                   	push   %rbp
    de46:	48 89 e5             	mov    %rsp,%rbp
    de49:	41 56                	push   %r14
    de4b:	53                   	push   %rbx
    de4c:	48 89 fb             	mov    %rdi,%rbx
    de4f:	48 83 ec 08          	sub    $0x8,%rsp
	const u32 ledctl_on = E1000_LEDCTL_MODE_LED_ON;
	const u32 ledctl_off = E1000_LEDCTL_MODE_LED_OFF;
	u16 eeprom_data, i, temp;
	const u16 led_mask = 0x0F;

	if (hw->mac_type < e1000_82540) {
    de53:	83 7f 18 04          	cmpl   $0x4,0x18(%rdi)
    de57:	0f 87 96 04 00 00    	ja     e2f3 <e1000_init_hw+0x4b3>
		e_dbg("Error Initializing Identification LED\n");
		return ret_val;
	}

	/* Set the media type and TBI compatibility */
	e1000_set_media_type(hw);
    de5d:	48 89 df             	mov    %rbx,%rdi
    de60:	e8 00 00 00 00       	callq  de65 <e1000_init_hw+0x25>

	/* Disabling VLAN filtering. */
	e_dbg("Initializing the IEEE VLAN\n");
    de65:	f6 05 00 00 00 00 04 	testb  $0x4,0x0(%rip)        # de6c <e1000_init_hw+0x2c>
    de6c:	0f 85 28 07 00 00    	jne    e59a <e1000_init_hw+0x75a>
	if (hw->mac_type < e1000_82545_rev_3)
    de72:	8b 53 18             	mov    0x18(%rbx),%edx
    de75:	83 fa 06             	cmp    $0x6,%edx
    de78:	0f 86 99 05 00 00    	jbe    e417 <e1000_init_hw+0x5d7>
    de7e:	31 c0                	xor    %eax,%eax
build_mmio_read(__readw, "w", unsigned short, "=r", )
build_mmio_read(__readl, "l", unsigned int, "=r", )

build_mmio_write(writeb, "b", unsigned char, "q", :"memory")
build_mmio_write(writew, "w", unsigned short, "r", :"memory")
build_mmio_write(writel, "l", unsigned int, "r", :"memory")
    de80:	31 f6                	xor    %esi,%esi
    de82:	eb 03                	jmp    de87 <e1000_init_hw+0x47>
    de84:	8b 53 18             	mov    0x18(%rbx),%edx
		/* If the offset we want to clear is the same offset of the
		 * manageability VLAN ID, then clear all bits except that of the
		 * manageability unit
		 */
		vfta_value = (offset == vfta_offset) ? vfta_bit_in_reg : 0;
		E1000_WRITE_REG_ARRAY(hw, VFTA, offset, vfta_value);
    de87:	83 fa 03             	cmp    $0x3,%edx
    de8a:	8d 0c 85 00 00 00 00 	lea    0x0(,%rax,4),%ecx
    de91:	48 19 d2             	sbb    %rdx,%rdx
    de94:	48 81 e2 00 b0 ff ff 	and    $0xffffffffffffb000,%rdx
    de9b:	48 8d 94 0a 00 56 00 	lea    0x5600(%rdx,%rcx,1),%rdx
    dea2:	00 
    dea3:	48 03 13             	add    (%rbx),%rdx
    dea6:	89 32                	mov    %esi,(%rdx)
		E1000_WRITE_FLUSH();
    dea8:	48 8b 13             	mov    (%rbx),%rdx
{ asm volatile("mov" size " %0,%1": :reg (val), \
"m" (*(volatile type __force *)addr) barrier); }

build_mmio_read(readb, "b", unsigned char, "=q", :"memory")
build_mmio_read(readw, "w", unsigned short, "=r", :"memory")
build_mmio_read(readl, "l", unsigned int, "=r", :"memory")
    deab:	8b 52 08             	mov    0x8(%rdx),%edx
	u32 offset;
	u32 vfta_value = 0;
	u32 vfta_offset = 0;
	u32 vfta_bit_in_reg = 0;

	for (offset = 0; offset < E1000_VLAN_FILTER_TBL_SIZE; offset++) {
    deae:	83 c0 01             	add    $0x1,%eax
    deb1:	3d 80 00 00 00       	cmp    $0x80,%eax
    deb6:	75 cc                	jne    de84 <e1000_init_hw+0x44>
	if (hw->mac_type < e1000_82545_rev_3)
		ew32(VET, 0);
	e1000_clear_vfta(hw);

	/* For 82542 (rev 2.0), disable MWI and put the receiver into reset */
	if (hw->mac_type == e1000_82542_rev2_0) {
    deb8:	83 7b 18 01          	cmpl   $0x1,0x18(%rbx)
    debc:	0f 84 d2 05 00 00    	je     e494 <e1000_init_hw+0x654>
{
	u32 i;
	u32 rar_num;

	/* Setup the receive address. */
	e_dbg("Programming MAC Address into RAR[0]\n");
    dec2:	f6 05 00 00 00 00 04 	testb  $0x4,0x0(%rip)        # dec9 <e1000_init_hw+0x89>
    dec9:	0f 85 3a 07 00 00    	jne    e609 <e1000_init_hw+0x7c9>

	e1000_rar_set(hw, hw->mac_addr, 0);
    decf:	48 8d b3 f4 00 00 00 	lea    0xf4(%rbx),%rsi
    ded6:	31 d2                	xor    %edx,%edx
    ded8:	48 89 df             	mov    %rbx,%rdi
    dedb:	e8 00 00 00 00       	callq  dee0 <e1000_init_hw+0xa0>

	rar_num = E1000_RAR_ENTRIES;

	/* Zero out the other 15 receive addresses. */
	e_dbg("Clearing RAR[1-15]\n");
    dee0:	f6 05 00 00 00 00 04 	testb  $0x4,0x0(%rip)        # dee7 <e1000_init_hw+0xa7>
    dee7:	0f 85 f7 06 00 00    	jne    e5e4 <e1000_init_hw+0x7a4>
		/* If the offset we want to clear is the same offset of the
		 * manageability VLAN ID, then clear all bits except that of the
		 * manageability unit
		 */
		vfta_value = (offset == vfta_offset) ? vfta_bit_in_reg : 0;
		E1000_WRITE_REG_ARRAY(hw, VFTA, offset, vfta_value);
    deed:	b8 01 00 00 00       	mov    $0x1,%eax
build_mmio_read(__readw, "w", unsigned short, "=r", )
build_mmio_read(__readl, "l", unsigned int, "=r", )

build_mmio_write(writeb, "b", unsigned char, "q", :"memory")
build_mmio_write(writew, "w", unsigned short, "r", :"memory")
build_mmio_write(writel, "l", unsigned int, "r", :"memory")
    def2:	31 c9                	xor    %ecx,%ecx
	rar_num = E1000_RAR_ENTRIES;

	/* Zero out the other 15 receive addresses. */
	e_dbg("Clearing RAR[1-15]\n");
	for (i = 1; i < rar_num; i++) {
		E1000_WRITE_REG_ARRAY(hw, RA, (i << 1), 0);
    def4:	83 7b 18 03          	cmpl   $0x3,0x18(%rbx)
    def8:	8d 34 c5 00 00 00 00 	lea    0x0(,%rax,8),%esi
    deff:	48 19 d2             	sbb    %rdx,%rdx
    df02:	48 81 e2 40 ac ff ff 	and    $0xffffffffffffac40,%rdx
    df09:	48 8d 94 32 00 54 00 	lea    0x5400(%rdx,%rsi,1),%rdx
    df10:	00 
    df11:	48 03 13             	add    (%rbx),%rdx
    df14:	89 0a                	mov    %ecx,(%rdx)
		E1000_WRITE_FLUSH();
    df16:	48 8b 13             	mov    (%rbx),%rdx
{ asm volatile("mov" size " %0,%1": :reg (val), \
"m" (*(volatile type __force *)addr) barrier); }

build_mmio_read(readb, "b", unsigned char, "=q", :"memory")
build_mmio_read(readw, "w", unsigned short, "=r", :"memory")
build_mmio_read(readl, "l", unsigned int, "=r", :"memory")
    df19:	8b 52 08             	mov    0x8(%rdx),%edx
		E1000_WRITE_REG_ARRAY(hw, RA, ((i << 1) + 1), 0);
    df1c:	83 7b 18 03          	cmpl   $0x3,0x18(%rbx)
    df20:	8d 34 c5 04 00 00 00 	lea    0x4(,%rax,8),%esi
    df27:	48 19 d2             	sbb    %rdx,%rdx
    df2a:	48 81 e2 40 ac ff ff 	and    $0xffffffffffffac40,%rdx
    df31:	48 8d 94 32 00 54 00 	lea    0x5400(%rdx,%rsi,1),%rdx
    df38:	00 
    df39:	48 03 13             	add    (%rbx),%rdx
build_mmio_read(__readw, "w", unsigned short, "=r", )
build_mmio_read(__readl, "l", unsigned int, "=r", )

build_mmio_write(writeb, "b", unsigned char, "q", :"memory")
build_mmio_write(writew, "w", unsigned short, "r", :"memory")
build_mmio_write(writel, "l", unsigned int, "r", :"memory")
    df3c:	89 0a                	mov    %ecx,(%rdx)
		E1000_WRITE_FLUSH();
    df3e:	48 8b 13             	mov    (%rbx),%rdx
{ asm volatile("mov" size " %0,%1": :reg (val), \
"m" (*(volatile type __force *)addr) barrier); }

build_mmio_read(readb, "b", unsigned char, "=q", :"memory")
build_mmio_read(readw, "w", unsigned short, "=r", :"memory")
build_mmio_read(readl, "l", unsigned int, "=r", :"memory")
    df41:	8b 52 08             	mov    0x8(%rdx),%edx

	rar_num = E1000_RAR_ENTRIES;

	/* Zero out the other 15 receive addresses. */
	e_dbg("Clearing RAR[1-15]\n");
	for (i = 1; i < rar_num; i++) {
    df44:	83 c0 01             	add    $0x1,%eax
    df47:	83 f8 0f             	cmp    $0xf,%eax
    df4a:	75 a8                	jne    def4 <e1000_init_hw+0xb4>
	 * Receive Address Registers (RARs 0 - 15).
	 */
	e1000_init_rx_addrs(hw);

	/* For 82542 (rev 2.0), take the receiver out of reset and enable MWI */
	if (hw->mac_type == e1000_82542_rev2_0) {
    df4c:	83 7b 18 01          	cmpl   $0x1,0x18(%rbx)
    df50:	0f 84 9b 05 00 00    	je     e4f1 <e1000_init_hw+0x6b1>
		if (hw->pci_cmd_word & PCI_COMMAND_INVALIDATE)
			e1000_pci_set_mwi(hw);
	}

	/* Zero out the Multicast HASH table */
	e_dbg("Zeroing the MTA\n");
    df56:	f6 05 00 00 00 00 04 	testb  $0x4,0x0(%rip)        # df5d <e1000_init_hw+0x11d>
    df5d:	0f 85 5c 06 00 00    	jne    e5bf <e1000_init_hw+0x77f>
	/* Zero out the other 15 receive addresses. */
	e_dbg("Clearing RAR[1-15]\n");
	for (i = 1; i < rar_num; i++) {
		E1000_WRITE_REG_ARRAY(hw, RA, (i << 1), 0);
		E1000_WRITE_FLUSH();
		E1000_WRITE_REG_ARRAY(hw, RA, ((i << 1) + 1), 0);
    df63:	31 c0                	xor    %eax,%eax
build_mmio_read(__readw, "w", unsigned short, "=r", )
build_mmio_read(__readl, "l", unsigned int, "=r", )

build_mmio_write(writeb, "b", unsigned char, "q", :"memory")
build_mmio_write(writew, "w", unsigned short, "r", :"memory")
build_mmio_write(writel, "l", unsigned int, "r", :"memory")
    df65:	31 f6                	xor    %esi,%esi

	/* Zero out the Multicast HASH table */
	e_dbg("Zeroing the MTA\n");
	mta_size = E1000_MC_TBL_SIZE;
	for (i = 0; i < mta_size; i++) {
		E1000_WRITE_REG_ARRAY(hw, MTA, i, 0);
    df67:	83 7b 18 03          	cmpl   $0x3,0x18(%rbx)
    df6b:	8d 0c 85 00 00 00 00 	lea    0x0(,%rax,4),%ecx
    df72:	48 19 d2             	sbb    %rdx,%rdx
    df75:	48 81 e2 00 b0 ff ff 	and    $0xffffffffffffb000,%rdx
    df7c:	48 8d 94 0a 00 52 00 	lea    0x5200(%rdx,%rcx,1),%rdx
    df83:	00 
    df84:	48 03 13             	add    (%rbx),%rdx
    df87:	89 32                	mov    %esi,(%rdx)
		/* use write flush to prevent Memory Write Block (MWB) from
		 * occurring when accessing our register space
		 */
		E1000_WRITE_FLUSH();
    df89:	48 8b 13             	mov    (%rbx),%rdx
{ asm volatile("mov" size " %0,%1": :reg (val), \
"m" (*(volatile type __force *)addr) barrier); }

build_mmio_read(readb, "b", unsigned char, "=q", :"memory")
build_mmio_read(readw, "w", unsigned short, "=r", :"memory")
build_mmio_read(readl, "l", unsigned int, "=r", :"memory")
    df8c:	8b 52 08             	mov    0x8(%rdx),%edx
	}

	/* Zero out the Multicast HASH table */
	e_dbg("Zeroing the MTA\n");
	mta_size = E1000_MC_TBL_SIZE;
	for (i = 0; i < mta_size; i++) {
    df8f:	83 c0 01             	add    $0x1,%eax
    df92:	3d 80 00 00 00       	cmp    $0x80,%eax
    df97:	75 ce                	jne    df67 <e1000_init_hw+0x127>
	/* Set the PCI priority bit correctly in the CTRL register.  This
	 * determines if the adapter gives priority to receives, or if it
	 * gives equal priority to transmits and receives.  Valid only on
	 * 82542 and 82543 silicon.
	 */
	if (hw->dma_fairness && hw->mac_type <= e1000_82543) {
    df99:	80 bb f3 00 00 00 00 	cmpb   $0x0,0xf3(%rbx)
    dfa0:	8b 43 18             	mov    0x18(%rbx),%eax
    dfa3:	74 15                	je     dfba <e1000_init_hw+0x17a>
    dfa5:	83 f8 03             	cmp    $0x3,%eax
    dfa8:	77 10                	ja     dfba <e1000_init_hw+0x17a>
		ctrl = er32(CTRL);
    dfaa:	48 8b 03             	mov    (%rbx),%rax
    dfad:	8b 00                	mov    (%rax),%eax
		ew32(CTRL, ctrl | E1000_CTRL_PRIOR);
    dfaf:	48 8b 13             	mov    (%rbx),%rdx
    dfb2:	83 c8 04             	or     $0x4,%eax
build_mmio_read(__readw, "w", unsigned short, "=r", )
build_mmio_read(__readl, "l", unsigned int, "=r", )

build_mmio_write(writeb, "b", unsigned char, "q", :"memory")
build_mmio_write(writew, "w", unsigned short, "r", :"memory")
build_mmio_write(writel, "l", unsigned int, "r", :"memory")
    dfb5:	89 02                	mov    %eax,(%rdx)
    dfb7:	8b 43 18             	mov    0x18(%rbx),%eax
	}

	switch (hw->mac_type) {
    dfba:	83 f8 07             	cmp    $0x7,%eax
    dfbd:	74 0f                	je     dfce <e1000_init_hw+0x18e>
    dfbf:	83 f8 0a             	cmp    $0xa,%eax
    dfc2:	74 0a                	je     dfce <e1000_init_hw+0x18e>
		break;
	default:
		/* Workaround for PCI-X problem when BIOS sets MMRBC
		 * incorrectly.
		 */
		if (hw->bus_type == e1000_bus_type_pcix
    dfc4:	83 7b 4c 02          	cmpl   $0x2,0x4c(%rbx)
    dfc8:	0f 84 fe 04 00 00    	je     e4cc <e1000_init_hw+0x68c>
			e1000_pcix_set_mmrbc(hw, 2048);
		break;
	}

	/* Call a subroutine to configure the link and setup flow control. */
	ret_val = e1000_setup_link(hw);
    dfce:	48 89 df             	mov    %rbx,%rdi
    dfd1:	e8 00 00 00 00       	callq  dfd6 <e1000_init_hw+0x196>

	/* Set the transmit descriptor write-back policy */
	if (hw->mac_type > e1000_82544) {
    dfd6:	83 7b 18 04          	cmpl   $0x4,0x18(%rbx)
			e1000_pcix_set_mmrbc(hw, 2048);
		break;
	}

	/* Call a subroutine to configure the link and setup flow control. */
	ret_val = e1000_setup_link(hw);
    dfda:	89 c1                	mov    %eax,%ecx

	/* Set the transmit descriptor write-back policy */
	if (hw->mac_type > e1000_82544) {
    dfdc:	76 1e                	jbe    dffc <e1000_init_hw+0x1bc>
		ctrl = er32(TXDCTL);
    dfde:	48 8b 03             	mov    (%rbx),%rax
{ asm volatile("mov" size " %0,%1": :reg (val), \
"m" (*(volatile type __force *)addr) barrier); }

build_mmio_read(readb, "b", unsigned char, "=q", :"memory")
build_mmio_read(readw, "w", unsigned short, "=r", :"memory")
build_mmio_read(readl, "l", unsigned int, "=r", :"memory")
    dfe1:	8b 90 28 38 00 00    	mov    0x3828(%rax),%edx
		ctrl =
		    (ctrl & ~E1000_TXDCTL_WTHRESH) |
    dfe7:	81 e2 ff ff c0 fe    	and    $0xfec0ffff,%edx
		    E1000_TXDCTL_FULL_TX_DESC_WB;
		ew32(TXDCTL, ctrl);
    dfed:	48 8b 03             	mov    (%rbx),%rax
	ret_val = e1000_setup_link(hw);

	/* Set the transmit descriptor write-back policy */
	if (hw->mac_type > e1000_82544) {
		ctrl = er32(TXDCTL);
		ctrl =
    dff0:	81 ca 00 00 01 01    	or     $0x1010000,%edx
build_mmio_read(__readw, "w", unsigned short, "=r", )
build_mmio_read(__readl, "l", unsigned int, "=r", )

build_mmio_write(writeb, "b", unsigned char, "q", :"memory")
build_mmio_write(writew, "w", unsigned short, "r", :"memory")
build_mmio_write(writel, "l", unsigned int, "r", :"memory")
    dff6:	89 90 28 38 00 00    	mov    %edx,0x3828(%rax)
 */
static void e1000_clear_hw_cntrs(struct e1000_hw *hw)
{
	volatile u32 temp;

	temp = er32(CRCERRS);
    dffc:	48 8b 03             	mov    (%rbx),%rax
{ asm volatile("mov" size " %0,%1": :reg (val), \
"m" (*(volatile type __force *)addr) barrier); }

build_mmio_read(readb, "b", unsigned char, "=q", :"memory")
build_mmio_read(readw, "w", unsigned short, "=r", :"memory")
build_mmio_read(readl, "l", unsigned int, "=r", :"memory")
    dfff:	8b 80 00 40 00 00    	mov    0x4000(%rax),%eax
    e005:	89 45 ec             	mov    %eax,-0x14(%rbp)
	temp = er32(SYMERRS);
    e008:	48 8b 03             	mov    (%rbx),%rax
    e00b:	8b 80 08 40 00 00    	mov    0x4008(%rax),%eax
    e011:	89 45 ec             	mov    %eax,-0x14(%rbp)
	temp = er32(MPC);
    e014:	48 8b 03             	mov    (%rbx),%rax
    e017:	8b 80 10 40 00 00    	mov    0x4010(%rax),%eax
    e01d:	89 45 ec             	mov    %eax,-0x14(%rbp)
	temp = er32(SCC);
    e020:	48 8b 03             	mov    (%rbx),%rax
    e023:	8b 80 14 40 00 00    	mov    0x4014(%rax),%eax
    e029:	89 45 ec             	mov    %eax,-0x14(%rbp)
	temp = er32(ECOL);
    e02c:	48 8b 03             	mov    (%rbx),%rax
    e02f:	8b 80 18 40 00 00    	mov    0x4018(%rax),%eax
    e035:	89 45 ec             	mov    %eax,-0x14(%rbp)
	temp = er32(MCC);
    e038:	48 8b 03             	mov    (%rbx),%rax
    e03b:	8b 80 1c 40 00 00    	mov    0x401c(%rax),%eax
    e041:	89 45 ec             	mov    %eax,-0x14(%rbp)
	temp = er32(LATECOL);
    e044:	48 8b 03             	mov    (%rbx),%rax
    e047:	8b 80 20 40 00 00    	mov    0x4020(%rax),%eax
    e04d:	89 45 ec             	mov    %eax,-0x14(%rbp)
	temp = er32(COLC);
    e050:	48 8b 03             	mov    (%rbx),%rax
    e053:	8b 80 28 40 00 00    	mov    0x4028(%rax),%eax
    e059:	89 45 ec             	mov    %eax,-0x14(%rbp)
	temp = er32(DC);
    e05c:	48 8b 03             	mov    (%rbx),%rax
    e05f:	8b 80 30 40 00 00    	mov    0x4030(%rax),%eax
    e065:	89 45 ec             	mov    %eax,-0x14(%rbp)
	temp = er32(SEC);
    e068:	48 8b 03             	mov    (%rbx),%rax
    e06b:	8b 80 38 40 00 00    	mov    0x4038(%rax),%eax
    e071:	89 45 ec             	mov    %eax,-0x14(%rbp)
	temp = er32(RLEC);
    e074:	48 8b 03             	mov    (%rbx),%rax
    e077:	8b 80 40 40 00 00    	mov    0x4040(%rax),%eax
    e07d:	89 45 ec             	mov    %eax,-0x14(%rbp)
	temp = er32(XONRXC);
    e080:	48 8b 03             	mov    (%rbx),%rax
    e083:	8b 80 48 40 00 00    	mov    0x4048(%rax),%eax
    e089:	89 45 ec             	mov    %eax,-0x14(%rbp)
	temp = er32(XONTXC);
    e08c:	48 8b 03             	mov    (%rbx),%rax
    e08f:	8b 80 4c 40 00 00    	mov    0x404c(%rax),%eax
    e095:	89 45 ec             	mov    %eax,-0x14(%rbp)
	temp = er32(XOFFRXC);
    e098:	48 8b 03             	mov    (%rbx),%rax
    e09b:	8b 80 50 40 00 00    	mov    0x4050(%rax),%eax
    e0a1:	89 45 ec             	mov    %eax,-0x14(%rbp)
	temp = er32(XOFFTXC);
    e0a4:	48 8b 03             	mov    (%rbx),%rax
    e0a7:	8b 80 54 40 00 00    	mov    0x4054(%rax),%eax
    e0ad:	89 45 ec             	mov    %eax,-0x14(%rbp)
	temp = er32(FCRUC);
    e0b0:	48 8b 03             	mov    (%rbx),%rax
    e0b3:	8b 80 58 40 00 00    	mov    0x4058(%rax),%eax
    e0b9:	89 45 ec             	mov    %eax,-0x14(%rbp)

	temp = er32(PRC64);
    e0bc:	48 8b 03             	mov    (%rbx),%rax
    e0bf:	8b 80 5c 40 00 00    	mov    0x405c(%rax),%eax
    e0c5:	89 45 ec             	mov    %eax,-0x14(%rbp)
	temp = er32(PRC127);
    e0c8:	48 8b 03             	mov    (%rbx),%rax
    e0cb:	8b 80 60 40 00 00    	mov    0x4060(%rax),%eax
    e0d1:	89 45 ec             	mov    %eax,-0x14(%rbp)
	temp = er32(PRC255);
    e0d4:	48 8b 03             	mov    (%rbx),%rax
    e0d7:	8b 80 64 40 00 00    	mov    0x4064(%rax),%eax
    e0dd:	89 45 ec             	mov    %eax,-0x14(%rbp)
	temp = er32(PRC511);
    e0e0:	48 8b 03             	mov    (%rbx),%rax
    e0e3:	8b 80 68 40 00 00    	mov    0x4068(%rax),%eax
    e0e9:	89 45 ec             	mov    %eax,-0x14(%rbp)
	temp = er32(PRC1023);
    e0ec:	48 8b 03             	mov    (%rbx),%rax
    e0ef:	8b 80 6c 40 00 00    	mov    0x406c(%rax),%eax
    e0f5:	89 45 ec             	mov    %eax,-0x14(%rbp)
	temp = er32(PRC1522);
    e0f8:	48 8b 03             	mov    (%rbx),%rax
    e0fb:	8b 80 70 40 00 00    	mov    0x4070(%rax),%eax
    e101:	89 45 ec             	mov    %eax,-0x14(%rbp)

	temp = er32(GPRC);
    e104:	48 8b 03             	mov    (%rbx),%rax
    e107:	8b 80 74 40 00 00    	mov    0x4074(%rax),%eax
    e10d:	89 45 ec             	mov    %eax,-0x14(%rbp)
	temp = er32(BPRC);
    e110:	48 8b 03             	mov    (%rbx),%rax
    e113:	8b 80 78 40 00 00    	mov    0x4078(%rax),%eax
    e119:	89 45 ec             	mov    %eax,-0x14(%rbp)
	temp = er32(MPRC);
    e11c:	48 8b 03             	mov    (%rbx),%rax
    e11f:	8b 80 7c 40 00 00    	mov    0x407c(%rax),%eax
    e125:	89 45 ec             	mov    %eax,-0x14(%rbp)
	temp = er32(GPTC);
    e128:	48 8b 03             	mov    (%rbx),%rax
    e12b:	8b 80 80 40 00 00    	mov    0x4080(%rax),%eax
    e131:	89 45 ec             	mov    %eax,-0x14(%rbp)
	temp = er32(GORCL);
    e134:	48 8b 03             	mov    (%rbx),%rax
    e137:	8b 80 88 40 00 00    	mov    0x4088(%rax),%eax
    e13d:	89 45 ec             	mov    %eax,-0x14(%rbp)
	temp = er32(GORCH);
    e140:	48 8b 03             	mov    (%rbx),%rax
    e143:	8b 80 8c 40 00 00    	mov    0x408c(%rax),%eax
    e149:	89 45 ec             	mov    %eax,-0x14(%rbp)
	temp = er32(GOTCL);
    e14c:	48 8b 03             	mov    (%rbx),%rax
    e14f:	8b 80 90 40 00 00    	mov    0x4090(%rax),%eax
    e155:	89 45 ec             	mov    %eax,-0x14(%rbp)
	temp = er32(GOTCH);
    e158:	48 8b 03             	mov    (%rbx),%rax
    e15b:	8b 80 94 40 00 00    	mov    0x4094(%rax),%eax
    e161:	89 45 ec             	mov    %eax,-0x14(%rbp)
	temp = er32(RNBC);
    e164:	48 8b 03             	mov    (%rbx),%rax
    e167:	8b 80 a0 40 00 00    	mov    0x40a0(%rax),%eax
    e16d:	89 45 ec             	mov    %eax,-0x14(%rbp)
	temp = er32(RUC);
    e170:	48 8b 03             	mov    (%rbx),%rax
    e173:	8b 80 a4 40 00 00    	mov    0x40a4(%rax),%eax
    e179:	89 45 ec             	mov    %eax,-0x14(%rbp)
	temp = er32(RFC);
    e17c:	48 8b 03             	mov    (%rbx),%rax
    e17f:	8b 80 a8 40 00 00    	mov    0x40a8(%rax),%eax
    e185:	89 45 ec             	mov    %eax,-0x14(%rbp)
	temp = er32(ROC);
    e188:	48 8b 03             	mov    (%rbx),%rax
    e18b:	8b 80 ac 40 00 00    	mov    0x40ac(%rax),%eax
    e191:	89 45 ec             	mov    %eax,-0x14(%rbp)
	temp = er32(RJC);
    e194:	48 8b 03             	mov    (%rbx),%rax
    e197:	8b 80 b0 40 00 00    	mov    0x40b0(%rax),%eax
    e19d:	89 45 ec             	mov    %eax,-0x14(%rbp)
	temp = er32(TORL);
    e1a0:	48 8b 03             	mov    (%rbx),%rax
    e1a3:	8b 80 c0 40 00 00    	mov    0x40c0(%rax),%eax
    e1a9:	89 45 ec             	mov    %eax,-0x14(%rbp)
	temp = er32(TORH);
    e1ac:	48 8b 03             	mov    (%rbx),%rax
    e1af:	8b 80 c4 40 00 00    	mov    0x40c4(%rax),%eax
    e1b5:	89 45 ec             	mov    %eax,-0x14(%rbp)
	temp = er32(TOTL);
    e1b8:	48 8b 03             	mov    (%rbx),%rax
    e1bb:	8b 80 c8 40 00 00    	mov    0x40c8(%rax),%eax
    e1c1:	89 45 ec             	mov    %eax,-0x14(%rbp)
	temp = er32(TOTH);
    e1c4:	48 8b 03             	mov    (%rbx),%rax
    e1c7:	8b 80 cc 40 00 00    	mov    0x40cc(%rax),%eax
    e1cd:	89 45 ec             	mov    %eax,-0x14(%rbp)
	temp = er32(TPR);
    e1d0:	48 8b 03             	mov    (%rbx),%rax
    e1d3:	8b 80 d0 40 00 00    	mov    0x40d0(%rax),%eax
    e1d9:	89 45 ec             	mov    %eax,-0x14(%rbp)
	temp = er32(TPT);
    e1dc:	48 8b 03             	mov    (%rbx),%rax
    e1df:	8b 80 d4 40 00 00    	mov    0x40d4(%rax),%eax
    e1e5:	89 45 ec             	mov    %eax,-0x14(%rbp)

	temp = er32(PTC64);
    e1e8:	48 8b 03             	mov    (%rbx),%rax
    e1eb:	8b 80 d8 40 00 00    	mov    0x40d8(%rax),%eax
    e1f1:	89 45 ec             	mov    %eax,-0x14(%rbp)
	temp = er32(PTC127);
    e1f4:	48 8b 03             	mov    (%rbx),%rax
    e1f7:	8b 80 dc 40 00 00    	mov    0x40dc(%rax),%eax
    e1fd:	89 45 ec             	mov    %eax,-0x14(%rbp)
	temp = er32(PTC255);
    e200:	48 8b 03             	mov    (%rbx),%rax
    e203:	8b 80 e0 40 00 00    	mov    0x40e0(%rax),%eax
    e209:	89 45 ec             	mov    %eax,-0x14(%rbp)
	temp = er32(PTC511);
    e20c:	48 8b 03             	mov    (%rbx),%rax
    e20f:	8b 80 e4 40 00 00    	mov    0x40e4(%rax),%eax
    e215:	89 45 ec             	mov    %eax,-0x14(%rbp)
	temp = er32(PTC1023);
    e218:	48 8b 03             	mov    (%rbx),%rax
    e21b:	8b 80 e8 40 00 00    	mov    0x40e8(%rax),%eax
    e221:	89 45 ec             	mov    %eax,-0x14(%rbp)
	temp = er32(PTC1522);
    e224:	48 8b 03             	mov    (%rbx),%rax
    e227:	8b 80 ec 40 00 00    	mov    0x40ec(%rax),%eax
    e22d:	89 45 ec             	mov    %eax,-0x14(%rbp)

	temp = er32(MPTC);
    e230:	48 8b 03             	mov    (%rbx),%rax
    e233:	8b 80 f0 40 00 00    	mov    0x40f0(%rax),%eax
    e239:	89 45 ec             	mov    %eax,-0x14(%rbp)
	temp = er32(BPTC);
    e23c:	48 8b 03             	mov    (%rbx),%rax
    e23f:	8b 80 f4 40 00 00    	mov    0x40f4(%rax),%eax

	if (hw->mac_type < e1000_82543)
    e245:	83 7b 18 02          	cmpl   $0x2,0x18(%rbx)
	temp = er32(PTC511);
	temp = er32(PTC1023);
	temp = er32(PTC1522);

	temp = er32(MPTC);
	temp = er32(BPTC);
    e249:	89 45 ec             	mov    %eax,-0x14(%rbp)

	if (hw->mac_type < e1000_82543)
    e24c:	76 72                	jbe    e2c0 <e1000_init_hw+0x480>
		return;

	temp = er32(ALGNERRC);
    e24e:	48 8b 03             	mov    (%rbx),%rax
    e251:	8b 80 04 40 00 00    	mov    0x4004(%rax),%eax
    e257:	89 45 ec             	mov    %eax,-0x14(%rbp)
	temp = er32(RXERRC);
    e25a:	48 8b 03             	mov    (%rbx),%rax
    e25d:	8b 80 0c 40 00 00    	mov    0x400c(%rax),%eax
    e263:	89 45 ec             	mov    %eax,-0x14(%rbp)
	temp = er32(TNCRS);
    e266:	48 8b 03             	mov    (%rbx),%rax
    e269:	8b 80 34 40 00 00    	mov    0x4034(%rax),%eax
    e26f:	89 45 ec             	mov    %eax,-0x14(%rbp)
	temp = er32(CEXTERR);
    e272:	48 8b 03             	mov    (%rbx),%rax
    e275:	8b 80 3c 40 00 00    	mov    0x403c(%rax),%eax
    e27b:	89 45 ec             	mov    %eax,-0x14(%rbp)
	temp = er32(TSCTC);
    e27e:	48 8b 03             	mov    (%rbx),%rax
    e281:	8b 80 f8 40 00 00    	mov    0x40f8(%rax),%eax
    e287:	89 45 ec             	mov    %eax,-0x14(%rbp)
	temp = er32(TSCTFC);
    e28a:	48 8b 03             	mov    (%rbx),%rax
    e28d:	8b 80 fc 40 00 00    	mov    0x40fc(%rax),%eax

	if (hw->mac_type <= e1000_82544)
    e293:	83 7b 18 04          	cmpl   $0x4,0x18(%rbx)
	temp = er32(ALGNERRC);
	temp = er32(RXERRC);
	temp = er32(TNCRS);
	temp = er32(CEXTERR);
	temp = er32(TSCTC);
	temp = er32(TSCTFC);
    e297:	89 45 ec             	mov    %eax,-0x14(%rbp)

	if (hw->mac_type <= e1000_82544)
    e29a:	76 24                	jbe    e2c0 <e1000_init_hw+0x480>
		return;

	temp = er32(MGTPRC);
    e29c:	48 8b 03             	mov    (%rbx),%rax
    e29f:	8b 80 b4 40 00 00    	mov    0x40b4(%rax),%eax
    e2a5:	89 45 ec             	mov    %eax,-0x14(%rbp)
	temp = er32(MGTPDC);
    e2a8:	48 8b 03             	mov    (%rbx),%rax
    e2ab:	8b 80 b8 40 00 00    	mov    0x40b8(%rax),%eax
    e2b1:	89 45 ec             	mov    %eax,-0x14(%rbp)
	temp = er32(MGTPTC);
    e2b4:	48 8b 03             	mov    (%rbx),%rax
    e2b7:	8b 80 bc 40 00 00    	mov    0x40bc(%rax),%eax
    e2bd:	89 45 ec             	mov    %eax,-0x14(%rbp)
	 * because the symbol error count will increment wildly if there
	 * is no link.
	 */
	e1000_clear_hw_cntrs(hw);

	if (hw->device_id == E1000_DEV_ID_82546GB_QUAD_COPPER ||
    e2c0:	0f b7 93 e6 00 00 00 	movzwl 0xe6(%rbx),%edx
    e2c7:	66 81 fa b5 10       	cmp    $0x10b5,%dx
    e2cc:	74 09                	je     e2d7 <e1000_init_hw+0x497>
    e2ce:	66 81 fa 99 10       	cmp    $0x1099,%dx
		 */
		ctrl_ext |= E1000_CTRL_EXT_RO_DIS;
		ew32(CTRL_EXT, ctrl_ext);
	}

	return ret_val;
    e2d3:	89 c8                	mov    %ecx,%eax
	 * because the symbol error count will increment wildly if there
	 * is no link.
	 */
	e1000_clear_hw_cntrs(hw);

	if (hw->device_id == E1000_DEV_ID_82546GB_QUAD_COPPER ||
    e2d5:	75 13                	jne    e2ea <e1000_init_hw+0x4aa>
	    hw->device_id == E1000_DEV_ID_82546GB_QUAD_COPPER_KSP3) {
		ctrl_ext = er32(CTRL_EXT);
    e2d7:	48 8b 03             	mov    (%rbx),%rax
    e2da:	8b 40 18             	mov    0x18(%rax),%eax
		/* Relaxed ordering must be disabled to avoid a parity
		 * error crash in a PCI slot.
		 */
		ctrl_ext |= E1000_CTRL_EXT_RO_DIS;
    e2dd:	0d 00 00 02 00       	or     $0x20000,%eax
		ew32(CTRL_EXT, ctrl_ext);
    e2e2:	48 8b 13             	mov    (%rbx),%rdx
build_mmio_read(__readw, "w", unsigned short, "=r", )
build_mmio_read(__readl, "l", unsigned int, "=r", )

build_mmio_write(writeb, "b", unsigned char, "q", :"memory")
build_mmio_write(writew, "w", unsigned short, "r", :"memory")
build_mmio_write(writel, "l", unsigned int, "r", :"memory")
    e2e5:	89 42 18             	mov    %eax,0x18(%rdx)
	}

	return ret_val;
    e2e8:	89 c8                	mov    %ecx,%eax
}
    e2ea:	48 83 c4 08          	add    $0x8,%rsp
    e2ee:	5b                   	pop    %rbx
    e2ef:	41 5e                	pop    %r14
    e2f1:	5d                   	pop    %rbp
    e2f2:	c3                   	retq   
	if (hw->mac_type < e1000_82540) {
		/* Nothing to do */
		return E1000_SUCCESS;
	}

	ledctl = er32(LEDCTL);
    e2f3:	48 8b 07             	mov    (%rdi),%rax
{ asm volatile("mov" size " %0,%1": :reg (val), \
"m" (*(volatile type __force *)addr) barrier); }

build_mmio_read(readb, "b", unsigned char, "=q", :"memory")
build_mmio_read(readw, "w", unsigned short, "=r", :"memory")
build_mmio_read(readl, "l", unsigned int, "=r", :"memory")
    e2f6:	8b 80 00 0e 00 00    	mov    0xe00(%rax),%eax
	hw->ledctl_default = ledctl;
	hw->ledctl_mode1 = hw->ledctl_default;
	hw->ledctl_mode2 = hw->ledctl_default;

	if (e1000_read_eeprom(hw, EEPROM_ID_LED_SETTINGS, 1, &eeprom_data) < 0) {
    e2fc:	48 8d 4d ec          	lea    -0x14(%rbp),%rcx
		/* Nothing to do */
		return E1000_SUCCESS;
	}

	ledctl = er32(LEDCTL);
	hw->ledctl_default = ledctl;
    e300:	89 87 b0 00 00 00    	mov    %eax,0xb0(%rdi)
	hw->ledctl_mode1 = hw->ledctl_default;
    e306:	89 87 b4 00 00 00    	mov    %eax,0xb4(%rdi)
	hw->ledctl_mode2 = hw->ledctl_default;
    e30c:	89 87 b8 00 00 00    	mov    %eax,0xb8(%rdi)

	if (e1000_read_eeprom(hw, EEPROM_ID_LED_SETTINGS, 1, &eeprom_data) < 0) {
    e312:	ba 01 00 00 00       	mov    $0x1,%edx
    e317:	be 04 00 00 00       	mov    $0x4,%esi
    e31c:	e8 00 00 00 00       	callq  e321 <e1000_init_hw+0x4e1>
    e321:	85 c0                	test   %eax,%eax
    e323:	0f 88 43 01 00 00    	js     e46c <e1000_init_hw+0x62c>
		e_dbg("EEPROM Read Error\n");
		return -E1000_ERR_EEPROM;
	}

	if ((eeprom_data == ID_LED_RESERVED_0000) ||
    e329:	44 0f b7 45 ec       	movzwl -0x14(%rbp),%r8d
    e32e:	41 8d 40 ff          	lea    -0x1(%r8),%eax
    e332:	66 83 f8 fd          	cmp    $0xfffd,%ax
    e336:	0f 87 1c 01 00 00    	ja     e458 <e1000_init_hw+0x618>
	    (eeprom_data == ID_LED_RESERVED_FFFF)) {
		eeprom_data = ID_LED_DEFAULT;
    e33c:	31 c0                	xor    %eax,%eax
		temp = (eeprom_data >> (i << 2)) & led_mask;
		switch (temp) {
		case ID_LED_ON1_DEF2:
		case ID_LED_ON1_ON2:
		case ID_LED_ON1_OFF2:
			hw->ledctl_mode1 &= ~(ledctl_mask << (i << 3));
    e33e:	bf ff 00 00 00       	mov    $0xff,%edi
			hw->ledctl_mode1 |= ledctl_on << (i << 3);
    e343:	41 bb 0e 00 00 00    	mov    $0xe,%r11d
			break;
		case ID_LED_OFF1_DEF2:
		case ID_LED_OFF1_ON2:
		case ID_LED_OFF1_OFF2:
			hw->ledctl_mode1 &= ~(ledctl_mask << (i << 3));
			hw->ledctl_mode1 |= ledctl_off << (i << 3);
    e349:	41 b9 0f 00 00 00    	mov    $0xf,%r9d
    e34f:	41 ba 01 00 00 00    	mov    $0x1,%r10d
	    (eeprom_data == ID_LED_RESERVED_FFFF)) {
		eeprom_data = ID_LED_DEFAULT;
	}

	for (i = 0; i < 4; i++) {
		temp = (eeprom_data >> (i << 2)) & led_mask;
    e355:	8d 0c 85 00 00 00 00 	lea    0x0(,%rax,4),%ecx
    e35c:	44 89 c2             	mov    %r8d,%edx
    e35f:	d3 fa                	sar    %cl,%edx
    e361:	83 e2 0f             	and    $0xf,%edx
		switch (temp) {
    e364:	66 83 fa 04          	cmp    $0x4,%dx
    e368:	72 2e                	jb     e398 <e1000_init_hw+0x558>
    e36a:	66 83 fa 06          	cmp    $0x6,%dx
    e36e:	76 52                	jbe    e3c2 <e1000_init_hw+0x582>
    e370:	66 83 fa 09          	cmp    $0x9,%dx
    e374:	77 22                	ja     e398 <e1000_init_hw+0x558>
			hw->ledctl_mode1 |= ledctl_on << (i << 3);
			break;
		case ID_LED_OFF1_DEF2:
		case ID_LED_OFF1_ON2:
		case ID_LED_OFF1_OFF2:
			hw->ledctl_mode1 &= ~(ledctl_mask << (i << 3));
    e376:	8d 0c c5 00 00 00 00 	lea    0x0(,%rax,8),%ecx
    e37d:	89 fe                	mov    %edi,%esi
			hw->ledctl_mode1 |= ledctl_off << (i << 3);
    e37f:	45 89 ce             	mov    %r9d,%r14d
			hw->ledctl_mode1 |= ledctl_on << (i << 3);
			break;
		case ID_LED_OFF1_DEF2:
		case ID_LED_OFF1_ON2:
		case ID_LED_OFF1_OFF2:
			hw->ledctl_mode1 &= ~(ledctl_mask << (i << 3));
    e382:	d3 e6                	shl    %cl,%esi
			hw->ledctl_mode1 |= ledctl_off << (i << 3);
    e384:	41 d3 e6             	shl    %cl,%r14d
			hw->ledctl_mode1 |= ledctl_on << (i << 3);
			break;
		case ID_LED_OFF1_DEF2:
		case ID_LED_OFF1_ON2:
		case ID_LED_OFF1_OFF2:
			hw->ledctl_mode1 &= ~(ledctl_mask << (i << 3));
    e387:	f7 d6                	not    %esi
    e389:	23 b3 b4 00 00 00    	and    0xb4(%rbx),%esi
			hw->ledctl_mode1 |= ledctl_off << (i << 3);
    e38f:	44 09 f6             	or     %r14d,%esi
    e392:	89 b3 b4 00 00 00    	mov    %esi,0xb4(%rbx)
    e398:	8d 4a fe             	lea    -0x2(%rdx),%ecx
    e39b:	66 83 f9 07          	cmp    $0x7,%cx
    e39f:	77 14                	ja     e3b5 <e1000_init_hw+0x575>
    e3a1:	4c 89 d6             	mov    %r10,%rsi
    e3a4:	48 d3 e6             	shl    %cl,%rsi
    e3a7:	40 f6 c6 92          	test   $0x92,%sil
    e3ab:	48 89 f1             	mov    %rsi,%rcx
    e3ae:	75 36                	jne    e3e6 <e1000_init_hw+0x5a6>
    e3b0:	83 e1 49             	and    $0x49,%ecx
    e3b3:	75 72                	jne    e427 <e1000_init_hw+0x5e7>
    e3b5:	83 c0 01             	add    $0x1,%eax
	if ((eeprom_data == ID_LED_RESERVED_0000) ||
	    (eeprom_data == ID_LED_RESERVED_FFFF)) {
		eeprom_data = ID_LED_DEFAULT;
	}

	for (i = 0; i < 4; i++) {
    e3b8:	83 f8 04             	cmp    $0x4,%eax
    e3bb:	75 98                	jne    e355 <e1000_init_hw+0x515>
    e3bd:	e9 9b fa ff ff       	jmpq   de5d <e1000_init_hw+0x1d>
		temp = (eeprom_data >> (i << 2)) & led_mask;
		switch (temp) {
		case ID_LED_ON1_DEF2:
		case ID_LED_ON1_ON2:
		case ID_LED_ON1_OFF2:
			hw->ledctl_mode1 &= ~(ledctl_mask << (i << 3));
    e3c2:	8d 0c c5 00 00 00 00 	lea    0x0(,%rax,8),%ecx
    e3c9:	89 fe                	mov    %edi,%esi
			hw->ledctl_mode1 |= ledctl_on << (i << 3);
    e3cb:	45 89 de             	mov    %r11d,%r14d
		temp = (eeprom_data >> (i << 2)) & led_mask;
		switch (temp) {
		case ID_LED_ON1_DEF2:
		case ID_LED_ON1_ON2:
		case ID_LED_ON1_OFF2:
			hw->ledctl_mode1 &= ~(ledctl_mask << (i << 3));
    e3ce:	d3 e6                	shl    %cl,%esi
			hw->ledctl_mode1 |= ledctl_on << (i << 3);
    e3d0:	41 d3 e6             	shl    %cl,%r14d
		temp = (eeprom_data >> (i << 2)) & led_mask;
		switch (temp) {
		case ID_LED_ON1_DEF2:
		case ID_LED_ON1_ON2:
		case ID_LED_ON1_OFF2:
			hw->ledctl_mode1 &= ~(ledctl_mask << (i << 3));
    e3d3:	f7 d6                	not    %esi
    e3d5:	23 b3 b4 00 00 00    	and    0xb4(%rbx),%esi
			hw->ledctl_mode1 |= ledctl_on << (i << 3);
    e3db:	44 09 f6             	or     %r14d,%esi
    e3de:	89 b3 b4 00 00 00    	mov    %esi,0xb4(%rbx)
    e3e4:	eb b2                	jmp    e398 <e1000_init_hw+0x558>
			hw->ledctl_mode2 |= ledctl_on << (i << 3);
			break;
		case ID_LED_DEF1_OFF2:
		case ID_LED_ON1_OFF2:
		case ID_LED_OFF1_OFF2:
			hw->ledctl_mode2 &= ~(ledctl_mask << (i << 3));
    e3e6:	8d 0c c5 00 00 00 00 	lea    0x0(,%rax,8),%ecx
    e3ed:	89 fa                	mov    %edi,%edx
			hw->ledctl_mode2 |= ledctl_off << (i << 3);
    e3ef:	44 89 ce             	mov    %r9d,%esi
    e3f2:	83 c0 01             	add    $0x1,%eax
			hw->ledctl_mode2 |= ledctl_on << (i << 3);
			break;
		case ID_LED_DEF1_OFF2:
		case ID_LED_ON1_OFF2:
		case ID_LED_OFF1_OFF2:
			hw->ledctl_mode2 &= ~(ledctl_mask << (i << 3));
    e3f5:	d3 e2                	shl    %cl,%edx
			hw->ledctl_mode2 |= ledctl_off << (i << 3);
    e3f7:	d3 e6                	shl    %cl,%esi
			hw->ledctl_mode2 |= ledctl_on << (i << 3);
			break;
		case ID_LED_DEF1_OFF2:
		case ID_LED_ON1_OFF2:
		case ID_LED_OFF1_OFF2:
			hw->ledctl_mode2 &= ~(ledctl_mask << (i << 3));
    e3f9:	f7 d2                	not    %edx
    e3fb:	23 93 b8 00 00 00    	and    0xb8(%rbx),%edx
			hw->ledctl_mode2 |= ledctl_off << (i << 3);
    e401:	09 f2                	or     %esi,%edx
	if ((eeprom_data == ID_LED_RESERVED_0000) ||
	    (eeprom_data == ID_LED_RESERVED_FFFF)) {
		eeprom_data = ID_LED_DEFAULT;
	}

	for (i = 0; i < 4; i++) {
    e403:	83 f8 04             	cmp    $0x4,%eax
			break;
		case ID_LED_DEF1_OFF2:
		case ID_LED_ON1_OFF2:
		case ID_LED_OFF1_OFF2:
			hw->ledctl_mode2 &= ~(ledctl_mask << (i << 3));
			hw->ledctl_mode2 |= ledctl_off << (i << 3);
    e406:	89 93 b8 00 00 00    	mov    %edx,0xb8(%rbx)
	if ((eeprom_data == ID_LED_RESERVED_0000) ||
	    (eeprom_data == ID_LED_RESERVED_FFFF)) {
		eeprom_data = ID_LED_DEFAULT;
	}

	for (i = 0; i < 4; i++) {
    e40c:	0f 85 43 ff ff ff    	jne    e355 <e1000_init_hw+0x515>
    e412:	e9 46 fa ff ff       	jmpq   de5d <e1000_init_hw+0x1d>
	e1000_set_media_type(hw);

	/* Disabling VLAN filtering. */
	e_dbg("Initializing the IEEE VLAN\n");
	if (hw->mac_type < e1000_82545_rev_3)
		ew32(VET, 0);
    e417:	48 8b 13             	mov    (%rbx),%rdx
build_mmio_read(__readw, "w", unsigned short, "=r", )
build_mmio_read(__readl, "l", unsigned int, "=r", )

build_mmio_write(writeb, "b", unsigned char, "q", :"memory")
build_mmio_write(writew, "w", unsigned short, "r", :"memory")
build_mmio_write(writel, "l", unsigned int, "r", :"memory")
    e41a:	31 c0                	xor    %eax,%eax
    e41c:	89 42 38             	mov    %eax,0x38(%rdx)
    e41f:	8b 53 18             	mov    0x18(%rbx),%edx
    e422:	e9 57 fa ff ff       	jmpq   de7e <e1000_init_hw+0x3e>
		}
		switch (temp) {
		case ID_LED_DEF1_ON2:
		case ID_LED_ON1_ON2:
		case ID_LED_OFF1_ON2:
			hw->ledctl_mode2 &= ~(ledctl_mask << (i << 3));
    e427:	8d 0c c5 00 00 00 00 	lea    0x0(,%rax,8),%ecx
    e42e:	89 fa                	mov    %edi,%edx
			hw->ledctl_mode2 |= ledctl_on << (i << 3);
    e430:	44 89 de             	mov    %r11d,%esi
    e433:	83 c0 01             	add    $0x1,%eax
		}
		switch (temp) {
		case ID_LED_DEF1_ON2:
		case ID_LED_ON1_ON2:
		case ID_LED_OFF1_ON2:
			hw->ledctl_mode2 &= ~(ledctl_mask << (i << 3));
    e436:	d3 e2                	shl    %cl,%edx
			hw->ledctl_mode2 |= ledctl_on << (i << 3);
    e438:	d3 e6                	shl    %cl,%esi
		}
		switch (temp) {
		case ID_LED_DEF1_ON2:
		case ID_LED_ON1_ON2:
		case ID_LED_OFF1_ON2:
			hw->ledctl_mode2 &= ~(ledctl_mask << (i << 3));
    e43a:	f7 d2                	not    %edx
    e43c:	23 93 b8 00 00 00    	and    0xb8(%rbx),%edx
			hw->ledctl_mode2 |= ledctl_on << (i << 3);
    e442:	09 f2                	or     %esi,%edx
	if ((eeprom_data == ID_LED_RESERVED_0000) ||
	    (eeprom_data == ID_LED_RESERVED_FFFF)) {
		eeprom_data = ID_LED_DEFAULT;
	}

	for (i = 0; i < 4; i++) {
    e444:	83 f8 04             	cmp    $0x4,%eax
		switch (temp) {
		case ID_LED_DEF1_ON2:
		case ID_LED_ON1_ON2:
		case ID_LED_OFF1_ON2:
			hw->ledctl_mode2 &= ~(ledctl_mask << (i << 3));
			hw->ledctl_mode2 |= ledctl_on << (i << 3);
    e447:	89 93 b8 00 00 00    	mov    %edx,0xb8(%rbx)
	if ((eeprom_data == ID_LED_RESERVED_0000) ||
	    (eeprom_data == ID_LED_RESERVED_FFFF)) {
		eeprom_data = ID_LED_DEFAULT;
	}

	for (i = 0; i < 4; i++) {
    e44d:	0f 85 02 ff ff ff    	jne    e355 <e1000_init_hw+0x515>
    e453:	e9 05 fa ff ff       	jmpq   de5d <e1000_init_hw+0x1d>
		return -E1000_ERR_EEPROM;
	}

	if ((eeprom_data == ID_LED_RESERVED_0000) ||
	    (eeprom_data == ID_LED_RESERVED_FFFF)) {
		eeprom_data = ID_LED_DEFAULT;
    e458:	b8 11 89 ff ff       	mov    $0xffff8911,%eax
    e45d:	41 b8 11 89 00 00    	mov    $0x8911,%r8d
    e463:	66 89 45 ec          	mov    %ax,-0x14(%rbp)
    e467:	e9 d0 fe ff ff       	jmpq   e33c <e1000_init_hw+0x4fc>
	hw->ledctl_default = ledctl;
	hw->ledctl_mode1 = hw->ledctl_default;
	hw->ledctl_mode2 = hw->ledctl_default;

	if (e1000_read_eeprom(hw, EEPROM_ID_LED_SETTINGS, 1, &eeprom_data) < 0) {
		e_dbg("EEPROM Read Error\n");
    e46c:	f6 05 00 00 00 00 04 	testb  $0x4,0x0(%rip)        # e473 <e1000_init_hw+0x633>
    e473:	0f 85 fc 00 00 00    	jne    e575 <e1000_init_hw+0x735>
	u32 ctrl_ext;

	/* Initialize Identification LED */
	ret_val = e1000_id_led_init(hw);
	if (ret_val) {
		e_dbg("Error Initializing Identification LED\n");
    e479:	f6 05 00 00 00 00 04 	testb  $0x4,0x0(%rip)        # e480 <e1000_init_hw+0x640>
    e480:	0f 85 c5 00 00 00    	jne    e54b <e1000_init_hw+0x70b>
		ctrl_ext |= E1000_CTRL_EXT_RO_DIS;
		ew32(CTRL_EXT, ctrl_ext);
	}

	return ret_val;
}
    e486:	48 83 c4 08          	add    $0x8,%rsp
    e48a:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
    e48f:	5b                   	pop    %rbx
    e490:	41 5e                	pop    %r14
    e492:	5d                   	pop    %rbp
    e493:	c3                   	retq   
		ew32(VET, 0);
	e1000_clear_vfta(hw);

	/* For 82542 (rev 2.0), disable MWI and put the receiver into reset */
	if (hw->mac_type == e1000_82542_rev2_0) {
		e_dbg("Disabling MWI on 82542 rev 2.0\n");
    e494:	f6 05 00 00 00 00 04 	testb  $0x4,0x0(%rip)        # e49b <e1000_init_hw+0x65b>
    e49b:	0f 85 85 00 00 00    	jne    e526 <e1000_init_hw+0x6e6>
		e1000_pci_clear_mwi(hw);
    e4a1:	48 89 df             	mov    %rbx,%rdi
    e4a4:	e8 00 00 00 00       	callq  e4a9 <e1000_init_hw+0x669>
		ew32(RCTL, E1000_RCTL_RST);
    e4a9:	48 8b 13             	mov    (%rbx),%rdx
    e4ac:	b8 01 00 00 00       	mov    $0x1,%eax
    e4b1:	89 82 00 01 00 00    	mov    %eax,0x100(%rdx)
		E1000_WRITE_FLUSH();
    e4b7:	48 8b 03             	mov    (%rbx),%rax
{ asm volatile("mov" size " %0,%1": :reg (val), \
"m" (*(volatile type __force *)addr) barrier); }

build_mmio_read(readb, "b", unsigned char, "=q", :"memory")
build_mmio_read(readw, "w", unsigned short, "=r", :"memory")
build_mmio_read(readl, "l", unsigned int, "=r", :"memory")
    e4ba:	8b 40 08             	mov    0x8(%rax),%eax
		msleep(5);
    e4bd:	bf 05 00 00 00       	mov    $0x5,%edi
    e4c2:	e8 00 00 00 00       	callq  e4c7 <e1000_init_hw+0x687>
    e4c7:	e9 f6 f9 ff ff       	jmpq   dec2 <e1000_init_hw+0x82>
	default:
		/* Workaround for PCI-X problem when BIOS sets MMRBC
		 * incorrectly.
		 */
		if (hw->bus_type == e1000_bus_type_pcix
		    && e1000_pcix_get_mmrbc(hw) > 2048)
    e4cc:	48 89 df             	mov    %rbx,%rdi
    e4cf:	e8 00 00 00 00       	callq  e4d4 <e1000_init_hw+0x694>
    e4d4:	3d 00 08 00 00       	cmp    $0x800,%eax
    e4d9:	0f 8e ef fa ff ff    	jle    dfce <e1000_init_hw+0x18e>
			e1000_pcix_set_mmrbc(hw, 2048);
    e4df:	be 00 08 00 00       	mov    $0x800,%esi
    e4e4:	48 89 df             	mov    %rbx,%rdi
    e4e7:	e8 00 00 00 00       	callq  e4ec <e1000_init_hw+0x6ac>
    e4ec:	e9 dd fa ff ff       	jmpq   dfce <e1000_init_hw+0x18e>
	 */
	e1000_init_rx_addrs(hw);

	/* For 82542 (rev 2.0), take the receiver out of reset and enable MWI */
	if (hw->mac_type == e1000_82542_rev2_0) {
		ew32(RCTL, 0);
    e4f1:	48 8b 13             	mov    (%rbx),%rdx
build_mmio_read(__readw, "w", unsigned short, "=r", )
build_mmio_read(__readl, "l", unsigned int, "=r", )

build_mmio_write(writeb, "b", unsigned char, "q", :"memory")
build_mmio_write(writew, "w", unsigned short, "r", :"memory")
build_mmio_write(writel, "l", unsigned int, "r", :"memory")
    e4f4:	30 c0                	xor    %al,%al
    e4f6:	89 82 00 01 00 00    	mov    %eax,0x100(%rdx)
		E1000_WRITE_FLUSH();
    e4fc:	48 8b 03             	mov    (%rbx),%rax
{ asm volatile("mov" size " %0,%1": :reg (val), \
"m" (*(volatile type __force *)addr) barrier); }

build_mmio_read(readb, "b", unsigned char, "=q", :"memory")
build_mmio_read(readw, "w", unsigned short, "=r", :"memory")
build_mmio_read(readl, "l", unsigned int, "=r", :"memory")
    e4ff:	8b 40 08             	mov    0x8(%rax),%eax
		msleep(1);
    e502:	bf 01 00 00 00       	mov    $0x1,%edi
    e507:	e8 00 00 00 00       	callq  e50c <e1000_init_hw+0x6cc>
		if (hw->pci_cmd_word & PCI_COMMAND_INVALIDATE)
    e50c:	f6 83 d4 00 00 00 10 	testb  $0x10,0xd4(%rbx)
    e513:	0f 84 3d fa ff ff    	je     df56 <e1000_init_hw+0x116>
			e1000_pci_set_mwi(hw);
    e519:	48 89 df             	mov    %rbx,%rdi
    e51c:	e8 00 00 00 00       	callq  e521 <e1000_init_hw+0x6e1>
    e521:	e9 30 fa ff ff       	jmpq   df56 <e1000_init_hw+0x116>
		ew32(VET, 0);
	e1000_clear_vfta(hw);

	/* For 82542 (rev 2.0), disable MWI and put the receiver into reset */
	if (hw->mac_type == e1000_82542_rev2_0) {
		e_dbg("Disabling MWI on 82542 rev 2.0\n");
    e526:	48 89 df             	mov    %rbx,%rdi
    e529:	e8 00 00 00 00       	callq  e52e <e1000_init_hw+0x6ee>
    e52e:	48 c7 c2 00 00 00 00 	mov    $0x0,%rdx
    e535:	48 89 c6             	mov    %rax,%rsi
    e538:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
    e53f:	31 c0                	xor    %eax,%eax
    e541:	e8 00 00 00 00       	callq  e546 <e1000_init_hw+0x706>
    e546:	e9 56 ff ff ff       	jmpq   e4a1 <e1000_init_hw+0x661>
	u32 ctrl_ext;

	/* Initialize Identification LED */
	ret_val = e1000_id_led_init(hw);
	if (ret_val) {
		e_dbg("Error Initializing Identification LED\n");
    e54b:	48 89 df             	mov    %rbx,%rdi
    e54e:	e8 00 00 00 00       	callq  e553 <e1000_init_hw+0x713>
    e553:	48 c7 c2 00 00 00 00 	mov    $0x0,%rdx
    e55a:	48 89 c6             	mov    %rax,%rsi
    e55d:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
    e564:	31 c0                	xor    %eax,%eax
    e566:	e8 00 00 00 00       	callq  e56b <e1000_init_hw+0x72b>
    e56b:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
    e570:	e9 75 fd ff ff       	jmpq   e2ea <e1000_init_hw+0x4aa>
	hw->ledctl_default = ledctl;
	hw->ledctl_mode1 = hw->ledctl_default;
	hw->ledctl_mode2 = hw->ledctl_default;

	if (e1000_read_eeprom(hw, EEPROM_ID_LED_SETTINGS, 1, &eeprom_data) < 0) {
		e_dbg("EEPROM Read Error\n");
    e575:	48 89 df             	mov    %rbx,%rdi
    e578:	e8 00 00 00 00       	callq  e57d <e1000_init_hw+0x73d>
    e57d:	48 c7 c2 00 00 00 00 	mov    $0x0,%rdx
    e584:	48 89 c6             	mov    %rax,%rsi
    e587:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
    e58e:	31 c0                	xor    %eax,%eax
    e590:	e8 00 00 00 00       	callq  e595 <e1000_init_hw+0x755>
    e595:	e9 df fe ff ff       	jmpq   e479 <e1000_init_hw+0x639>

	/* Set the media type and TBI compatibility */
	e1000_set_media_type(hw);

	/* Disabling VLAN filtering. */
	e_dbg("Initializing the IEEE VLAN\n");
    e59a:	48 89 df             	mov    %rbx,%rdi
    e59d:	e8 00 00 00 00       	callq  e5a2 <e1000_init_hw+0x762>
    e5a2:	48 c7 c2 00 00 00 00 	mov    $0x0,%rdx
    e5a9:	48 89 c6             	mov    %rax,%rsi
    e5ac:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
    e5b3:	31 c0                	xor    %eax,%eax
    e5b5:	e8 00 00 00 00       	callq  e5ba <e1000_init_hw+0x77a>
    e5ba:	e9 b3 f8 ff ff       	jmpq   de72 <e1000_init_hw+0x32>
		if (hw->pci_cmd_word & PCI_COMMAND_INVALIDATE)
			e1000_pci_set_mwi(hw);
	}

	/* Zero out the Multicast HASH table */
	e_dbg("Zeroing the MTA\n");
    e5bf:	48 89 df             	mov    %rbx,%rdi
    e5c2:	e8 00 00 00 00       	callq  e5c7 <e1000_init_hw+0x787>
    e5c7:	48 c7 c2 00 00 00 00 	mov    $0x0,%rdx
    e5ce:	48 89 c6             	mov    %rax,%rsi
    e5d1:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
    e5d8:	31 c0                	xor    %eax,%eax
    e5da:	e8 00 00 00 00       	callq  e5df <e1000_init_hw+0x79f>
    e5df:	e9 7f f9 ff ff       	jmpq   df63 <e1000_init_hw+0x123>
	e1000_rar_set(hw, hw->mac_addr, 0);

	rar_num = E1000_RAR_ENTRIES;

	/* Zero out the other 15 receive addresses. */
	e_dbg("Clearing RAR[1-15]\n");
    e5e4:	48 89 df             	mov    %rbx,%rdi
    e5e7:	e8 00 00 00 00       	callq  e5ec <e1000_init_hw+0x7ac>
    e5ec:	48 c7 c2 00 00 00 00 	mov    $0x0,%rdx
    e5f3:	48 89 c6             	mov    %rax,%rsi
    e5f6:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
    e5fd:	31 c0                	xor    %eax,%eax
    e5ff:	e8 00 00 00 00       	callq  e604 <e1000_init_hw+0x7c4>
    e604:	e9 e4 f8 ff ff       	jmpq   deed <e1000_init_hw+0xad>
{
	u32 i;
	u32 rar_num;

	/* Setup the receive address. */
	e_dbg("Programming MAC Address into RAR[0]\n");
    e609:	48 89 df             	mov    %rbx,%rdi
    e60c:	e8 00 00 00 00       	callq  e611 <e1000_init_hw+0x7d1>
    e611:	48 c7 c2 00 00 00 00 	mov    $0x0,%rdx
    e618:	48 89 c6             	mov    %rax,%rsi
    e61b:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
    e622:	31 c0                	xor    %eax,%eax
    e624:	e8 00 00 00 00       	callq  e629 <e1000_init_hw+0x7e9>
    e629:	e9 a1 f8 ff ff       	jmpq   decf <e1000_init_hw+0x8f>
    e62e:	66 90                	xchg   %ax,%ax

000000000000e630 <e1000_write_vfta>:
 * @hw: Struct containing variables accessed by shared code
 * @offset: Offset in VLAN filer table to write
 * @value: Value to write into VLAN filter table
 */
void e1000_write_vfta(struct e1000_hw *hw, u32 offset, u32 value)
{
    e630:	e8 00 00 00 00       	callq  e635 <e1000_write_vfta+0x5>
    e635:	55                   	push   %rbp
	u32 temp;

	if ((hw->mac_type == e1000_82544) && ((offset & 0x1) == 1)) {
    e636:	8b 4f 18             	mov    0x18(%rdi),%ecx
 * @hw: Struct containing variables accessed by shared code
 * @offset: Offset in VLAN filer table to write
 * @value: Value to write into VLAN filter table
 */
void e1000_write_vfta(struct e1000_hw *hw, u32 offset, u32 value)
{
    e639:	48 89 e5             	mov    %rsp,%rbp
	u32 temp;

	if ((hw->mac_type == e1000_82544) && ((offset & 0x1) == 1)) {
    e63c:	83 f9 04             	cmp    $0x4,%ecx
    e63f:	74 29                	je     e66a <e1000_write_vfta+0x3a>
		E1000_WRITE_REG_ARRAY(hw, VFTA, offset, value);
		E1000_WRITE_FLUSH();
		E1000_WRITE_REG_ARRAY(hw, VFTA, (offset - 1), temp);
		E1000_WRITE_FLUSH();
	} else {
		E1000_WRITE_REG_ARRAY(hw, VFTA, offset, value);
    e641:	83 f9 03             	cmp    $0x3,%ecx
    e644:	4c 8b 07             	mov    (%rdi),%r8
    e647:	48 19 c0             	sbb    %rax,%rax
    e64a:	48 25 00 b0 ff ff    	and    $0xffffffffffffb000,%rax
    e650:	48 05 00 56 00 00    	add    $0x5600,%rax
    e656:	c1 e6 02             	shl    $0x2,%esi
    e659:	48 01 f0             	add    %rsi,%rax
    e65c:	49 01 c0             	add    %rax,%r8
build_mmio_read(__readw, "w", unsigned short, "=r", )
build_mmio_read(__readl, "l", unsigned int, "=r", )

build_mmio_write(writeb, "b", unsigned char, "q", :"memory")
build_mmio_write(writew, "w", unsigned short, "r", :"memory")
build_mmio_write(writel, "l", unsigned int, "r", :"memory")
    e65f:	41 89 10             	mov    %edx,(%r8)
		E1000_WRITE_FLUSH();
    e662:	48 8b 07             	mov    (%rdi),%rax
{ asm volatile("mov" size " %0,%1": :reg (val), \
"m" (*(volatile type __force *)addr) barrier); }

build_mmio_read(readb, "b", unsigned char, "=q", :"memory")
build_mmio_read(readw, "w", unsigned short, "=r", :"memory")
build_mmio_read(readl, "l", unsigned int, "=r", :"memory")
    e665:	8b 40 08             	mov    0x8(%rax),%eax
	}
}
    e668:	5d                   	pop    %rbp
    e669:	c3                   	retq   
 */
void e1000_write_vfta(struct e1000_hw *hw, u32 offset, u32 value)
{
	u32 temp;

	if ((hw->mac_type == e1000_82544) && ((offset & 0x1) == 1)) {
    e66a:	40 f6 c6 01          	test   $0x1,%sil
    e66e:	74 57                	je     e6c7 <e1000_write_vfta+0x97>
		temp = E1000_READ_REG_ARRAY(hw, VFTA, (offset - 1));
    e670:	8d 04 b5 fc ff ff ff 	lea    -0x4(,%rsi,4),%eax
    e677:	4c 8d 80 00 56 00 00 	lea    0x5600(%rax),%r8
    e67e:	4c 89 c1             	mov    %r8,%rcx
    e681:	48 03 0f             	add    (%rdi),%rcx
    e684:	44 8b 09             	mov    (%rcx),%r9d
		E1000_WRITE_REG_ARRAY(hw, VFTA, offset, value);
    e687:	83 7f 18 03          	cmpl   $0x3,0x18(%rdi)
    e68b:	48 19 c9             	sbb    %rcx,%rcx
    e68e:	c1 e6 02             	shl    $0x2,%esi
    e691:	48 81 e1 00 b0 ff ff 	and    $0xffffffffffffb000,%rcx
    e698:	48 8d 8c 31 00 56 00 	lea    0x5600(%rcx,%rsi,1),%rcx
    e69f:	00 
    e6a0:	48 03 0f             	add    (%rdi),%rcx
build_mmio_read(__readw, "w", unsigned short, "=r", )
build_mmio_read(__readl, "l", unsigned int, "=r", )

build_mmio_write(writeb, "b", unsigned char, "q", :"memory")
build_mmio_write(writew, "w", unsigned short, "r", :"memory")
build_mmio_write(writel, "l", unsigned int, "r", :"memory")
    e6a3:	89 11                	mov    %edx,(%rcx)
		E1000_WRITE_FLUSH();
    e6a5:	48 8b 17             	mov    (%rdi),%rdx
{ asm volatile("mov" size " %0,%1": :reg (val), \
"m" (*(volatile type __force *)addr) barrier); }

build_mmio_read(readb, "b", unsigned char, "=q", :"memory")
build_mmio_read(readw, "w", unsigned short, "=r", :"memory")
build_mmio_read(readl, "l", unsigned int, "=r", :"memory")
    e6a8:	8b 52 08             	mov    0x8(%rdx),%edx
    e6ab:	48 05 00 06 00 00    	add    $0x600,%rax
    e6b1:	83 7f 18 02          	cmpl   $0x2,0x18(%rdi)
    e6b5:	49 0f 47 c0          	cmova  %r8,%rax
		E1000_WRITE_REG_ARRAY(hw, VFTA, (offset - 1), temp);
    e6b9:	48 03 07             	add    (%rdi),%rax
build_mmio_read(__readw, "w", unsigned short, "=r", )
build_mmio_read(__readl, "l", unsigned int, "=r", )

build_mmio_write(writeb, "b", unsigned char, "q", :"memory")
build_mmio_write(writew, "w", unsigned short, "r", :"memory")
build_mmio_write(writel, "l", unsigned int, "r", :"memory")
    e6bc:	44 89 08             	mov    %r9d,(%rax)
		E1000_WRITE_FLUSH();
    e6bf:	48 8b 07             	mov    (%rdi),%rax
{ asm volatile("mov" size " %0,%1": :reg (val), \
"m" (*(volatile type __force *)addr) barrier); }

build_mmio_read(readb, "b", unsigned char, "=q", :"memory")
build_mmio_read(readw, "w", unsigned short, "=r", :"memory")
build_mmio_read(readl, "l", unsigned int, "=r", :"memory")
    e6c2:	8b 40 08             	mov    0x8(%rax),%eax
	} else {
		E1000_WRITE_REG_ARRAY(hw, VFTA, offset, value);
		E1000_WRITE_FLUSH();
	}
}
    e6c5:	5d                   	pop    %rbp
    e6c6:	c3                   	retq   
		E1000_WRITE_REG_ARRAY(hw, VFTA, offset, value);
		E1000_WRITE_FLUSH();
		E1000_WRITE_REG_ARRAY(hw, VFTA, (offset - 1), temp);
		E1000_WRITE_FLUSH();
	} else {
		E1000_WRITE_REG_ARRAY(hw, VFTA, offset, value);
    e6c7:	4c 8b 07             	mov    (%rdi),%r8
    e6ca:	b8 00 56 00 00       	mov    $0x5600,%eax
    e6cf:	eb 85                	jmp    e656 <e1000_write_vfta+0x26>
    e6d1:	66 66 66 66 66 66 2e 	data32 data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
    e6d8:	0f 1f 84 00 00 00 00 
    e6df:	00 

000000000000e6e0 <e1000_setup_led>:
 * @hw: Struct containing variables accessed by shared code
 *
 * Prepares SW controlable LED for use and saves the current state of the LED.
 */
s32 e1000_setup_led(struct e1000_hw *hw)
{
    e6e0:	e8 00 00 00 00       	callq  e6e5 <e1000_setup_led+0x5>
    e6e5:	55                   	push   %rbp
    e6e6:	48 89 e5             	mov    %rsp,%rbp
    e6e9:	53                   	push   %rbx
	u32 ledctl;
	s32 ret_val = E1000_SUCCESS;

	switch (hw->mac_type) {
    e6ea:	8b 57 18             	mov    0x18(%rdi),%edx
 * @hw: Struct containing variables accessed by shared code
 *
 * Prepares SW controlable LED for use and saves the current state of the LED.
 */
s32 e1000_setup_led(struct e1000_hw *hw)
{
    e6ed:	48 89 fb             	mov    %rdi,%rbx
	u32 ledctl;
	s32 ret_val = E1000_SUCCESS;

	switch (hw->mac_type) {
    e6f0:	83 fa 01             	cmp    $0x1,%edx
    e6f3:	72 45                	jb     e73a <e1000_setup_led+0x5a>
		} else if (hw->media_type == e1000_media_type_copper)
			ew32(LEDCTL, hw->ledctl_mode1);
		break;
	}

	return E1000_SUCCESS;
    e6f5:	31 c0                	xor    %eax,%eax
s32 e1000_setup_led(struct e1000_hw *hw)
{
	u32 ledctl;
	s32 ret_val = E1000_SUCCESS;

	switch (hw->mac_type) {
    e6f7:	83 fa 04             	cmp    $0x4,%edx
    e6fa:	76 1d                	jbe    e719 <e1000_setup_led+0x39>
    e6fc:	83 ea 0b             	sub    $0xb,%edx
    e6ff:	83 fa 03             	cmp    $0x3,%edx
    e702:	77 36                	ja     e73a <e1000_setup_led+0x5a>
	case e1000_82541:
	case e1000_82547:
	case e1000_82541_rev_2:
	case e1000_82547_rev_2:
		/* Turn off PHY Smart Power Down (if enabled) */
		ret_val = e1000_read_phy_reg(hw, IGP01E1000_GMII_FIFO,
    e704:	48 8d 97 d0 00 00 00 	lea    0xd0(%rdi),%rdx
    e70b:	be 14 00 00 00       	mov    $0x14,%esi
    e710:	e8 00 00 00 00       	callq  e715 <e1000_setup_led+0x35>
					     &hw->phy_spd_default);
		if (ret_val)
    e715:	85 c0                	test   %eax,%eax
    e717:	74 03                	je     e71c <e1000_setup_led+0x3c>
			ew32(LEDCTL, hw->ledctl_mode1);
		break;
	}

	return E1000_SUCCESS;
}
    e719:	5b                   	pop    %rbx
    e71a:	5d                   	pop    %rbp
    e71b:	c3                   	retq   
		/* Turn off PHY Smart Power Down (if enabled) */
		ret_val = e1000_read_phy_reg(hw, IGP01E1000_GMII_FIFO,
					     &hw->phy_spd_default);
		if (ret_val)
			return ret_val;
		ret_val = e1000_write_phy_reg(hw, IGP01E1000_GMII_FIFO,
    e71c:	0f b7 93 d0 00 00 00 	movzwl 0xd0(%rbx),%edx
    e723:	be 14 00 00 00       	mov    $0x14,%esi
    e728:	48 89 df             	mov    %rbx,%rdi
    e72b:	81 e2 df ff 00 00    	and    $0xffdf,%edx
    e731:	e8 00 00 00 00       	callq  e736 <e1000_setup_led+0x56>
					      (u16) (hw->phy_spd_default &
						     ~IGP01E1000_GMII_SPD));
		if (ret_val)
    e736:	85 c0                	test   %eax,%eax
    e738:	75 df                	jne    e719 <e1000_setup_led+0x39>
			return ret_val;
		/* Fall Through */
	default:
		if (hw->media_type == e1000_media_type_fiber) {
    e73a:	8b 53 24             	mov    0x24(%rbx),%edx
    e73d:	83 fa 01             	cmp    $0x1,%edx
    e740:	74 18                	je     e75a <e1000_setup_led+0x7a>
		} else if (hw->media_type == e1000_media_type_copper)
			ew32(LEDCTL, hw->ledctl_mode1);
		break;
	}

	return E1000_SUCCESS;
    e742:	31 c0                	xor    %eax,%eax
				    E1000_LEDCTL_LED0_BLINK |
				    E1000_LEDCTL_LED0_MODE_MASK);
			ledctl |= (E1000_LEDCTL_MODE_LED_OFF <<
				   E1000_LEDCTL_LED0_MODE_SHIFT);
			ew32(LEDCTL, ledctl);
		} else if (hw->media_type == e1000_media_type_copper)
    e744:	85 d2                	test   %edx,%edx
    e746:	75 d1                	jne    e719 <e1000_setup_led+0x39>
			ew32(LEDCTL, hw->ledctl_mode1);
    e748:	48 8b 0b             	mov    (%rbx),%rcx
    e74b:	8b 93 b4 00 00 00    	mov    0xb4(%rbx),%edx
build_mmio_read(__readw, "w", unsigned short, "=r", )
build_mmio_read(__readl, "l", unsigned int, "=r", )

build_mmio_write(writeb, "b", unsigned char, "q", :"memory")
build_mmio_write(writew, "w", unsigned short, "r", :"memory")
build_mmio_write(writel, "l", unsigned int, "r", :"memory")
    e751:	89 91 00 0e 00 00    	mov    %edx,0xe00(%rcx)
		break;
	}

	return E1000_SUCCESS;
}
    e757:	5b                   	pop    %rbx
    e758:	5d                   	pop    %rbp
    e759:	c3                   	retq   
		if (ret_val)
			return ret_val;
		/* Fall Through */
	default:
		if (hw->media_type == e1000_media_type_fiber) {
			ledctl = er32(LEDCTL);
    e75a:	48 8b 03             	mov    (%rbx),%rax
{ asm volatile("mov" size " %0,%1": :reg (val), \
"m" (*(volatile type __force *)addr) barrier); }

build_mmio_read(readb, "b", unsigned char, "=q", :"memory")
build_mmio_read(readw, "w", unsigned short, "=r", :"memory")
build_mmio_read(readl, "l", unsigned int, "=r", :"memory")
    e75d:	8b 80 00 0e 00 00    	mov    0xe00(%rax),%eax
			/* Save current LEDCTL settings */
			hw->ledctl_default = ledctl;
    e763:	89 83 b0 00 00 00    	mov    %eax,0xb0(%rbx)
			/* Turn off LED0 */
			ledctl &= ~(E1000_LEDCTL_LED0_IVRT |
    e769:	24 30                	and    $0x30,%al
				    E1000_LEDCTL_LED0_BLINK |
				    E1000_LEDCTL_LED0_MODE_MASK);
			ledctl |= (E1000_LEDCTL_MODE_LED_OFF <<
				   E1000_LEDCTL_LED0_MODE_SHIFT);
			ew32(LEDCTL, ledctl);
    e76b:	48 8b 13             	mov    (%rbx),%rdx
			hw->ledctl_default = ledctl;
			/* Turn off LED0 */
			ledctl &= ~(E1000_LEDCTL_LED0_IVRT |
				    E1000_LEDCTL_LED0_BLINK |
				    E1000_LEDCTL_LED0_MODE_MASK);
			ledctl |= (E1000_LEDCTL_MODE_LED_OFF <<
    e76e:	83 c8 0f             	or     $0xf,%eax
build_mmio_read(__readw, "w", unsigned short, "=r", )
build_mmio_read(__readl, "l", unsigned int, "=r", )

build_mmio_write(writeb, "b", unsigned char, "q", :"memory")
build_mmio_write(writew, "w", unsigned short, "r", :"memory")
build_mmio_write(writel, "l", unsigned int, "r", :"memory")
    e771:	89 82 00 0e 00 00    	mov    %eax,0xe00(%rdx)
		} else if (hw->media_type == e1000_media_type_copper)
			ew32(LEDCTL, hw->ledctl_mode1);
		break;
	}

	return E1000_SUCCESS;
    e777:	31 c0                	xor    %eax,%eax
    e779:	eb 9e                	jmp    e719 <e1000_setup_led+0x39>
    e77b:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)

000000000000e780 <e1000_cleanup_led>:
/**
 * e1000_cleanup_led - Restores the saved state of the SW controlable LED.
 * @hw: Struct containing variables accessed by shared code
 */
s32 e1000_cleanup_led(struct e1000_hw *hw)
{
    e780:	e8 00 00 00 00       	callq  e785 <e1000_cleanup_led+0x5>
    e785:	55                   	push   %rbp
    e786:	48 89 e5             	mov    %rsp,%rbp
    e789:	53                   	push   %rbx
	s32 ret_val = E1000_SUCCESS;

	switch (hw->mac_type) {
    e78a:	8b 57 18             	mov    0x18(%rdi),%edx
/**
 * e1000_cleanup_led - Restores the saved state of the SW controlable LED.
 * @hw: Struct containing variables accessed by shared code
 */
s32 e1000_cleanup_led(struct e1000_hw *hw)
{
    e78d:	48 89 fb             	mov    %rdi,%rbx
	s32 ret_val = E1000_SUCCESS;

	switch (hw->mac_type) {
    e790:	83 fa 01             	cmp    $0x1,%edx
    e793:	72 24                	jb     e7b9 <e1000_cleanup_led+0x39>
		/* Restore LEDCTL settings */
		ew32(LEDCTL, hw->ledctl_default);
		break;
	}

	return E1000_SUCCESS;
    e795:	31 c0                	xor    %eax,%eax
 */
s32 e1000_cleanup_led(struct e1000_hw *hw)
{
	s32 ret_val = E1000_SUCCESS;

	switch (hw->mac_type) {
    e797:	83 fa 04             	cmp    $0x4,%edx
    e79a:	76 2e                	jbe    e7ca <e1000_cleanup_led+0x4a>
    e79c:	83 ea 0b             	sub    $0xb,%edx
    e79f:	83 fa 03             	cmp    $0x3,%edx
    e7a2:	77 15                	ja     e7b9 <e1000_cleanup_led+0x39>
	case e1000_82541:
	case e1000_82547:
	case e1000_82541_rev_2:
	case e1000_82547_rev_2:
		/* Turn on PHY Smart Power Down (if previously enabled) */
		ret_val = e1000_write_phy_reg(hw, IGP01E1000_GMII_FIFO,
    e7a4:	0f b7 97 d0 00 00 00 	movzwl 0xd0(%rdi),%edx
    e7ab:	be 14 00 00 00       	mov    $0x14,%esi
    e7b0:	e8 00 00 00 00       	callq  e7b5 <e1000_cleanup_led+0x35>
					      hw->phy_spd_default);
		if (ret_val)
    e7b5:	85 c0                	test   %eax,%eax
    e7b7:	75 11                	jne    e7ca <e1000_cleanup_led+0x4a>
			return ret_val;
		/* Fall Through */
	default:
		/* Restore LEDCTL settings */
		ew32(LEDCTL, hw->ledctl_default);
    e7b9:	48 8b 13             	mov    (%rbx),%rdx
    e7bc:	8b 83 b0 00 00 00    	mov    0xb0(%rbx),%eax
    e7c2:	89 82 00 0e 00 00    	mov    %eax,0xe00(%rdx)
		break;
	}

	return E1000_SUCCESS;
    e7c8:	31 c0                	xor    %eax,%eax
}
    e7ca:	5b                   	pop    %rbx
    e7cb:	5d                   	pop    %rbp
    e7cc:	c3                   	retq   
    e7cd:	0f 1f 00             	nopl   (%rax)

000000000000e7d0 <e1000_led_on>:
/**
 * e1000_led_on - Turns on the software controllable LED
 * @hw: Struct containing variables accessed by shared code
 */
s32 e1000_led_on(struct e1000_hw *hw)
{
    e7d0:	e8 00 00 00 00       	callq  e7d5 <e1000_led_on+0x5>
    e7d5:	55                   	push   %rbp
	u32 ctrl = er32(CTRL);
    e7d6:	48 8b 07             	mov    (%rdi),%rax
/**
 * e1000_led_on - Turns on the software controllable LED
 * @hw: Struct containing variables accessed by shared code
 */
s32 e1000_led_on(struct e1000_hw *hw)
{
    e7d9:	48 89 e5             	mov    %rsp,%rbp
{ asm volatile("mov" size " %0,%1": :reg (val), \
"m" (*(volatile type __force *)addr) barrier); }

build_mmio_read(readb, "b", unsigned char, "=q", :"memory")
build_mmio_read(readw, "w", unsigned short, "=r", :"memory")
build_mmio_read(readl, "l", unsigned int, "=r", :"memory")
    e7dc:	8b 08                	mov    (%rax),%ecx
	u32 ctrl = er32(CTRL);

	switch (hw->mac_type) {
    e7de:	8b 57 18             	mov    0x18(%rdi),%edx
    e7e1:	89 c8                	mov    %ecx,%eax
    e7e3:	83 fa 01             	cmp    $0x1,%edx
    e7e6:	72 2a                	jb     e812 <e1000_led_on+0x42>
    e7e8:	83 fa 03             	cmp    $0x3,%edx
    e7eb:	76 42                	jbe    e82f <e1000_led_on+0x5f>
    e7ed:	83 fa 04             	cmp    $0x4,%edx
    e7f0:	75 20                	jne    e812 <e1000_led_on+0x42>
			/* Set SW Defineable Pin 0 to turn on the LED */
			ctrl |= E1000_CTRL_SWDPIN0;
			ctrl |= E1000_CTRL_SWDPIO0;
		} else {
			/* Clear SW Defineable Pin 0 to turn on the LED */
			ctrl &= ~E1000_CTRL_SWDPIN0;
    e7f2:	25 ff ff fb ff       	and    $0xfffbffff,%eax
		break;
	case e1000_82544:
		if (hw->media_type == e1000_media_type_fiber) {
			/* Set SW Defineable Pin 0 to turn on the LED */
			ctrl |= E1000_CTRL_SWDPIN0;
			ctrl |= E1000_CTRL_SWDPIO0;
    e7f7:	81 c9 00 00 44 00    	or     $0x440000,%ecx
		} else {
			/* Clear SW Defineable Pin 0 to turn on the LED */
			ctrl &= ~E1000_CTRL_SWDPIN0;
			ctrl |= E1000_CTRL_SWDPIO0;
    e7fd:	0d 00 00 40 00       	or     $0x400000,%eax
		break;
	case e1000_82544:
		if (hw->media_type == e1000_media_type_fiber) {
			/* Set SW Defineable Pin 0 to turn on the LED */
			ctrl |= E1000_CTRL_SWDPIN0;
			ctrl |= E1000_CTRL_SWDPIO0;
    e802:	83 7f 24 01          	cmpl   $0x1,0x24(%rdi)
    e806:	0f 44 c1             	cmove  %ecx,%eax
			return E1000_SUCCESS;
		}
		break;
	}

	ew32(CTRL, ctrl);
    e809:	48 8b 17             	mov    (%rdi),%rdx
build_mmio_read(__readw, "w", unsigned short, "=r", )
build_mmio_read(__readl, "l", unsigned int, "=r", )

build_mmio_write(writeb, "b", unsigned char, "q", :"memory")
build_mmio_write(writew, "w", unsigned short, "r", :"memory")
build_mmio_write(writel, "l", unsigned int, "r", :"memory")
    e80c:	89 02                	mov    %eax,(%rdx)

	return E1000_SUCCESS;
}
    e80e:	31 c0                	xor    %eax,%eax
    e810:	5d                   	pop    %rbp
    e811:	c3                   	retq   
			ctrl &= ~E1000_CTRL_SWDPIN0;
			ctrl |= E1000_CTRL_SWDPIO0;
		}
		break;
	default:
		if (hw->media_type == e1000_media_type_fiber) {
    e812:	8b 57 24             	mov    0x24(%rdi),%edx
    e815:	83 fa 01             	cmp    $0x1,%edx
    e818:	74 1c                	je     e836 <e1000_led_on+0x66>
			/* Clear SW Defineable Pin 0 to turn on the LED */
			ctrl &= ~E1000_CTRL_SWDPIN0;
			ctrl |= E1000_CTRL_SWDPIO0;
		} else if (hw->media_type == e1000_media_type_copper) {
    e81a:	85 d2                	test   %edx,%edx
    e81c:	75 eb                	jne    e809 <e1000_led_on+0x39>
			ew32(LEDCTL, hw->ledctl_mode2);
    e81e:	48 8b 17             	mov    (%rdi),%rdx
    e821:	8b 87 b8 00 00 00    	mov    0xb8(%rdi),%eax
    e827:	89 82 00 0e 00 00    	mov    %eax,0xe00(%rdx)
			return E1000_SUCCESS;
    e82d:	eb df                	jmp    e80e <e1000_led_on+0x3e>
	case e1000_82542_rev2_0:
	case e1000_82542_rev2_1:
	case e1000_82543:
		/* Set SW Defineable Pin 0 to turn on the LED */
		ctrl |= E1000_CTRL_SWDPIN0;
		ctrl |= E1000_CTRL_SWDPIO0;
    e82f:	0d 00 00 44 00       	or     $0x440000,%eax
		break;
    e834:	eb d3                	jmp    e809 <e1000_led_on+0x39>
		}
		break;
	default:
		if (hw->media_type == e1000_media_type_fiber) {
			/* Clear SW Defineable Pin 0 to turn on the LED */
			ctrl &= ~E1000_CTRL_SWDPIN0;
    e836:	89 c8                	mov    %ecx,%eax
    e838:	25 ff ff fb ff       	and    $0xfffbffff,%eax
			ctrl |= E1000_CTRL_SWDPIO0;
    e83d:	0d 00 00 40 00       	or     $0x400000,%eax
    e842:	eb c5                	jmp    e809 <e1000_led_on+0x39>
    e844:	66 66 66 2e 0f 1f 84 	data32 data32 nopw %cs:0x0(%rax,%rax,1)
    e84b:	00 00 00 00 00 

000000000000e850 <e1000_led_off>:
/**
 * e1000_led_off - Turns off the software controllable LED
 * @hw: Struct containing variables accessed by shared code
 */
s32 e1000_led_off(struct e1000_hw *hw)
{
    e850:	e8 00 00 00 00       	callq  e855 <e1000_led_off+0x5>
    e855:	55                   	push   %rbp
	u32 ctrl = er32(CTRL);
    e856:	48 8b 07             	mov    (%rdi),%rax
/**
 * e1000_led_off - Turns off the software controllable LED
 * @hw: Struct containing variables accessed by shared code
 */
s32 e1000_led_off(struct e1000_hw *hw)
{
    e859:	48 89 e5             	mov    %rsp,%rbp
{ asm volatile("mov" size " %0,%1": :reg (val), \
"m" (*(volatile type __force *)addr) barrier); }

build_mmio_read(readb, "b", unsigned char, "=q", :"memory")
build_mmio_read(readw, "w", unsigned short, "=r", :"memory")
build_mmio_read(readl, "l", unsigned int, "=r", :"memory")
    e85c:	8b 08                	mov    (%rax),%ecx
	u32 ctrl = er32(CTRL);

	switch (hw->mac_type) {
    e85e:	8b 57 18             	mov    0x18(%rdi),%edx
    e861:	89 c8                	mov    %ecx,%eax
    e863:	83 fa 01             	cmp    $0x1,%edx
    e866:	72 1e                	jb     e886 <e1000_led_off+0x36>
    e868:	83 fa 03             	cmp    $0x3,%edx
    e86b:	76 38                	jbe    e8a5 <e1000_led_off+0x55>
    e86d:	83 fa 04             	cmp    $0x4,%edx
    e870:	75 14                	jne    e886 <e1000_led_off+0x36>
			ctrl &= ~E1000_CTRL_SWDPIN0;
			ctrl |= E1000_CTRL_SWDPIO0;
		} else {
			/* Set SW Defineable Pin 0 to turn off the LED */
			ctrl |= E1000_CTRL_SWDPIN0;
			ctrl |= E1000_CTRL_SWDPIO0;
    e872:	0d 00 00 44 00       	or     $0x440000,%eax
		/* Clear SW Defineable Pin 0 to turn off the LED */
		ctrl &= ~E1000_CTRL_SWDPIN0;
		ctrl |= E1000_CTRL_SWDPIO0;
		break;
	case e1000_82544:
		if (hw->media_type == e1000_media_type_fiber) {
    e877:	83 7f 24 01          	cmpl   $0x1,0x24(%rdi)
    e87b:	74 26                	je     e8a3 <e1000_led_off+0x53>
			return E1000_SUCCESS;
		}
		break;
	}

	ew32(CTRL, ctrl);
    e87d:	48 8b 17             	mov    (%rdi),%rdx
build_mmio_read(__readw, "w", unsigned short, "=r", )
build_mmio_read(__readl, "l", unsigned int, "=r", )

build_mmio_write(writeb, "b", unsigned char, "q", :"memory")
build_mmio_write(writew, "w", unsigned short, "r", :"memory")
build_mmio_write(writel, "l", unsigned int, "r", :"memory")
    e880:	89 02                	mov    %eax,(%rdx)

	return E1000_SUCCESS;
}
    e882:	31 c0                	xor    %eax,%eax
    e884:	5d                   	pop    %rbp
    e885:	c3                   	retq   
			ctrl |= E1000_CTRL_SWDPIN0;
			ctrl |= E1000_CTRL_SWDPIO0;
		}
		break;
	default:
		if (hw->media_type == e1000_media_type_fiber) {
    e886:	8b 57 24             	mov    0x24(%rdi),%edx
    e889:	83 fa 01             	cmp    $0x1,%edx
    e88c:	74 23                	je     e8b1 <e1000_led_off+0x61>
			/* Set SW Defineable Pin 0 to turn off the LED */
			ctrl |= E1000_CTRL_SWDPIN0;
			ctrl |= E1000_CTRL_SWDPIO0;
		} else if (hw->media_type == e1000_media_type_copper) {
    e88e:	85 d2                	test   %edx,%edx
    e890:	75 eb                	jne    e87d <e1000_led_off+0x2d>
			ew32(LEDCTL, hw->ledctl_mode1);
    e892:	48 8b 17             	mov    (%rdi),%rdx
    e895:	8b 87 b4 00 00 00    	mov    0xb4(%rdi),%eax
    e89b:	89 82 00 0e 00 00    	mov    %eax,0xe00(%rdx)
			return E1000_SUCCESS;
    e8a1:	eb df                	jmp    e882 <e1000_led_off+0x32>
		ctrl |= E1000_CTRL_SWDPIO0;
		break;
	case e1000_82544:
		if (hw->media_type == e1000_media_type_fiber) {
			/* Clear SW Defineable Pin 0 to turn off the LED */
			ctrl &= ~E1000_CTRL_SWDPIN0;
    e8a3:	89 c8                	mov    %ecx,%eax
    e8a5:	25 ff ff fb ff       	and    $0xfffbffff,%eax
			ctrl |= E1000_CTRL_SWDPIO0;
    e8aa:	0d 00 00 40 00       	or     $0x400000,%eax
    e8af:	eb cc                	jmp    e87d <e1000_led_off+0x2d>
		break;
	default:
		if (hw->media_type == e1000_media_type_fiber) {
			/* Set SW Defineable Pin 0 to turn off the LED */
			ctrl |= E1000_CTRL_SWDPIN0;
			ctrl |= E1000_CTRL_SWDPIO0;
    e8b1:	89 c8                	mov    %ecx,%eax
    e8b3:	0d 00 00 44 00       	or     $0x440000,%eax
    e8b8:	eb c3                	jmp    e87d <e1000_led_off+0x2d>
    e8ba:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)

000000000000e8c0 <e1000_reset_adaptive>:
 * hw->ifs_params_forced to true. However, you must initialize hw->
 * current_ifs_val, ifs_min_val, ifs_max_val, ifs_step_size, and ifs_ratio
 * before calling this function.
 */
void e1000_reset_adaptive(struct e1000_hw *hw)
{
    e8c0:	e8 00 00 00 00       	callq  e8c5 <e1000_reset_adaptive+0x5>
	if (hw->adaptive_ifs) {
    e8c5:	80 bf 16 01 00 00 00 	cmpb   $0x0,0x116(%rdi)
    e8cc:	74 57                	je     e925 <e1000_reset_adaptive+0x65>
		if (!hw->ifs_params_forced) {
    e8ce:	80 bf 17 01 00 00 00 	cmpb   $0x0,0x117(%rdi)
    e8d5:	75 3b                	jne    e912 <e1000_reset_adaptive+0x52>
			hw->current_ifs_val = 0;
    e8d7:	31 c0                	xor    %eax,%eax
			hw->ifs_min_val = IFS_MIN;
    e8d9:	ba 28 00 00 00       	mov    $0x28,%edx
			hw->ifs_max_val = IFS_MAX;
    e8de:	b9 50 00 00 00       	mov    $0x50,%ecx
			hw->ifs_step_size = IFS_STEP;
    e8e3:	be 0a 00 00 00       	mov    $0xa,%esi
			hw->ifs_ratio = IFS_RATIO;
    e8e8:	41 b8 04 00 00 00    	mov    $0x4,%r8d
 */
void e1000_reset_adaptive(struct e1000_hw *hw)
{
	if (hw->adaptive_ifs) {
		if (!hw->ifs_params_forced) {
			hw->current_ifs_val = 0;
    e8ee:	66 89 87 dc 00 00 00 	mov    %ax,0xdc(%rdi)
			hw->ifs_min_val = IFS_MIN;
    e8f5:	66 89 97 de 00 00 00 	mov    %dx,0xde(%rdi)
			hw->ifs_max_val = IFS_MAX;
    e8fc:	66 89 8f e0 00 00 00 	mov    %cx,0xe0(%rdi)
			hw->ifs_step_size = IFS_STEP;
    e903:	66 89 b7 e2 00 00 00 	mov    %si,0xe2(%rdi)
			hw->ifs_ratio = IFS_RATIO;
    e90a:	66 44 89 87 e4 00 00 	mov    %r8w,0xe4(%rdi)
    e911:	00 
		}
		hw->in_ifs_mode = false;
    e912:	c6 87 18 01 00 00 00 	movb   $0x0,0x118(%rdi)
		ew32(AIT, 0);
    e919:	48 8b 17             	mov    (%rdi),%rdx
    e91c:	31 c0                	xor    %eax,%eax
    e91e:	89 82 58 04 00 00    	mov    %eax,0x458(%rdx)
    e924:	c3                   	retq   
	} else {
		e_dbg("Not in Adaptive IFS mode!\n");
    e925:	f6 05 00 00 00 00 04 	testb  $0x4,0x0(%rip)        # e92c <e1000_reset_adaptive+0x6c>
    e92c:	75 01                	jne    e92f <e1000_reset_adaptive+0x6f>
	}
}
    e92e:	c3                   	retq   
 * hw->ifs_params_forced to true. However, you must initialize hw->
 * current_ifs_val, ifs_min_val, ifs_max_val, ifs_step_size, and ifs_ratio
 * before calling this function.
 */
void e1000_reset_adaptive(struct e1000_hw *hw)
{
    e92f:	55                   	push   %rbp
    e930:	48 89 e5             	mov    %rsp,%rbp
			hw->ifs_ratio = IFS_RATIO;
		}
		hw->in_ifs_mode = false;
		ew32(AIT, 0);
	} else {
		e_dbg("Not in Adaptive IFS mode!\n");
    e933:	e8 00 00 00 00       	callq  e938 <e1000_reset_adaptive+0x78>
    e938:	48 c7 c2 00 00 00 00 	mov    $0x0,%rdx
    e93f:	48 89 c6             	mov    %rax,%rsi
    e942:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
    e949:	31 c0                	xor    %eax,%eax
    e94b:	e8 00 00 00 00       	callq  e950 <e1000_reset_adaptive+0x90>
	}
}
    e950:	5d                   	pop    %rbp
    e951:	c3                   	retq   
    e952:	66 66 66 66 66 2e 0f 	data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
    e959:	1f 84 00 00 00 00 00 

000000000000e960 <e1000_update_adaptive>:
 *
 * Called during the callback/watchdog routine to update IFS value based on
 * the ratio of transmits to collisions.
 */
void e1000_update_adaptive(struct e1000_hw *hw)
{
    e960:	e8 00 00 00 00       	callq  e965 <e1000_update_adaptive+0x5>
	if (hw->adaptive_ifs) {
    e965:	80 bf 16 01 00 00 00 	cmpb   $0x0,0x116(%rdi)
    e96c:	74 57                	je     e9c5 <e1000_update_adaptive+0x65>
		if ((hw->collision_delta *hw->ifs_ratio) > hw->tx_packet_delta) {
    e96e:	0f b7 87 e4 00 00 00 	movzwl 0xe4(%rdi),%eax
    e975:	8b 97 ac 00 00 00    	mov    0xac(%rdi),%edx
    e97b:	0f af 87 a8 00 00 00 	imul   0xa8(%rdi),%eax
    e982:	39 d0                	cmp    %edx,%eax
    e984:	76 49                	jbe    e9cf <e1000_update_adaptive+0x6f>
			if (hw->tx_packet_delta > MIN_NUM_XMITS) {
    e986:	81 fa e8 03 00 00    	cmp    $0x3e8,%edx
    e98c:	76 40                	jbe    e9ce <e1000_update_adaptive+0x6e>
				hw->in_ifs_mode = true;
				if (hw->current_ifs_val < hw->ifs_max_val) {
    e98e:	0f b7 87 dc 00 00 00 	movzwl 0xdc(%rdi),%eax
void e1000_update_adaptive(struct e1000_hw *hw)
{
	if (hw->adaptive_ifs) {
		if ((hw->collision_delta *hw->ifs_ratio) > hw->tx_packet_delta) {
			if (hw->tx_packet_delta > MIN_NUM_XMITS) {
				hw->in_ifs_mode = true;
    e995:	c6 87 18 01 00 00 01 	movb   $0x1,0x118(%rdi)
				if (hw->current_ifs_val < hw->ifs_max_val) {
    e99c:	66 3b 87 e0 00 00 00 	cmp    0xe0(%rdi),%ax
    e9a3:	73 29                	jae    e9ce <e1000_update_adaptive+0x6e>
					if (hw->current_ifs_val == 0)
    e9a5:	66 85 c0             	test   %ax,%ax
    e9a8:	74 52                	je     e9fc <e1000_update_adaptive+0x9c>
						hw->current_ifs_val =
						    hw->ifs_min_val;
					else
						hw->current_ifs_val +=
    e9aa:	66 03 87 e2 00 00 00 	add    0xe2(%rdi),%ax
    e9b1:	66 89 87 dc 00 00 00 	mov    %ax,0xdc(%rdi)
						    hw->ifs_step_size;
					ew32(AIT, hw->current_ifs_val);
    e9b8:	48 8b 17             	mov    (%rdi),%rdx
    e9bb:	0f b7 c0             	movzwl %ax,%eax
    e9be:	89 82 58 04 00 00    	mov    %eax,0x458(%rdx)
    e9c4:	c3                   	retq   
				hw->in_ifs_mode = false;
				ew32(AIT, 0);
			}
		}
	} else {
		e_dbg("Not in Adaptive IFS mode!\n");
    e9c5:	f6 05 00 00 00 00 04 	testb  $0x4,0x0(%rip)        # e9cc <e1000_update_adaptive+0x6c>
    e9cc:	75 3e                	jne    ea0c <e1000_update_adaptive+0xac>
	}
}
    e9ce:	c3                   	retq   
						    hw->ifs_step_size;
					ew32(AIT, hw->current_ifs_val);
				}
			}
		} else {
			if (hw->in_ifs_mode
    e9cf:	80 bf 18 01 00 00 00 	cmpb   $0x0,0x118(%rdi)
    e9d6:	74 f6                	je     e9ce <e1000_update_adaptive+0x6e>
			    && (hw->tx_packet_delta <= MIN_NUM_XMITS)) {
    e9d8:	81 fa e8 03 00 00    	cmp    $0x3e8,%edx
    e9de:	77 ee                	ja     e9ce <e1000_update_adaptive+0x6e>
				hw->current_ifs_val = 0;
    e9e0:	31 c0                	xor    %eax,%eax
				hw->in_ifs_mode = false;
    e9e2:	c6 87 18 01 00 00 00 	movb   $0x0,0x118(%rdi)
				ew32(AIT, 0);
    e9e9:	48 8b 17             	mov    (%rdi),%rdx
				}
			}
		} else {
			if (hw->in_ifs_mode
			    && (hw->tx_packet_delta <= MIN_NUM_XMITS)) {
				hw->current_ifs_val = 0;
    e9ec:	66 89 87 dc 00 00 00 	mov    %ax,0xdc(%rdi)
    e9f3:	31 c0                	xor    %eax,%eax
    e9f5:	89 82 58 04 00 00    	mov    %eax,0x458(%rdx)
    e9fb:	c3                   	retq   
			if (hw->tx_packet_delta > MIN_NUM_XMITS) {
				hw->in_ifs_mode = true;
				if (hw->current_ifs_val < hw->ifs_max_val) {
					if (hw->current_ifs_val == 0)
						hw->current_ifs_val =
						    hw->ifs_min_val;
    e9fc:	0f b7 87 de 00 00 00 	movzwl 0xde(%rdi),%eax
		if ((hw->collision_delta *hw->ifs_ratio) > hw->tx_packet_delta) {
			if (hw->tx_packet_delta > MIN_NUM_XMITS) {
				hw->in_ifs_mode = true;
				if (hw->current_ifs_val < hw->ifs_max_val) {
					if (hw->current_ifs_val == 0)
						hw->current_ifs_val =
    ea03:	66 89 87 dc 00 00 00 	mov    %ax,0xdc(%rdi)
    ea0a:	eb ac                	jmp    e9b8 <e1000_update_adaptive+0x58>
 *
 * Called during the callback/watchdog routine to update IFS value based on
 * the ratio of transmits to collisions.
 */
void e1000_update_adaptive(struct e1000_hw *hw)
{
    ea0c:	55                   	push   %rbp
    ea0d:	48 89 e5             	mov    %rsp,%rbp
				hw->in_ifs_mode = false;
				ew32(AIT, 0);
			}
		}
	} else {
		e_dbg("Not in Adaptive IFS mode!\n");
    ea10:	e8 00 00 00 00       	callq  ea15 <e1000_update_adaptive+0xb5>
    ea15:	48 c7 c2 00 00 00 00 	mov    $0x0,%rdx
    ea1c:	48 89 c6             	mov    %rax,%rsi
    ea1f:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
    ea26:	31 c0                	xor    %eax,%eax
    ea28:	e8 00 00 00 00       	callq  ea2d <e1000_update_adaptive+0xcd>
	}
}
    ea2d:	5d                   	pop    %rbp
    ea2e:	c3                   	retq   
    ea2f:	90                   	nop

000000000000ea30 <e1000_get_bus_info>:
 * @hw: Struct containing variables accessed by shared code
 *
 * Gets the current PCI bus type, speed, and width of the hardware
 */
void e1000_get_bus_info(struct e1000_hw *hw)
{
    ea30:	e8 00 00 00 00       	callq  ea35 <e1000_get_bus_info+0x5>
    ea35:	55                   	push   %rbp
	u32 status;

	switch (hw->mac_type) {
    ea36:	8b 47 18             	mov    0x18(%rdi),%eax
 * @hw: Struct containing variables accessed by shared code
 *
 * Gets the current PCI bus type, speed, and width of the hardware
 */
void e1000_get_bus_info(struct e1000_hw *hw)
{
    ea39:	48 89 e5             	mov    %rsp,%rbp
	u32 status;

	switch (hw->mac_type) {
    ea3c:	83 e8 01             	sub    $0x1,%eax
    ea3f:	83 f8 01             	cmp    $0x1,%eax
    ea42:	76 59                	jbe    ea9d <e1000_get_bus_info+0x6d>
		hw->bus_type = e1000_bus_type_pci;
		hw->bus_speed = e1000_bus_speed_unknown;
		hw->bus_width = e1000_bus_width_unknown;
		break;
	default:
		status = er32(STATUS);
    ea44:	48 8b 07             	mov    (%rdi),%rax
{ asm volatile("mov" size " %0,%1": :reg (val), \
"m" (*(volatile type __force *)addr) barrier); }

build_mmio_read(readb, "b", unsigned char, "=q", :"memory")
build_mmio_read(readw, "w", unsigned short, "=r", :"memory")
build_mmio_read(readl, "l", unsigned int, "=r", :"memory")
    ea47:	8b 40 08             	mov    0x8(%rax),%eax
		hw->bus_type = (status & E1000_STATUS_PCIX_MODE) ?
    ea4a:	f6 c4 20             	test   $0x20,%ah
    ea4d:	74 65                	je     eab4 <e1000_get_bus_info+0x84>
		    e1000_bus_type_pcix : e1000_bus_type_pci;

		if (hw->device_id == E1000_DEV_ID_82546EB_QUAD_COPPER) {
    ea4f:	66 81 bf e6 00 00 00 	cmpw   $0x101d,0xe6(%rdi)
    ea56:	1d 10 
		hw->bus_speed = e1000_bus_speed_unknown;
		hw->bus_width = e1000_bus_width_unknown;
		break;
	default:
		status = er32(STATUS);
		hw->bus_type = (status & E1000_STATUS_PCIX_MODE) ?
    ea58:	c7 47 4c 02 00 00 00 	movl   $0x2,0x4c(%rdi)
		    e1000_bus_type_pcix : e1000_bus_type_pci;

		if (hw->device_id == E1000_DEV_ID_82546EB_QUAD_COPPER) {
    ea5f:	0f 84 98 00 00 00    	je     eafd <e1000_get_bus_info+0xcd>
			    e1000_bus_speed_66 : e1000_bus_speed_120;
		} else if (hw->bus_type == e1000_bus_type_pci) {
			hw->bus_speed = (status & E1000_STATUS_PCI66) ?
			    e1000_bus_speed_66 : e1000_bus_speed_33;
		} else {
			switch (status & E1000_STATUS_PCIX_SPEED) {
    ea65:	89 c2                	mov    %eax,%edx
    ea67:	81 e2 00 c0 00 00    	and    $0xc000,%edx
    ea6d:	81 fa 00 40 00 00    	cmp    $0x4000,%edx
    ea73:	74 76                	je     eaeb <e1000_get_bus_info+0xbb>
    ea75:	81 fa 00 80 00 00    	cmp    $0x8000,%edx
    ea7b:	74 77                	je     eaf4 <e1000_get_bus_info+0xc4>
				break;
			case E1000_STATUS_PCIX_SPEED_133:
				hw->bus_speed = e1000_bus_speed_133;
				break;
			default:
				hw->bus_speed = e1000_bus_speed_reserved;
    ea7d:	83 fa 01             	cmp    $0x1,%edx
    ea80:	19 d2                	sbb    %edx,%edx
				break;
			}
		}
		hw->bus_width = (status & E1000_STATUS_BUS64) ?
    ea82:	25 00 10 00 00       	and    $0x1000,%eax
				break;
			case E1000_STATUS_PCIX_SPEED_133:
				hw->bus_speed = e1000_bus_speed_133;
				break;
			default:
				hw->bus_speed = e1000_bus_speed_reserved;
    ea87:	83 e2 fc             	and    $0xfffffffc,%edx
    ea8a:	83 c2 06             	add    $0x6,%edx
				break;
			}
		}
		hw->bus_width = (status & E1000_STATUS_BUS64) ?
    ea8d:	83 f8 01             	cmp    $0x1,%eax
    ea90:	19 c0                	sbb    %eax,%eax
				break;
			case E1000_STATUS_PCIX_SPEED_133:
				hw->bus_speed = e1000_bus_speed_133;
				break;
			default:
				hw->bus_speed = e1000_bus_speed_reserved;
    ea92:	89 57 44             	mov    %edx,0x44(%rdi)
				break;
			}
		}
		hw->bus_width = (status & E1000_STATUS_BUS64) ?
    ea95:	83 c0 02             	add    $0x2,%eax
    ea98:	89 47 48             	mov    %eax,0x48(%rdi)
		    e1000_bus_width_64 : e1000_bus_width_32;
		break;
	}
}
    ea9b:	5d                   	pop    %rbp
    ea9c:	c3                   	retq   
	u32 status;

	switch (hw->mac_type) {
	case e1000_82542_rev2_0:
	case e1000_82542_rev2_1:
		hw->bus_type = e1000_bus_type_pci;
    ea9d:	c7 47 4c 01 00 00 00 	movl   $0x1,0x4c(%rdi)
		hw->bus_speed = e1000_bus_speed_unknown;
    eaa4:	c7 47 44 00 00 00 00 	movl   $0x0,0x44(%rdi)
		hw->bus_width = e1000_bus_width_unknown;
    eaab:	c7 47 48 00 00 00 00 	movl   $0x0,0x48(%rdi)
		}
		hw->bus_width = (status & E1000_STATUS_BUS64) ?
		    e1000_bus_width_64 : e1000_bus_width_32;
		break;
	}
}
    eab2:	5d                   	pop    %rbp
    eab3:	c3                   	retq   
	default:
		status = er32(STATUS);
		hw->bus_type = (status & E1000_STATUS_PCIX_MODE) ?
		    e1000_bus_type_pcix : e1000_bus_type_pci;

		if (hw->device_id == E1000_DEV_ID_82546EB_QUAD_COPPER) {
    eab4:	66 81 bf e6 00 00 00 	cmpw   $0x101d,0xe6(%rdi)
    eabb:	1d 10 
		hw->bus_speed = e1000_bus_speed_unknown;
		hw->bus_width = e1000_bus_width_unknown;
		break;
	default:
		status = er32(STATUS);
		hw->bus_type = (status & E1000_STATUS_PCIX_MODE) ?
    eabd:	c7 47 4c 01 00 00 00 	movl   $0x1,0x4c(%rdi)
		    e1000_bus_type_pcix : e1000_bus_type_pci;

		if (hw->device_id == E1000_DEV_ID_82546EB_QUAD_COPPER) {
    eac4:	74 3e                	je     eb04 <e1000_get_bus_info+0xd4>
			hw->bus_speed = (hw->bus_type == e1000_bus_type_pci) ?
			    e1000_bus_speed_66 : e1000_bus_speed_120;
		} else if (hw->bus_type == e1000_bus_type_pci) {
			hw->bus_speed = (status & E1000_STATUS_PCI66) ?
    eac6:	89 c2                	mov    %eax,%edx
    eac8:	81 e2 00 08 00 00    	and    $0x800,%edx
    eace:	83 fa 01             	cmp    $0x1,%edx
    ead1:	19 d2                	sbb    %edx,%edx
    ead3:	83 c2 02             	add    $0x2,%edx
    ead6:	89 57 44             	mov    %edx,0x44(%rdi)
			default:
				hw->bus_speed = e1000_bus_speed_reserved;
				break;
			}
		}
		hw->bus_width = (status & E1000_STATUS_BUS64) ?
    ead9:	25 00 10 00 00       	and    $0x1000,%eax
    eade:	83 f8 01             	cmp    $0x1,%eax
    eae1:	19 c0                	sbb    %eax,%eax
    eae3:	83 c0 02             	add    $0x2,%eax
    eae6:	89 47 48             	mov    %eax,0x48(%rdi)
		    e1000_bus_width_64 : e1000_bus_width_32;
		break;
	}
}
    eae9:	5d                   	pop    %rbp
    eaea:	c3                   	retq   
			switch (status & E1000_STATUS_PCIX_SPEED) {
			case E1000_STATUS_PCIX_SPEED_66:
				hw->bus_speed = e1000_bus_speed_66;
				break;
			case E1000_STATUS_PCIX_SPEED_100:
				hw->bus_speed = e1000_bus_speed_100;
    eaeb:	c7 47 44 03 00 00 00 	movl   $0x3,0x44(%rdi)
				break;
    eaf2:	eb e5                	jmp    ead9 <e1000_get_bus_info+0xa9>
			case E1000_STATUS_PCIX_SPEED_133:
				hw->bus_speed = e1000_bus_speed_133;
    eaf4:	c7 47 44 05 00 00 00 	movl   $0x5,0x44(%rdi)
				break;
    eafb:	eb dc                	jmp    ead9 <e1000_get_bus_info+0xa9>
		status = er32(STATUS);
		hw->bus_type = (status & E1000_STATUS_PCIX_MODE) ?
		    e1000_bus_type_pcix : e1000_bus_type_pci;

		if (hw->device_id == E1000_DEV_ID_82546EB_QUAD_COPPER) {
			hw->bus_speed = (hw->bus_type == e1000_bus_type_pci) ?
    eafd:	ba 04 00 00 00       	mov    $0x4,%edx
    eb02:	eb d2                	jmp    ead6 <e1000_get_bus_info+0xa6>
    eb04:	ba 02 00 00 00       	mov    $0x2,%edx
    eb09:	eb cb                	jmp    ead6 <e1000_get_bus_info+0xa6>
    eb0b:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)

000000000000eb10 <e1000_enable_mng_pass_thru>:
 *
 * Verifies the hardware needs to allow ARPs to be processed by the host
 * returns: - true/false
 */
u32 e1000_enable_mng_pass_thru(struct e1000_hw *hw)
{
    eb10:	e8 00 00 00 00       	callq  eb15 <e1000_enable_mng_pass_thru+0x5>
    eb15:	55                   	push   %rbp
	u32 manc;

	if (hw->asf_firmware_present) {
    eb16:	8b 47 6c             	mov    0x6c(%rdi),%eax
 *
 * Verifies the hardware needs to allow ARPs to be processed by the host
 * returns: - true/false
 */
u32 e1000_enable_mng_pass_thru(struct e1000_hw *hw)
{
    eb19:	48 89 e5             	mov    %rsp,%rbp
	u32 manc;

	if (hw->asf_firmware_present) {
    eb1c:	85 c0                	test   %eax,%eax
    eb1e:	74 19                	je     eb39 <e1000_enable_mng_pass_thru+0x29>
		manc = er32(MANC);
    eb20:	48 8b 07             	mov    (%rdi),%rax
    eb23:	8b 80 20 58 00 00    	mov    0x5820(%rax),%eax

		if (!(manc & E1000_MANC_RCV_TCO_EN) ||
    eb29:	89 c2                	mov    %eax,%edx
    eb2b:	81 e2 00 00 12 00    	and    $0x120000,%edx
    eb31:	81 fa 00 00 12 00    	cmp    $0x120000,%edx
    eb37:	74 04                	je     eb3d <e1000_enable_mng_pass_thru+0x2d>
		    !(manc & E1000_MANC_EN_MAC_ADDR_FILTER))
			return false;
		if ((manc & E1000_MANC_SMBUS_EN) && !(manc & E1000_MANC_ASF_EN))
			return true;
	}
	return false;
    eb39:	31 c0                	xor    %eax,%eax
}
    eb3b:	5d                   	pop    %rbp
    eb3c:	c3                   	retq   
		manc = er32(MANC);

		if (!(manc & E1000_MANC_RCV_TCO_EN) ||
		    !(manc & E1000_MANC_EN_MAC_ADDR_FILTER))
			return false;
		if ((manc & E1000_MANC_SMBUS_EN) && !(manc & E1000_MANC_ASF_EN))
    eb3d:	83 e0 03             	and    $0x3,%eax
    eb40:	83 f8 01             	cmp    $0x1,%eax
    eb43:	0f 94 c0             	sete   %al
    eb46:	0f b6 c0             	movzbl %al,%eax
			return true;
	}
	return false;
}
    eb49:	5d                   	pop    %rbp
    eb4a:	c3                   	retq   
    eb4b:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)

000000000000eb50 <e1000_get_pauseparam>:
	return e1000_has_link(adapter);
}

static void e1000_get_pauseparam(struct net_device *netdev,
				 struct ethtool_pauseparam *pause)
{
    eb50:	e8 00 00 00 00       	callq  eb55 <e1000_get_pauseparam+0x5>
    eb55:	55                   	push   %rbp
	struct e1000_adapter *adapter = netdev_priv(netdev);
	struct e1000_hw *hw = &adapter->hw;

	pause->autoneg =
		(adapter->fc_autoneg ? AUTONEG_ENABLE : AUTONEG_DISABLE);
    eb56:	31 c0                	xor    %eax,%eax
    eb58:	80 bf 7c 0a 00 00 00 	cmpb   $0x0,0xa7c(%rdi)
	return e1000_has_link(adapter);
}

static void e1000_get_pauseparam(struct net_device *netdev,
				 struct ethtool_pauseparam *pause)
{
    eb5f:	48 89 e5             	mov    %rsp,%rbp
	struct e1000_adapter *adapter = netdev_priv(netdev);
	struct e1000_hw *hw = &adapter->hw;

	pause->autoneg =
		(adapter->fc_autoneg ? AUTONEG_ENABLE : AUTONEG_DISABLE);
    eb62:	0f 95 c0             	setne  %al
				 struct ethtool_pauseparam *pause)
{
	struct e1000_adapter *adapter = netdev_priv(netdev);
	struct e1000_hw *hw = &adapter->hw;

	pause->autoneg =
    eb65:	89 46 04             	mov    %eax,0x4(%rsi)
		(adapter->fc_autoneg ? AUTONEG_ENABLE : AUTONEG_DISABLE);

	if (hw->fc == E1000_FC_RX_PAUSE) {
    eb68:	8b 87 40 0c 00 00    	mov    0xc40(%rdi),%eax
    eb6e:	83 f8 01             	cmp    $0x1,%eax
    eb71:	74 1e                	je     eb91 <e1000_get_pauseparam+0x41>
		pause->rx_pause = 1;
	} else if (hw->fc == E1000_FC_TX_PAUSE) {
    eb73:	83 f8 02             	cmp    $0x2,%eax
    eb76:	74 10                	je     eb88 <e1000_get_pauseparam+0x38>
		pause->tx_pause = 1;
	} else if (hw->fc == E1000_FC_FULL) {
    eb78:	83 f8 03             	cmp    $0x3,%eax
    eb7b:	74 04                	je     eb81 <e1000_get_pauseparam+0x31>
		pause->rx_pause = 1;
		pause->tx_pause = 1;
	}
}
    eb7d:	5d                   	pop    %rbp
    eb7e:	66 90                	xchg   %ax,%ax
    eb80:	c3                   	retq   
	if (hw->fc == E1000_FC_RX_PAUSE) {
		pause->rx_pause = 1;
	} else if (hw->fc == E1000_FC_TX_PAUSE) {
		pause->tx_pause = 1;
	} else if (hw->fc == E1000_FC_FULL) {
		pause->rx_pause = 1;
    eb81:	c7 46 08 01 00 00 00 	movl   $0x1,0x8(%rsi)
		pause->tx_pause = 1;
    eb88:	c7 46 0c 01 00 00 00 	movl   $0x1,0xc(%rsi)
	}
}
    eb8f:	5d                   	pop    %rbp
    eb90:	c3                   	retq   

	pause->autoneg =
		(adapter->fc_autoneg ? AUTONEG_ENABLE : AUTONEG_DISABLE);

	if (hw->fc == E1000_FC_RX_PAUSE) {
		pause->rx_pause = 1;
    eb91:	c7 46 08 01 00 00 00 	movl   $0x1,0x8(%rsi)
		pause->tx_pause = 1;
	} else if (hw->fc == E1000_FC_FULL) {
		pause->rx_pause = 1;
		pause->tx_pause = 1;
	}
}
    eb98:	5d                   	pop    %rbp
    eb99:	c3                   	retq   
    eb9a:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)

000000000000eba0 <e1000_get_msglevel>:
	clear_bit(__E1000_RESETTING, &adapter->flags);
	return retval;
}

static u32 e1000_get_msglevel(struct net_device *netdev)
{
    eba0:	e8 00 00 00 00       	callq  eba5 <e1000_get_msglevel+0x5>
    eba5:	55                   	push   %rbp
	struct e1000_adapter *adapter = netdev_priv(netdev);

	return adapter->msg_enable;
    eba6:	8b 87 e0 0f 00 00    	mov    0xfe0(%rdi),%eax
	clear_bit(__E1000_RESETTING, &adapter->flags);
	return retval;
}

static u32 e1000_get_msglevel(struct net_device *netdev)
{
    ebac:	48 89 e5             	mov    %rsp,%rbp
	struct e1000_adapter *adapter = netdev_priv(netdev);

	return adapter->msg_enable;
}
    ebaf:	5d                   	pop    %rbp
    ebb0:	c3                   	retq   
    ebb1:	66 66 66 66 66 66 2e 	data32 data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
    ebb8:	0f 1f 84 00 00 00 00 
    ebbf:	00 

000000000000ebc0 <e1000_set_msglevel>:

static void e1000_set_msglevel(struct net_device *netdev, u32 data)
{
    ebc0:	e8 00 00 00 00       	callq  ebc5 <e1000_set_msglevel+0x5>
    ebc5:	55                   	push   %rbp
	struct e1000_adapter *adapter = netdev_priv(netdev);

	adapter->msg_enable = data;
    ebc6:	89 b7 e0 0f 00 00    	mov    %esi,0xfe0(%rdi)

	return adapter->msg_enable;
}

static void e1000_set_msglevel(struct net_device *netdev, u32 data)
{
    ebcc:	48 89 e5             	mov    %rsp,%rbp
	struct e1000_adapter *adapter = netdev_priv(netdev);

	adapter->msg_enable = data;
}
    ebcf:	5d                   	pop    %rbp
    ebd0:	c3                   	retq   
    ebd1:	66 66 66 66 66 66 2e 	data32 data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
    ebd8:	0f 1f 84 00 00 00 00 
    ebdf:	00 

000000000000ebe0 <e1000_get_regs_len>:

static int e1000_get_regs_len(struct net_device *netdev)
{
    ebe0:	e8 00 00 00 00       	callq  ebe5 <e1000_get_regs_len+0x5>
    ebe5:	55                   	push   %rbp
#define E1000_REGS_LEN 32
	return E1000_REGS_LEN * sizeof(u32);
}
    ebe6:	b8 80 00 00 00       	mov    $0x80,%eax

	adapter->msg_enable = data;
}

static int e1000_get_regs_len(struct net_device *netdev)
{
    ebeb:	48 89 e5             	mov    %rsp,%rbp
#define E1000_REGS_LEN 32
	return E1000_REGS_LEN * sizeof(u32);
}
    ebee:	5d                   	pop    %rbp
    ebef:	c3                   	retq   

000000000000ebf0 <e1000_get_eeprom_len>:
		regs_buff[26] = er32(MANC);
	}
}

static int e1000_get_eeprom_len(struct net_device *netdev)
{
    ebf0:	e8 00 00 00 00       	callq  ebf5 <e1000_get_eeprom_len+0x5>
    ebf5:	55                   	push   %rbp
	struct e1000_adapter *adapter = netdev_priv(netdev);
	struct e1000_hw *hw = &adapter->hw;

	return hw->eeprom.word_size * 2;
    ebf6:	0f b7 87 54 0c 00 00 	movzwl 0xc54(%rdi),%eax
		regs_buff[26] = er32(MANC);
	}
}

static int e1000_get_eeprom_len(struct net_device *netdev)
{
    ebfd:	48 89 e5             	mov    %rsp,%rbp
	struct e1000_adapter *adapter = netdev_priv(netdev);
	struct e1000_hw *hw = &adapter->hw;

	return hw->eeprom.word_size * 2;
}
    ec00:	5d                   	pop    %rbp
static int e1000_get_eeprom_len(struct net_device *netdev)
{
	struct e1000_adapter *adapter = netdev_priv(netdev);
	struct e1000_hw *hw = &adapter->hw;

	return hw->eeprom.word_size * 2;
    ec01:	01 c0                	add    %eax,%eax
}
    ec03:	c3                   	retq   
    ec04:	66 66 66 2e 0f 1f 84 	data32 data32 nopw %cs:0x0(%rax,%rax,1)
    ec0b:	00 00 00 00 00 

000000000000ec10 <e1000_get_ringparam>:
		sizeof(drvinfo->bus_info));
}

static void e1000_get_ringparam(struct net_device *netdev,
				struct ethtool_ringparam *ring)
{
    ec10:	e8 00 00 00 00       	callq  ec15 <e1000_get_ringparam+0x5>
    ec15:	55                   	push   %rbp
	struct e1000_hw *hw = &adapter->hw;
	e1000_mac_type mac_type = hw->mac_type;
	struct e1000_tx_ring *txdr = adapter->tx_ring;
	struct e1000_rx_ring *rxdr = adapter->rx_ring;

	ring->rx_max_pending = (mac_type < e1000_82544) ? E1000_MAX_RXD :
    ec16:	83 bf 18 0c 00 00 03 	cmpl   $0x3,0xc18(%rdi)
				struct ethtool_ringparam *ring)
{
	struct e1000_adapter *adapter = netdev_priv(netdev);
	struct e1000_hw *hw = &adapter->hw;
	e1000_mac_type mac_type = hw->mac_type;
	struct e1000_tx_ring *txdr = adapter->tx_ring;
    ec1d:	48 8b 97 80 0a 00 00 	mov    0xa80(%rdi),%rdx
	struct e1000_rx_ring *rxdr = adapter->rx_ring;
    ec24:	48 8b 8f e8 0a 00 00 	mov    0xae8(%rdi),%rcx
		sizeof(drvinfo->bus_info));
}

static void e1000_get_ringparam(struct net_device *netdev,
				struct ethtool_ringparam *ring)
{
    ec2b:	48 89 e5             	mov    %rsp,%rbp
	struct e1000_hw *hw = &adapter->hw;
	e1000_mac_type mac_type = hw->mac_type;
	struct e1000_tx_ring *txdr = adapter->tx_ring;
	struct e1000_rx_ring *rxdr = adapter->rx_ring;

	ring->rx_max_pending = (mac_type < e1000_82544) ? E1000_MAX_RXD :
    ec2e:	77 1d                	ja     ec4d <e1000_get_ringparam+0x3d>
    ec30:	c7 46 04 00 01 00 00 	movl   $0x100,0x4(%rsi)
		E1000_MAX_82544_RXD;
	ring->tx_max_pending = (mac_type < e1000_82544) ? E1000_MAX_TXD :
    ec37:	b8 00 01 00 00       	mov    $0x100,%eax
    ec3c:	89 46 10             	mov    %eax,0x10(%rsi)
		E1000_MAX_82544_TXD;
	ring->rx_pending = rxdr->count;
    ec3f:	8b 41 14             	mov    0x14(%rcx),%eax
    ec42:	89 46 14             	mov    %eax,0x14(%rsi)
	ring->tx_pending = txdr->count;
    ec45:	8b 42 14             	mov    0x14(%rdx),%eax
    ec48:	89 46 20             	mov    %eax,0x20(%rsi)
}
    ec4b:	5d                   	pop    %rbp
    ec4c:	c3                   	retq   
	struct e1000_hw *hw = &adapter->hw;
	e1000_mac_type mac_type = hw->mac_type;
	struct e1000_tx_ring *txdr = adapter->tx_ring;
	struct e1000_rx_ring *rxdr = adapter->rx_ring;

	ring->rx_max_pending = (mac_type < e1000_82544) ? E1000_MAX_RXD :
    ec4d:	c7 46 04 00 10 00 00 	movl   $0x1000,0x4(%rsi)
		E1000_MAX_82544_RXD;
	ring->tx_max_pending = (mac_type < e1000_82544) ? E1000_MAX_TXD :
    ec54:	b8 00 10 00 00       	mov    $0x1000,%eax
    ec59:	eb e1                	jmp    ec3c <e1000_get_ringparam+0x2c>
    ec5b:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)

000000000000ec60 <e1000_test_intr>:

	return *data;
}

static irqreturn_t e1000_test_intr(int irq, void *data)
{
    ec60:	e8 00 00 00 00       	callq  ec65 <e1000_test_intr+0x5>
    ec65:	55                   	push   %rbp
	struct net_device *netdev = (struct net_device *)data;
	struct e1000_adapter *adapter = netdev_priv(netdev);
	struct e1000_hw *hw = &adapter->hw;

	adapter->test_icr |= er32(ICR);
    ec66:	8b 96 70 0f 00 00    	mov    0xf70(%rsi),%edx
    ec6c:	48 8b 86 00 0c 00 00 	mov    0xc00(%rsi),%rax

	return *data;
}

static irqreturn_t e1000_test_intr(int irq, void *data)
{
    ec73:	48 89 e5             	mov    %rsp,%rbp
    ec76:	8b 80 c0 00 00 00    	mov    0xc0(%rax),%eax
	struct net_device *netdev = (struct net_device *)data;
	struct e1000_adapter *adapter = netdev_priv(netdev);
	struct e1000_hw *hw = &adapter->hw;

	adapter->test_icr |= er32(ICR);
    ec7c:	09 d0                	or     %edx,%eax
    ec7e:	89 86 70 0f 00 00    	mov    %eax,0xf70(%rsi)

	return IRQ_HANDLED;
}
    ec84:	b8 01 00 00 00       	mov    $0x1,%eax
    ec89:	5d                   	pop    %rbp
    ec8a:	c3                   	retq   
    ec8b:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)

000000000000ec90 <e1000_get_sset_count>:
	}
	return *data;
}

static int e1000_get_sset_count(struct net_device *netdev, int sset)
{
    ec90:	e8 00 00 00 00       	callq  ec95 <e1000_get_sset_count+0x5>
    ec95:	55                   	push   %rbp
	switch (sset) {
    ec96:	85 f6                	test   %esi,%esi
	case ETH_SS_TEST:
		return E1000_TEST_LEN;
    ec98:	b8 05 00 00 00       	mov    $0x5,%eax
	}
	return *data;
}

static int e1000_get_sset_count(struct net_device *netdev, int sset)
{
    ec9d:	48 89 e5             	mov    %rsp,%rbp
	switch (sset) {
    eca0:	74 10                	je     ecb2 <e1000_get_sset_count+0x22>
	case ETH_SS_TEST:
		return E1000_TEST_LEN;
	case ETH_SS_STATS:
		return E1000_STATS_LEN;
	default:
		return -EOPNOTSUPP;
    eca2:	b8 a1 ff ff ff       	mov    $0xffffffa1,%eax
    eca7:	83 fe 01             	cmp    $0x1,%esi
    ecaa:	ba 2e 00 00 00       	mov    $0x2e,%edx
    ecaf:	0f 44 c2             	cmove  %edx,%eax
	}
}
    ecb2:	5d                   	pop    %rbp
    ecb3:	c3                   	retq   
    ecb4:	66 66 66 2e 0f 1f 84 	data32 data32 nopw %cs:0x0(%rax,%rax,1)
    ecbb:	00 00 00 00 00 

000000000000ecc0 <e1000_get_coalesce>:
	return 0;
}

static int e1000_get_coalesce(struct net_device *netdev,
			      struct ethtool_coalesce *ec)
{
    ecc0:	e8 00 00 00 00       	callq  ecc5 <e1000_get_coalesce+0x5>
    ecc5:	55                   	push   %rbp
	struct e1000_adapter *adapter = netdev_priv(netdev);

	if (adapter->hw.mac_type < e1000_82545)
    ecc6:	83 bf 18 0c 00 00 05 	cmpl   $0x5,0xc18(%rdi)
	return 0;
}

static int e1000_get_coalesce(struct net_device *netdev,
			      struct ethtool_coalesce *ec)
{
    eccd:	48 89 e5             	mov    %rsp,%rbp
	struct e1000_adapter *adapter = netdev_priv(netdev);

	if (adapter->hw.mac_type < e1000_82545)
    ecd0:	76 22                	jbe    ecf4 <e1000_get_coalesce+0x34>
		return -EOPNOTSUPP;

	if (adapter->itr_setting <= 4)
    ecd2:	8b 8f 74 0a 00 00    	mov    0xa74(%rdi),%ecx
    ecd8:	83 f9 04             	cmp    $0x4,%ecx
    ecdb:	76 10                	jbe    eced <e1000_get_coalesce+0x2d>
		ec->rx_coalesce_usecs = adapter->itr_setting;
	else
		ec->rx_coalesce_usecs = 1000000 / adapter->itr_setting;
    ecdd:	b8 40 42 0f 00       	mov    $0xf4240,%eax
    ece2:	31 d2                	xor    %edx,%edx
    ece4:	f7 f1                	div    %ecx
    ece6:	89 46 04             	mov    %eax,0x4(%rsi)

	return 0;
    ece9:	31 c0                	xor    %eax,%eax
}
    eceb:	5d                   	pop    %rbp
    ecec:	c3                   	retq   

	if (adapter->hw.mac_type < e1000_82545)
		return -EOPNOTSUPP;

	if (adapter->itr_setting <= 4)
		ec->rx_coalesce_usecs = adapter->itr_setting;
    eced:	89 4e 04             	mov    %ecx,0x4(%rsi)
	else
		ec->rx_coalesce_usecs = 1000000 / adapter->itr_setting;

	return 0;
    ecf0:	31 c0                	xor    %eax,%eax
}
    ecf2:	5d                   	pop    %rbp
    ecf3:	c3                   	retq   
			      struct ethtool_coalesce *ec)
{
	struct e1000_adapter *adapter = netdev_priv(netdev);

	if (adapter->hw.mac_type < e1000_82545)
		return -EOPNOTSUPP;
    ecf4:	b8 a1 ff ff ff       	mov    $0xffffffa1,%eax
		ec->rx_coalesce_usecs = adapter->itr_setting;
	else
		ec->rx_coalesce_usecs = 1000000 / adapter->itr_setting;

	return 0;
}
    ecf9:	5d                   	pop    %rbp
    ecfa:	c3                   	retq   
    ecfb:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)

000000000000ed00 <e1000_get_ethtool_stats>:
	return 0;
}

static void e1000_get_ethtool_stats(struct net_device *netdev,
				    struct ethtool_stats *stats, u64 *data)
{
    ed00:	e8 00 00 00 00       	callq  ed05 <e1000_get_ethtool_stats+0x5>
    ed05:	55                   	push   %rbp
    ed06:	48 89 e5             	mov    %rsp,%rbp
    ed09:	41 57                	push   %r15
	struct e1000_adapter *adapter = netdev_priv(netdev);
    ed0b:	4c 8d bf 40 08 00 00 	lea    0x840(%rdi),%r15
	return 0;
}

static void e1000_get_ethtool_stats(struct net_device *netdev,
				    struct ethtool_stats *stats, u64 *data)
{
    ed12:	41 56                	push   %r14
	struct e1000_adapter *adapter = netdev_priv(netdev);
	int i;
	char *p = NULL;
    ed14:	45 31 f6             	xor    %r14d,%r14d
	return 0;
}

static void e1000_get_ethtool_stats(struct net_device *netdev,
				    struct ethtool_stats *stats, u64 *data)
{
    ed17:	41 55                	push   %r13
	int i;
	char *p = NULL;
	const struct e1000_stats *stat = e1000_gstrings_stats;

	e1000_update_stats(adapter);
	for (i = 0; i < E1000_GLOBAL_STATS_LEN; i++) {
    ed19:	45 31 ed             	xor    %r13d,%r13d
	return 0;
}

static void e1000_get_ethtool_stats(struct net_device *netdev,
				    struct ethtool_stats *stats, u64 *data)
{
    ed1c:	41 54                	push   %r12
    ed1e:	49 89 d4             	mov    %rdx,%r12
    ed21:	53                   	push   %rbx
	struct e1000_adapter *adapter = netdev_priv(netdev);
	int i;
	char *p = NULL;
	const struct e1000_stats *stat = e1000_gstrings_stats;
    ed22:	48 c7 c3 00 00 00 00 	mov    $0x0,%rbx
	return 0;
}

static void e1000_get_ethtool_stats(struct net_device *netdev,
				    struct ethtool_stats *stats, u64 *data)
{
    ed29:	48 83 ec 08          	sub    $0x8,%rsp
	struct e1000_adapter *adapter = netdev_priv(netdev);
    ed2d:	48 89 7d d0          	mov    %rdi,-0x30(%rbp)
	int i;
	char *p = NULL;
	const struct e1000_stats *stat = e1000_gstrings_stats;

	e1000_update_stats(adapter);
    ed31:	4c 89 ff             	mov    %r15,%rdi
    ed34:	e8 00 00 00 00       	callq  ed39 <e1000_get_ethtool_stats+0x39>
	for (i = 0; i < E1000_GLOBAL_STATS_LEN; i++) {
    ed39:	4c 8b 4d d0          	mov    -0x30(%rbp),%r9
    ed3d:	eb 29                	jmp    ed68 <e1000_get_ethtool_stats+0x68>
		switch (stat->type) {
		case NETDEV_STATS:
			p = (char *)netdev + stat->stat_offset;
			break;
		case E1000_STATS:
			p = (char *)adapter + stat->stat_offset;
    ed3f:	4c 63 73 28          	movslq 0x28(%rbx),%r14
    ed43:	4d 01 fe             	add    %r15,%r14
			WARN_ONCE(1, "Invalid E1000 stat type: %u index %d\n",
				  stat->type, i);
			break;
		}

		if (stat->sizeof_stat == sizeof(u64))
    ed46:	83 7b 24 08          	cmpl   $0x8,0x24(%rbx)
    ed4a:	74 6c                	je     edb8 <e1000_get_ethtool_stats+0xb8>
			data[i] = *(u64 *)p;
		else
			data[i] = *(u32 *)p;
    ed4c:	41 8b 06             	mov    (%r14),%eax
    ed4f:	49 89 04 24          	mov    %rax,(%r12)

		stat++;
    ed53:	48 83 c3 2c          	add    $0x2c,%rbx
	int i;
	char *p = NULL;
	const struct e1000_stats *stat = e1000_gstrings_stats;

	e1000_update_stats(adapter);
	for (i = 0; i < E1000_GLOBAL_STATS_LEN; i++) {
    ed57:	41 83 c5 01          	add    $0x1,%r13d
    ed5b:	49 83 c4 08          	add    $0x8,%r12
    ed5f:	48 81 fb 00 00 00 00 	cmp    $0x0,%rbx
    ed66:	74 59                	je     edc1 <e1000_get_ethtool_stats+0xc1>
		switch (stat->type) {
    ed68:	8b 4b 20             	mov    0x20(%rbx),%ecx
    ed6b:	85 c9                	test   %ecx,%ecx
    ed6d:	74 3c                	je     edab <e1000_get_ethtool_stats+0xab>
    ed6f:	83 f9 01             	cmp    $0x1,%ecx
    ed72:	74 cb                	je     ed3f <e1000_get_ethtool_stats+0x3f>
			break;
		case E1000_STATS:
			p = (char *)adapter + stat->stat_offset;
			break;
		default:
			WARN_ONCE(1, "Invalid E1000 stat type: %u index %d\n",
    ed74:	80 3d 00 00 00 00 00 	cmpb   $0x0,0x0(%rip)        # ed7b <e1000_get_ethtool_stats+0x7b>
    ed7b:	75 c9                	jne    ed46 <e1000_get_ethtool_stats+0x46>
    ed7d:	45 89 e8             	mov    %r13d,%r8d
    ed80:	48 c7 c2 00 00 00 00 	mov    $0x0,%rdx
    ed87:	be 32 07 00 00       	mov    $0x732,%esi
    ed8c:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
    ed93:	31 c0                	xor    %eax,%eax
    ed95:	4c 89 4d d0          	mov    %r9,-0x30(%rbp)
    ed99:	e8 00 00 00 00       	callq  ed9e <e1000_get_ethtool_stats+0x9e>
    ed9e:	c6 05 00 00 00 00 01 	movb   $0x1,0x0(%rip)        # eda5 <e1000_get_ethtool_stats+0xa5>
    eda5:	4c 8b 4d d0          	mov    -0x30(%rbp),%r9
    eda9:	eb 9b                	jmp    ed46 <e1000_get_ethtool_stats+0x46>

	e1000_update_stats(adapter);
	for (i = 0; i < E1000_GLOBAL_STATS_LEN; i++) {
		switch (stat->type) {
		case NETDEV_STATS:
			p = (char *)netdev + stat->stat_offset;
    edab:	4c 63 73 28          	movslq 0x28(%rbx),%r14
    edaf:	4d 01 ce             	add    %r9,%r14
			WARN_ONCE(1, "Invalid E1000 stat type: %u index %d\n",
				  stat->type, i);
			break;
		}

		if (stat->sizeof_stat == sizeof(u64))
    edb2:	83 7b 24 08          	cmpl   $0x8,0x24(%rbx)
    edb6:	75 94                	jne    ed4c <e1000_get_ethtool_stats+0x4c>
			data[i] = *(u64 *)p;
    edb8:	49 8b 06             	mov    (%r14),%rax
    edbb:	49 89 04 24          	mov    %rax,(%r12)
    edbf:	eb 92                	jmp    ed53 <e1000_get_ethtool_stats+0x53>
			data[i] = *(u32 *)p;

		stat++;
	}
/* BUG_ON(i != E1000_STATS_LEN); */
}
    edc1:	48 83 c4 08          	add    $0x8,%rsp
    edc5:	5b                   	pop    %rbx
    edc6:	41 5c                	pop    %r12
    edc8:	41 5d                	pop    %r13
    edca:	41 5e                	pop    %r14
    edcc:	41 5f                	pop    %r15
    edce:	5d                   	pop    %rbp
    edcf:	c3                   	retq   

000000000000edd0 <e1000_set_phys_id>:
	return 0;
}

static int e1000_set_phys_id(struct net_device *netdev,
			     enum ethtool_phys_id_state state)
{
    edd0:	e8 00 00 00 00       	callq  edd5 <e1000_set_phys_id+0x5>
    edd5:	55                   	push   %rbp
	struct e1000_adapter *adapter = netdev_priv(netdev);
	struct e1000_hw *hw = &adapter->hw;
    edd6:	48 81 c7 00 0c 00 00 	add    $0xc00,%rdi

	switch (state) {
    eddd:	83 fe 01             	cmp    $0x1,%esi
	return 0;
}

static int e1000_set_phys_id(struct net_device *netdev,
			     enum ethtool_phys_id_state state)
{
    ede0:	48 89 e5             	mov    %rsp,%rbp
	struct e1000_adapter *adapter = netdev_priv(netdev);
	struct e1000_hw *hw = &adapter->hw;

	switch (state) {
    ede3:	74 34                	je     ee19 <e1000_set_phys_id+0x49>
    ede5:	72 26                	jb     ee0d <e1000_set_phys_id+0x3d>
    ede7:	83 fe 02             	cmp    $0x2,%esi
    edea:	74 0f                	je     edfb <e1000_set_phys_id+0x2b>
    edec:	83 fe 03             	cmp    $0x3,%esi
    edef:	90                   	nop
    edf0:	75 17                	jne    ee09 <e1000_set_phys_id+0x39>
	case ETHTOOL_ID_ON:
		e1000_led_on(hw);
		break;

	case ETHTOOL_ID_OFF:
		e1000_led_off(hw);
    edf2:	e8 00 00 00 00       	callq  edf7 <e1000_set_phys_id+0x27>

	case ETHTOOL_ID_INACTIVE:
		e1000_cleanup_led(hw);
	}

	return 0;
    edf7:	31 c0                	xor    %eax,%eax
}
    edf9:	5d                   	pop    %rbp
    edfa:	c3                   	retq   
    edfb:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)
	case ETHTOOL_ID_ACTIVE:
		e1000_setup_led(hw);
		return 2;

	case ETHTOOL_ID_ON:
		e1000_led_on(hw);
    ee00:	e8 00 00 00 00       	callq  ee05 <e1000_set_phys_id+0x35>

	case ETHTOOL_ID_INACTIVE:
		e1000_cleanup_led(hw);
	}

	return 0;
    ee05:	31 c0                	xor    %eax,%eax
}
    ee07:	5d                   	pop    %rbp
    ee08:	c3                   	retq   

	case ETHTOOL_ID_INACTIVE:
		e1000_cleanup_led(hw);
	}

	return 0;
    ee09:	31 c0                	xor    %eax,%eax
}
    ee0b:	5d                   	pop    %rbp
    ee0c:	c3                   	retq   
    ee0d:	0f 1f 00             	nopl   (%rax)
	case ETHTOOL_ID_OFF:
		e1000_led_off(hw);
		break;

	case ETHTOOL_ID_INACTIVE:
		e1000_cleanup_led(hw);
    ee10:	e8 00 00 00 00       	callq  ee15 <e1000_set_phys_id+0x45>
	}

	return 0;
    ee15:	31 c0                	xor    %eax,%eax
}
    ee17:	5d                   	pop    %rbp
    ee18:	c3                   	retq   
	struct e1000_adapter *adapter = netdev_priv(netdev);
	struct e1000_hw *hw = &adapter->hw;

	switch (state) {
	case ETHTOOL_ID_ACTIVE:
		e1000_setup_led(hw);
    ee19:	e8 00 00 00 00       	callq  ee1e <e1000_set_phys_id+0x4e>
		return 2;
    ee1e:	b8 02 00 00 00       	mov    $0x2,%eax
	case ETHTOOL_ID_INACTIVE:
		e1000_cleanup_led(hw);
	}

	return 0;
}
    ee23:	5d                   	pop    %rbp
    ee24:	c3                   	retq   
    ee25:	66 66 2e 0f 1f 84 00 	data32 nopw %cs:0x0(%rax,%rax,1)
    ee2c:	00 00 00 00 

000000000000ee30 <reg_pattern_test>:
	return err;
}

static bool reg_pattern_test(struct e1000_adapter *adapter, u64 *data, int reg,
			     u32 mask, u32 write)
{
    ee30:	e8 00 00 00 00       	callq  ee35 <reg_pattern_test+0x5>
    ee35:	55                   	push   %rbp
	u8 __iomem *address = hw->hw_addr + reg;
	u32 read;
	int i;

	for (i = 0; i < ARRAY_SIZE(test); i++) {
		writel(write & test[i], address);
    ee36:	45 89 c2             	mov    %r8d,%r10d
    ee39:	41 81 e2 5a 5a 5a 5a 	and    $0x5a5a5a5a,%r10d
	return err;
}

static bool reg_pattern_test(struct e1000_adapter *adapter, u64 *data, int reg,
			     u32 mask, u32 write)
{
    ee40:	48 89 e5             	mov    %rsp,%rbp
    ee43:	41 54                	push   %r12
    ee45:	49 89 f4             	mov    %rsi,%r12
    ee48:	53                   	push   %rbx
	struct e1000_hw *hw = &adapter->hw;
	static const u32 test[] = {
		0x5A5A5A5A, 0xA5A5A5A5, 0x00000000, 0xFFFFFFFF
	};
	u8 __iomem *address = hw->hw_addr + reg;
    ee49:	48 63 da             	movslq %edx,%rbx
    ee4c:	48 89 d8             	mov    %rbx,%rax
    ee4f:	48 03 87 c0 03 00 00 	add    0x3c0(%rdi),%rax
build_mmio_read(__readw, "w", unsigned short, "=r", )
build_mmio_read(__readl, "l", unsigned int, "=r", )

build_mmio_write(writeb, "b", unsigned char, "q", :"memory")
build_mmio_write(writew, "w", unsigned short, "r", :"memory")
build_mmio_write(writel, "l", unsigned int, "r", :"memory")
    ee56:	44 89 10             	mov    %r10d,(%rax)
{ asm volatile("mov" size " %0,%1": :reg (val), \
"m" (*(volatile type __force *)addr) barrier); }

build_mmio_read(readb, "b", unsigned char, "=q", :"memory")
build_mmio_read(readw, "w", unsigned short, "=r", :"memory")
build_mmio_read(readl, "l", unsigned int, "=r", :"memory")
    ee59:	44 8b 08             	mov    (%rax),%r9d
	int i;

	for (i = 0; i < ARRAY_SIZE(test); i++) {
		writel(write & test[i], address);
		read = readl(address);
		if (read != (write & test[i] & mask)) {
    ee5c:	41 21 ca             	and    %ecx,%r10d
    ee5f:	45 39 ca             	cmp    %r9d,%r10d
    ee62:	75 44                	jne    eea8 <reg_pattern_test+0x78>
	u8 __iomem *address = hw->hw_addr + reg;
	u32 read;
	int i;

	for (i = 0; i < ARRAY_SIZE(test); i++) {
		writel(write & test[i], address);
    ee64:	44 89 c6             	mov    %r8d,%esi
    ee67:	44 21 c1             	and    %r8d,%ecx
    ee6a:	81 e6 a5 a5 a5 a5    	and    $0xa5a5a5a5,%esi
build_mmio_read(__readw, "w", unsigned short, "=r", )
build_mmio_read(__readl, "l", unsigned int, "=r", )

build_mmio_write(writeb, "b", unsigned char, "q", :"memory")
build_mmio_write(writew, "w", unsigned short, "r", :"memory")
build_mmio_write(writel, "l", unsigned int, "r", :"memory")
    ee70:	89 30                	mov    %esi,(%rax)
{ asm volatile("mov" size " %0,%1": :reg (val), \
"m" (*(volatile type __force *)addr) barrier); }

build_mmio_read(readb, "b", unsigned char, "=q", :"memory")
build_mmio_read(readw, "w", unsigned short, "=r", :"memory")
build_mmio_read(readl, "l", unsigned int, "=r", :"memory")
    ee72:	44 8b 08             	mov    (%rax),%r9d
		read = readl(address);
		if (read != (write & test[i] & mask)) {
    ee75:	41 89 ca             	mov    %ecx,%r10d
    ee78:	41 81 e2 a5 a5 a5 a5 	and    $0xa5a5a5a5,%r10d
    ee7f:	45 39 ca             	cmp    %r9d,%r10d
    ee82:	75 24                	jne    eea8 <reg_pattern_test+0x78>
build_mmio_read(__readw, "w", unsigned short, "=r", )
build_mmio_read(__readl, "l", unsigned int, "=r", )

build_mmio_write(writeb, "b", unsigned char, "q", :"memory")
build_mmio_write(writew, "w", unsigned short, "r", :"memory")
build_mmio_write(writel, "l", unsigned int, "r", :"memory")
    ee84:	31 f6                	xor    %esi,%esi
    ee86:	89 30                	mov    %esi,(%rax)
{ asm volatile("mov" size " %0,%1": :reg (val), \
"m" (*(volatile type __force *)addr) barrier); }

build_mmio_read(readb, "b", unsigned char, "=q", :"memory")
build_mmio_read(readw, "w", unsigned short, "=r", :"memory")
build_mmio_read(readl, "l", unsigned int, "=r", :"memory")
    ee88:	44 8b 08             	mov    (%rax),%r9d
    ee8b:	45 85 c9             	test   %r9d,%r9d
    ee8e:	75 15                	jne    eea5 <reg_pattern_test+0x75>
build_mmio_read(__readw, "w", unsigned short, "=r", )
build_mmio_read(__readl, "l", unsigned int, "=r", )

build_mmio_write(writeb, "b", unsigned char, "q", :"memory")
build_mmio_write(writew, "w", unsigned short, "r", :"memory")
build_mmio_write(writel, "l", unsigned int, "r", :"memory")
    ee90:	44 89 00             	mov    %r8d,(%rax)
{ asm volatile("mov" size " %0,%1": :reg (val), \
"m" (*(volatile type __force *)addr) barrier); }

build_mmio_read(readb, "b", unsigned char, "=q", :"memory")
build_mmio_read(readw, "w", unsigned short, "=r", :"memory")
build_mmio_read(readl, "l", unsigned int, "=r", :"memory")
    ee93:	44 8b 08             	mov    (%rax),%r9d
			      reg, read, (write & test[i] & mask));
			*data = reg;
			return true;
		}
	}
	return false;
    ee96:	31 c0                	xor    %eax,%eax
	int i;

	for (i = 0; i < ARRAY_SIZE(test); i++) {
		writel(write & test[i], address);
		read = readl(address);
		if (read != (write & test[i] & mask)) {
    ee98:	41 39 c9             	cmp    %ecx,%r9d
    ee9b:	41 89 ca             	mov    %ecx,%r10d
    ee9e:	75 08                	jne    eea8 <reg_pattern_test+0x78>
			*data = reg;
			return true;
		}
	}
	return false;
}
    eea0:	5b                   	pop    %rbx
    eea1:	41 5c                	pop    %r12
    eea3:	5d                   	pop    %rbp
    eea4:	c3                   	retq   
	int i;

	for (i = 0; i < ARRAY_SIZE(test); i++) {
		writel(write & test[i], address);
		read = readl(address);
		if (read != (write & test[i] & mask)) {
    eea5:	45 31 d2             	xor    %r10d,%r10d
			e_err(drv, "pattern test reg %04X failed: "
    eea8:	f6 87 a0 07 00 00 01 	testb  $0x1,0x7a0(%rdi)
    eeaf:	74 1b                	je     eecc <reg_pattern_test+0x9c>
    eeb1:	48 8b bf b0 03 00 00 	mov    0x3b0(%rdi),%rdi
    eeb8:	45 89 d0             	mov    %r10d,%r8d
    eebb:	44 89 c9             	mov    %r9d,%ecx
    eebe:	48 c7 c6 00 00 00 00 	mov    $0x0,%rsi
    eec5:	31 c0                	xor    %eax,%eax
    eec7:	e8 00 00 00 00       	callq  eecc <reg_pattern_test+0x9c>
			      "got 0x%08X expected 0x%08X\n",
			      reg, read, (write & test[i] & mask));
			*data = reg;
    eecc:	49 89 1c 24          	mov    %rbx,(%r12)
			return true;
    eed0:	b8 01 00 00 00       	mov    $0x1,%eax
		}
	}
	return false;
}
    eed5:	5b                   	pop    %rbx
    eed6:	41 5c                	pop    %r12
    eed8:	5d                   	pop    %rbp
    eed9:	c3                   	retq   
    eeda:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)

000000000000eee0 <e1000_phy_disable_receiver>:
	e1000_free_desc_rings(adapter);
	return ret_val;
}

static void e1000_phy_disable_receiver(struct e1000_adapter *adapter)
{
    eee0:	e8 00 00 00 00       	callq  eee5 <e1000_phy_disable_receiver+0x5>
    eee5:	55                   	push   %rbp
	struct e1000_hw *hw = &adapter->hw;

	/* Write out to PHY registers 29 and 30 to disable the Receiver. */
	e1000_write_phy_reg(hw, 29, 0x001F);
    eee6:	ba 1f 00 00 00       	mov    $0x1f,%edx
    eeeb:	be 1d 00 00 00       	mov    $0x1d,%esi
	e1000_free_desc_rings(adapter);
	return ret_val;
}

static void e1000_phy_disable_receiver(struct e1000_adapter *adapter)
{
    eef0:	48 89 e5             	mov    %rsp,%rbp
    eef3:	53                   	push   %rbx
	struct e1000_hw *hw = &adapter->hw;
    eef4:	48 8d 9f c0 03 00 00 	lea    0x3c0(%rdi),%rbx

	/* Write out to PHY registers 29 and 30 to disable the Receiver. */
	e1000_write_phy_reg(hw, 29, 0x001F);
    eefb:	48 89 df             	mov    %rbx,%rdi
    eefe:	e8 00 00 00 00       	callq  ef03 <e1000_phy_disable_receiver+0x23>
	e1000_write_phy_reg(hw, 30, 0x8FFC);
    ef03:	48 89 df             	mov    %rbx,%rdi
    ef06:	ba fc 8f 00 00       	mov    $0x8ffc,%edx
    ef0b:	be 1e 00 00 00       	mov    $0x1e,%esi
    ef10:	e8 00 00 00 00       	callq  ef15 <e1000_phy_disable_receiver+0x35>
	e1000_write_phy_reg(hw, 29, 0x001A);
    ef15:	48 89 df             	mov    %rbx,%rdi
    ef18:	ba 1a 00 00 00       	mov    $0x1a,%edx
    ef1d:	be 1d 00 00 00       	mov    $0x1d,%esi
    ef22:	e8 00 00 00 00       	callq  ef27 <e1000_phy_disable_receiver+0x47>
	e1000_write_phy_reg(hw, 30, 0x8FF0);
    ef27:	48 89 df             	mov    %rbx,%rdi
    ef2a:	ba f0 8f 00 00       	mov    $0x8ff0,%edx
    ef2f:	be 1e 00 00 00       	mov    $0x1e,%esi
    ef34:	e8 00 00 00 00       	callq  ef39 <e1000_phy_disable_receiver+0x59>
}
    ef39:	5b                   	pop    %rbx
    ef3a:	5d                   	pop    %rbp
    ef3b:	c3                   	retq   
    ef3c:	0f 1f 40 00          	nopl   0x0(%rax)

000000000000ef40 <e1000_phy_reset_clk_and_crs>:

static void e1000_phy_reset_clk_and_crs(struct e1000_adapter *adapter)
{
    ef40:	e8 00 00 00 00       	callq  ef45 <e1000_phy_reset_clk_and_crs+0x5>
    ef45:	55                   	push   %rbp

	/* Because we reset the PHY above, we need to re-force TX_CLK in the
	 * Extended PHY Specific Control Register to 25MHz clock.  This
	 * value defaults back to a 2.5MHz clock when the PHY is reset.
	 */
	e1000_read_phy_reg(hw, M88E1000_EXT_PHY_SPEC_CTRL, &phy_reg);
    ef46:	be 14 00 00 00       	mov    $0x14,%esi
	e1000_write_phy_reg(hw, 29, 0x001A);
	e1000_write_phy_reg(hw, 30, 0x8FF0);
}

static void e1000_phy_reset_clk_and_crs(struct e1000_adapter *adapter)
{
    ef4b:	48 89 e5             	mov    %rsp,%rbp
    ef4e:	53                   	push   %rbx
	struct e1000_hw *hw = &adapter->hw;
    ef4f:	48 8d 9f c0 03 00 00 	lea    0x3c0(%rdi),%rbx

	/* Because we reset the PHY above, we need to re-force TX_CLK in the
	 * Extended PHY Specific Control Register to 25MHz clock.  This
	 * value defaults back to a 2.5MHz clock when the PHY is reset.
	 */
	e1000_read_phy_reg(hw, M88E1000_EXT_PHY_SPEC_CTRL, &phy_reg);
    ef56:	48 8d 55 f6          	lea    -0xa(%rbp),%rdx
	e1000_write_phy_reg(hw, 29, 0x001A);
	e1000_write_phy_reg(hw, 30, 0x8FF0);
}

static void e1000_phy_reset_clk_and_crs(struct e1000_adapter *adapter)
{
    ef5a:	48 83 ec 08          	sub    $0x8,%rsp

	/* Because we reset the PHY above, we need to re-force TX_CLK in the
	 * Extended PHY Specific Control Register to 25MHz clock.  This
	 * value defaults back to a 2.5MHz clock when the PHY is reset.
	 */
	e1000_read_phy_reg(hw, M88E1000_EXT_PHY_SPEC_CTRL, &phy_reg);
    ef5e:	48 89 df             	mov    %rbx,%rdi
    ef61:	e8 00 00 00 00       	callq  ef66 <e1000_phy_reset_clk_and_crs+0x26>
	phy_reg |= M88E1000_EPSCR_TX_CLK_25;
    ef66:	0f b7 55 f6          	movzwl -0xa(%rbp),%edx
	e1000_write_phy_reg(hw, M88E1000_EXT_PHY_SPEC_CTRL, phy_reg);
    ef6a:	48 89 df             	mov    %rbx,%rdi
    ef6d:	be 14 00 00 00       	mov    $0x14,%esi
	/* Because we reset the PHY above, we need to re-force TX_CLK in the
	 * Extended PHY Specific Control Register to 25MHz clock.  This
	 * value defaults back to a 2.5MHz clock when the PHY is reset.
	 */
	e1000_read_phy_reg(hw, M88E1000_EXT_PHY_SPEC_CTRL, &phy_reg);
	phy_reg |= M88E1000_EPSCR_TX_CLK_25;
    ef72:	83 ca 70             	or     $0x70,%edx
    ef75:	66 89 55 f6          	mov    %dx,-0xa(%rbp)
	e1000_write_phy_reg(hw, M88E1000_EXT_PHY_SPEC_CTRL, phy_reg);
    ef79:	0f b7 d2             	movzwl %dx,%edx
    ef7c:	e8 00 00 00 00       	callq  ef81 <e1000_phy_reset_clk_and_crs+0x41>

	/* In addition, because of the s/w reset above, we need to enable
	 * CRS on TX.  This must be set for both full and half duplex
	 * operation.
	 */
	e1000_read_phy_reg(hw, M88E1000_PHY_SPEC_CTRL, &phy_reg);
    ef81:	48 8d 55 f6          	lea    -0xa(%rbp),%rdx
    ef85:	48 89 df             	mov    %rbx,%rdi
    ef88:	be 10 00 00 00       	mov    $0x10,%esi
    ef8d:	e8 00 00 00 00       	callq  ef92 <e1000_phy_reset_clk_and_crs+0x52>
	phy_reg |= M88E1000_PSCR_ASSERT_CRS_ON_TX;
    ef92:	0f b7 55 f6          	movzwl -0xa(%rbp),%edx
	e1000_write_phy_reg(hw, M88E1000_PHY_SPEC_CTRL, phy_reg);
    ef96:	48 89 df             	mov    %rbx,%rdi
    ef99:	be 10 00 00 00       	mov    $0x10,%esi
	/* In addition, because of the s/w reset above, we need to enable
	 * CRS on TX.  This must be set for both full and half duplex
	 * operation.
	 */
	e1000_read_phy_reg(hw, M88E1000_PHY_SPEC_CTRL, &phy_reg);
	phy_reg |= M88E1000_PSCR_ASSERT_CRS_ON_TX;
    ef9e:	80 ce 08             	or     $0x8,%dh
    efa1:	66 89 55 f6          	mov    %dx,-0xa(%rbp)
	e1000_write_phy_reg(hw, M88E1000_PHY_SPEC_CTRL, phy_reg);
    efa5:	0f b7 d2             	movzwl %dx,%edx
    efa8:	e8 00 00 00 00       	callq  efad <e1000_phy_reset_clk_and_crs+0x6d>
}
    efad:	48 83 c4 08          	add    $0x8,%rsp
    efb1:	5b                   	pop    %rbx
    efb2:	5d                   	pop    %rbp
    efb3:	c3                   	retq   
    efb4:	66 66 66 2e 0f 1f 84 	data32 data32 nopw %cs:0x0(%rax,%rax,1)
    efbb:	00 00 00 00 00 

000000000000efc0 <e1000_get_regs>:
	return E1000_REGS_LEN * sizeof(u32);
}

static void e1000_get_regs(struct net_device *netdev, struct ethtool_regs *regs,
			   void *p)
{
    efc0:	e8 00 00 00 00       	callq  efc5 <e1000_get_regs+0x5>
    efc5:	55                   	push   %rbp
	struct e1000_adapter *adapter = netdev_priv(netdev);
	struct e1000_hw *hw = &adapter->hw;
	u32 *regs_buff = p;
	u16 phy_data;

	memset(p, 0, E1000_REGS_LEN * sizeof(u32));
    efc6:	41 b8 80 00 00 00    	mov    $0x80,%r8d
	return E1000_REGS_LEN * sizeof(u32);
}

static void e1000_get_regs(struct net_device *netdev, struct ethtool_regs *regs,
			   void *p)
{
    efcc:	48 89 e5             	mov    %rsp,%rbp
    efcf:	41 56                	push   %r14
    efd1:	41 55                	push   %r13
	struct e1000_adapter *adapter = netdev_priv(netdev);
	struct e1000_hw *hw = &adapter->hw;
    efd3:	4c 8d af 00 0c 00 00 	lea    0xc00(%rdi),%r13
	return E1000_REGS_LEN * sizeof(u32);
}

static void e1000_get_regs(struct net_device *netdev, struct ethtool_regs *regs,
			   void *p)
{
    efda:	41 54                	push   %r12
    efdc:	49 89 fc             	mov    %rdi,%r12
	struct e1000_adapter *adapter = netdev_priv(netdev);
	struct e1000_hw *hw = &adapter->hw;
	u32 *regs_buff = p;
	u16 phy_data;

	memset(p, 0, E1000_REGS_LEN * sizeof(u32));
    efdf:	48 89 d7             	mov    %rdx,%rdi
	return E1000_REGS_LEN * sizeof(u32);
}

static void e1000_get_regs(struct net_device *netdev, struct ethtool_regs *regs,
			   void *p)
{
    efe2:	53                   	push   %rbx
    efe3:	48 89 d3             	mov    %rdx,%rbx
    efe6:	48 83 ec 08          	sub    $0x8,%rsp
	struct e1000_adapter *adapter = netdev_priv(netdev);
	struct e1000_hw *hw = &adapter->hw;
	u32 *regs_buff = p;
	u16 phy_data;

	memset(p, 0, E1000_REGS_LEN * sizeof(u32));
    efea:	f6 c2 01             	test   $0x1,%dl
    efed:	0f 85 dd 03 00 00    	jne    f3d0 <e1000_get_regs+0x410>
    eff3:	40 f6 c7 02          	test   $0x2,%dil
    eff7:	0f 85 e7 03 00 00    	jne    f3e4 <e1000_get_regs+0x424>
    effd:	40 f6 c7 04          	test   $0x4,%dil
    f001:	0f 85 b6 03 00 00    	jne    f3bd <e1000_get_regs+0x3fd>
    f007:	44 89 c1             	mov    %r8d,%ecx
    f00a:	31 c0                	xor    %eax,%eax
    f00c:	c1 e9 03             	shr    $0x3,%ecx
    f00f:	41 f6 c0 04          	test   $0x4,%r8b
    f013:	f3 48 ab             	rep stos %rax,%es:(%rdi)
    f016:	74 0a                	je     f022 <e1000_get_regs+0x62>
    f018:	c7 07 00 00 00 00    	movl   $0x0,(%rdi)
    f01e:	48 83 c7 04          	add    $0x4,%rdi
    f022:	41 f6 c0 02          	test   $0x2,%r8b
    f026:	74 0a                	je     f032 <e1000_get_regs+0x72>
    f028:	31 d2                	xor    %edx,%edx
    f02a:	48 83 c7 02          	add    $0x2,%rdi
    f02e:	66 89 57 fe          	mov    %dx,-0x2(%rdi)
    f032:	41 83 e0 01          	and    $0x1,%r8d
    f036:	74 03                	je     f03b <e1000_get_regs+0x7b>
    f038:	c6 07 00             	movb   $0x0,(%rdi)

	regs->version = (1 << 24) | (hw->revision_id << 16) | hw->device_id;
    f03b:	41 0f b7 84 24 e6 0c 	movzwl 0xce6(%r12),%eax
    f042:	00 00 
    f044:	41 0f b6 94 24 ee 0c 	movzbl 0xcee(%r12),%edx
    f04b:	00 00 
    f04d:	0d 00 00 00 01       	or     $0x1000000,%eax
    f052:	c1 e2 10             	shl    $0x10,%edx
    f055:	09 d0                	or     %edx,%eax
    f057:	89 46 04             	mov    %eax,0x4(%rsi)

	regs_buff[0]  = er32(CTRL);
    f05a:	49 8b 84 24 00 0c 00 	mov    0xc00(%r12),%rax
    f061:	00 
    f062:	8b 00                	mov    (%rax),%eax
    f064:	89 03                	mov    %eax,(%rbx)
	regs_buff[1]  = er32(STATUS);
    f066:	49 8b 84 24 00 0c 00 	mov    0xc00(%r12),%rax
    f06d:	00 
    f06e:	8b 40 08             	mov    0x8(%rax),%eax
    f071:	89 43 04             	mov    %eax,0x4(%rbx)

	regs_buff[2]  = er32(RCTL);
    f074:	49 8b 84 24 00 0c 00 	mov    0xc00(%r12),%rax
    f07b:	00 
    f07c:	8b 80 00 01 00 00    	mov    0x100(%rax),%eax
    f082:	89 43 08             	mov    %eax,0x8(%rbx)
	regs_buff[3]  = er32(RDLEN);
    f085:	41 83 bc 24 18 0c 00 	cmpl   $0x3,0xc18(%r12)
    f08c:	00 03 
    f08e:	48 19 c0             	sbb    %rax,%rax
    f091:	48 25 10 d9 ff ff    	and    $0xffffffffffffd910,%rax
    f097:	48 05 08 28 00 00    	add    $0x2808,%rax
    f09d:	49 03 84 24 00 0c 00 	add    0xc00(%r12),%rax
    f0a4:	00 
    f0a5:	8b 00                	mov    (%rax),%eax
    f0a7:	89 43 0c             	mov    %eax,0xc(%rbx)
	regs_buff[4]  = er32(RDH);
    f0aa:	41 83 bc 24 18 0c 00 	cmpl   $0x3,0xc18(%r12)
    f0b1:	00 03 
    f0b3:	48 19 c0             	sbb    %rax,%rax
    f0b6:	48 25 10 d9 ff ff    	and    $0xffffffffffffd910,%rax
    f0bc:	48 05 10 28 00 00    	add    $0x2810,%rax
    f0c2:	49 03 84 24 00 0c 00 	add    0xc00(%r12),%rax
    f0c9:	00 
    f0ca:	8b 00                	mov    (%rax),%eax
    f0cc:	89 43 10             	mov    %eax,0x10(%rbx)
	regs_buff[5]  = er32(RDT);
    f0cf:	41 83 bc 24 18 0c 00 	cmpl   $0x3,0xc18(%r12)
    f0d6:	00 03 
    f0d8:	48 19 c0             	sbb    %rax,%rax
    f0db:	48 25 10 d9 ff ff    	and    $0xffffffffffffd910,%rax
    f0e1:	48 05 18 28 00 00    	add    $0x2818,%rax
    f0e7:	49 03 84 24 00 0c 00 	add    0xc00(%r12),%rax
    f0ee:	00 
    f0ef:	8b 00                	mov    (%rax),%eax
    f0f1:	89 43 14             	mov    %eax,0x14(%rbx)
	regs_buff[6]  = er32(RDTR);
    f0f4:	41 83 bc 24 18 0c 00 	cmpl   $0x3,0xc18(%r12)
    f0fb:	00 03 
    f0fd:	48 19 c0             	sbb    %rax,%rax
    f100:	48 25 e8 d8 ff ff    	and    $0xffffffffffffd8e8,%rax
    f106:	48 05 20 28 00 00    	add    $0x2820,%rax
    f10c:	49 03 84 24 00 0c 00 	add    0xc00(%r12),%rax
    f113:	00 
    f114:	8b 00                	mov    (%rax),%eax
    f116:	89 43 18             	mov    %eax,0x18(%rbx)

	regs_buff[7]  = er32(TCTL);
    f119:	49 8b 84 24 00 0c 00 	mov    0xc00(%r12),%rax
    f120:	00 
    f121:	8b 80 00 04 00 00    	mov    0x400(%rax),%eax
    f127:	89 43 1c             	mov    %eax,0x1c(%rbx)
	regs_buff[8]  = er32(TDLEN);
    f12a:	41 83 bc 24 18 0c 00 	cmpl   $0x3,0xc18(%r12)
    f131:	00 03 
    f133:	48 19 c0             	sbb    %rax,%rax
    f136:	48 25 20 cc ff ff    	and    $0xffffffffffffcc20,%rax
    f13c:	48 05 08 38 00 00    	add    $0x3808,%rax
    f142:	49 03 84 24 00 0c 00 	add    0xc00(%r12),%rax
    f149:	00 
    f14a:	8b 00                	mov    (%rax),%eax
    f14c:	89 43 20             	mov    %eax,0x20(%rbx)
	regs_buff[9]  = er32(TDH);
    f14f:	41 83 bc 24 18 0c 00 	cmpl   $0x3,0xc18(%r12)
    f156:	00 03 
    f158:	48 19 c0             	sbb    %rax,%rax
    f15b:	48 25 20 cc ff ff    	and    $0xffffffffffffcc20,%rax
    f161:	48 05 10 38 00 00    	add    $0x3810,%rax
    f167:	49 03 84 24 00 0c 00 	add    0xc00(%r12),%rax
    f16e:	00 
    f16f:	8b 00                	mov    (%rax),%eax
    f171:	89 43 24             	mov    %eax,0x24(%rbx)
	regs_buff[10] = er32(TDT);
    f174:	41 83 bc 24 18 0c 00 	cmpl   $0x3,0xc18(%r12)
    f17b:	00 03 
    f17d:	48 19 c0             	sbb    %rax,%rax
    f180:	48 25 20 cc ff ff    	and    $0xffffffffffffcc20,%rax
    f186:	48 05 18 38 00 00    	add    $0x3818,%rax
    f18c:	49 03 84 24 00 0c 00 	add    0xc00(%r12),%rax
    f193:	00 
    f194:	8b 00                	mov    (%rax),%eax
    f196:	89 43 28             	mov    %eax,0x28(%rbx)
	regs_buff[11] = er32(TIDV);
    f199:	41 83 bc 24 18 0c 00 	cmpl   $0x3,0xc18(%r12)
    f1a0:	00 03 
    f1a2:	48 19 c0             	sbb    %rax,%rax
    f1a5:	48 25 20 cc ff ff    	and    $0xffffffffffffcc20,%rax
    f1ab:	48 05 20 38 00 00    	add    $0x3820,%rax
    f1b1:	49 03 84 24 00 0c 00 	add    0xc00(%r12),%rax
    f1b8:	00 
    f1b9:	8b 00                	mov    (%rax),%eax
    f1bb:	89 43 2c             	mov    %eax,0x2c(%rbx)

	regs_buff[12] = hw->phy_type;  /* PHY type (IGP=1, M88=0) */
    f1be:	41 8b 84 24 1c 0c 00 	mov    0xc1c(%r12),%eax
    f1c5:	00 
    f1c6:	89 43 30             	mov    %eax,0x30(%rbx)
	if (hw->phy_type == e1000_phy_igp) {
    f1c9:	41 83 bc 24 1c 0c 00 	cmpl   $0x1,0xc1c(%r12)
    f1d0:	00 01 
    f1d2:	0f 84 bf 00 00 00    	je     f297 <e1000_get_regs+0x2d7>
		regs_buff[20] = 0; /* polarity correction enabled (always) */
		regs_buff[22] = 0; /* phy receive errors (unavailable) */
		regs_buff[23] = regs_buff[18]; /* mdix mode */
		e1000_write_phy_reg(hw, IGP01E1000_PHY_PAGE_SELECT, 0x0);
	} else {
		e1000_read_phy_reg(hw, M88E1000_PHY_SPEC_STATUS, &phy_data);
    f1d8:	4c 8d 75 de          	lea    -0x22(%rbp),%r14
    f1dc:	be 11 00 00 00       	mov    $0x11,%esi
    f1e1:	4c 89 ef             	mov    %r13,%rdi
    f1e4:	4c 89 f2             	mov    %r14,%rdx
    f1e7:	e8 00 00 00 00       	callq  f1ec <e1000_get_regs+0x22c>
		regs_buff[13] = (u32)phy_data; /* cable length */
    f1ec:	0f b7 45 de          	movzwl -0x22(%rbp),%eax
		regs_buff[14] = 0;  /* Dummy (to align w/ IGP phy reg dump) */
		regs_buff[15] = 0;  /* Dummy (to align w/ IGP phy reg dump) */
		regs_buff[16] = 0;  /* Dummy (to align w/ IGP phy reg dump) */
		e1000_read_phy_reg(hw, M88E1000_PHY_SPEC_CTRL, &phy_data);
    f1f0:	4c 89 f2             	mov    %r14,%rdx
		regs_buff[23] = regs_buff[18]; /* mdix mode */
		e1000_write_phy_reg(hw, IGP01E1000_PHY_PAGE_SELECT, 0x0);
	} else {
		e1000_read_phy_reg(hw, M88E1000_PHY_SPEC_STATUS, &phy_data);
		regs_buff[13] = (u32)phy_data; /* cable length */
		regs_buff[14] = 0;  /* Dummy (to align w/ IGP phy reg dump) */
    f1f3:	c7 43 38 00 00 00 00 	movl   $0x0,0x38(%rbx)
		regs_buff[15] = 0;  /* Dummy (to align w/ IGP phy reg dump) */
    f1fa:	c7 43 3c 00 00 00 00 	movl   $0x0,0x3c(%rbx)
		regs_buff[16] = 0;  /* Dummy (to align w/ IGP phy reg dump) */
    f201:	c7 43 40 00 00 00 00 	movl   $0x0,0x40(%rbx)
		e1000_read_phy_reg(hw, M88E1000_PHY_SPEC_CTRL, &phy_data);
    f208:	be 10 00 00 00       	mov    $0x10,%esi
    f20d:	4c 89 ef             	mov    %r13,%rdi
		regs_buff[22] = 0; /* phy receive errors (unavailable) */
		regs_buff[23] = regs_buff[18]; /* mdix mode */
		e1000_write_phy_reg(hw, IGP01E1000_PHY_PAGE_SELECT, 0x0);
	} else {
		e1000_read_phy_reg(hw, M88E1000_PHY_SPEC_STATUS, &phy_data);
		regs_buff[13] = (u32)phy_data; /* cable length */
    f210:	89 43 34             	mov    %eax,0x34(%rbx)
		regs_buff[14] = 0;  /* Dummy (to align w/ IGP phy reg dump) */
		regs_buff[15] = 0;  /* Dummy (to align w/ IGP phy reg dump) */
		regs_buff[16] = 0;  /* Dummy (to align w/ IGP phy reg dump) */
		e1000_read_phy_reg(hw, M88E1000_PHY_SPEC_CTRL, &phy_data);
    f213:	e8 00 00 00 00       	callq  f218 <e1000_get_regs+0x258>
		regs_buff[17] = (u32)phy_data; /* extended 10bt distance */
    f218:	0f b7 55 de          	movzwl -0x22(%rbp),%edx
		regs_buff[18] = regs_buff[13]; /* cable polarity */
    f21c:	8b 43 34             	mov    0x34(%rbx),%eax
		regs_buff[19] = 0;  /* Dummy (to align w/ IGP phy reg dump) */
    f21f:	c7 43 4c 00 00 00 00 	movl   $0x0,0x4c(%rbx)
		regs_buff[14] = 0;  /* Dummy (to align w/ IGP phy reg dump) */
		regs_buff[15] = 0;  /* Dummy (to align w/ IGP phy reg dump) */
		regs_buff[16] = 0;  /* Dummy (to align w/ IGP phy reg dump) */
		e1000_read_phy_reg(hw, M88E1000_PHY_SPEC_CTRL, &phy_data);
		regs_buff[17] = (u32)phy_data; /* extended 10bt distance */
		regs_buff[18] = regs_buff[13]; /* cable polarity */
    f226:	89 43 48             	mov    %eax,0x48(%rbx)
		regs_buff[13] = (u32)phy_data; /* cable length */
		regs_buff[14] = 0;  /* Dummy (to align w/ IGP phy reg dump) */
		regs_buff[15] = 0;  /* Dummy (to align w/ IGP phy reg dump) */
		regs_buff[16] = 0;  /* Dummy (to align w/ IGP phy reg dump) */
		e1000_read_phy_reg(hw, M88E1000_PHY_SPEC_CTRL, &phy_data);
		regs_buff[17] = (u32)phy_data; /* extended 10bt distance */
    f229:	89 53 44             	mov    %edx,0x44(%rbx)
		regs_buff[18] = regs_buff[13]; /* cable polarity */
		regs_buff[19] = 0;  /* Dummy (to align w/ IGP phy reg dump) */
		regs_buff[20] = regs_buff[17]; /* polarity correction */
    f22c:	89 53 50             	mov    %edx,0x50(%rbx)
		/* phy receive errors */
		regs_buff[22] = adapter->phy_stats.receive_errors;
    f22f:	41 8b 94 24 6c 0f 00 	mov    0xf6c(%r12),%edx
    f236:	00 
		regs_buff[23] = regs_buff[13]; /* mdix mode */
    f237:	89 43 5c             	mov    %eax,0x5c(%rbx)
		regs_buff[17] = (u32)phy_data; /* extended 10bt distance */
		regs_buff[18] = regs_buff[13]; /* cable polarity */
		regs_buff[19] = 0;  /* Dummy (to align w/ IGP phy reg dump) */
		regs_buff[20] = regs_buff[17]; /* polarity correction */
		/* phy receive errors */
		regs_buff[22] = adapter->phy_stats.receive_errors;
    f23a:	89 53 58             	mov    %edx,0x58(%rbx)
		regs_buff[23] = regs_buff[13]; /* mdix mode */
	}
	regs_buff[21] = adapter->phy_stats.idle_errors;  /* phy idle errors */
    f23d:	41 8b 84 24 68 0f 00 	mov    0xf68(%r12),%eax
    f244:	00 
	e1000_read_phy_reg(hw, PHY_1000T_STATUS, &phy_data);
    f245:	4c 89 f2             	mov    %r14,%rdx
    f248:	be 0a 00 00 00       	mov    $0xa,%esi
    f24d:	4c 89 ef             	mov    %r13,%rdi
		regs_buff[20] = regs_buff[17]; /* polarity correction */
		/* phy receive errors */
		regs_buff[22] = adapter->phy_stats.receive_errors;
		regs_buff[23] = regs_buff[13]; /* mdix mode */
	}
	regs_buff[21] = adapter->phy_stats.idle_errors;  /* phy idle errors */
    f250:	89 43 54             	mov    %eax,0x54(%rbx)
	e1000_read_phy_reg(hw, PHY_1000T_STATUS, &phy_data);
    f253:	e8 00 00 00 00       	callq  f258 <e1000_get_regs+0x298>
	regs_buff[24] = (u32)phy_data;  /* phy local receiver status */
    f258:	0f b7 45 de          	movzwl -0x22(%rbp),%eax
    f25c:	89 43 60             	mov    %eax,0x60(%rbx)
	regs_buff[25] = regs_buff[24];  /* phy remote receiver status */
    f25f:	89 43 64             	mov    %eax,0x64(%rbx)
	if (hw->mac_type >= e1000_82540 &&
    f262:	41 83 bc 24 18 0c 00 	cmpl   $0x4,0xc18(%r12)
    f269:	00 04 
    f26b:	76 1d                	jbe    f28a <e1000_get_regs+0x2ca>
    f26d:	41 8b 84 24 24 0c 00 	mov    0xc24(%r12),%eax
    f274:	00 
    f275:	85 c0                	test   %eax,%eax
    f277:	75 11                	jne    f28a <e1000_get_regs+0x2ca>
	    hw->media_type == e1000_media_type_copper) {
		regs_buff[26] = er32(MANC);
    f279:	49 8b 84 24 00 0c 00 	mov    0xc00(%r12),%rax
    f280:	00 
    f281:	8b 80 20 58 00 00    	mov    0x5820(%rax),%eax
    f287:	89 43 68             	mov    %eax,0x68(%rbx)
	}
}
    f28a:	48 83 c4 08          	add    $0x8,%rsp
    f28e:	5b                   	pop    %rbx
    f28f:	41 5c                	pop    %r12
    f291:	41 5d                	pop    %r13
    f293:	41 5e                	pop    %r14
    f295:	5d                   	pop    %rbp
    f296:	c3                   	retq   

	regs_buff[12] = hw->phy_type;  /* PHY type (IGP=1, M88=0) */
	if (hw->phy_type == e1000_phy_igp) {
		e1000_write_phy_reg(hw, IGP01E1000_PHY_PAGE_SELECT,
				    IGP01E1000_PHY_AGC_A);
		e1000_read_phy_reg(hw, IGP01E1000_PHY_AGC_A &
    f297:	4c 8d 75 de          	lea    -0x22(%rbp),%r14
	regs_buff[10] = er32(TDT);
	regs_buff[11] = er32(TIDV);

	regs_buff[12] = hw->phy_type;  /* PHY type (IGP=1, M88=0) */
	if (hw->phy_type == e1000_phy_igp) {
		e1000_write_phy_reg(hw, IGP01E1000_PHY_PAGE_SELECT,
    f29b:	4c 89 ef             	mov    %r13,%rdi
    f29e:	ba 72 11 00 00       	mov    $0x1172,%edx
    f2a3:	be 1f 00 00 00       	mov    $0x1f,%esi
    f2a8:	e8 00 00 00 00       	callq  f2ad <e1000_get_regs+0x2ed>
				    IGP01E1000_PHY_AGC_A);
		e1000_read_phy_reg(hw, IGP01E1000_PHY_AGC_A &
    f2ad:	4c 89 f2             	mov    %r14,%rdx
    f2b0:	4c 89 ef             	mov    %r13,%rdi
    f2b3:	be 12 00 00 00       	mov    $0x12,%esi
    f2b8:	e8 00 00 00 00       	callq  f2bd <e1000_get_regs+0x2fd>
				   IGP01E1000_PHY_PAGE_SELECT, &phy_data);
		regs_buff[13] = (u32)phy_data; /* cable length */
    f2bd:	0f b7 45 de          	movzwl -0x22(%rbp),%eax
		e1000_write_phy_reg(hw, IGP01E1000_PHY_PAGE_SELECT,
    f2c1:	4c 89 ef             	mov    %r13,%rdi
    f2c4:	ba 72 12 00 00       	mov    $0x1272,%edx
    f2c9:	be 1f 00 00 00       	mov    $0x1f,%esi
	if (hw->phy_type == e1000_phy_igp) {
		e1000_write_phy_reg(hw, IGP01E1000_PHY_PAGE_SELECT,
				    IGP01E1000_PHY_AGC_A);
		e1000_read_phy_reg(hw, IGP01E1000_PHY_AGC_A &
				   IGP01E1000_PHY_PAGE_SELECT, &phy_data);
		regs_buff[13] = (u32)phy_data; /* cable length */
    f2ce:	89 43 34             	mov    %eax,0x34(%rbx)
		e1000_write_phy_reg(hw, IGP01E1000_PHY_PAGE_SELECT,
    f2d1:	e8 00 00 00 00       	callq  f2d6 <e1000_get_regs+0x316>
				    IGP01E1000_PHY_AGC_B);
		e1000_read_phy_reg(hw, IGP01E1000_PHY_AGC_B &
    f2d6:	4c 89 f2             	mov    %r14,%rdx
    f2d9:	4c 89 ef             	mov    %r13,%rdi
    f2dc:	be 12 00 00 00       	mov    $0x12,%esi
    f2e1:	e8 00 00 00 00       	callq  f2e6 <e1000_get_regs+0x326>
				   IGP01E1000_PHY_PAGE_SELECT, &phy_data);
		regs_buff[14] = (u32)phy_data; /* cable length */
    f2e6:	0f b7 45 de          	movzwl -0x22(%rbp),%eax
		e1000_write_phy_reg(hw, IGP01E1000_PHY_PAGE_SELECT,
    f2ea:	4c 89 ef             	mov    %r13,%rdi
    f2ed:	ba 72 14 00 00       	mov    $0x1472,%edx
    f2f2:	be 1f 00 00 00       	mov    $0x1f,%esi
		regs_buff[13] = (u32)phy_data; /* cable length */
		e1000_write_phy_reg(hw, IGP01E1000_PHY_PAGE_SELECT,
				    IGP01E1000_PHY_AGC_B);
		e1000_read_phy_reg(hw, IGP01E1000_PHY_AGC_B &
				   IGP01E1000_PHY_PAGE_SELECT, &phy_data);
		regs_buff[14] = (u32)phy_data; /* cable length */
    f2f7:	89 43 38             	mov    %eax,0x38(%rbx)
		e1000_write_phy_reg(hw, IGP01E1000_PHY_PAGE_SELECT,
    f2fa:	e8 00 00 00 00       	callq  f2ff <e1000_get_regs+0x33f>
				    IGP01E1000_PHY_AGC_C);
		e1000_read_phy_reg(hw, IGP01E1000_PHY_AGC_C &
    f2ff:	4c 89 f2             	mov    %r14,%rdx
    f302:	4c 89 ef             	mov    %r13,%rdi
    f305:	be 12 00 00 00       	mov    $0x12,%esi
    f30a:	e8 00 00 00 00       	callq  f30f <e1000_get_regs+0x34f>
				   IGP01E1000_PHY_PAGE_SELECT, &phy_data);
		regs_buff[15] = (u32)phy_data; /* cable length */
    f30f:	0f b7 45 de          	movzwl -0x22(%rbp),%eax
		e1000_write_phy_reg(hw, IGP01E1000_PHY_PAGE_SELECT,
    f313:	4c 89 ef             	mov    %r13,%rdi
    f316:	ba 72 18 00 00       	mov    $0x1872,%edx
    f31b:	be 1f 00 00 00       	mov    $0x1f,%esi
		regs_buff[14] = (u32)phy_data; /* cable length */
		e1000_write_phy_reg(hw, IGP01E1000_PHY_PAGE_SELECT,
				    IGP01E1000_PHY_AGC_C);
		e1000_read_phy_reg(hw, IGP01E1000_PHY_AGC_C &
				   IGP01E1000_PHY_PAGE_SELECT, &phy_data);
		regs_buff[15] = (u32)phy_data; /* cable length */
    f320:	89 43 3c             	mov    %eax,0x3c(%rbx)
		e1000_write_phy_reg(hw, IGP01E1000_PHY_PAGE_SELECT,
    f323:	e8 00 00 00 00       	callq  f328 <e1000_get_regs+0x368>
				    IGP01E1000_PHY_AGC_D);
		e1000_read_phy_reg(hw, IGP01E1000_PHY_AGC_D &
    f328:	4c 89 f2             	mov    %r14,%rdx
    f32b:	4c 89 ef             	mov    %r13,%rdi
    f32e:	be 12 00 00 00       	mov    $0x12,%esi
    f333:	e8 00 00 00 00       	callq  f338 <e1000_get_regs+0x378>
				   IGP01E1000_PHY_PAGE_SELECT, &phy_data);
		regs_buff[16] = (u32)phy_data; /* cable length */
    f338:	0f b7 45 de          	movzwl -0x22(%rbp),%eax
		regs_buff[17] = 0; /* extended 10bt distance (not needed) */
		e1000_write_phy_reg(hw, IGP01E1000_PHY_PAGE_SELECT, 0x0);
    f33c:	31 d2                	xor    %edx,%edx
    f33e:	4c 89 ef             	mov    %r13,%rdi
		e1000_write_phy_reg(hw, IGP01E1000_PHY_PAGE_SELECT,
				    IGP01E1000_PHY_AGC_D);
		e1000_read_phy_reg(hw, IGP01E1000_PHY_AGC_D &
				   IGP01E1000_PHY_PAGE_SELECT, &phy_data);
		regs_buff[16] = (u32)phy_data; /* cable length */
		regs_buff[17] = 0; /* extended 10bt distance (not needed) */
    f341:	c7 43 44 00 00 00 00 	movl   $0x0,0x44(%rbx)
		e1000_write_phy_reg(hw, IGP01E1000_PHY_PAGE_SELECT, 0x0);
    f348:	be 1f 00 00 00       	mov    $0x1f,%esi
		regs_buff[15] = (u32)phy_data; /* cable length */
		e1000_write_phy_reg(hw, IGP01E1000_PHY_PAGE_SELECT,
				    IGP01E1000_PHY_AGC_D);
		e1000_read_phy_reg(hw, IGP01E1000_PHY_AGC_D &
				   IGP01E1000_PHY_PAGE_SELECT, &phy_data);
		regs_buff[16] = (u32)phy_data; /* cable length */
    f34d:	89 43 40             	mov    %eax,0x40(%rbx)
		regs_buff[17] = 0; /* extended 10bt distance (not needed) */
		e1000_write_phy_reg(hw, IGP01E1000_PHY_PAGE_SELECT, 0x0);
    f350:	e8 00 00 00 00       	callq  f355 <e1000_get_regs+0x395>
		e1000_read_phy_reg(hw, IGP01E1000_PHY_PORT_STATUS &
    f355:	4c 89 f2             	mov    %r14,%rdx
    f358:	4c 89 ef             	mov    %r13,%rdi
    f35b:	be 11 00 00 00       	mov    $0x11,%esi
    f360:	e8 00 00 00 00       	callq  f365 <e1000_get_regs+0x3a5>
				   IGP01E1000_PHY_PAGE_SELECT, &phy_data);
		regs_buff[18] = (u32)phy_data; /* cable polarity */
    f365:	0f b7 45 de          	movzwl -0x22(%rbp),%eax
		e1000_write_phy_reg(hw, IGP01E1000_PHY_PAGE_SELECT,
    f369:	4c 89 ef             	mov    %r13,%rdi
    f36c:	ba b4 00 00 00       	mov    $0xb4,%edx
    f371:	be 1f 00 00 00       	mov    $0x1f,%esi
		regs_buff[16] = (u32)phy_data; /* cable length */
		regs_buff[17] = 0; /* extended 10bt distance (not needed) */
		e1000_write_phy_reg(hw, IGP01E1000_PHY_PAGE_SELECT, 0x0);
		e1000_read_phy_reg(hw, IGP01E1000_PHY_PORT_STATUS &
				   IGP01E1000_PHY_PAGE_SELECT, &phy_data);
		regs_buff[18] = (u32)phy_data; /* cable polarity */
    f376:	89 43 48             	mov    %eax,0x48(%rbx)
		e1000_write_phy_reg(hw, IGP01E1000_PHY_PAGE_SELECT,
    f379:	e8 00 00 00 00       	callq  f37e <e1000_get_regs+0x3be>
				    IGP01E1000_PHY_PCS_INIT_REG);
		e1000_read_phy_reg(hw, IGP01E1000_PHY_PCS_INIT_REG &
    f37e:	4c 89 f2             	mov    %r14,%rdx
    f381:	4c 89 ef             	mov    %r13,%rdi
    f384:	be 14 00 00 00       	mov    $0x14,%esi
    f389:	e8 00 00 00 00       	callq  f38e <e1000_get_regs+0x3ce>
				   IGP01E1000_PHY_PAGE_SELECT, &phy_data);
		regs_buff[19] = (u32)phy_data; /* cable polarity */
    f38e:	0f b7 45 de          	movzwl -0x22(%rbp),%eax
		regs_buff[20] = 0; /* polarity correction enabled (always) */
    f392:	c7 43 50 00 00 00 00 	movl   $0x0,0x50(%rbx)
		regs_buff[22] = 0; /* phy receive errors (unavailable) */
		regs_buff[23] = regs_buff[18]; /* mdix mode */
		e1000_write_phy_reg(hw, IGP01E1000_PHY_PAGE_SELECT, 0x0);
    f399:	31 d2                	xor    %edx,%edx
				    IGP01E1000_PHY_PCS_INIT_REG);
		e1000_read_phy_reg(hw, IGP01E1000_PHY_PCS_INIT_REG &
				   IGP01E1000_PHY_PAGE_SELECT, &phy_data);
		regs_buff[19] = (u32)phy_data; /* cable polarity */
		regs_buff[20] = 0; /* polarity correction enabled (always) */
		regs_buff[22] = 0; /* phy receive errors (unavailable) */
    f39b:	c7 43 58 00 00 00 00 	movl   $0x0,0x58(%rbx)
		regs_buff[23] = regs_buff[18]; /* mdix mode */
		e1000_write_phy_reg(hw, IGP01E1000_PHY_PAGE_SELECT, 0x0);
    f3a2:	be 1f 00 00 00       	mov    $0x1f,%esi
    f3a7:	4c 89 ef             	mov    %r13,%rdi
		regs_buff[18] = (u32)phy_data; /* cable polarity */
		e1000_write_phy_reg(hw, IGP01E1000_PHY_PAGE_SELECT,
				    IGP01E1000_PHY_PCS_INIT_REG);
		e1000_read_phy_reg(hw, IGP01E1000_PHY_PCS_INIT_REG &
				   IGP01E1000_PHY_PAGE_SELECT, &phy_data);
		regs_buff[19] = (u32)phy_data; /* cable polarity */
    f3aa:	89 43 4c             	mov    %eax,0x4c(%rbx)
		regs_buff[20] = 0; /* polarity correction enabled (always) */
		regs_buff[22] = 0; /* phy receive errors (unavailable) */
		regs_buff[23] = regs_buff[18]; /* mdix mode */
    f3ad:	8b 43 48             	mov    0x48(%rbx),%eax
    f3b0:	89 43 5c             	mov    %eax,0x5c(%rbx)
		e1000_write_phy_reg(hw, IGP01E1000_PHY_PAGE_SELECT, 0x0);
    f3b3:	e8 00 00 00 00       	callq  f3b8 <e1000_get_regs+0x3f8>
    f3b8:	e9 80 fe ff ff       	jmpq   f23d <e1000_get_regs+0x27d>
	struct e1000_adapter *adapter = netdev_priv(netdev);
	struct e1000_hw *hw = &adapter->hw;
	u32 *regs_buff = p;
	u16 phy_data;

	memset(p, 0, E1000_REGS_LEN * sizeof(u32));
    f3bd:	c7 07 00 00 00 00    	movl   $0x0,(%rdi)
    f3c3:	41 83 e8 04          	sub    $0x4,%r8d
    f3c7:	48 83 c7 04          	add    $0x4,%rdi
    f3cb:	e9 37 fc ff ff       	jmpq   f007 <e1000_get_regs+0x47>
    f3d0:	48 8d 7a 01          	lea    0x1(%rdx),%rdi
    f3d4:	c6 02 00             	movb   $0x0,(%rdx)
    f3d7:	41 b0 7f             	mov    $0x7f,%r8b
    f3da:	40 f6 c7 02          	test   $0x2,%dil
    f3de:	0f 84 19 fc ff ff    	je     effd <e1000_get_regs+0x3d>
    f3e4:	31 c9                	xor    %ecx,%ecx
    f3e6:	48 83 c7 02          	add    $0x2,%rdi
    f3ea:	41 83 e8 02          	sub    $0x2,%r8d
    f3ee:	66 89 4f fe          	mov    %cx,-0x2(%rdi)
    f3f2:	e9 06 fc ff ff       	jmpq   effd <e1000_get_regs+0x3d>
    f3f7:	66 0f 1f 84 00 00 00 	nopw   0x0(%rax,%rax,1)
    f3fe:	00 00 

000000000000f400 <e1000_link_test>:
out:
	return *data;
}

static int e1000_link_test(struct e1000_adapter *adapter, u64 *data)
{
    f400:	e8 00 00 00 00       	callq  f405 <e1000_link_test+0x5>
    f405:	55                   	push   %rbp
	struct e1000_hw *hw = &adapter->hw;
	*data = 0;
    f406:	48 c7 06 00 00 00 00 	movq   $0x0,(%rsi)
out:
	return *data;
}

static int e1000_link_test(struct e1000_adapter *adapter, u64 *data)
{
    f40d:	48 89 e5             	mov    %rsp,%rbp
    f410:	41 56                	push   %r14
    f412:	49 89 f6             	mov    %rsi,%r14
    f415:	41 55                	push   %r13
	struct e1000_hw *hw = &adapter->hw;
    f417:	4c 8d af c0 03 00 00 	lea    0x3c0(%rdi),%r13
out:
	return *data;
}

static int e1000_link_test(struct e1000_adapter *adapter, u64 *data)
{
    f41e:	41 54                	push   %r12
    f420:	49 89 fc             	mov    %rdi,%r12
    f423:	53                   	push   %rbx
	struct e1000_hw *hw = &adapter->hw;
	*data = 0;
	if (hw->media_type == e1000_media_type_internal_serdes) {
    f424:	83 bf e4 03 00 00 02 	cmpl   $0x2,0x3e4(%rdi)
    f42b:	74 43                	je     f470 <e1000_link_test+0x70>
			msleep(20);
		} while (i++ < 3750);

		*data = 1;
	} else {
		e1000_check_for_link(hw);
    f42d:	4c 89 ef             	mov    %r13,%rdi
    f430:	e8 00 00 00 00       	callq  f435 <e1000_link_test+0x35>
		if (hw->autoneg)  /* if auto_neg is set wait for it */
    f435:	41 80 bc 24 af 04 00 	cmpb   $0x0,0x4af(%r12)
    f43c:	00 00 
    f43e:	75 62                	jne    f4a2 <e1000_link_test+0xa2>
			msleep(4000);

		if (!(er32(STATUS) & E1000_STATUS_LU))
    f440:	49 8b 84 24 c0 03 00 	mov    0x3c0(%r12),%rax
    f447:	00 
    f448:	8b 40 08             	mov    0x8(%rax),%eax
    f44b:	a8 02                	test   $0x2,%al
    f44d:	74 0c                	je     f45b <e1000_link_test+0x5b>
			*data = 1;
	}
	return *data;
}
    f44f:	5b                   	pop    %rbx
    f450:	41 5c                	pop    %r12
    f452:	41 5d                	pop    %r13
    f454:	41 8b 06             	mov    (%r14),%eax
    f457:	41 5e                	pop    %r14
    f459:	5d                   	pop    %rbp
    f45a:	c3                   	retq   
    f45b:	5b                   	pop    %rbx
    f45c:	41 5c                	pop    %r12
    f45e:	41 5d                	pop    %r13
			if (hw->serdes_has_link)
				return *data;
			msleep(20);
		} while (i++ < 3750);

		*data = 1;
    f460:	49 c7 06 01 00 00 00 	movq   $0x1,(%r14)
    f467:	b8 01 00 00 00       	mov    $0x1,%eax

		if (!(er32(STATUS) & E1000_STATUS_LU))
			*data = 1;
	}
	return *data;
}
    f46c:	41 5e                	pop    %r14
    f46e:	5d                   	pop    %rbp
    f46f:	c3                   	retq   
	struct e1000_hw *hw = &adapter->hw;
	*data = 0;
	if (hw->media_type == e1000_media_type_internal_serdes) {
		int i = 0;

		hw->serdes_has_link = false;
    f470:	c6 87 cd 04 00 00 00 	movb   $0x0,0x4cd(%rdi)
    f477:	bb a7 0e 00 00       	mov    $0xea7,%ebx
    f47c:	eb 0f                	jmp    f48d <e1000_link_test+0x8d>
		 */
		do {
			e1000_check_for_link(hw);
			if (hw->serdes_has_link)
				return *data;
			msleep(20);
    f47e:	bf 14 00 00 00       	mov    $0x14,%edi
    f483:	e8 00 00 00 00       	callq  f488 <e1000_link_test+0x88>
		} while (i++ < 3750);
    f488:	83 eb 01             	sub    $0x1,%ebx
    f48b:	74 ce                	je     f45b <e1000_link_test+0x5b>

		/* On some blade server designs, link establishment
		 * could take as long as 2-3 minutes
		 */
		do {
			e1000_check_for_link(hw);
    f48d:	4c 89 ef             	mov    %r13,%rdi
    f490:	e8 00 00 00 00       	callq  f495 <e1000_link_test+0x95>
			if (hw->serdes_has_link)
    f495:	41 80 bc 24 cd 04 00 	cmpb   $0x0,0x4cd(%r12)
    f49c:	00 00 
    f49e:	74 de                	je     f47e <e1000_link_test+0x7e>
    f4a0:	eb ad                	jmp    f44f <e1000_link_test+0x4f>

		*data = 1;
	} else {
		e1000_check_for_link(hw);
		if (hw->autoneg)  /* if auto_neg is set wait for it */
			msleep(4000);
    f4a2:	bf a0 0f 00 00       	mov    $0xfa0,%edi
    f4a7:	e8 00 00 00 00       	callq  f4ac <e1000_link_test+0xac>
    f4ac:	eb 92                	jmp    f440 <e1000_link_test+0x40>
    f4ae:	66 90                	xchg   %ax,%ax

000000000000f4b0 <e1000_set_pauseparam>:
	}
}

static int e1000_set_pauseparam(struct net_device *netdev,
				struct ethtool_pauseparam *pause)
{
    f4b0:	e8 00 00 00 00       	callq  f4b5 <e1000_set_pauseparam+0x5>
    f4b5:	55                   	push   %rbp
    f4b6:	48 89 e5             	mov    %rsp,%rbp
    f4b9:	41 55                	push   %r13
    f4bb:	4c 8d af e8 0f 00 00 	lea    0xfe8(%rdi),%r13
    f4c2:	41 54                	push   %r12
    f4c4:	49 89 f4             	mov    %rsi,%r12
    f4c7:	53                   	push   %rbx
	struct e1000_adapter *adapter = netdev_priv(netdev);
	struct e1000_hw *hw = &adapter->hw;
	int retval = 0;

	adapter->fc_autoneg = pause->autoneg;
    f4c8:	8b 46 04             	mov    0x4(%rsi),%eax
	}
}

static int e1000_set_pauseparam(struct net_device *netdev,
				struct ethtool_pauseparam *pause)
{
    f4cb:	48 89 fb             	mov    %rdi,%rbx
	struct e1000_adapter *adapter = netdev_priv(netdev);
	struct e1000_hw *hw = &adapter->hw;
	int retval = 0;

	adapter->fc_autoneg = pause->autoneg;
    f4ce:	88 87 7c 0a 00 00    	mov    %al,0xa7c(%rdi)
 * This operation is atomic and cannot be reordered.
 * It also implies a memory barrier.
 */
static inline int test_and_set_bit(long nr, volatile unsigned long *addr)
{
	GEN_BINARY_RMWcc(LOCK_PREFIX "bts", *addr, "Ir", nr, "%0", "c");
    f4d4:	f0 41 0f ba 6d 00 01 	lock btsl $0x1,0x0(%r13)
    f4db:	72 5c                	jb     f539 <e1000_set_pauseparam+0x89>

	while (test_and_set_bit(__E1000_RESETTING, &adapter->flags))
		msleep(1);

	if (pause->rx_pause && pause->tx_pause)
    f4dd:	41 8b 4c 24 08       	mov    0x8(%r12),%ecx
    f4e2:	85 c9                	test   %ecx,%ecx
    f4e4:	74 5f                	je     f545 <e1000_set_pauseparam+0x95>
    f4e6:	41 8b 54 24 0c       	mov    0xc(%r12),%edx
    f4eb:	85 d2                	test   %edx,%edx
    f4ed:	0f 85 a3 00 00 00    	jne    f596 <e1000_set_pauseparam+0xe6>
		hw->fc = E1000_FC_FULL;
	else if (pause->rx_pause && !pause->tx_pause)
		hw->fc = E1000_FC_RX_PAUSE;
    f4f3:	c7 83 40 0c 00 00 01 	movl   $0x1,0xc40(%rbx)
    f4fa:	00 00 00 
    f4fd:	b8 01 00 00 00       	mov    $0x1,%eax
	else if (!pause->rx_pause && !pause->tx_pause)
		hw->fc = E1000_FC_NONE;

	hw->original_fc = hw->fc;

	if (adapter->fc_autoneg == AUTONEG_ENABLE) {
    f502:	80 bb 7c 0a 00 00 01 	cmpb   $0x1,0xa7c(%rbx)
	else if (!pause->rx_pause && pause->tx_pause)
		hw->fc = E1000_FC_TX_PAUSE;
	else if (!pause->rx_pause && !pause->tx_pause)
		hw->fc = E1000_FC_NONE;

	hw->original_fc = hw->fc;
    f509:	89 83 8c 0c 00 00    	mov    %eax,0xc8c(%rbx)

	if (adapter->fc_autoneg == AUTONEG_ENABLE) {
    f50f:	74 5b                	je     f56c <e1000_set_pauseparam+0xbc>
		} else {
			e1000_reset(adapter);
		}
	} else
		retval = ((hw->media_type == e1000_media_type_fiber) ?
			  e1000_setup_link(hw) : e1000_force_mac_fc(hw));
    f511:	83 bb 24 0c 00 00 01 	cmpl   $0x1,0xc24(%rbx)

static int e1000_set_pauseparam(struct net_device *netdev,
				struct ethtool_pauseparam *pause)
{
	struct e1000_adapter *adapter = netdev_priv(netdev);
	struct e1000_hw *hw = &adapter->hw;
    f518:	48 8d bb 00 0c 00 00 	lea    0xc00(%rbx),%rdi
		} else {
			e1000_reset(adapter);
		}
	} else
		retval = ((hw->media_type == e1000_media_type_fiber) ?
			  e1000_setup_link(hw) : e1000_force_mac_fc(hw));
    f51f:	0f 84 96 00 00 00    	je     f5bb <e1000_set_pauseparam+0x10b>
    f525:	e8 00 00 00 00       	callq  f52a <e1000_set_pauseparam+0x7a>
 */
static __always_inline void
clear_bit(long nr, volatile unsigned long *addr)
{
	if (IS_IMMEDIATE(nr)) {
		asm volatile(LOCK_PREFIX "andb %1,%0"
    f52a:	f0 80 a3 e8 0f 00 00 	lock andb $0xfd,0xfe8(%rbx)
    f531:	fd 

	clear_bit(__E1000_RESETTING, &adapter->flags);
	return retval;
}
    f532:	5b                   	pop    %rbx
    f533:	41 5c                	pop    %r12
    f535:	41 5d                	pop    %r13
    f537:	5d                   	pop    %rbp
    f538:	c3                   	retq   
	int retval = 0;

	adapter->fc_autoneg = pause->autoneg;

	while (test_and_set_bit(__E1000_RESETTING, &adapter->flags))
		msleep(1);
    f539:	bf 01 00 00 00       	mov    $0x1,%edi
    f53e:	e8 00 00 00 00       	callq  f543 <e1000_set_pauseparam+0x93>
    f543:	eb 8f                	jmp    f4d4 <e1000_set_pauseparam+0x24>

	if (pause->rx_pause && pause->tx_pause)
		hw->fc = E1000_FC_FULL;
	else if (pause->rx_pause && !pause->tx_pause)
		hw->fc = E1000_FC_RX_PAUSE;
	else if (!pause->rx_pause && pause->tx_pause)
    f545:	41 8b 44 24 0c       	mov    0xc(%r12),%eax
    f54a:	85 c0                	test   %eax,%eax
    f54c:	74 5c                	je     f5aa <e1000_set_pauseparam+0xfa>
	else if (!pause->rx_pause && !pause->tx_pause)
		hw->fc = E1000_FC_NONE;

	hw->original_fc = hw->fc;

	if (adapter->fc_autoneg == AUTONEG_ENABLE) {
    f54e:	80 bb 7c 0a 00 00 01 	cmpb   $0x1,0xa7c(%rbx)
	if (pause->rx_pause && pause->tx_pause)
		hw->fc = E1000_FC_FULL;
	else if (pause->rx_pause && !pause->tx_pause)
		hw->fc = E1000_FC_RX_PAUSE;
	else if (!pause->rx_pause && pause->tx_pause)
		hw->fc = E1000_FC_TX_PAUSE;
    f555:	b8 02 00 00 00       	mov    $0x2,%eax
    f55a:	c7 83 40 0c 00 00 02 	movl   $0x2,0xc40(%rbx)
    f561:	00 00 00 
	else if (!pause->rx_pause && !pause->tx_pause)
		hw->fc = E1000_FC_NONE;

	hw->original_fc = hw->fc;
    f564:	89 83 8c 0c 00 00    	mov    %eax,0xc8c(%rbx)

	if (adapter->fc_autoneg == AUTONEG_ENABLE) {
    f56a:	75 a5                	jne    f511 <e1000_set_pauseparam+0x61>
		if (netif_running(adapter->netdev)) {
    f56c:	48 8b 83 f0 0b 00 00 	mov    0xbf0(%rbx),%rax
}

static int e1000_set_pauseparam(struct net_device *netdev,
				struct ethtool_pauseparam *pause)
{
	struct e1000_adapter *adapter = netdev_priv(netdev);
    f573:	4c 8d a3 40 08 00 00 	lea    0x840(%rbx),%r12

	hw->original_fc = hw->fc;

	if (adapter->fc_autoneg == AUTONEG_ENABLE) {
		if (netif_running(adapter->netdev)) {
			e1000_down(adapter);
    f57a:	4c 89 e7             	mov    %r12,%rdi
}

static __always_inline int constant_test_bit(long nr, const volatile unsigned long *addr)
{
	return ((1UL << (nr & (BITS_PER_LONG-1))) &
		(addr[nr >> _BITOPS_LONG_SHIFT])) != 0;
    f57d:	48 8b 40 48          	mov    0x48(%rax),%rax
		hw->fc = E1000_FC_NONE;

	hw->original_fc = hw->fc;

	if (adapter->fc_autoneg == AUTONEG_ENABLE) {
		if (netif_running(adapter->netdev)) {
    f581:	a8 01                	test   $0x1,%al
    f583:	74 40                	je     f5c5 <e1000_set_pauseparam+0x115>
			e1000_down(adapter);
    f585:	e8 00 00 00 00       	callq  f58a <e1000_set_pauseparam+0xda>
			e1000_up(adapter);
    f58a:	4c 89 e7             	mov    %r12,%rdi
    f58d:	e8 00 00 00 00       	callq  f592 <e1000_set_pauseparam+0xe2>
static int e1000_set_pauseparam(struct net_device *netdev,
				struct ethtool_pauseparam *pause)
{
	struct e1000_adapter *adapter = netdev_priv(netdev);
	struct e1000_hw *hw = &adapter->hw;
	int retval = 0;
    f592:	31 c0                	xor    %eax,%eax
    f594:	eb 94                	jmp    f52a <e1000_set_pauseparam+0x7a>

	while (test_and_set_bit(__E1000_RESETTING, &adapter->flags))
		msleep(1);

	if (pause->rx_pause && pause->tx_pause)
		hw->fc = E1000_FC_FULL;
    f596:	c7 83 40 0c 00 00 03 	movl   $0x3,0xc40(%rbx)
    f59d:	00 00 00 
    f5a0:	b8 03 00 00 00       	mov    $0x3,%eax
    f5a5:	e9 58 ff ff ff       	jmpq   f502 <e1000_set_pauseparam+0x52>
	else if (pause->rx_pause && !pause->tx_pause)
		hw->fc = E1000_FC_RX_PAUSE;
	else if (!pause->rx_pause && pause->tx_pause)
		hw->fc = E1000_FC_TX_PAUSE;
	else if (!pause->rx_pause && !pause->tx_pause)
		hw->fc = E1000_FC_NONE;
    f5aa:	c7 83 40 0c 00 00 00 	movl   $0x0,0xc40(%rbx)
    f5b1:	00 00 00 
    f5b4:	31 c0                	xor    %eax,%eax
    f5b6:	e9 47 ff ff ff       	jmpq   f502 <e1000_set_pauseparam+0x52>
		} else {
			e1000_reset(adapter);
		}
	} else
		retval = ((hw->media_type == e1000_media_type_fiber) ?
			  e1000_setup_link(hw) : e1000_force_mac_fc(hw));
    f5bb:	e8 00 00 00 00       	callq  f5c0 <e1000_set_pauseparam+0x110>
    f5c0:	e9 65 ff ff ff       	jmpq   f52a <e1000_set_pauseparam+0x7a>
	if (adapter->fc_autoneg == AUTONEG_ENABLE) {
		if (netif_running(adapter->netdev)) {
			e1000_down(adapter);
			e1000_up(adapter);
		} else {
			e1000_reset(adapter);
    f5c5:	e8 00 00 00 00       	callq  f5ca <e1000_set_pauseparam+0x11a>
static int e1000_set_pauseparam(struct net_device *netdev,
				struct ethtool_pauseparam *pause)
{
	struct e1000_adapter *adapter = netdev_priv(netdev);
	struct e1000_hw *hw = &adapter->hw;
	int retval = 0;
    f5ca:	31 c0                	xor    %eax,%eax
    f5cc:	0f 1f 40 00          	nopl   0x0(%rax)
    f5d0:	e9 55 ff ff ff       	jmpq   f52a <e1000_set_pauseparam+0x7a>
    f5d5:	66 66 2e 0f 1f 84 00 	data32 nopw %cs:0x0(%rax,%rax,1)
    f5dc:	00 00 00 00 

000000000000f5e0 <e1000_get_link>:
	clear_bit(__E1000_RESETTING, &adapter->flags);
	return 0;
}

static u32 e1000_get_link(struct net_device *netdev)
{
    f5e0:	e8 00 00 00 00       	callq  f5e5 <e1000_get_link+0x5>
    f5e5:	48 89 f8             	mov    %rdi,%rax
    f5e8:	55                   	push   %rbp
	struct e1000_adapter *adapter = netdev_priv(netdev);
    f5e9:	48 8d bf 40 08 00 00 	lea    0x840(%rdi),%rdi
    f5f0:	48 8b 50 48          	mov    0x48(%rax),%rdx
	clear_bit(__E1000_RESETTING, &adapter->flags);
	return 0;
}

static u32 e1000_get_link(struct net_device *netdev)
{
    f5f4:	48 89 e5             	mov    %rsp,%rbp
	 * and so the physical link state may have changed since we last
	 * looked. Set get_link_status to make sure that the true link
	 * state is interrogated, rather than pulling a cached and possibly
	 * stale link state from the driver.
	 */
	if (!netif_carrier_ok(netdev))
    f5f7:	83 e2 04             	and    $0x4,%edx
    f5fa:	74 07                	je     f603 <e1000_get_link+0x23>
		adapter->hw.get_link_status = 1;
    f5fc:	c6 80 0c 0d 00 00 01 	movb   $0x1,0xd0c(%rax)

	return e1000_has_link(adapter);
    f603:	e8 00 00 00 00       	callq  f608 <e1000_get_link+0x28>
}
    f608:	5d                   	pop    %rbp
	 * stale link state from the driver.
	 */
	if (!netif_carrier_ok(netdev))
		adapter->hw.get_link_status = 1;

	return e1000_has_link(adapter);
    f609:	0f b6 c0             	movzbl %al,%eax
}
    f60c:	c3                   	retq   
    f60d:	0f 1f 00             	nopl   (%rax)

000000000000f610 <e1000_nway_reset>:

	return 0;
}

static int e1000_nway_reset(struct net_device *netdev)
{
    f610:	e8 00 00 00 00       	callq  f615 <e1000_nway_reset+0x5>
    f615:	48 8b 47 48          	mov    0x48(%rdi),%rax
	struct e1000_adapter *adapter = netdev_priv(netdev);

	if (netif_running(netdev))
    f619:	a8 01                	test   $0x1,%al
    f61b:	75 03                	jne    f620 <e1000_nway_reset+0x10>
		e1000_reinit_locked(adapter);
	return 0;
}
    f61d:	31 c0                	xor    %eax,%eax
    f61f:	c3                   	retq   

	return 0;
}

static int e1000_nway_reset(struct net_device *netdev)
{
    f620:	55                   	push   %rbp
	struct e1000_adapter *adapter = netdev_priv(netdev);
    f621:	48 81 c7 40 08 00 00 	add    $0x840,%rdi

	return 0;
}

static int e1000_nway_reset(struct net_device *netdev)
{
    f628:	48 89 e5             	mov    %rsp,%rbp
	struct e1000_adapter *adapter = netdev_priv(netdev);

	if (netif_running(netdev))
		e1000_reinit_locked(adapter);
    f62b:	e8 00 00 00 00       	callq  f630 <e1000_nway_reset+0x20>
	return 0;
}
    f630:	31 c0                	xor    %eax,%eax
    f632:	5d                   	pop    %rbp
    f633:	c3                   	retq   
    f634:	66 66 66 2e 0f 1f 84 	data32 data32 nopw %cs:0x0(%rax,%rax,1)
    f63b:	00 00 00 00 00 

000000000000f640 <e1000_get_drvinfo>:
	return ret_val;
}

static void e1000_get_drvinfo(struct net_device *netdev,
			      struct ethtool_drvinfo *drvinfo)
{
    f640:	e8 00 00 00 00       	callq  f645 <e1000_get_drvinfo+0x5>
    f645:	55                   	push   %rbp
	struct e1000_adapter *adapter = netdev_priv(netdev);

	strlcpy(drvinfo->driver,  e1000_driver_name,
    f646:	ba 20 00 00 00       	mov    $0x20,%edx
	return ret_val;
}

static void e1000_get_drvinfo(struct net_device *netdev,
			      struct ethtool_drvinfo *drvinfo)
{
    f64b:	48 89 e5             	mov    %rsp,%rbp
    f64e:	41 54                	push   %r12
    f650:	49 89 fc             	mov    %rdi,%r12
	struct e1000_adapter *adapter = netdev_priv(netdev);

	strlcpy(drvinfo->driver,  e1000_driver_name,
    f653:	48 8d 7e 04          	lea    0x4(%rsi),%rdi
	return ret_val;
}

static void e1000_get_drvinfo(struct net_device *netdev,
			      struct ethtool_drvinfo *drvinfo)
{
    f657:	53                   	push   %rbx
    f658:	48 89 f3             	mov    %rsi,%rbx
	struct e1000_adapter *adapter = netdev_priv(netdev);

	strlcpy(drvinfo->driver,  e1000_driver_name,
    f65b:	48 c7 c6 00 00 00 00 	mov    $0x0,%rsi
    f662:	e8 00 00 00 00       	callq  f667 <e1000_get_drvinfo+0x27>
		sizeof(drvinfo->driver));
	strlcpy(drvinfo->version, e1000_driver_version,
    f667:	48 8d 7b 24          	lea    0x24(%rbx),%rdi
    f66b:	48 c7 c6 00 00 00 00 	mov    $0x0,%rsi
    f672:	ba 20 00 00 00       	mov    $0x20,%edx
    f677:	e8 00 00 00 00       	callq  f67c <e1000_get_drvinfo+0x3c>
		sizeof(drvinfo->version));

	strlcpy(drvinfo->bus_info, pci_name(adapter->pdev),
    f67c:	49 8b 84 24 f8 0b 00 	mov    0xbf8(%r12),%rax
    f683:	00 
#include <linux/pm_wakeup.h>

static inline const char *dev_name(const struct device *dev)
{
	/* Use the init name until the kobject becomes available */
	if (dev->init_name)
    f684:	48 8b b0 e8 00 00 00 	mov    0xe8(%rax),%rsi
    f68b:	48 85 f6             	test   %rsi,%rsi
    f68e:	74 13                	je     f6a3 <e1000_get_drvinfo+0x63>
    f690:	48 8d 7b 64          	lea    0x64(%rbx),%rdi
    f694:	ba 20 00 00 00       	mov    $0x20,%edx
    f699:	e8 00 00 00 00       	callq  f69e <e1000_get_drvinfo+0x5e>
		sizeof(drvinfo->bus_info));
}
    f69e:	5b                   	pop    %rbx
    f69f:	41 5c                	pop    %r12
    f6a1:	5d                   	pop    %rbp
    f6a2:	c3                   	retq   
		return dev->init_name;

	return kobject_name(&dev->kobj);
    f6a3:	48 8b b0 a8 00 00 00 	mov    0xa8(%rax),%rsi
    f6aa:	eb e4                	jmp    f690 <e1000_get_drvinfo+0x50>
    f6ac:	0f 1f 40 00          	nopl   0x0(%rax)

000000000000f6b0 <e1000_set_settings>:
	return 0;
}

static int e1000_set_settings(struct net_device *netdev,
			      struct ethtool_cmd *ecmd)
{
    f6b0:	e8 00 00 00 00       	callq  f6b5 <e1000_set_settings+0x5>
    f6b5:	55                   	push   %rbp
    f6b6:	48 89 e5             	mov    %rsp,%rbp
    f6b9:	41 55                	push   %r13
    f6bb:	41 54                	push   %r12
    f6bd:	49 89 f4             	mov    %rsi,%r12
    f6c0:	53                   	push   %rbx

	/* MDI setting is only allowed when autoneg enabled because
	 * some hardware doesn't allow MDI setting when speed or
	 * duplex is forced.
	 */
	if (ecmd->eth_tp_mdix_ctrl) {
    f6c1:	0f b6 46 1f          	movzbl 0x1f(%rsi),%eax
	return 0;
}

static int e1000_set_settings(struct net_device *netdev,
			      struct ethtool_cmd *ecmd)
{
    f6c5:	48 89 fb             	mov    %rdi,%rbx

	/* MDI setting is only allowed when autoneg enabled because
	 * some hardware doesn't allow MDI setting when speed or
	 * duplex is forced.
	 */
	if (ecmd->eth_tp_mdix_ctrl) {
    f6c8:	84 c0                	test   %al,%al
    f6ca:	74 50                	je     f71c <e1000_set_settings+0x6c>
		if (hw->media_type != e1000_media_type_copper)
    f6cc:	8b 97 24 0c 00 00    	mov    0xc24(%rdi),%edx
    f6d2:	85 d2                	test   %edx,%edx
    f6d4:	0f 85 2b 01 00 00    	jne    f805 <e1000_set_settings+0x155>
			return -EOPNOTSUPP;

		if ((ecmd->eth_tp_mdix_ctrl != ETH_TP_MDI_AUTO) &&
    f6da:	3c 03                	cmp    $0x3,%al
    f6dc:	74 3e                	je     f71c <e1000_set_settings+0x6c>
    f6de:	80 7e 12 01          	cmpb   $0x1,0x12(%rsi)
    f6e2:	74 38                	je     f71c <e1000_set_settings+0x6c>
		    (ecmd->autoneg != AUTONEG_ENABLE)) {
			e_err(drv, "forcing MDI/MDI-X state is not supported when link speed and/or duplex are forced\n");
    f6e4:	f6 87 e0 0f 00 00 01 	testb  $0x1,0xfe0(%rdi)
			return -EINVAL;
    f6eb:	41 bc ea ff ff ff    	mov    $0xffffffea,%r12d
		if (hw->media_type != e1000_media_type_copper)
			return -EOPNOTSUPP;

		if ((ecmd->eth_tp_mdix_ctrl != ETH_TP_MDI_AUTO) &&
		    (ecmd->autoneg != AUTONEG_ENABLE)) {
			e_err(drv, "forcing MDI/MDI-X state is not supported when link speed and/or duplex are forced\n");
    f6f1:	75 0a                	jne    f6fd <e1000_set_settings+0x4d>
	} else {
		e1000_reset(adapter);
	}
	clear_bit(__E1000_RESETTING, &adapter->flags);
	return 0;
}
    f6f3:	5b                   	pop    %rbx
    f6f4:	44 89 e0             	mov    %r12d,%eax
    f6f7:	41 5c                	pop    %r12
    f6f9:	41 5d                	pop    %r13
    f6fb:	5d                   	pop    %rbp
    f6fc:	c3                   	retq   
		if (hw->media_type != e1000_media_type_copper)
			return -EOPNOTSUPP;

		if ((ecmd->eth_tp_mdix_ctrl != ETH_TP_MDI_AUTO) &&
		    (ecmd->autoneg != AUTONEG_ENABLE)) {
			e_err(drv, "forcing MDI/MDI-X state is not supported when link speed and/or duplex are forced\n");
    f6fd:	48 8b bf f0 0b 00 00 	mov    0xbf0(%rdi),%rdi
    f704:	31 c0                	xor    %eax,%eax
    f706:	48 c7 c6 00 00 00 00 	mov    $0x0,%rsi
    f70d:	e8 00 00 00 00       	callq  f712 <e1000_set_settings+0x62>
	} else {
		e1000_reset(adapter);
	}
	clear_bit(__E1000_RESETTING, &adapter->flags);
	return 0;
}
    f712:	5b                   	pop    %rbx
    f713:	44 89 e0             	mov    %r12d,%eax
    f716:	41 5c                	pop    %r12
    f718:	41 5d                	pop    %r13
    f71a:	5d                   	pop    %rbp
    f71b:	c3                   	retq   
    f71c:	4c 8d ab e8 0f 00 00 	lea    0xfe8(%rbx),%r13
 * This operation is atomic and cannot be reordered.
 * It also implies a memory barrier.
 */
static inline int test_and_set_bit(long nr, volatile unsigned long *addr)
{
	GEN_BINARY_RMWcc(LOCK_PREFIX "bts", *addr, "Ir", nr, "%0", "c");
    f723:	f0 41 0f ba 6d 00 01 	lock btsl $0x1,0x0(%r13)
    f72a:	0f 82 89 00 00 00    	jb     f7b9 <e1000_set_settings+0x109>
}

static int e1000_set_settings(struct net_device *netdev,
			      struct ethtool_cmd *ecmd)
{
	struct e1000_adapter *adapter = netdev_priv(netdev);
    f730:	4c 8d ab 40 08 00 00 	lea    0x840(%rbx),%r13
	}

	while (test_and_set_bit(__E1000_RESETTING, &adapter->flags))
		msleep(1);

	if (ecmd->autoneg == AUTONEG_ENABLE) {
    f737:	41 80 7c 24 12 01    	cmpb   $0x1,0x12(%r12)
    f73d:	0f 85 85 00 00 00    	jne    f7c8 <e1000_set_settings+0x118>
		hw->autoneg = 1;
		if (hw->media_type == e1000_media_type_fiber)
    f743:	83 bb 24 0c 00 00 01 	cmpl   $0x1,0xc24(%rbx)

	while (test_and_set_bit(__E1000_RESETTING, &adapter->flags))
		msleep(1);

	if (ecmd->autoneg == AUTONEG_ENABLE) {
		hw->autoneg = 1;
    f74a:	c6 83 ef 0c 00 00 01 	movb   $0x1,0xcef(%rbx)
		if (hw->media_type == e1000_media_type_fiber)
    f751:	0f 84 b9 00 00 00    	je     f810 <e1000_set_settings+0x160>
			hw->autoneg_advertised = ADVERTISED_1000baseT_Full |
				     ADVERTISED_FIBRE |
				     ADVERTISED_Autoneg;
		else
			hw->autoneg_advertised = ecmd->advertising |
    f757:	41 0f b7 44 24 08    	movzwl 0x8(%r12),%eax
    f75d:	0c c0                	or     $0xc0,%al
    f75f:	66 89 83 d2 0c 00 00 	mov    %ax,0xcd2(%rbx)
    f766:	0f b7 c0             	movzwl %ax,%eax
						 ADVERTISED_TP |
						 ADVERTISED_Autoneg;
		ecmd->advertising = hw->autoneg_advertised;
    f769:	41 89 44 24 08       	mov    %eax,0x8(%r12)
			return -EINVAL;
		}
	}

	/* MDI-X => 2; MDI => 1; Auto => 3 */
	if (ecmd->eth_tp_mdix_ctrl) {
    f76e:	41 0f b6 44 24 1f    	movzbl 0x1f(%r12),%eax
    f774:	84 c0                	test   %al,%al
    f776:	74 0d                	je     f785 <e1000_set_settings+0xd5>
		if (ecmd->eth_tp_mdix_ctrl == ETH_TP_MDI_AUTO)
			hw->mdix = AUTO_ALL_MODES;
    f778:	31 d2                	xor    %edx,%edx
    f77a:	3c 03                	cmp    $0x3,%al
    f77c:	0f 45 d0             	cmovne %eax,%edx
    f77f:	88 93 f0 0c 00 00    	mov    %dl,0xcf0(%rbx)
			hw->mdix = ecmd->eth_tp_mdix_ctrl;
	}

	/* reset the link */

	if (netif_running(adapter->netdev)) {
    f785:	48 8b 83 f0 0b 00 00 	mov    0xbf0(%rbx),%rax
		e1000_down(adapter);
    f78c:	4c 89 ef             	mov    %r13,%rdi
}

static __always_inline int constant_test_bit(long nr, const volatile unsigned long *addr)
{
	return ((1UL << (nr & (BITS_PER_LONG-1))) &
		(addr[nr >> _BITOPS_LONG_SHIFT])) != 0;
    f78f:	48 8b 40 48          	mov    0x48(%rax),%rax
			hw->mdix = ecmd->eth_tp_mdix_ctrl;
	}

	/* reset the link */

	if (netif_running(adapter->netdev)) {
    f793:	a8 01                	test   $0x1,%al
    f795:	74 67                	je     f7fe <e1000_set_settings+0x14e>
		e1000_down(adapter);
    f797:	e8 00 00 00 00       	callq  f79c <e1000_set_settings+0xec>
		e1000_up(adapter);
    f79c:	4c 89 ef             	mov    %r13,%rdi
    f79f:	e8 00 00 00 00       	callq  f7a4 <e1000_set_settings+0xf4>
 */
static __always_inline void
clear_bit(long nr, volatile unsigned long *addr)
{
	if (IS_IMMEDIATE(nr)) {
		asm volatile(LOCK_PREFIX "andb %1,%0"
    f7a4:	f0 80 a3 e8 0f 00 00 	lock andb $0xfd,0xfe8(%rbx)
    f7ab:	fd 
	} else {
		e1000_reset(adapter);
	}
	clear_bit(__E1000_RESETTING, &adapter->flags);
	return 0;
    f7ac:	45 31 e4             	xor    %r12d,%r12d
}
    f7af:	5b                   	pop    %rbx
    f7b0:	44 89 e0             	mov    %r12d,%eax
    f7b3:	41 5c                	pop    %r12
    f7b5:	41 5d                	pop    %r13
    f7b7:	5d                   	pop    %rbp
    f7b8:	c3                   	retq   
			return -EINVAL;
		}
	}

	while (test_and_set_bit(__E1000_RESETTING, &adapter->flags))
		msleep(1);
    f7b9:	bf 01 00 00 00       	mov    $0x1,%edi
    f7be:	e8 00 00 00 00       	callq  f7c3 <e1000_set_settings+0x113>
    f7c3:	e9 5b ff ff ff       	jmpq   f723 <e1000_set_settings+0x73>
	ep->speed_hi = (__u16)(speed >> 16);
}

static inline __u32 ethtool_cmd_speed(const struct ethtool_cmd *ep)
{
	return (ep->speed_hi << 16) | ep->speed;
    f7c8:	41 0f b7 74 24 1c    	movzwl 0x1c(%r12),%esi
    f7ce:	41 0f b7 44 24 0c    	movzwl 0xc(%r12),%eax
						 ADVERTISED_Autoneg;
		ecmd->advertising = hw->autoneg_advertised;
	} else {
		u32 speed = ethtool_cmd_speed(ecmd);
		/* calling this overrides forced MDI setting */
		if (e1000_set_spd_dplx(adapter, speed, ecmd->duplex)) {
    f7d4:	4c 89 ef             	mov    %r13,%rdi
    f7d7:	41 0f b6 54 24 0e    	movzbl 0xe(%r12),%edx
    f7dd:	c1 e6 10             	shl    $0x10,%esi
    f7e0:	09 c6                	or     %eax,%esi
    f7e2:	e8 00 00 00 00       	callq  f7e7 <e1000_set_settings+0x137>
    f7e7:	85 c0                	test   %eax,%eax
    f7e9:	74 83                	je     f76e <e1000_set_settings+0xbe>
    f7eb:	f0 80 a3 e8 0f 00 00 	lock andb $0xfd,0xfe8(%rbx)
    f7f2:	fd 
			clear_bit(__E1000_RESETTING, &adapter->flags);
			return -EINVAL;
    f7f3:	41 bc ea ff ff ff    	mov    $0xffffffea,%r12d
    f7f9:	e9 f5 fe ff ff       	jmpq   f6f3 <e1000_set_settings+0x43>

	if (netif_running(adapter->netdev)) {
		e1000_down(adapter);
		e1000_up(adapter);
	} else {
		e1000_reset(adapter);
    f7fe:	e8 00 00 00 00       	callq  f803 <e1000_set_settings+0x153>
    f803:	eb 9f                	jmp    f7a4 <e1000_set_settings+0xf4>
	 * some hardware doesn't allow MDI setting when speed or
	 * duplex is forced.
	 */
	if (ecmd->eth_tp_mdix_ctrl) {
		if (hw->media_type != e1000_media_type_copper)
			return -EOPNOTSUPP;
    f805:	41 bc a1 ff ff ff    	mov    $0xffffffa1,%r12d
    f80b:	e9 e3 fe ff ff       	jmpq   f6f3 <e1000_set_settings+0x43>
		msleep(1);

	if (ecmd->autoneg == AUTONEG_ENABLE) {
		hw->autoneg = 1;
		if (hw->media_type == e1000_media_type_fiber)
			hw->autoneg_advertised = ADVERTISED_1000baseT_Full |
    f810:	b8 60 04 00 00       	mov    $0x460,%eax
    f815:	66 89 83 d2 0c 00 00 	mov    %ax,0xcd2(%rbx)
    f81c:	b8 60 04 00 00       	mov    $0x460,%eax
    f821:	e9 43 ff ff ff       	jmpq   f769 <e1000_set_settings+0xb9>
    f826:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    f82d:	00 00 00 

000000000000f830 <e1000_get_settings>:

#define E1000_TEST_LEN	ARRAY_SIZE(e1000_gstrings_test)

static int e1000_get_settings(struct net_device *netdev,
			      struct ethtool_cmd *ecmd)
{
    f830:	e8 00 00 00 00       	callq  f835 <e1000_get_settings+0x5>
    f835:	55                   	push   %rbp
    f836:	48 89 e5             	mov    %rsp,%rbp
    f839:	41 54                	push   %r12
    f83b:	49 89 fc             	mov    %rdi,%r12
    f83e:	53                   	push   %rbx
	struct e1000_adapter *adapter = netdev_priv(netdev);
	struct e1000_hw *hw = &adapter->hw;

	if (hw->media_type == e1000_media_type_copper) {
    f83f:	8b bf 24 0c 00 00    	mov    0xc24(%rdi),%edi

#define E1000_TEST_LEN	ARRAY_SIZE(e1000_gstrings_test)

static int e1000_get_settings(struct net_device *netdev,
			      struct ethtool_cmd *ecmd)
{
    f845:	48 89 f3             	mov    %rsi,%rbx
	struct e1000_adapter *adapter = netdev_priv(netdev);
	struct e1000_hw *hw = &adapter->hw;

	if (hw->media_type == e1000_media_type_copper) {
    f848:	85 ff                	test   %edi,%edi
    f84a:	0f 85 bd 00 00 00    	jne    f90d <e1000_get_settings+0xdd>
		ecmd->supported = (SUPPORTED_10baseT_Half |
    f850:	c7 46 04 ef 00 00 00 	movl   $0xef,0x4(%rsi)
				   SUPPORTED_100baseT_Half |
				   SUPPORTED_100baseT_Full |
				   SUPPORTED_1000baseT_Full|
				   SUPPORTED_Autoneg |
				   SUPPORTED_TP);
		ecmd->advertising = ADVERTISED_TP;
    f857:	c7 46 08 80 00 00 00 	movl   $0x80,0x8(%rsi)

		if (hw->autoneg == 1) {
    f85e:	41 80 bc 24 ef 0c 00 	cmpb   $0x1,0xcef(%r12)
    f865:	00 01 
    f867:	0f 84 20 01 00 00    	je     f98d <e1000_get_settings+0x15d>
			ecmd->advertising |= ADVERTISED_Autoneg;
			/* the e1000 autoneg seems to match ethtool nicely */
			ecmd->advertising |= hw->autoneg_advertised;
		}

		ecmd->port = PORT_TP;
    f86d:	c6 43 0f 00          	movb   $0x0,0xf(%rbx)
		ecmd->phy_address = hw->phy_addr;
    f871:	41 8b 84 24 88 0c 00 	mov    0xc88(%r12),%eax
    f878:	00 
    f879:	88 43 10             	mov    %al,0x10(%rbx)

		if (hw->mac_type == e1000_82543)
    f87c:	41 83 bc 24 18 0c 00 	cmpl   $0x3,0xc18(%r12)
    f883:	00 03 
    f885:	0f 84 a3 00 00 00    	je     f92e <e1000_get_settings+0xfe>
			ecmd->transceiver = XCVR_EXTERNAL;
		else
			ecmd->transceiver = XCVR_INTERNAL;
    f88b:	c6 43 11 00          	movb   $0x0,0x11(%rbx)
			ecmd->transceiver = XCVR_INTERNAL;
		else
			ecmd->transceiver = XCVR_EXTERNAL;
	}

	if (er32(STATUS) & E1000_STATUS_LU) {
    f88f:	49 8b 84 24 00 0c 00 	mov    0xc00(%r12),%rax
    f896:	00 
    f897:	8b 40 08             	mov    0x8(%rax),%eax
    f89a:	a8 02                	test   $0x2,%al
    f89c:	0f 85 a8 00 00 00    	jne    f94a <e1000_get_settings+0x11a>

static inline void ethtool_cmd_speed_set(struct ethtool_cmd *ep,
					 __u32 speed)
{

	ep->speed = (__u16)speed;
    f8a2:	ba ff ff ff ff       	mov    $0xffffffff,%edx
	ep->speed_hi = (__u16)(speed >> 16);
    f8a7:	b9 ff ff ff ff       	mov    $0xffffffff,%ecx
			ecmd->duplex = DUPLEX_FULL;
		else
			ecmd->duplex = DUPLEX_HALF;
	} else {
		ethtool_cmd_speed_set(ecmd, SPEED_UNKNOWN);
		ecmd->duplex = DUPLEX_UNKNOWN;
    f8ac:	c6 43 0e ff          	movb   $0xff,0xe(%rbx)

static inline void ethtool_cmd_speed_set(struct ethtool_cmd *ep,
					 __u32 speed)
{

	ep->speed = (__u16)speed;
    f8b0:	66 89 53 0c          	mov    %dx,0xc(%rbx)
	ep->speed_hi = (__u16)(speed >> 16);
    f8b4:	66 89 4b 1c          	mov    %cx,0x1c(%rbx)
	}

	ecmd->autoneg = ((hw->media_type == e1000_media_type_fiber) ||
			 hw->autoneg) ? AUTONEG_ENABLE : AUTONEG_DISABLE;
    f8b8:	41 83 bc 24 24 0c 00 	cmpl   $0x1,0xc24(%r12)
    f8bf:	00 01 
    f8c1:	b8 01 00 00 00       	mov    $0x1,%eax
    f8c6:	74 0c                	je     f8d4 <e1000_get_settings+0xa4>
    f8c8:	41 80 bc 24 ef 0c 00 	cmpb   $0x0,0xcef(%r12)
    f8cf:	00 00 
    f8d1:	0f 95 c0             	setne  %al
	} else {
		ethtool_cmd_speed_set(ecmd, SPEED_UNKNOWN);
		ecmd->duplex = DUPLEX_UNKNOWN;
	}

	ecmd->autoneg = ((hw->media_type == e1000_media_type_fiber) ||
    f8d4:	88 43 12             	mov    %al,0x12(%rbx)
			 hw->autoneg) ? AUTONEG_ENABLE : AUTONEG_DISABLE;

	/* MDI-X => 1; MDI => 0 */
	if ((hw->media_type == e1000_media_type_copper) &&
    f8d7:	41 8b 84 24 24 0c 00 	mov    0xc24(%r12),%eax
    f8de:	00 
    f8df:	85 c0                	test   %eax,%eax
    f8e1:	75 09                	jne    f8ec <e1000_get_settings+0xbc>
}

static __always_inline int constant_test_bit(long nr, const volatile unsigned long *addr)
{
	return ((1UL << (nr & (BITS_PER_LONG-1))) &
		(addr[nr >> _BITOPS_LONG_SHIFT])) != 0;
    f8e3:	49 8b 44 24 48       	mov    0x48(%r12),%rax
    f8e8:	a8 04                	test   $0x4,%al
    f8ea:	74 4b                	je     f937 <e1000_get_settings+0x107>
	    netif_carrier_ok(netdev))
		ecmd->eth_tp_mdix = (!!adapter->phy_info.mdix_mode ?
				     ETH_TP_MDI_X : ETH_TP_MDI);
	else
		ecmd->eth_tp_mdix = ETH_TP_MDI_INVALID;
    f8ec:	c6 43 1e 00          	movb   $0x0,0x1e(%rbx)

	if (hw->mdix == AUTO_ALL_MODES)
    f8f0:	41 0f b6 94 24 f0 0c 	movzbl 0xcf0(%r12),%edx
    f8f7:	00 00 
		ecmd->eth_tp_mdix_ctrl = ETH_TP_MDI_AUTO;
    f8f9:	b8 03 00 00 00       	mov    $0x3,%eax
    f8fe:	84 d2                	test   %dl,%dl
    f900:	0f 45 c2             	cmovne %edx,%eax
    f903:	88 43 1f             	mov    %al,0x1f(%rbx)
	else
		ecmd->eth_tp_mdix_ctrl = hw->mdix;
	return 0;
}
    f906:	31 c0                	xor    %eax,%eax
    f908:	5b                   	pop    %rbx
    f909:	41 5c                	pop    %r12
    f90b:	5d                   	pop    %rbp
    f90c:	c3                   	retq   
			ecmd->transceiver = XCVR_EXTERNAL;
		else
			ecmd->transceiver = XCVR_INTERNAL;

	} else {
		ecmd->supported   = (SUPPORTED_1000baseT_Full |
    f90d:	c7 46 04 60 04 00 00 	movl   $0x460,0x4(%rsi)
				     SUPPORTED_FIBRE |
				     SUPPORTED_Autoneg);

		ecmd->advertising = (ADVERTISED_1000baseT_Full |
    f914:	c7 46 08 60 04 00 00 	movl   $0x460,0x8(%rsi)
				     ADVERTISED_FIBRE |
				     ADVERTISED_Autoneg);

		ecmd->port = PORT_FIBRE;
    f91b:	c6 46 0f 03          	movb   $0x3,0xf(%rsi)

		if (hw->mac_type >= e1000_82545)
    f91f:	41 83 bc 24 18 0c 00 	cmpl   $0x5,0xc18(%r12)
    f926:	00 05 
    f928:	0f 87 5d ff ff ff    	ja     f88b <e1000_get_settings+0x5b>

		ecmd->port = PORT_TP;
		ecmd->phy_address = hw->phy_addr;

		if (hw->mac_type == e1000_82543)
			ecmd->transceiver = XCVR_EXTERNAL;
    f92e:	c6 43 11 01          	movb   $0x1,0x11(%rbx)
    f932:	e9 58 ff ff ff       	jmpq   f88f <e1000_get_settings+0x5f>
			 hw->autoneg) ? AUTONEG_ENABLE : AUTONEG_DISABLE;

	/* MDI-X => 1; MDI => 0 */
	if ((hw->media_type == e1000_media_type_copper) &&
	    netif_carrier_ok(netdev))
		ecmd->eth_tp_mdix = (!!adapter->phy_info.mdix_mode ?
    f937:	41 83 bc 24 5c 0f 00 	cmpl   $0x1,0xf5c(%r12)
    f93e:	00 01 
    f940:	19 c0                	sbb    %eax,%eax
    f942:	83 c0 02             	add    $0x2,%eax
    f945:	88 43 1e             	mov    %al,0x1e(%rbx)
    f948:	eb a6                	jmp    f8f0 <e1000_get_settings+0xc0>
		else
			ecmd->transceiver = XCVR_EXTERNAL;
	}

	if (er32(STATUS) & E1000_STATUS_LU) {
		e1000_get_speed_and_duplex(hw, &adapter->link_speed,
    f94a:	49 8d b4 24 58 0a 00 	lea    0xa58(%r12),%rsi
    f951:	00 
    f952:	49 8d 94 24 5a 0a 00 	lea    0xa5a(%r12),%rdx
    f959:	00 

static int e1000_get_settings(struct net_device *netdev,
			      struct ethtool_cmd *ecmd)
{
	struct e1000_adapter *adapter = netdev_priv(netdev);
	struct e1000_hw *hw = &adapter->hw;
    f95a:	49 8d bc 24 00 0c 00 	lea    0xc00(%r12),%rdi
    f961:	00 
		else
			ecmd->transceiver = XCVR_EXTERNAL;
	}

	if (er32(STATUS) & E1000_STATUS_LU) {
		e1000_get_speed_and_duplex(hw, &adapter->link_speed,
    f962:	e8 00 00 00 00       	callq  f967 <e1000_get_settings+0x137>
					   &adapter->link_duplex);
		ethtool_cmd_speed_set(ecmd, adapter->link_speed);
    f967:	41 0f b7 84 24 58 0a 	movzwl 0xa58(%r12),%eax
    f96e:	00 00 
    f970:	31 f6                	xor    %esi,%esi
    f972:	66 89 73 1c          	mov    %si,0x1c(%rbx)

static inline void ethtool_cmd_speed_set(struct ethtool_cmd *ep,
					 __u32 speed)
{

	ep->speed = (__u16)speed;
    f976:	66 89 43 0c          	mov    %ax,0xc(%rbx)

		/* unfortunately FULL_DUPLEX != DUPLEX_FULL
		 * and HALF_DUPLEX != DUPLEX_HALF
		 */
		if (adapter->link_duplex == FULL_DUPLEX)
			ecmd->duplex = DUPLEX_FULL;
    f97a:	66 41 83 bc 24 5a 0a 	cmpw   $0x2,0xa5a(%r12)
    f981:	00 00 02 
    f984:	0f 94 43 0e          	sete   0xe(%rbx)
    f988:	e9 2b ff ff ff       	jmpq   f8b8 <e1000_get_settings+0x88>
				   SUPPORTED_Autoneg |
				   SUPPORTED_TP);
		ecmd->advertising = ADVERTISED_TP;

		if (hw->autoneg == 1) {
			ecmd->advertising |= ADVERTISED_Autoneg;
    f98d:	c7 46 08 c0 00 00 00 	movl   $0xc0,0x8(%rsi)
			/* the e1000 autoneg seems to match ethtool nicely */
			ecmd->advertising |= hw->autoneg_advertised;
    f994:	41 0f b7 84 24 d2 0c 	movzwl 0xcd2(%r12),%eax
    f99b:	00 00 
    f99d:	0c c0                	or     $0xc0,%al
    f99f:	0f b7 c0             	movzwl %ax,%eax
    f9a2:	89 46 08             	mov    %eax,0x8(%rsi)
    f9a5:	e9 c3 fe ff ff       	jmpq   f86d <e1000_get_settings+0x3d>
    f9aa:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)

000000000000f9b0 <e1000_wol_exclusion.isra.11>:
		clear_bit(__E1000_TESTING, &adapter->flags);
	}
	msleep_interruptible(4 * 1000);
}

static int e1000_wol_exclusion(struct e1000_adapter *adapter,
    f9b0:	e8 00 00 00 00       	callq  f9b5 <e1000_wol_exclusion.isra.11+0x5>
    f9b5:	55                   	push   %rbp
			       struct ethtool_wolinfo *wol)
{
	struct e1000_hw *hw = &adapter->hw;
	int retval = 1; /* fail by default */

	switch (hw->device_id) {
    f9b6:	0f b7 87 a6 04 00 00 	movzwl 0x4a6(%rdi),%eax
		clear_bit(__E1000_TESTING, &adapter->flags);
	}
	msleep_interruptible(4 * 1000);
}

static int e1000_wol_exclusion(struct e1000_adapter *adapter,
    f9bd:	48 89 e5             	mov    %rsp,%rbp
			       struct ethtool_wolinfo *wol)
{
	struct e1000_hw *hw = &adapter->hw;
	int retval = 1; /* fail by default */

	switch (hw->device_id) {
    f9c0:	66 3d 11 10          	cmp    $0x1011,%ax
    f9c4:	74 21                	je     f9e7 <e1000_wol_exclusion.isra.11+0x37>
    f9c6:	76 44                	jbe    fa0c <e1000_wol_exclusion.isra.11+0x5c>
    f9c8:	66 3d 7a 10          	cmp    $0x107a,%ax
    f9cc:	74 2c                	je     f9fa <e1000_wol_exclusion.isra.11+0x4a>
    f9ce:	66 90                	xchg   %ax,%ax
    f9d0:	76 22                	jbe    f9f4 <e1000_wol_exclusion.isra.11+0x44>
    f9d2:	66 3d 99 10          	cmp    $0x1099,%ax
    f9d6:	74 0f                	je     f9e7 <e1000_wol_exclusion.isra.11+0x37>
    f9d8:	66 3d b5 10          	cmp    $0x10b5,%ax
    f9dc:	75 74                	jne    fa52 <e1000_wol_exclusion.isra.11+0xa2>
		/* return success for non excluded adapter ports */
		retval = 0;
		break;
	case E1000_DEV_ID_82546GB_QUAD_COPPER_KSP3:
		/* quad port adapters only support WoL on port A */
		if (!adapter->quad_port_a) {
    f9de:	80 bf a6 07 00 00 00 	cmpb   $0x0,0x7a6(%rdi)
    f9e5:	75 21                	jne    fa08 <e1000_wol_exclusion.isra.11+0x58>

static int e1000_wol_exclusion(struct e1000_adapter *adapter,
			       struct ethtool_wolinfo *wol)
{
	struct e1000_hw *hw = &adapter->hw;
	int retval = 1; /* fail by default */
    f9e7:	b8 01 00 00 00       	mov    $0x1,%eax
		break;
	case E1000_DEV_ID_82546EB_FIBER:
	case E1000_DEV_ID_82546GB_FIBER:
		/* Wake events not supported on port B */
		if (er32(STATUS) & E1000_STATUS_FUNC_1) {
			wol->supported = 0;
    f9ec:	c7 06 00 00 00 00    	movl   $0x0,(%rsi)

		retval = 0;
	}

	return retval;
}
    f9f2:	5d                   	pop    %rbp
    f9f3:	c3                   	retq   
			       struct ethtool_wolinfo *wol)
{
	struct e1000_hw *hw = &adapter->hw;
	int retval = 1; /* fail by default */

	switch (hw->device_id) {
    f9f4:	66 3d 12 10          	cmp    $0x1012,%ax
    f9f8:	75 4e                	jne    fa48 <e1000_wol_exclusion.isra.11+0x98>
		wol->supported = 0;
		break;
	case E1000_DEV_ID_82546EB_FIBER:
	case E1000_DEV_ID_82546GB_FIBER:
		/* Wake events not supported on port B */
		if (er32(STATUS) & E1000_STATUS_FUNC_1) {
    f9fa:	48 8b 87 c0 03 00 00 	mov    0x3c0(%rdi),%rax
    fa01:	8b 40 08             	mov    0x8(%rax),%eax
    fa04:	a8 04                	test   $0x4,%al
    fa06:	75 df                	jne    f9e7 <e1000_wol_exclusion.isra.11+0x37>
			wol->supported = 0;
			break;
		}
		/* return success for non excluded adapter ports */
		retval = 0;
    fa08:	31 c0                	xor    %eax,%eax

		retval = 0;
	}

	return retval;
}
    fa0a:	5d                   	pop    %rbp
    fa0b:	c3                   	retq   
			       struct ethtool_wolinfo *wol)
{
	struct e1000_hw *hw = &adapter->hw;
	int retval = 1; /* fail by default */

	switch (hw->device_id) {
    fa0c:	66 3d 04 10          	cmp    $0x1004,%ax
    fa10:	74 d5                	je     f9e7 <e1000_wol_exclusion.isra.11+0x37>
    fa12:	76 28                	jbe    fa3c <e1000_wol_exclusion.isra.11+0x8c>
    fa14:	66 3d 09 10          	cmp    $0x1009,%ax
    fa18:	74 cd                	je     f9e7 <e1000_wol_exclusion.isra.11+0x37>
    fa1a:	66 3d 0f 10          	cmp    $0x100f,%ax
    fa1e:	66 90                	xchg   %ax,%ax
    fa20:	74 c5                	je     f9e7 <e1000_wol_exclusion.isra.11+0x37>
	default:
		/* dual port cards only support WoL on port A from now on
		 * unless it was enabled in the eeprom for port B
		 * so exclude FUNC_1 ports from having WoL enabled
		 */
		if (er32(STATUS) & E1000_STATUS_FUNC_1 &&
    fa22:	48 8b 87 c0 03 00 00 	mov    0x3c0(%rdi),%rax
    fa29:	8b 40 08             	mov    0x8(%rax),%eax
    fa2c:	a8 04                	test   $0x4,%al
    fa2e:	74 d8                	je     fa08 <e1000_wol_exclusion.isra.11+0x58>
    fa30:	8b 87 b0 07 00 00    	mov    0x7b0(%rdi),%eax
    fa36:	85 c0                	test   %eax,%eax
    fa38:	74 ad                	je     f9e7 <e1000_wol_exclusion.isra.11+0x37>
    fa3a:	eb cc                	jmp    fa08 <e1000_wol_exclusion.isra.11+0x58>
			       struct ethtool_wolinfo *wol)
{
	struct e1000_hw *hw = &adapter->hw;
	int retval = 1; /* fail by default */

	switch (hw->device_id) {
    fa3c:	66 2d 00 10          	sub    $0x1000,%ax
    fa40:	66 83 f8 01          	cmp    $0x1,%ax
    fa44:	77 dc                	ja     fa22 <e1000_wol_exclusion.isra.11+0x72>
    fa46:	eb 9f                	jmp    f9e7 <e1000_wol_exclusion.isra.11+0x37>
    fa48:	66 3d 1d 10          	cmp    $0x101d,%ax
    fa4c:	75 d4                	jne    fa22 <e1000_wol_exclusion.isra.11+0x72>
    fa4e:	66 90                	xchg   %ax,%ax
    fa50:	eb 95                	jmp    f9e7 <e1000_wol_exclusion.isra.11+0x37>
    fa52:	66 3d 8a 10          	cmp    $0x108a,%ax
    fa56:	75 ca                	jne    fa22 <e1000_wol_exclusion.isra.11+0x72>
    fa58:	eb 8d                	jmp    f9e7 <e1000_wol_exclusion.isra.11+0x37>
    fa5a:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)

000000000000fa60 <e1000_set_wol>:
	if (adapter->wol & E1000_WUFC_MAG)
		wol->wolopts |= WAKE_MAGIC;
}

static int e1000_set_wol(struct net_device *netdev, struct ethtool_wolinfo *wol)
{
    fa60:	e8 00 00 00 00       	callq  fa65 <e1000_set_wol+0x5>
    fa65:	55                   	push   %rbp
    fa66:	48 89 e5             	mov    %rsp,%rbp
    fa69:	41 55                	push   %r13
    fa6b:	49 89 fd             	mov    %rdi,%r13
	struct e1000_adapter *adapter = netdev_priv(netdev);
    fa6e:	48 8d bf 40 08 00 00 	lea    0x840(%rdi),%rdi
	if (adapter->wol & E1000_WUFC_MAG)
		wol->wolopts |= WAKE_MAGIC;
}

static int e1000_set_wol(struct net_device *netdev, struct ethtool_wolinfo *wol)
{
    fa75:	41 54                	push   %r12
    fa77:	53                   	push   %rbx
	struct e1000_adapter *adapter = netdev_priv(netdev);
	struct e1000_hw *hw = &adapter->hw;

	if (wol->wolopts & (WAKE_PHY | WAKE_ARP | WAKE_MAGICSECURE))
    fa78:	f6 46 08 51          	testb  $0x51,0x8(%rsi)
	if (adapter->wol & E1000_WUFC_MAG)
		wol->wolopts |= WAKE_MAGIC;
}

static int e1000_set_wol(struct net_device *netdev, struct ethtool_wolinfo *wol)
{
    fa7c:	48 89 f3             	mov    %rsi,%rbx
	struct e1000_adapter *adapter = netdev_priv(netdev);
	struct e1000_hw *hw = &adapter->hw;

	if (wol->wolopts & (WAKE_PHY | WAKE_ARP | WAKE_MAGICSECURE))
    fa7f:	0f 85 bb 00 00 00    	jne    fb40 <e1000_set_wol+0xe0>
    fa85:	48 8d 76 04          	lea    0x4(%rsi),%rsi
		return -EOPNOTSUPP;

	if (e1000_wol_exclusion(adapter, wol) ||
    fa89:	e8 22 ff ff ff       	callq  f9b0 <e1000_wol_exclusion.isra.11>
    fa8e:	85 c0                	test   %eax,%eax
    fa90:	41 89 c4             	mov    %eax,%r12d
    fa93:	0f 85 9d 00 00 00    	jne    fb36 <e1000_set_wol+0xd6>
	    !device_can_wakeup(&adapter->pdev->dev))
    fa99:	49 8b bd f8 0b 00 00 	mov    0xbf8(%r13),%rdi
	struct e1000_hw *hw = &adapter->hw;

	if (wol->wolopts & (WAKE_PHY | WAKE_ARP | WAKE_MAGICSECURE))
		return -EOPNOTSUPP;

	if (e1000_wol_exclusion(adapter, wol) ||
    faa0:	f6 87 44 01 00 00 01 	testb  $0x1,0x144(%rdi)
    faa7:	0f 84 89 00 00 00    	je     fb36 <e1000_set_wol+0xd6>
	    !device_can_wakeup(&adapter->pdev->dev))
		return wol->wolopts ? -EOPNOTSUPP : 0;

	switch (hw->device_id) {
    faad:	66 41 81 bd e6 0c 00 	cmpw   $0x10b5,0xce6(%r13)
    fab4:	00 b5 10 
    fab7:	0f 84 93 00 00 00    	je     fb50 <e1000_set_wol+0xf0>
	default:
		break;
	}

	/* these settings will always override what we currently have */
	adapter->wol = 0;
    fabd:	41 c7 85 4c 0a 00 00 	movl   $0x0,0xa4c(%r13)
    fac4:	00 00 00 00 

	if (wol->wolopts & WAKE_UCAST)
    fac8:	8b 53 08             	mov    0x8(%rbx),%edx
    facb:	31 c0                	xor    %eax,%eax
    facd:	f6 c2 02             	test   $0x2,%dl
    fad0:	74 13                	je     fae5 <e1000_set_wol+0x85>
		adapter->wol |= E1000_WUFC_EX;
    fad2:	41 c7 85 4c 0a 00 00 	movl   $0x4,0xa4c(%r13)
    fad9:	04 00 00 00 
    fadd:	8b 53 08             	mov    0x8(%rbx),%edx
    fae0:	b8 04 00 00 00       	mov    $0x4,%eax
	if (wol->wolopts & WAKE_MCAST)
    fae5:	f6 c2 04             	test   $0x4,%dl
    fae8:	74 0d                	je     faf7 <e1000_set_wol+0x97>
		adapter->wol |= E1000_WUFC_MC;
    faea:	83 c8 08             	or     $0x8,%eax
    faed:	41 89 85 4c 0a 00 00 	mov    %eax,0xa4c(%r13)
    faf4:	8b 53 08             	mov    0x8(%rbx),%edx
	if (wol->wolopts & WAKE_BCAST)
    faf7:	f6 c2 08             	test   $0x8,%dl
    fafa:	74 0d                	je     fb09 <e1000_set_wol+0xa9>
		adapter->wol |= E1000_WUFC_BC;
    fafc:	83 c8 10             	or     $0x10,%eax
    faff:	41 89 85 4c 0a 00 00 	mov    %eax,0xa4c(%r13)
    fb06:	8b 53 08             	mov    0x8(%rbx),%edx
	if (wol->wolopts & WAKE_MAGIC)
    fb09:	83 e2 20             	and    $0x20,%edx
    fb0c:	74 0a                	je     fb18 <e1000_set_wol+0xb8>
		adapter->wol |= E1000_WUFC_MAG;
    fb0e:	83 c8 02             	or     $0x2,%eax
    fb11:	41 89 85 4c 0a 00 00 	mov    %eax,0xa4c(%r13)

	device_set_wakeup_enable(&adapter->pdev->dev, adapter->wol);
    fb18:	31 f6                	xor    %esi,%esi
    fb1a:	85 c0                	test   %eax,%eax
    fb1c:	40 0f 95 c6          	setne  %sil
    fb20:	48 81 c7 98 00 00 00 	add    $0x98,%rdi
    fb27:	e8 00 00 00 00       	callq  fb2c <e1000_set_wol+0xcc>

	return 0;
}
    fb2c:	5b                   	pop    %rbx
    fb2d:	44 89 e0             	mov    %r12d,%eax
    fb30:	41 5c                	pop    %r12
    fb32:	41 5d                	pop    %r13
    fb34:	5d                   	pop    %rbp
    fb35:	c3                   	retq   
	if (wol->wolopts & (WAKE_PHY | WAKE_ARP | WAKE_MAGICSECURE))
		return -EOPNOTSUPP;

	if (e1000_wol_exclusion(adapter, wol) ||
	    !device_can_wakeup(&adapter->pdev->dev))
		return wol->wolopts ? -EOPNOTSUPP : 0;
    fb36:	8b 43 08             	mov    0x8(%rbx),%eax
    fb39:	45 31 e4             	xor    %r12d,%r12d
    fb3c:	85 c0                	test   %eax,%eax
    fb3e:	74 ec                	je     fb2c <e1000_set_wol+0xcc>
		adapter->wol |= E1000_WUFC_MAG;

	device_set_wakeup_enable(&adapter->pdev->dev, adapter->wol);

	return 0;
}
    fb40:	5b                   	pop    %rbx
	switch (hw->device_id) {
	case E1000_DEV_ID_82546GB_QUAD_COPPER_KSP3:
		if (wol->wolopts & WAKE_UCAST) {
			e_err(drv, "Interface does not support directed "
			      "(unicast) frame wake-up packets\n");
			return -EOPNOTSUPP;
    fb41:	41 bc a1 ff ff ff    	mov    $0xffffffa1,%r12d
		adapter->wol |= E1000_WUFC_MAG;

	device_set_wakeup_enable(&adapter->pdev->dev, adapter->wol);

	return 0;
}
    fb47:	44 89 e0             	mov    %r12d,%eax
    fb4a:	41 5c                	pop    %r12
    fb4c:	41 5d                	pop    %r13
    fb4e:	5d                   	pop    %rbp
    fb4f:	c3                   	retq   
	    !device_can_wakeup(&adapter->pdev->dev))
		return wol->wolopts ? -EOPNOTSUPP : 0;

	switch (hw->device_id) {
	case E1000_DEV_ID_82546GB_QUAD_COPPER_KSP3:
		if (wol->wolopts & WAKE_UCAST) {
    fb50:	f6 43 08 02          	testb  $0x2,0x8(%rbx)
    fb54:	0f 84 63 ff ff ff    	je     fabd <e1000_set_wol+0x5d>
			e_err(drv, "Interface does not support directed "
    fb5a:	41 f6 85 e0 0f 00 00 	testb  $0x1,0xfe0(%r13)
    fb61:	01 
    fb62:	74 dc                	je     fb40 <e1000_set_wol+0xe0>
    fb64:	49 8b bd f0 0b 00 00 	mov    0xbf0(%r13),%rdi
    fb6b:	48 c7 c6 00 00 00 00 	mov    $0x0,%rsi
    fb72:	31 c0                	xor    %eax,%eax
    fb74:	e8 00 00 00 00       	callq  fb79 <e1000_set_wol+0x119>
    fb79:	eb c5                	jmp    fb40 <e1000_set_wol+0xe0>
    fb7b:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)

000000000000fb80 <e1000_set_coalesce>:
	return 0;
}

static int e1000_set_coalesce(struct net_device *netdev,
			      struct ethtool_coalesce *ec)
{
    fb80:	e8 00 00 00 00       	callq  fb85 <e1000_set_coalesce+0x5>
    fb85:	55                   	push   %rbp
	struct e1000_adapter *adapter = netdev_priv(netdev);
	struct e1000_hw *hw = &adapter->hw;

	if (hw->mac_type < e1000_82545)
    fb86:	83 bf 18 0c 00 00 05 	cmpl   $0x5,0xc18(%rdi)
	return 0;
}

static int e1000_set_coalesce(struct net_device *netdev,
			      struct ethtool_coalesce *ec)
{
    fb8d:	48 89 e5             	mov    %rsp,%rbp
	struct e1000_adapter *adapter = netdev_priv(netdev);
	struct e1000_hw *hw = &adapter->hw;

	if (hw->mac_type < e1000_82545)
    fb90:	0f 86 ae 00 00 00    	jbe    fc44 <e1000_set_coalesce+0xc4>
		return -EOPNOTSUPP;

	if ((ec->rx_coalesce_usecs > E1000_MAX_ITR_USECS) ||
    fb96:	8b 4e 04             	mov    0x4(%rsi),%ecx
    fb99:	81 f9 10 27 00 00    	cmp    $0x2710,%ecx
    fb9f:	0f 87 98 00 00 00    	ja     fc3d <e1000_set_coalesce+0xbd>
    fba5:	8d 41 fb             	lea    -0x5(%rcx),%eax
    fba8:	83 f8 04             	cmp    $0x4,%eax
    fbab:	0f 86 8c 00 00 00    	jbe    fc3d <e1000_set_coalesce+0xbd>
	    ((ec->rx_coalesce_usecs > 4) &&
	     (ec->rx_coalesce_usecs < E1000_MIN_ITR_USECS)) ||
    fbb1:	83 f9 02             	cmp    $0x2,%ecx
    fbb4:	0f 84 83 00 00 00    	je     fc3d <e1000_set_coalesce+0xbd>
	    (ec->rx_coalesce_usecs == 2))
		return -EINVAL;

	if (ec->rx_coalesce_usecs == 4) {
    fbba:	83 f9 04             	cmp    $0x4,%ecx
    fbbd:	74 47                	je     fc06 <e1000_set_coalesce+0x86>
		adapter->itr = adapter->itr_setting = 4;
	} else if (ec->rx_coalesce_usecs <= 3) {
    fbbf:	83 f9 03             	cmp    $0x3,%ecx
    fbc2:	76 2d                	jbe    fbf1 <e1000_set_coalesce+0x71>
		adapter->itr = 20000;
		adapter->itr_setting = ec->rx_coalesce_usecs;
	} else {
		adapter->itr = (1000000 / ec->rx_coalesce_usecs);
    fbc4:	b8 40 42 0f 00       	mov    $0xf4240,%eax
    fbc9:	31 d2                	xor    %edx,%edx
    fbcb:	f7 f1                	div    %ecx
    fbcd:	89 87 70 0a 00 00    	mov    %eax,0xa70(%rdi)
		adapter->itr_setting = adapter->itr & ~3;
    fbd3:	83 e0 fc             	and    $0xfffffffc,%eax
    fbd6:	89 87 74 0a 00 00    	mov    %eax,0xa74(%rdi)
	}

	if (adapter->itr_setting != 0)
    fbdc:	85 c0                	test   %eax,%eax
    fbde:	75 3a                	jne    fc1a <e1000_set_coalesce+0x9a>
		ew32(ITR, 1000000000 / (adapter->itr * 256));
	else
		ew32(ITR, 0);
    fbe0:	48 8b 97 00 0c 00 00 	mov    0xc00(%rdi),%rdx
build_mmio_read(__readw, "w", unsigned short, "=r", )
build_mmio_read(__readl, "l", unsigned int, "=r", )

build_mmio_write(writeb, "b", unsigned char, "q", :"memory")
build_mmio_write(writew, "w", unsigned short, "r", :"memory")
build_mmio_write(writel, "l", unsigned int, "r", :"memory")
    fbe7:	31 c0                	xor    %eax,%eax
    fbe9:	89 82 c4 00 00 00    	mov    %eax,0xc4(%rdx)

	return 0;
}
    fbef:	5d                   	pop    %rbp
    fbf0:	c3                   	retq   
		return -EINVAL;

	if (ec->rx_coalesce_usecs == 4) {
		adapter->itr = adapter->itr_setting = 4;
	} else if (ec->rx_coalesce_usecs <= 3) {
		adapter->itr = 20000;
    fbf1:	c7 87 70 0a 00 00 20 	movl   $0x4e20,0xa70(%rdi)
    fbf8:	4e 00 00 
		adapter->itr_setting = ec->rx_coalesce_usecs;
    fbfb:	8b 46 04             	mov    0x4(%rsi),%eax
    fbfe:	89 87 74 0a 00 00    	mov    %eax,0xa74(%rdi)
    fc04:	eb d6                	jmp    fbdc <e1000_set_coalesce+0x5c>
	     (ec->rx_coalesce_usecs < E1000_MIN_ITR_USECS)) ||
	    (ec->rx_coalesce_usecs == 2))
		return -EINVAL;

	if (ec->rx_coalesce_usecs == 4) {
		adapter->itr = adapter->itr_setting = 4;
    fc06:	c7 87 74 0a 00 00 04 	movl   $0x4,0xa74(%rdi)
    fc0d:	00 00 00 
    fc10:	c7 87 70 0a 00 00 04 	movl   $0x4,0xa70(%rdi)
    fc17:	00 00 00 
		adapter->itr = (1000000 / ec->rx_coalesce_usecs);
		adapter->itr_setting = adapter->itr & ~3;
	}

	if (adapter->itr_setting != 0)
		ew32(ITR, 1000000000 / (adapter->itr * 256));
    fc1a:	8b 8f 70 0a 00 00    	mov    0xa70(%rdi),%ecx
    fc20:	31 d2                	xor    %edx,%edx
    fc22:	b8 00 ca 9a 3b       	mov    $0x3b9aca00,%eax
    fc27:	48 8b b7 00 0c 00 00 	mov    0xc00(%rdi),%rsi
    fc2e:	c1 e1 08             	shl    $0x8,%ecx
    fc31:	f7 f1                	div    %ecx
    fc33:	89 86 c4 00 00 00    	mov    %eax,0xc4(%rsi)
    fc39:	31 c0                	xor    %eax,%eax
	else
		ew32(ITR, 0);

	return 0;
}
    fc3b:	5d                   	pop    %rbp
    fc3c:	c3                   	retq   

	if ((ec->rx_coalesce_usecs > E1000_MAX_ITR_USECS) ||
	    ((ec->rx_coalesce_usecs > 4) &&
	     (ec->rx_coalesce_usecs < E1000_MIN_ITR_USECS)) ||
	    (ec->rx_coalesce_usecs == 2))
		return -EINVAL;
    fc3d:	b8 ea ff ff ff       	mov    $0xffffffea,%eax
		ew32(ITR, 1000000000 / (adapter->itr * 256));
	else
		ew32(ITR, 0);

	return 0;
}
    fc42:	5d                   	pop    %rbp
    fc43:	c3                   	retq   
{
	struct e1000_adapter *adapter = netdev_priv(netdev);
	struct e1000_hw *hw = &adapter->hw;

	if (hw->mac_type < e1000_82545)
		return -EOPNOTSUPP;
    fc44:	b8 a1 ff ff ff       	mov    $0xffffffa1,%eax
		ew32(ITR, 1000000000 / (adapter->itr * 256));
	else
		ew32(ITR, 0);

	return 0;
}
    fc49:	5d                   	pop    %rbp
    fc4a:	c3                   	retq   
    fc4b:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)

000000000000fc50 <e1000_get_strings>:
/* BUG_ON(i != E1000_STATS_LEN); */
}

static void e1000_get_strings(struct net_device *netdev, u32 stringset,
			      u8 *data)
{
    fc50:	e8 00 00 00 00       	callq  fc55 <e1000_get_strings+0x5>
    fc55:	55                   	push   %rbp
	u8 *p = data;
	int i;

	switch (stringset) {
    fc56:	85 f6                	test   %esi,%esi
/* BUG_ON(i != E1000_STATS_LEN); */
}

static void e1000_get_strings(struct net_device *netdev, u32 stringset,
			      u8 *data)
{
    fc58:	48 89 e5             	mov    %rsp,%rbp
	u8 *p = data;
	int i;

	switch (stringset) {
    fc5b:	74 41                	je     fc9e <e1000_get_strings+0x4e>
    fc5d:	83 fe 01             	cmp    $0x1,%esi
    fc60:	75 3a                	jne    fc9c <e1000_get_strings+0x4c>
    fc62:	48 8d b2 c0 05 00 00 	lea    0x5c0(%rdx),%rsi
    fc69:	48 c7 c0 00 00 00 00 	mov    $0x0,%rax
	case ETH_SS_TEST:
		memcpy(data, e1000_gstrings_test, sizeof(e1000_gstrings_test));
		break;
	case ETH_SS_STATS:
		for (i = 0; i < E1000_GLOBAL_STATS_LEN; i++) {
			memcpy(p, e1000_gstrings_stats[i].stat_string,
    fc70:	48 8b 08             	mov    (%rax),%rcx
			       ETH_GSTRING_LEN);
			p += ETH_GSTRING_LEN;
    fc73:	48 83 c2 20          	add    $0x20,%rdx
    fc77:	48 83 c0 2c          	add    $0x2c,%rax
	case ETH_SS_TEST:
		memcpy(data, e1000_gstrings_test, sizeof(e1000_gstrings_test));
		break;
	case ETH_SS_STATS:
		for (i = 0; i < E1000_GLOBAL_STATS_LEN; i++) {
			memcpy(p, e1000_gstrings_stats[i].stat_string,
    fc7b:	48 89 4a e0          	mov    %rcx,-0x20(%rdx)
    fc7f:	48 8b 48 dc          	mov    -0x24(%rax),%rcx
    fc83:	48 89 4a e8          	mov    %rcx,-0x18(%rdx)
    fc87:	48 8b 48 e4          	mov    -0x1c(%rax),%rcx
    fc8b:	48 89 4a f0          	mov    %rcx,-0x10(%rdx)
    fc8f:	48 8b 48 ec          	mov    -0x14(%rax),%rcx
    fc93:	48 89 4a f8          	mov    %rcx,-0x8(%rdx)
	switch (stringset) {
	case ETH_SS_TEST:
		memcpy(data, e1000_gstrings_test, sizeof(e1000_gstrings_test));
		break;
	case ETH_SS_STATS:
		for (i = 0; i < E1000_GLOBAL_STATS_LEN; i++) {
    fc97:	48 39 f2             	cmp    %rsi,%rdx
    fc9a:	75 d4                	jne    fc70 <e1000_get_strings+0x20>
			p += ETH_GSTRING_LEN;
		}
		/* BUG_ON(p - data != E1000_STATS_LEN * ETH_GSTRING_LEN); */
		break;
	}
}
    fc9c:	5d                   	pop    %rbp
    fc9d:	c3                   	retq   
	u8 *p = data;
	int i;

	switch (stringset) {
	case ETH_SS_TEST:
		memcpy(data, e1000_gstrings_test, sizeof(e1000_gstrings_test));
    fc9e:	f6 c2 01             	test   $0x1,%dl
    fca1:	48 89 d7             	mov    %rdx,%rdi
    fca4:	48 c7 c6 00 00 00 00 	mov    $0x0,%rsi
    fcab:	b8 a0 00 00 00       	mov    $0xa0,%eax
    fcb0:	75 5e                	jne    fd10 <e1000_get_strings+0xc0>
    fcb2:	40 f6 c7 02          	test   $0x2,%dil
    fcb6:	75 73                	jne    fd2b <e1000_get_strings+0xdb>
    fcb8:	40 f6 c7 04          	test   $0x4,%dil
    fcbc:	75 40                	jne    fcfe <e1000_get_strings+0xae>
    fcbe:	89 c1                	mov    %eax,%ecx
    fcc0:	31 d2                	xor    %edx,%edx
    fcc2:	c1 e9 03             	shr    $0x3,%ecx
    fcc5:	a8 04                	test   $0x4,%al
    fcc7:	f3 48 a5             	rep movsq %ds:(%rsi),%es:(%rdi)
    fcca:	75 23                	jne    fcef <e1000_get_strings+0x9f>
    fccc:	a8 02                	test   $0x2,%al
    fcce:	75 0d                	jne    fcdd <e1000_get_strings+0x8d>
    fcd0:	a8 01                	test   $0x1,%al
    fcd2:	74 c8                	je     fc9c <e1000_get_strings+0x4c>
    fcd4:	0f b6 04 16          	movzbl (%rsi,%rdx,1),%eax
    fcd8:	88 04 17             	mov    %al,(%rdi,%rdx,1)
			p += ETH_GSTRING_LEN;
		}
		/* BUG_ON(p - data != E1000_STATS_LEN * ETH_GSTRING_LEN); */
		break;
	}
}
    fcdb:	5d                   	pop    %rbp
    fcdc:	c3                   	retq   
	u8 *p = data;
	int i;

	switch (stringset) {
	case ETH_SS_TEST:
		memcpy(data, e1000_gstrings_test, sizeof(e1000_gstrings_test));
    fcdd:	0f b7 0c 16          	movzwl (%rsi,%rdx,1),%ecx
    fce1:	66 89 0c 17          	mov    %cx,(%rdi,%rdx,1)
    fce5:	48 83 c2 02          	add    $0x2,%rdx
    fce9:	a8 01                	test   $0x1,%al
    fceb:	74 af                	je     fc9c <e1000_get_strings+0x4c>
    fced:	eb e5                	jmp    fcd4 <e1000_get_strings+0x84>
    fcef:	8b 16                	mov    (%rsi),%edx
    fcf1:	a8 02                	test   $0x2,%al
    fcf3:	89 17                	mov    %edx,(%rdi)
    fcf5:	ba 04 00 00 00       	mov    $0x4,%edx
    fcfa:	74 d4                	je     fcd0 <e1000_get_strings+0x80>
    fcfc:	eb df                	jmp    fcdd <e1000_get_strings+0x8d>
    fcfe:	8b 16                	mov    (%rsi),%edx
    fd00:	48 83 c7 04          	add    $0x4,%rdi
    fd04:	48 83 c6 04          	add    $0x4,%rsi
    fd08:	83 e8 04             	sub    $0x4,%eax
    fd0b:	89 57 fc             	mov    %edx,-0x4(%rdi)
    fd0e:	eb ae                	jmp    fcbe <e1000_get_strings+0x6e>
    fd10:	0f b6 05 00 00 00 00 	movzbl 0x0(%rip),%eax        # fd17 <e1000_get_strings+0xc7>
    fd17:	48 83 c7 01          	add    $0x1,%rdi
    fd1b:	48 c7 c6 00 00 00 00 	mov    $0x0,%rsi
    fd22:	88 02                	mov    %al,(%rdx)
    fd24:	b8 9f 00 00 00       	mov    $0x9f,%eax
    fd29:	eb 87                	jmp    fcb2 <e1000_get_strings+0x62>
    fd2b:	0f b7 16             	movzwl (%rsi),%edx
    fd2e:	48 83 c7 02          	add    $0x2,%rdi
    fd32:	48 83 c6 02          	add    $0x2,%rsi
    fd36:	83 e8 02             	sub    $0x2,%eax
    fd39:	66 89 57 fe          	mov    %dx,-0x2(%rdi)
    fd3d:	e9 76 ff ff ff       	jmpq   fcb8 <e1000_get_strings+0x68>
    fd42:	66 66 66 66 66 2e 0f 	data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
    fd49:	1f 84 00 00 00 00 00 

000000000000fd50 <e1000_get_wol>:
	return retval;
}

static void e1000_get_wol(struct net_device *netdev,
			  struct ethtool_wolinfo *wol)
{
    fd50:	e8 00 00 00 00       	callq  fd55 <e1000_get_wol+0x5>
    fd55:	55                   	push   %rbp
    fd56:	48 89 e5             	mov    %rsp,%rbp
    fd59:	41 54                	push   %r12
    fd5b:	49 89 fc             	mov    %rdi,%r12
	struct e1000_adapter *adapter = netdev_priv(netdev);
    fd5e:	48 8d bf 40 08 00 00 	lea    0x840(%rdi),%rdi
	return retval;
}

static void e1000_get_wol(struct net_device *netdev,
			  struct ethtool_wolinfo *wol)
{
    fd65:	53                   	push   %rbx
	struct e1000_adapter *adapter = netdev_priv(netdev);
	struct e1000_hw *hw = &adapter->hw;

	wol->supported = WAKE_UCAST | WAKE_MCAST | WAKE_BCAST | WAKE_MAGIC;
    fd66:	c7 46 04 2e 00 00 00 	movl   $0x2e,0x4(%rsi)
	return retval;
}

static void e1000_get_wol(struct net_device *netdev,
			  struct ethtool_wolinfo *wol)
{
    fd6d:	48 89 f3             	mov    %rsi,%rbx
	struct e1000_adapter *adapter = netdev_priv(netdev);
	struct e1000_hw *hw = &adapter->hw;

	wol->supported = WAKE_UCAST | WAKE_MCAST | WAKE_BCAST | WAKE_MAGIC;
	wol->wolopts = 0;
    fd70:	c7 46 08 00 00 00 00 	movl   $0x0,0x8(%rsi)
    fd77:	48 8d 76 04          	lea    0x4(%rsi),%rsi

	/* this function will set ->supported = 0 and return 1 if wol is not
	 * supported by this hardware
	 */
	if (e1000_wol_exclusion(adapter, wol) ||
    fd7b:	e8 30 fc ff ff       	callq  f9b0 <e1000_wol_exclusion.isra.11>
    fd80:	85 c0                	test   %eax,%eax
    fd82:	75 61                	jne    fde5 <e1000_get_wol+0x95>
 * Changes to device_may_wakeup take effect on the next pm state change.
 */

static inline bool device_can_wakeup(struct device *dev)
{
	return dev->power.can_wakeup;
    fd84:	49 8b 84 24 f8 0b 00 	mov    0xbf8(%r12),%rax
    fd8b:	00 
    fd8c:	f6 80 44 01 00 00 01 	testb  $0x1,0x144(%rax)
    fd93:	74 50                	je     fde5 <e1000_get_wol+0x95>
	    !device_can_wakeup(&adapter->pdev->dev))
		return;

	/* apply any specific unsupported masks here */
	switch (hw->device_id) {
    fd95:	66 41 81 bc 24 e6 0c 	cmpw   $0x10b5,0xce6(%r12)
    fd9c:	00 00 b5 10 
    fda0:	75 5e                	jne    fe00 <e1000_get_wol+0xb0>
	case E1000_DEV_ID_82546GB_QUAD_COPPER_KSP3:
		/* KSP3 does not support UCAST wake-ups */
		wol->supported &= ~WAKE_UCAST;
    fda2:	83 63 04 fd          	andl   $0xfffffffd,0x4(%rbx)

		if (adapter->wol & E1000_WUFC_EX)
    fda6:	41 8b 84 24 4c 0a 00 	mov    0xa4c(%r12),%eax
    fdad:	00 
    fdae:	a8 04                	test   $0x4,%al
    fdb0:	74 17                	je     fdc9 <e1000_get_wol+0x79>
			e_err(drv, "Interface does not support directed "
    fdb2:	41 f6 84 24 e0 0f 00 	testb  $0x1,0xfe0(%r12)
    fdb9:	00 01 
    fdbb:	75 2d                	jne    fdea <e1000_get_wol+0x9a>
	default:
		break;
	}

	if (adapter->wol & E1000_WUFC_EX)
		wol->wolopts |= WAKE_UCAST;
    fdbd:	83 4b 08 02          	orl    $0x2,0x8(%rbx)
    fdc1:	41 8b 84 24 4c 0a 00 	mov    0xa4c(%r12),%eax
    fdc8:	00 
	if (adapter->wol & E1000_WUFC_MC)
    fdc9:	a8 08                	test   $0x8,%al
    fdcb:	74 0c                	je     fdd9 <e1000_get_wol+0x89>
		wol->wolopts |= WAKE_MCAST;
    fdcd:	83 4b 08 04          	orl    $0x4,0x8(%rbx)
    fdd1:	41 8b 84 24 4c 0a 00 	mov    0xa4c(%r12),%eax
    fdd8:	00 
	if (adapter->wol & E1000_WUFC_BC)
    fdd9:	a8 10                	test   $0x10,%al
    fddb:	75 31                	jne    fe0e <e1000_get_wol+0xbe>
		wol->wolopts |= WAKE_BCAST;
	if (adapter->wol & E1000_WUFC_MAG)
    fddd:	a8 02                	test   $0x2,%al
    fddf:	74 04                	je     fde5 <e1000_get_wol+0x95>
		wol->wolopts |= WAKE_MAGIC;
    fde1:	83 4b 08 20          	orl    $0x20,0x8(%rbx)
}
    fde5:	5b                   	pop    %rbx
    fde6:	41 5c                	pop    %r12
    fde8:	5d                   	pop    %rbp
    fde9:	c3                   	retq   
	case E1000_DEV_ID_82546GB_QUAD_COPPER_KSP3:
		/* KSP3 does not support UCAST wake-ups */
		wol->supported &= ~WAKE_UCAST;

		if (adapter->wol & E1000_WUFC_EX)
			e_err(drv, "Interface does not support directed "
    fdea:	49 8b bc 24 f0 0b 00 	mov    0xbf0(%r12),%rdi
    fdf1:	00 
    fdf2:	48 c7 c6 00 00 00 00 	mov    $0x0,%rsi
    fdf9:	31 c0                	xor    %eax,%eax
    fdfb:	e8 00 00 00 00       	callq  fe00 <e1000_get_wol+0xb0>
		break;
	default:
		break;
	}

	if (adapter->wol & E1000_WUFC_EX)
    fe00:	41 8b 84 24 4c 0a 00 	mov    0xa4c(%r12),%eax
    fe07:	00 
    fe08:	a8 04                	test   $0x4,%al
    fe0a:	75 b1                	jne    fdbd <e1000_get_wol+0x6d>
    fe0c:	eb bb                	jmp    fdc9 <e1000_get_wol+0x79>
		wol->wolopts |= WAKE_UCAST;
	if (adapter->wol & E1000_WUFC_MC)
		wol->wolopts |= WAKE_MCAST;
	if (adapter->wol & E1000_WUFC_BC)
		wol->wolopts |= WAKE_BCAST;
    fe0e:	83 4b 08 08          	orl    $0x8,0x8(%rbx)
    fe12:	41 8b 84 24 4c 0a 00 	mov    0xa4c(%r12),%eax
    fe19:	00 
    fe1a:	eb c1                	jmp    fddd <e1000_get_wol+0x8d>
    fe1c:	0f 1f 40 00          	nopl   0x0(%rax)

000000000000fe20 <e1000_set_phy_loopback>:

	return 0;
}

static int e1000_set_phy_loopback(struct e1000_adapter *adapter)
{
    fe20:	e8 00 00 00 00       	callq  fe25 <e1000_set_phy_loopback+0x5>
    fe25:	55                   	push   %rbp
	struct e1000_hw *hw = &adapter->hw;
	u16 phy_reg = 0;
    fe26:	45 31 c0             	xor    %r8d,%r8d

	return 0;
}

static int e1000_set_phy_loopback(struct e1000_adapter *adapter)
{
    fe29:	48 89 e5             	mov    %rsp,%rbp
    fe2c:	41 55                	push   %r13
    fe2e:	41 54                	push   %r12
	struct e1000_hw *hw = &adapter->hw;
    fe30:	4c 8d a7 c0 03 00 00 	lea    0x3c0(%rdi),%r12

	return 0;
}

static int e1000_set_phy_loopback(struct e1000_adapter *adapter)
{
    fe37:	53                   	push   %rbx
    fe38:	48 89 fb             	mov    %rdi,%rbx
    fe3b:	48 83 ec 08          	sub    $0x8,%rsp
    fe3f:	8b 87 d8 03 00 00    	mov    0x3d8(%rdi),%eax
	struct e1000_hw *hw = &adapter->hw;
	u16 phy_reg = 0;
    fe45:	66 44 89 45 e4       	mov    %r8w,-0x1c(%rbp)
    fe4a:	8d 48 fd             	lea    -0x3(%rax),%ecx
    fe4d:	83 f9 0b             	cmp    $0xb,%ecx
    fe50:	0f 87 0b 01 00 00    	ja     ff61 <e1000_set_phy_loopback+0x141>
    fe56:	b8 01 00 00 00       	mov    $0x1,%eax
    fe5b:	48 d3 e0             	shl    %cl,%rax
    fe5e:	a9 be 0f 00 00       	test   $0xfbe,%eax
    fe63:	0f 85 2b 01 00 00    	jne    ff94 <e1000_set_phy_loopback+0x174>
    fe69:	a8 01                	test   $0x1,%al
    fe6b:	0f 84 f0 00 00 00    	je     ff61 <e1000_set_phy_loopback+0x141>
	u16 count = 0;

	switch (hw->mac_type) {
	case e1000_82543:
		if (hw->media_type == e1000_media_type_copper) {
    fe71:	8b bf e4 03 00 00    	mov    0x3e4(%rdi),%edi
		phy_reg |= MII_CR_LOOPBACK;
		e1000_write_phy_reg(hw, PHY_CTRL, phy_reg);
		return 0;
	}

	return 8;
    fe77:	b8 08 00 00 00       	mov    $0x8,%eax
	u16 phy_reg = 0;
	u16 count = 0;

	switch (hw->mac_type) {
	case e1000_82543:
		if (hw->media_type == e1000_media_type_copper) {
    fe7c:	85 ff                	test   %edi,%edi
    fe7e:	0f 85 05 01 00 00    	jne    ff89 <e1000_set_phy_loopback+0x169>
    fe84:	45 31 ed             	xor    %r13d,%r13d
	u32 ctrl_reg;
	u16 phy_reg;

	/* Setup the Device Control Register for PHY loopback test. */

	ctrl_reg = er32(CTRL);
    fe87:	48 8b 83 c0 03 00 00 	mov    0x3c0(%rbx),%rax
{ asm volatile("mov" size " %0,%1": :reg (val), \
"m" (*(volatile type __force *)addr) barrier); }

build_mmio_read(readb, "b", unsigned char, "=q", :"memory")
build_mmio_read(readw, "w", unsigned short, "=r", :"memory")
build_mmio_read(readl, "l", unsigned int, "=r", :"memory")
    fe8e:	8b 00                	mov    (%rax),%eax
	ctrl_reg |= (E1000_CTRL_ILOS |		/* Invert Loss-Of-Signal */
    fe90:	0d 81 1a 00 00       	or     $0x1a81,%eax
		     E1000_CTRL_FRCSPD |	/* Set the Force Speed Bit */
		     E1000_CTRL_FRCDPX |	/* Set the Force Duplex Bit */
		     E1000_CTRL_SPD_1000 |	/* Force Speed to 1000 */
		     E1000_CTRL_FD);		/* Force Duplex to FULL */

	ew32(CTRL, ctrl_reg);
    fe95:	48 8b 93 c0 03 00 00 	mov    0x3c0(%rbx),%rdx
build_mmio_read(__readw, "w", unsigned short, "=r", )
build_mmio_read(__readl, "l", unsigned int, "=r", )

build_mmio_write(writeb, "b", unsigned char, "q", :"memory")
build_mmio_write(writew, "w", unsigned short, "r", :"memory")
build_mmio_write(writel, "l", unsigned int, "r", :"memory")
    fe9c:	89 02                	mov    %eax,(%rdx)

	/* Read the PHY Specific Control Register (0x10) */
	e1000_read_phy_reg(hw, M88E1000_PHY_SPEC_CTRL, &phy_reg);
    fe9e:	48 8d 55 e6          	lea    -0x1a(%rbp),%rdx
    fea2:	be 10 00 00 00       	mov    $0x10,%esi
    fea7:	4c 89 e7             	mov    %r12,%rdi
    feaa:	e8 00 00 00 00       	callq  feaf <e1000_set_phy_loopback+0x8f>

	/* Clear Auto-Crossover bits in PHY Specific Control Register
	 * (bits 6:5).
	 */
	phy_reg &= ~M88E1000_PSCR_AUTO_X_MODE;
    feaf:	0f b7 55 e6          	movzwl -0x1a(%rbp),%edx
	e1000_write_phy_reg(hw, M88E1000_PHY_SPEC_CTRL, phy_reg);
    feb3:	be 10 00 00 00       	mov    $0x10,%esi
    feb8:	4c 89 e7             	mov    %r12,%rdi
	e1000_read_phy_reg(hw, M88E1000_PHY_SPEC_CTRL, &phy_reg);

	/* Clear Auto-Crossover bits in PHY Specific Control Register
	 * (bits 6:5).
	 */
	phy_reg &= ~M88E1000_PSCR_AUTO_X_MODE;
    febb:	83 e2 9f             	and    $0xffffff9f,%edx
    febe:	66 89 55 e6          	mov    %dx,-0x1a(%rbp)
	e1000_write_phy_reg(hw, M88E1000_PHY_SPEC_CTRL, phy_reg);
    fec2:	0f b7 d2             	movzwl %dx,%edx
    fec5:	e8 00 00 00 00       	callq  feca <e1000_set_phy_loopback+0xaa>

	/* Perform software reset on the PHY */
	e1000_phy_reset(hw);
    feca:	4c 89 e7             	mov    %r12,%rdi
    fecd:	e8 00 00 00 00       	callq  fed2 <e1000_set_phy_loopback+0xb2>

	/* Have to setup TX_CLK and TX_CRS after software reset */
	e1000_phy_reset_clk_and_crs(adapter);
    fed2:	48 89 df             	mov    %rbx,%rdi
    fed5:	e8 66 f0 ff ff       	callq  ef40 <e1000_phy_reset_clk_and_crs>

	e1000_write_phy_reg(hw, PHY_CTRL, 0x8100);
    feda:	31 f6                	xor    %esi,%esi
    fedc:	ba 00 81 00 00       	mov    $0x8100,%edx
    fee1:	4c 89 e7             	mov    %r12,%rdi
    fee4:	e8 00 00 00 00       	callq  fee9 <e1000_set_phy_loopback+0xc9>

	/* Wait for reset to complete. */
	udelay(500);
    fee9:	bf ac c4 20 00       	mov    $0x20c4ac,%edi
    feee:	e8 00 00 00 00       	callq  fef3 <e1000_set_phy_loopback+0xd3>

	/* Have to setup TX_CLK and TX_CRS after software reset */
	e1000_phy_reset_clk_and_crs(adapter);
    fef3:	48 89 df             	mov    %rbx,%rdi
    fef6:	e8 45 f0 ff ff       	callq  ef40 <e1000_phy_reset_clk_and_crs>

	/* Write out to PHY registers 29 and 30 to disable the Receiver. */
	e1000_phy_disable_receiver(adapter);
    fefb:	48 89 df             	mov    %rbx,%rdi
    fefe:	e8 dd ef ff ff       	callq  eee0 <e1000_phy_disable_receiver>

	/* Set the loopback bit in the PHY control register. */
	e1000_read_phy_reg(hw, PHY_CTRL, &phy_reg);
    ff03:	48 8d 55 e6          	lea    -0x1a(%rbp),%rdx
    ff07:	31 f6                	xor    %esi,%esi
    ff09:	4c 89 e7             	mov    %r12,%rdi
    ff0c:	e8 00 00 00 00       	callq  ff11 <e1000_set_phy_loopback+0xf1>
	phy_reg |= MII_CR_LOOPBACK;
    ff11:	0f b7 55 e6          	movzwl -0x1a(%rbp),%edx
	e1000_write_phy_reg(hw, PHY_CTRL, phy_reg);
    ff15:	31 f6                	xor    %esi,%esi
    ff17:	4c 89 e7             	mov    %r12,%rdi
	/* Write out to PHY registers 29 and 30 to disable the Receiver. */
	e1000_phy_disable_receiver(adapter);

	/* Set the loopback bit in the PHY control register. */
	e1000_read_phy_reg(hw, PHY_CTRL, &phy_reg);
	phy_reg |= MII_CR_LOOPBACK;
    ff1a:	80 ce 40             	or     $0x40,%dh
    ff1d:	66 89 55 e6          	mov    %dx,-0x1a(%rbp)
	e1000_write_phy_reg(hw, PHY_CTRL, phy_reg);
    ff21:	0f b7 d2             	movzwl %dx,%edx
    ff24:	e8 00 00 00 00       	callq  ff29 <e1000_set_phy_loopback+0x109>

	/* Setup TX_CLK and TX_CRS one more time. */
	e1000_phy_reset_clk_and_crs(adapter);
    ff29:	48 89 df             	mov    %rbx,%rdi
    ff2c:	e8 0f f0 ff ff       	callq  ef40 <e1000_phy_reset_clk_and_crs>

	/* Check Phy Configuration */
	e1000_read_phy_reg(hw, PHY_CTRL, &phy_reg);
    ff31:	48 8d 55 e6          	lea    -0x1a(%rbp),%rdx
    ff35:	31 f6                	xor    %esi,%esi
    ff37:	4c 89 e7             	mov    %r12,%rdi
    ff3a:	e8 00 00 00 00       	callq  ff3f <e1000_set_phy_loopback+0x11f>
	if (phy_reg != 0x4100)
    ff3f:	66 81 7d e6 00 41    	cmpw   $0x4100,-0x1a(%rbp)
    ff45:	0f 84 ee 00 00 00    	je     10039 <e1000_set_phy_loopback+0x219>
			/* Attempt to setup Loopback mode on Non-integrated PHY.
			 * Some PHY registers get corrupted at random, so
			 * attempt this 10 times.
			 */
			while (e1000_nonintegrated_phy_loopback(adapter) &&
			       count++ < 10);
    ff4b:	41 83 c5 01          	add    $0x1,%r13d
		if (hw->media_type == e1000_media_type_copper) {
			/* Attempt to setup Loopback mode on Non-integrated PHY.
			 * Some PHY registers get corrupted at random, so
			 * attempt this 10 times.
			 */
			while (e1000_nonintegrated_phy_loopback(adapter) &&
    ff4f:	66 41 83 fd 0b       	cmp    $0xb,%r13w
    ff54:	0f 85 2d ff ff ff    	jne    fe87 <e1000_set_phy_loopback+0x67>
		phy_reg |= MII_CR_LOOPBACK;
		e1000_write_phy_reg(hw, PHY_CTRL, phy_reg);
		return 0;
	}

	return 8;
    ff5a:	b8 08 00 00 00       	mov    $0x8,%eax
    ff5f:	eb 28                	jmp    ff89 <e1000_set_phy_loopback+0x169>
		return e1000_integrated_phy_loopback(adapter);
	default:
		/* Default PHY loopback work is to read the MII
		 * control register and assert bit 14 (loopback mode).
		 */
		e1000_read_phy_reg(hw, PHY_CTRL, &phy_reg);
    ff61:	48 8d 55 e4          	lea    -0x1c(%rbp),%rdx
    ff65:	31 f6                	xor    %esi,%esi
    ff67:	4c 89 e7             	mov    %r12,%rdi
    ff6a:	e8 00 00 00 00       	callq  ff6f <e1000_set_phy_loopback+0x14f>
		phy_reg |= MII_CR_LOOPBACK;
    ff6f:	0f b7 55 e4          	movzwl -0x1c(%rbp),%edx
		e1000_write_phy_reg(hw, PHY_CTRL, phy_reg);
    ff73:	31 f6                	xor    %esi,%esi
    ff75:	4c 89 e7             	mov    %r12,%rdi
	default:
		/* Default PHY loopback work is to read the MII
		 * control register and assert bit 14 (loopback mode).
		 */
		e1000_read_phy_reg(hw, PHY_CTRL, &phy_reg);
		phy_reg |= MII_CR_LOOPBACK;
    ff78:	80 ce 40             	or     $0x40,%dh
    ff7b:	66 89 55 e4          	mov    %dx,-0x1c(%rbp)
		e1000_write_phy_reg(hw, PHY_CTRL, phy_reg);
    ff7f:	0f b7 d2             	movzwl %dx,%edx
    ff82:	e8 00 00 00 00       	callq  ff87 <e1000_set_phy_loopback+0x167>
		return 0;
    ff87:	31 c0                	xor    %eax,%eax
	}

	return 8;
}
    ff89:	48 83 c4 08          	add    $0x8,%rsp
    ff8d:	5b                   	pop    %rbx
    ff8e:	41 5c                	pop    %r12
    ff90:	41 5d                	pop    %r13
    ff92:	5d                   	pop    %rbp
    ff93:	c3                   	retq   
	u32 ctrl_reg = 0;
	u32 stat_reg = 0;

	hw->autoneg = false;

	if (hw->phy_type == e1000_phy_m88) {
    ff94:	8b b7 dc 03 00 00    	mov    0x3dc(%rdi),%esi
{
	struct e1000_hw *hw = &adapter->hw;
	u32 ctrl_reg = 0;
	u32 stat_reg = 0;

	hw->autoneg = false;
    ff9a:	c6 87 af 04 00 00 00 	movb   $0x0,0x4af(%rdi)

	if (hw->phy_type == e1000_phy_m88) {
    ffa1:	85 f6                	test   %esi,%esi
    ffa3:	0f 84 cf 00 00 00    	je     10078 <e1000_set_phy_loopback+0x258>
		e1000_write_phy_reg(hw, PHY_CTRL, 0x9140);
		/* autoneg off */
		e1000_write_phy_reg(hw, PHY_CTRL, 0x8140);
	}

	ctrl_reg = er32(CTRL);
    ffa9:	48 8b 83 c0 03 00 00 	mov    0x3c0(%rbx),%rax
{ asm volatile("mov" size " %0,%1": :reg (val), \
"m" (*(volatile type __force *)addr) barrier); }

build_mmio_read(readb, "b", unsigned char, "=q", :"memory")
build_mmio_read(readw, "w", unsigned short, "=r", :"memory")
build_mmio_read(readl, "l", unsigned int, "=r", :"memory")
    ffb0:	8b 00                	mov    (%rax),%eax

	/* force 1000, set loopback */
	e1000_write_phy_reg(hw, PHY_CTRL, 0x4140);
    ffb2:	ba 40 41 00 00       	mov    $0x4140,%edx
    ffb7:	31 f6                	xor    %esi,%esi
    ffb9:	4c 89 e7             	mov    %r12,%rdi
    ffbc:	e8 00 00 00 00       	callq  ffc1 <e1000_set_phy_loopback+0x1a1>

	/* Now set up the MAC to the same speed/duplex as the PHY. */
	ctrl_reg = er32(CTRL);
    ffc1:	48 8b 83 c0 03 00 00 	mov    0x3c0(%rbx),%rax
    ffc8:	8b 00                	mov    (%rax),%eax
	ctrl_reg |= (E1000_CTRL_FRCSPD | /* Set the Force Speed Bit */
			E1000_CTRL_FRCDPX | /* Set the Force Duplex Bit */
			E1000_CTRL_SPD_1000 |/* Force Speed to 1000 */
			E1000_CTRL_FD); /* Force Duplex to FULL */

	if (hw->media_type == e1000_media_type_copper &&
    ffca:	8b 8b e4 03 00 00    	mov    0x3e4(%rbx),%ecx
	/* force 1000, set loopback */
	e1000_write_phy_reg(hw, PHY_CTRL, 0x4140);

	/* Now set up the MAC to the same speed/duplex as the PHY. */
	ctrl_reg = er32(CTRL);
	ctrl_reg &= ~E1000_CTRL_SPD_SEL; /* Clear the speed sel bits */
    ffd0:	80 e4 fc             	and    $0xfc,%ah
	ctrl_reg |= (E1000_CTRL_FRCSPD | /* Set the Force Speed Bit */
			E1000_CTRL_FRCDPX | /* Set the Force Duplex Bit */
			E1000_CTRL_SPD_1000 |/* Force Speed to 1000 */
			E1000_CTRL_FD); /* Force Duplex to FULL */

	if (hw->media_type == e1000_media_type_copper &&
    ffd3:	85 c9                	test   %ecx,%ecx
    ffd5:	75 0a                	jne    ffe1 <e1000_set_phy_loopback+0x1c1>
    ffd7:	8b 93 dc 03 00 00    	mov    0x3dc(%rbx),%edx
    ffdd:	85 d2                	test   %edx,%edx
    ffdf:	74 4f                	je     10030 <e1000_set_phy_loopback+0x210>
		ctrl_reg |= E1000_CTRL_ILOS; /* Invert Loss of Signal */
	else {
		/* Set the ILOS bit on the fiber Nic is half
		 * duplex link is detected.
		 */
		stat_reg = er32(STATUS);
    ffe1:	48 8b 93 c0 03 00 00 	mov    0x3c0(%rbx),%rdx
    ffe8:	8b 4a 08             	mov    0x8(%rdx),%ecx
	e1000_write_phy_reg(hw, PHY_CTRL, 0x4140);

	/* Now set up the MAC to the same speed/duplex as the PHY. */
	ctrl_reg = er32(CTRL);
	ctrl_reg &= ~E1000_CTRL_SPD_SEL; /* Clear the speed sel bits */
	ctrl_reg |= (E1000_CTRL_FRCSPD | /* Set the Force Speed Bit */
    ffeb:	89 c2                	mov    %eax,%edx
    ffed:	0d c1 1a 00 00       	or     $0x1ac1,%eax
    fff2:	81 ca 01 1a 00 00    	or     $0x1a01,%edx
    fff8:	83 e1 01             	and    $0x1,%ecx
    fffb:	0f 44 d0             	cmove  %eax,%edx
		stat_reg = er32(STATUS);
		if ((stat_reg & E1000_STATUS_FD) == 0)
			ctrl_reg |= (E1000_CTRL_ILOS | E1000_CTRL_SLU);
	}

	ew32(CTRL, ctrl_reg);
    fffe:	48 8b 83 c0 03 00 00 	mov    0x3c0(%rbx),%rax
build_mmio_read(__readw, "w", unsigned short, "=r", )
build_mmio_read(__readl, "l", unsigned int, "=r", )

build_mmio_write(writeb, "b", unsigned char, "q", :"memory")
build_mmio_write(writew, "w", unsigned short, "r", :"memory")
build_mmio_write(writel, "l", unsigned int, "r", :"memory")
   10005:	89 10                	mov    %edx,(%rax)

	/* Disable the receiver on the PHY so when a cable is plugged in, the
	 * PHY does not begin to autoneg when a cable is reconnected to the NIC.
	 */
	if (hw->phy_type == e1000_phy_m88)
   10007:	8b 83 dc 03 00 00    	mov    0x3dc(%rbx),%eax
   1000d:	85 c0                	test   %eax,%eax
   1000f:	75 08                	jne    10019 <e1000_set_phy_loopback+0x1f9>
		e1000_phy_disable_receiver(adapter);
   10011:	48 89 df             	mov    %rbx,%rdi
   10014:	e8 c7 ee ff ff       	callq  eee0 <e1000_phy_disable_receiver>

	udelay(500);
   10019:	bf ac c4 20 00       	mov    $0x20c4ac,%edi
   1001e:	e8 00 00 00 00       	callq  10023 <e1000_set_phy_loopback+0x203>
		e1000_write_phy_reg(hw, PHY_CTRL, phy_reg);
		return 0;
	}

	return 8;
}
   10023:	48 83 c4 08          	add    $0x8,%rsp
	case e1000_82546_rev_3:
	case e1000_82541:
	case e1000_82541_rev_2:
	case e1000_82547:
	case e1000_82547_rev_2:
		return e1000_integrated_phy_loopback(adapter);
   10027:	31 c0                	xor    %eax,%eax
		e1000_write_phy_reg(hw, PHY_CTRL, phy_reg);
		return 0;
	}

	return 8;
}
   10029:	5b                   	pop    %rbx
   1002a:	41 5c                	pop    %r12
   1002c:	41 5d                	pop    %r13
   1002e:	5d                   	pop    %rbp
   1002f:	c3                   	retq   
			E1000_CTRL_SPD_1000 |/* Force Speed to 1000 */
			E1000_CTRL_FD); /* Force Duplex to FULL */

	if (hw->media_type == e1000_media_type_copper &&
	    hw->phy_type == e1000_phy_m88)
		ctrl_reg |= E1000_CTRL_ILOS; /* Invert Loss of Signal */
   10030:	0d 81 1a 00 00       	or     $0x1a81,%eax
   10035:	89 c2                	mov    %eax,%edx
   10037:	eb c5                	jmp    fffe <e1000_set_phy_loopback+0x1de>
	/* Check Phy Configuration */
	e1000_read_phy_reg(hw, PHY_CTRL, &phy_reg);
	if (phy_reg != 0x4100)
		return 9;

	e1000_read_phy_reg(hw, M88E1000_EXT_PHY_SPEC_CTRL, &phy_reg);
   10039:	48 8d 55 e6          	lea    -0x1a(%rbp),%rdx
   1003d:	be 14 00 00 00       	mov    $0x14,%esi
   10042:	4c 89 e7             	mov    %r12,%rdi
   10045:	e8 00 00 00 00       	callq  1004a <e1000_set_phy_loopback+0x22a>
	if (phy_reg != 0x0070)
   1004a:	66 83 7d e6 70       	cmpw   $0x70,-0x1a(%rbp)
   1004f:	0f 85 f6 fe ff ff    	jne    ff4b <e1000_set_phy_loopback+0x12b>
		return 10;

	e1000_read_phy_reg(hw, 29, &phy_reg);
   10055:	48 8d 55 e6          	lea    -0x1a(%rbp),%rdx
   10059:	be 1d 00 00 00       	mov    $0x1d,%esi
   1005e:	4c 89 e7             	mov    %r12,%rdi
   10061:	e8 00 00 00 00       	callq  10066 <e1000_set_phy_loopback+0x246>
	if (phy_reg != 0x001A)
   10066:	66 83 7d e6 1a       	cmpw   $0x1a,-0x1a(%rbp)
   1006b:	0f 85 da fe ff ff    	jne    ff4b <e1000_set_phy_loopback+0x12b>
			 * attempt this 10 times.
			 */
			while (e1000_nonintegrated_phy_loopback(adapter) &&
			       count++ < 10);
			if (count < 11)
				return 0;
   10071:	31 c0                	xor    %eax,%eax
   10073:	e9 11 ff ff ff       	jmpq   ff89 <e1000_set_phy_loopback+0x169>

	hw->autoneg = false;

	if (hw->phy_type == e1000_phy_m88) {
		/* Auto-MDI/MDIX Off */
		e1000_write_phy_reg(hw,
   10078:	4c 89 e7             	mov    %r12,%rdi
   1007b:	ba 08 08 00 00       	mov    $0x808,%edx
   10080:	be 10 00 00 00       	mov    $0x10,%esi
   10085:	e8 00 00 00 00       	callq  1008a <e1000_set_phy_loopback+0x26a>
				    M88E1000_PHY_SPEC_CTRL, 0x0808);
		/* reset to update Auto-MDI/MDIX */
		e1000_write_phy_reg(hw, PHY_CTRL, 0x9140);
   1008a:	31 f6                	xor    %esi,%esi
   1008c:	4c 89 e7             	mov    %r12,%rdi
   1008f:	ba 40 91 00 00       	mov    $0x9140,%edx
   10094:	e8 00 00 00 00       	callq  10099 <e1000_set_phy_loopback+0x279>
		/* autoneg off */
		e1000_write_phy_reg(hw, PHY_CTRL, 0x8140);
   10099:	ba 40 81 00 00       	mov    $0x8140,%edx
   1009e:	31 f6                	xor    %esi,%esi
   100a0:	4c 89 e7             	mov    %r12,%rdi
   100a3:	e8 00 00 00 00       	callq  100a8 <e1000_set_phy_loopback+0x288>
   100a8:	e9 fc fe ff ff       	jmpq   ffa9 <e1000_set_phy_loopback+0x189>
   100ad:	0f 1f 00             	nopl   (%rax)

00000000000100b0 <e1000_get_eeprom>:
	return hw->eeprom.word_size * 2;
}

static int e1000_get_eeprom(struct net_device *netdev,
			    struct ethtool_eeprom *eeprom, u8 *bytes)
{
   100b0:	e8 00 00 00 00       	callq  100b5 <e1000_get_eeprom+0x5>
   100b5:	55                   	push   %rbp
   100b6:	48 89 e5             	mov    %rsp,%rbp
   100b9:	41 57                	push   %r15
   100bb:	41 56                	push   %r14
   100bd:	49 89 fe             	mov    %rdi,%r14
	struct e1000_adapter *adapter = netdev_priv(netdev);
	struct e1000_hw *hw = &adapter->hw;
   100c0:	49 8d 86 00 0c 00 00 	lea    0xc00(%r14),%rax
	return hw->eeprom.word_size * 2;
}

static int e1000_get_eeprom(struct net_device *netdev,
			    struct ethtool_eeprom *eeprom, u8 *bytes)
{
   100c7:	41 55                	push   %r13
   100c9:	41 54                	push   %r12
   100cb:	53                   	push   %rbx
   100cc:	48 83 ec 20          	sub    $0x20,%rsp
   100d0:	48 89 55 c0          	mov    %rdx,-0x40(%rbp)
	u16 *eeprom_buff;
	int first_word, last_word;
	int ret_val = 0;
	u16 i;

	if (eeprom->len == 0)
   100d4:	8b 56 0c             	mov    0xc(%rsi),%edx
	return hw->eeprom.word_size * 2;
}

static int e1000_get_eeprom(struct net_device *netdev,
			    struct ethtool_eeprom *eeprom, u8 *bytes)
{
   100d7:	48 89 75 c8          	mov    %rsi,-0x38(%rbp)
	struct e1000_adapter *adapter = netdev_priv(netdev);
	struct e1000_hw *hw = &adapter->hw;
   100db:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
	u16 *eeprom_buff;
	int first_word, last_word;
	int ret_val = 0;
	u16 i;

	if (eeprom->len == 0)
   100df:	85 d2                	test   %edx,%edx
   100e1:	0f 84 10 01 00 00    	je     101f7 <e1000_get_eeprom+0x147>
		return -EINVAL;

	eeprom->magic = hw->vendor_id | (hw->device_id << 16);
   100e7:	41 0f b7 86 e6 0c 00 	movzwl 0xce6(%r14),%eax
   100ee:	00 
   100ef:	41 0f b7 8e e8 0c 00 	movzwl 0xce8(%r14),%ecx
   100f6:	00 
   100f7:	c1 e0 10             	shl    $0x10,%eax
   100fa:	09 c8                	or     %ecx,%eax
   100fc:	89 46 04             	mov    %eax,0x4(%rsi)

	first_word = eeprom->offset >> 1;
   100ff:	8b 46 08             	mov    0x8(%rsi),%eax
			return kmem_cache_alloc_trace(kmalloc_caches[index],
					flags, size);
		}
#endif
	}
	return __kmalloc(size, flags);
   10102:	be c0 00 40 02       	mov    $0x24000c0,%esi
	last_word = (eeprom->offset + eeprom->len - 1) >> 1;
   10107:	8d 54 02 ff          	lea    -0x1(%rdx,%rax,1),%edx
	if (eeprom->len == 0)
		return -EINVAL;

	eeprom->magic = hw->vendor_id | (hw->device_id << 16);

	first_word = eeprom->offset >> 1;
   1010b:	89 c1                	mov    %eax,%ecx
   1010d:	d1 e9                	shr    %ecx
	last_word = (eeprom->offset + eeprom->len - 1) >> 1;
   1010f:	d1 ea                	shr    %edx

	eeprom_buff = kmalloc(sizeof(u16) *
			(last_word - first_word + 1), GFP_KERNEL);
   10111:	89 4d bc             	mov    %ecx,-0x44(%rbp)
   10114:	89 d3                	mov    %edx,%ebx
   10116:	89 55 b8             	mov    %edx,-0x48(%rbp)
   10119:	29 cb                	sub    %ecx,%ebx
   1011b:	83 c3 01             	add    $0x1,%ebx
	eeprom->magic = hw->vendor_id | (hw->device_id << 16);

	first_word = eeprom->offset >> 1;
	last_word = (eeprom->offset + eeprom->len - 1) >> 1;

	eeprom_buff = kmalloc(sizeof(u16) *
   1011e:	48 63 fb             	movslq %ebx,%rdi
   10121:	48 01 ff             	add    %rdi,%rdi
   10124:	e8 00 00 00 00       	callq  10129 <e1000_get_eeprom+0x79>
			(last_word - first_word + 1), GFP_KERNEL);
	if (!eeprom_buff)
   10129:	48 85 c0             	test   %rax,%rax
   1012c:	49 89 c4             	mov    %rax,%r12
   1012f:	0f 84 c9 00 00 00    	je     101fe <e1000_get_eeprom+0x14e>
		return -ENOMEM;

	if (hw->eeprom.type == e1000_eeprom_spi)
   10135:	41 83 be 50 0c 00 00 	cmpl   $0x1,0xc50(%r14)
   1013c:	01 
   1013d:	8b 4d bc             	mov    -0x44(%rbp),%ecx
   10140:	8b 55 b8             	mov    -0x48(%rbp),%edx
   10143:	0f 84 8e 00 00 00    	je     101d7 <e1000_get_eeprom+0x127>
		ret_val = e1000_read_eeprom(hw, first_word,
					    last_word - first_word + 1,
					    eeprom_buff);
	else {
		for (i = 0; i < last_word - first_word + 1; i++) {
   10149:	45 31 ff             	xor    %r15d,%r15d
   1014c:	45 31 d2             	xor    %r10d,%r10d
   1014f:	85 db                	test   %ebx,%ebx
   10151:	41 89 ce             	mov    %ecx,%r14d
   10154:	7f 13                	jg     10169 <e1000_get_eeprom+0xb9>
   10156:	eb 44                	jmp    1019c <e1000_get_eeprom+0xec>
   10158:	45 8d 4d 01          	lea    0x1(%r13),%r9d
   1015c:	41 83 c7 01          	add    $0x1,%r15d
   10160:	45 0f b7 c9          	movzwl %r9w,%r9d
   10164:	44 39 cb             	cmp    %r9d,%ebx
   10167:	7e 27                	jle    10190 <e1000_get_eeprom+0xe0>
			ret_val = e1000_read_eeprom(hw, first_word + i, 1,
   10169:	41 0f b7 c7          	movzwl %r15w,%eax
   1016d:	43 8d 34 3e          	lea    (%r14,%r15,1),%esi
   10171:	48 8b 7d d0          	mov    -0x30(%rbp),%rdi
   10175:	49 8d 0c 44          	lea    (%r12,%rax,2),%rcx
   10179:	ba 01 00 00 00       	mov    $0x1,%edx
   1017e:	45 89 fd             	mov    %r15d,%r13d
   10181:	0f b7 f6             	movzwl %si,%esi
   10184:	e8 00 00 00 00       	callq  10189 <e1000_get_eeprom+0xd9>
						    &eeprom_buff[i]);
			if (ret_val)
   10189:	85 c0                	test   %eax,%eax
		ret_val = e1000_read_eeprom(hw, first_word,
					    last_word - first_word + 1,
					    eeprom_buff);
	else {
		for (i = 0; i < last_word - first_word + 1; i++) {
			ret_val = e1000_read_eeprom(hw, first_word + i, 1,
   1018b:	41 89 c2             	mov    %eax,%r10d
						    &eeprom_buff[i]);
			if (ret_val)
   1018e:	74 c8                	je     10158 <e1000_get_eeprom+0xa8>
	if (hw->eeprom.type == e1000_eeprom_spi)
		ret_val = e1000_read_eeprom(hw, first_word,
					    last_word - first_word + 1,
					    eeprom_buff);
	else {
		for (i = 0; i < last_word - first_word + 1; i++) {
   10190:	31 d2                	xor    %edx,%edx
				break;
		}
	}

	/* Device's eeprom is always little-endian, word addressable */
	for (i = 0; i < last_word - first_word + 1; i++)
   10192:	83 c2 01             	add    $0x1,%edx
   10195:	0f b7 ca             	movzwl %dx,%ecx
   10198:	39 cb                	cmp    %ecx,%ebx
   1019a:	7f f6                	jg     10192 <e1000_get_eeprom+0xe2>
		le16_to_cpus(&eeprom_buff[i]);

	memcpy(bytes, (u8 *)eeprom_buff + (eeprom->offset & 1),
   1019c:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
   101a0:	48 8b 7d c0          	mov    -0x40(%rbp),%rdi
   101a4:	44 89 55 d0          	mov    %r10d,-0x30(%rbp)
   101a8:	8b 70 08             	mov    0x8(%rax),%esi
   101ab:	8b 50 0c             	mov    0xc(%rax),%edx
   101ae:	83 e6 01             	and    $0x1,%esi
   101b1:	4c 01 e6             	add    %r12,%rsi
   101b4:	e8 00 00 00 00       	callq  101b9 <e1000_get_eeprom+0x109>
	       eeprom->len);
	kfree(eeprom_buff);
   101b9:	4c 89 e7             	mov    %r12,%rdi
   101bc:	e8 00 00 00 00       	callq  101c1 <e1000_get_eeprom+0x111>

	return ret_val;
   101c1:	44 8b 55 d0          	mov    -0x30(%rbp),%r10d
   101c5:	44 89 d0             	mov    %r10d,%eax
}
   101c8:	48 83 c4 20          	add    $0x20,%rsp
   101cc:	5b                   	pop    %rbx
   101cd:	41 5c                	pop    %r12
   101cf:	41 5d                	pop    %r13
   101d1:	41 5e                	pop    %r14
   101d3:	41 5f                	pop    %r15
   101d5:	5d                   	pop    %rbp
   101d6:	c3                   	retq   
			(last_word - first_word + 1), GFP_KERNEL);
	if (!eeprom_buff)
		return -ENOMEM;

	if (hw->eeprom.type == e1000_eeprom_spi)
		ret_val = e1000_read_eeprom(hw, first_word,
   101d7:	29 ca                	sub    %ecx,%edx
   101d9:	48 8b 7d d0          	mov    -0x30(%rbp),%rdi
   101dd:	0f b7 f1             	movzwl %cx,%esi
   101e0:	83 c2 01             	add    $0x1,%edx
   101e3:	48 89 c1             	mov    %rax,%rcx
   101e6:	0f b7 d2             	movzwl %dx,%edx
   101e9:	e8 00 00 00 00       	callq  101ee <e1000_get_eeprom+0x13e>
				break;
		}
	}

	/* Device's eeprom is always little-endian, word addressable */
	for (i = 0; i < last_word - first_word + 1; i++)
   101ee:	85 db                	test   %ebx,%ebx
			(last_word - first_word + 1), GFP_KERNEL);
	if (!eeprom_buff)
		return -ENOMEM;

	if (hw->eeprom.type == e1000_eeprom_spi)
		ret_val = e1000_read_eeprom(hw, first_word,
   101f0:	41 89 c2             	mov    %eax,%r10d
				break;
		}
	}

	/* Device's eeprom is always little-endian, word addressable */
	for (i = 0; i < last_word - first_word + 1; i++)
   101f3:	7f 9b                	jg     10190 <e1000_get_eeprom+0xe0>
   101f5:	eb a5                	jmp    1019c <e1000_get_eeprom+0xec>
	int first_word, last_word;
	int ret_val = 0;
	u16 i;

	if (eeprom->len == 0)
		return -EINVAL;
   101f7:	b8 ea ff ff ff       	mov    $0xffffffea,%eax
   101fc:	eb ca                	jmp    101c8 <e1000_get_eeprom+0x118>
	last_word = (eeprom->offset + eeprom->len - 1) >> 1;

	eeprom_buff = kmalloc(sizeof(u16) *
			(last_word - first_word + 1), GFP_KERNEL);
	if (!eeprom_buff)
		return -ENOMEM;
   101fe:	b8 f4 ff ff ff       	mov    $0xfffffff4,%eax
   10203:	eb c3                	jmp    101c8 <e1000_get_eeprom+0x118>
   10205:	66 66 2e 0f 1f 84 00 	data32 nopw %cs:0x0(%rax,%rax,1)
   1020c:	00 00 00 00 

0000000000010210 <e1000_set_ringparam>:
	ring->tx_pending = txdr->count;
}

static int e1000_set_ringparam(struct net_device *netdev,
			       struct ethtool_ringparam *ring)
{
   10210:	e8 00 00 00 00       	callq  10215 <e1000_set_ringparam+0x5>
   10215:	55                   	push   %rbp
	struct e1000_tx_ring *txdr, *tx_old;
	struct e1000_rx_ring *rxdr, *rx_old;
	int i, err;

	if ((ring->rx_mini_pending) || (ring->rx_jumbo_pending))
		return -EINVAL;
   10216:	b8 ea ff ff ff       	mov    $0xffffffea,%eax
	ring->tx_pending = txdr->count;
}

static int e1000_set_ringparam(struct net_device *netdev,
			       struct ethtool_ringparam *ring)
{
   1021b:	48 89 e5             	mov    %rsp,%rbp
   1021e:	41 57                	push   %r15
   10220:	41 56                	push   %r14
   10222:	41 55                	push   %r13
   10224:	41 54                	push   %r12
   10226:	49 89 f4             	mov    %rsi,%r12
   10229:	53                   	push   %rbx
   1022a:	48 89 fb             	mov    %rdi,%rbx
   1022d:	48 83 ec 18          	sub    $0x18,%rsp
	struct e1000_adapter *adapter = netdev_priv(netdev);
	struct e1000_hw *hw = &adapter->hw;
	e1000_mac_type mac_type = hw->mac_type;
   10231:	44 8b bf 18 0c 00 00 	mov    0xc18(%rdi),%r15d
	struct e1000_tx_ring *txdr, *tx_old;
	struct e1000_rx_ring *rxdr, *rx_old;
	int i, err;

	if ((ring->rx_mini_pending) || (ring->rx_jumbo_pending))
   10238:	8b 7e 18             	mov    0x18(%rsi),%edi
   1023b:	85 ff                	test   %edi,%edi
   1023d:	75 07                	jne    10246 <e1000_set_ringparam+0x36>
   1023f:	8b 76 1c             	mov    0x1c(%rsi),%esi
   10242:	85 f6                	test   %esi,%esi
   10244:	74 0f                	je     10255 <e1000_set_ringparam+0x45>
err_alloc_tx:
	e1000_up(adapter);
err_setup:
	clear_bit(__E1000_RESETTING, &adapter->flags);
	return err;
}
   10246:	48 83 c4 18          	add    $0x18,%rsp
   1024a:	5b                   	pop    %rbx
   1024b:	41 5c                	pop    %r12
   1024d:	41 5d                	pop    %r13
   1024f:	41 5e                	pop    %r14
   10251:	41 5f                	pop    %r15
   10253:	5d                   	pop    %rbp
   10254:	c3                   	retq   
   10255:	4c 8d ab e8 0f 00 00 	lea    0xfe8(%rbx),%r13
 * This operation is atomic and cannot be reordered.
 * It also implies a memory barrier.
 */
static inline int test_and_set_bit(long nr, volatile unsigned long *addr)
{
	GEN_BINARY_RMWcc(LOCK_PREFIX "bts", *addr, "Ir", nr, "%0", "c");
   1025c:	f0 41 0f ba 6d 00 01 	lock btsl $0x1,0x0(%r13)
   10263:	0f 82 86 01 00 00    	jb     103ef <e1000_set_ringparam+0x1df>
}

static int e1000_set_ringparam(struct net_device *netdev,
			       struct ethtool_ringparam *ring)
{
	struct e1000_adapter *adapter = netdev_priv(netdev);
   10269:	4c 8d ab 40 08 00 00 	lea    0x840(%rbx),%r13
		return -EINVAL;

	while (test_and_set_bit(__E1000_RESETTING, &adapter->flags))
		msleep(1);

	if (netif_running(adapter->netdev))
   10270:	48 8b 83 f0 0b 00 00 	mov    0xbf0(%rbx),%rax
}

static __always_inline int constant_test_bit(long nr, const volatile unsigned long *addr)
{
	return ((1UL << (nr & (BITS_PER_LONG-1))) &
		(addr[nr >> _BITOPS_LONG_SHIFT])) != 0;
   10277:	48 8b 40 48          	mov    0x48(%rax),%rax
   1027b:	a8 01                	test   $0x1,%al
   1027d:	0f 85 a7 01 00 00    	jne    1042a <e1000_set_ringparam+0x21a>
		e1000_down(adapter);

	tx_old = adapter->tx_ring;
   10283:	48 8b 83 80 0a 00 00 	mov    0xa80(%rbx),%rax
 * @size: element size.
 * @flags: the type of memory to allocate (see kmalloc).
 */
static inline void *kmalloc_array(size_t n, size_t size, gfp_t flags)
{
	if (size != 0 && n > SIZE_MAX / size)
   1028a:	48 b9 55 55 55 55 55 	movabs $0x555555555555555,%rcx
   10291:	55 55 05 
   10294:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
	rx_old = adapter->rx_ring;
   10298:	48 8b 83 e8 0a 00 00 	mov    0xae8(%rbx),%rax
   1029f:	48 89 45 c8          	mov    %rax,-0x38(%rbp)

	err = -ENOMEM;
	txdr = kcalloc(adapter->num_tx_queues, sizeof(struct e1000_tx_ring),
   102a3:	48 63 83 b8 0b 00 00 	movslq 0xbb8(%rbx),%rax
   102aa:	48 39 c8             	cmp    %rcx,%rax
   102ad:	0f 87 5d 02 00 00    	ja     10510 <e1000_set_ringparam+0x300>
		return NULL;
	return __kmalloc(n * size, flags);
   102b3:	48 8d 3c 40          	lea    (%rax,%rax,2),%rdi
   102b7:	be c0 80 40 02       	mov    $0x24080c0,%esi
   102bc:	48 c1 e7 04          	shl    $0x4,%rdi
   102c0:	e8 00 00 00 00       	callq  102c5 <e1000_set_ringparam+0xb5>
		       GFP_KERNEL);
	if (!txdr)
   102c5:	48 85 c0             	test   %rax,%rax
   102c8:	49 89 c6             	mov    %rax,%r14
   102cb:	0f 84 3f 02 00 00    	je     10510 <e1000_set_ringparam+0x300>
		goto err_alloc_tx;

	rxdr = kcalloc(adapter->num_rx_queues, sizeof(struct e1000_rx_ring),
   102d1:	48 63 bb bc 0b 00 00 	movslq 0xbbc(%rbx),%rdi
 * @size: element size.
 * @flags: the type of memory to allocate (see kmalloc).
 */
static inline void *kmalloc_array(size_t n, size_t size, gfp_t flags)
{
	if (size != 0 && n > SIZE_MAX / size)
   102d8:	48 b8 92 24 49 92 24 	movabs $0x492492492492492,%rax
   102df:	49 92 04 
   102e2:	48 39 c7             	cmp    %rax,%rdi
   102e5:	0f 87 2d 02 00 00    	ja     10518 <e1000_set_ringparam+0x308>
		return NULL;
	return __kmalloc(n * size, flags);
   102eb:	48 8d 04 fd 00 00 00 	lea    0x0(,%rdi,8),%rax
   102f2:	00 
   102f3:	48 c1 e7 06          	shl    $0x6,%rdi
   102f7:	be c0 80 40 02       	mov    $0x24080c0,%esi
   102fc:	48 29 c7             	sub    %rax,%rdi
   102ff:	e8 00 00 00 00       	callq  10304 <e1000_set_ringparam+0xf4>
		       GFP_KERNEL);
	if (!rxdr)
   10304:	48 85 c0             	test   %rax,%rax
   10307:	48 89 c6             	mov    %rax,%rsi
   1030a:	0f 84 08 02 00 00    	je     10518 <e1000_set_ringparam+0x308>
		goto err_alloc_rx;

	adapter->tx_ring = txdr;
	adapter->rx_ring = rxdr;
   10310:	48 89 83 e8 0a 00 00 	mov    %rax,0xae8(%rbx)
	rxdr = kcalloc(adapter->num_rx_queues, sizeof(struct e1000_rx_ring),
		       GFP_KERNEL);
	if (!rxdr)
		goto err_alloc_rx;

	adapter->tx_ring = txdr;
   10317:	4c 89 b3 80 0a 00 00 	mov    %r14,0xa80(%rbx)
	adapter->rx_ring = rxdr;

	rxdr->count = max(ring->rx_pending, (u32)E1000_MIN_RXD);
   1031e:	bf 30 00 00 00       	mov    $0x30,%edi
   10323:	41 83 7c 24 14 30    	cmpl   $0x30,0x14(%r12)
   10329:	89 f8                	mov    %edi,%eax
   1032b:	41 0f 43 44 24 14    	cmovae 0x14(%r12),%eax
	rxdr->count = min(rxdr->count, (u32)(mac_type < e1000_82544 ?
   10331:	41 83 ff 03          	cmp    $0x3,%r15d
		goto err_alloc_rx;

	adapter->tx_ring = txdr;
	adapter->rx_ring = rxdr;

	rxdr->count = max(ring->rx_pending, (u32)E1000_MIN_RXD);
   10335:	89 46 14             	mov    %eax,0x14(%rsi)
	rxdr->count = min(rxdr->count, (u32)(mac_type < e1000_82544 ?
   10338:	0f 86 c0 00 00 00    	jbe    103fe <e1000_set_ringparam+0x1ee>
   1033e:	3d 00 10 00 00       	cmp    $0x1000,%eax
   10343:	ba 00 10 00 00       	mov    $0x1000,%edx
   10348:	0f 46 d0             	cmovbe %eax,%edx
			  E1000_MAX_RXD : E1000_MAX_82544_RXD));
	rxdr->count = ALIGN(rxdr->count, REQ_RX_DESCRIPTOR_MULTIPLE);
   1034b:	8d 42 07             	lea    0x7(%rdx),%eax
   1034e:	83 e0 f8             	and    $0xfffffff8,%eax
   10351:	89 46 14             	mov    %eax,0x14(%rsi)
	txdr->count = max(ring->tx_pending, (u32)E1000_MIN_TXD);
   10354:	41 83 7c 24 20 30    	cmpl   $0x30,0x20(%r12)
	txdr->count = min(txdr->count, (u32)(mac_type < e1000_82544 ?
   1035a:	b8 00 10 00 00       	mov    $0x1000,%eax

	rxdr->count = max(ring->rx_pending, (u32)E1000_MIN_RXD);
	rxdr->count = min(rxdr->count, (u32)(mac_type < e1000_82544 ?
			  E1000_MAX_RXD : E1000_MAX_82544_RXD));
	rxdr->count = ALIGN(rxdr->count, REQ_RX_DESCRIPTOR_MULTIPLE);
	txdr->count = max(ring->tx_pending, (u32)E1000_MIN_TXD);
   1035f:	41 0f 43 7c 24 20    	cmovae 0x20(%r12),%edi
	txdr->count = min(txdr->count, (u32)(mac_type < e1000_82544 ?
   10365:	39 c7                	cmp    %eax,%edi
   10367:	0f 47 f8             	cmova  %eax,%edi
			  E1000_MAX_TXD : E1000_MAX_82544_TXD));
	txdr->count = ALIGN(txdr->count, REQ_TX_DESCRIPTOR_MULTIPLE);

	for (i = 0; i < adapter->num_tx_queues; i++)
   1036a:	31 d2                	xor    %edx,%edx
			  E1000_MAX_RXD : E1000_MAX_82544_RXD));
	rxdr->count = ALIGN(rxdr->count, REQ_RX_DESCRIPTOR_MULTIPLE);
	txdr->count = max(ring->tx_pending, (u32)E1000_MIN_TXD);
	txdr->count = min(txdr->count, (u32)(mac_type < e1000_82544 ?
			  E1000_MAX_TXD : E1000_MAX_82544_TXD));
	txdr->count = ALIGN(txdr->count, REQ_TX_DESCRIPTOR_MULTIPLE);
   1036c:	83 c7 07             	add    $0x7,%edi
   1036f:	83 e7 f8             	and    $0xfffffff8,%edi
   10372:	41 89 7e 14          	mov    %edi,0x14(%r14)

	for (i = 0; i < adapter->num_tx_queues; i++)
   10376:	8b 8b b8 0b 00 00    	mov    0xbb8(%rbx),%ecx
   1037c:	85 c9                	test   %ecx,%ecx
   1037e:	7f 06                	jg     10386 <e1000_set_ringparam+0x176>
   10380:	eb 1f                	jmp    103a1 <e1000_set_ringparam+0x191>
   10382:	41 8b 7e 14          	mov    0x14(%r14),%edi
		txdr[i].count = txdr->count;
   10386:	48 63 c2             	movslq %edx,%rax
	txdr->count = max(ring->tx_pending, (u32)E1000_MIN_TXD);
	txdr->count = min(txdr->count, (u32)(mac_type < e1000_82544 ?
			  E1000_MAX_TXD : E1000_MAX_82544_TXD));
	txdr->count = ALIGN(txdr->count, REQ_TX_DESCRIPTOR_MULTIPLE);

	for (i = 0; i < adapter->num_tx_queues; i++)
   10389:	83 c2 01             	add    $0x1,%edx
		txdr[i].count = txdr->count;
   1038c:	48 8d 0c 40          	lea    (%rax,%rax,2),%rcx
   10390:	48 c1 e1 04          	shl    $0x4,%rcx
   10394:	41 89 7c 0e 14       	mov    %edi,0x14(%r14,%rcx,1)
	txdr->count = max(ring->tx_pending, (u32)E1000_MIN_TXD);
	txdr->count = min(txdr->count, (u32)(mac_type < e1000_82544 ?
			  E1000_MAX_TXD : E1000_MAX_82544_TXD));
	txdr->count = ALIGN(txdr->count, REQ_TX_DESCRIPTOR_MULTIPLE);

	for (i = 0; i < adapter->num_tx_queues; i++)
   10399:	39 93 b8 0b 00 00    	cmp    %edx,0xbb8(%rbx)
   1039f:	7f e1                	jg     10382 <e1000_set_ringparam+0x172>
		txdr[i].count = txdr->count;
	for (i = 0; i < adapter->num_rx_queues; i++)
   103a1:	8b 83 bc 0b 00 00    	mov    0xbbc(%rbx),%eax
   103a7:	31 d2                	xor    %edx,%edx
   103a9:	85 c0                	test   %eax,%eax
   103ab:	7e 24                	jle    103d1 <e1000_set_ringparam+0x1c1>
		rxdr[i].count = rxdr->count;
   103ad:	48 63 ca             	movslq %edx,%rcx
   103b0:	8b 46 14             	mov    0x14(%rsi),%eax
			  E1000_MAX_TXD : E1000_MAX_82544_TXD));
	txdr->count = ALIGN(txdr->count, REQ_TX_DESCRIPTOR_MULTIPLE);

	for (i = 0; i < adapter->num_tx_queues; i++)
		txdr[i].count = txdr->count;
	for (i = 0; i < adapter->num_rx_queues; i++)
   103b3:	83 c2 01             	add    $0x1,%edx
		rxdr[i].count = rxdr->count;
   103b6:	48 8d 3c cd 00 00 00 	lea    0x0(,%rcx,8),%rdi
   103bd:	00 
   103be:	48 c1 e1 06          	shl    $0x6,%rcx
   103c2:	48 29 f9             	sub    %rdi,%rcx
   103c5:	89 44 0e 14          	mov    %eax,0x14(%rsi,%rcx,1)
			  E1000_MAX_TXD : E1000_MAX_82544_TXD));
	txdr->count = ALIGN(txdr->count, REQ_TX_DESCRIPTOR_MULTIPLE);

	for (i = 0; i < adapter->num_tx_queues; i++)
		txdr[i].count = txdr->count;
	for (i = 0; i < adapter->num_rx_queues; i++)
   103c9:	39 93 bc 0b 00 00    	cmp    %edx,0xbbc(%rbx)
   103cf:	7f dc                	jg     103ad <e1000_set_ringparam+0x19d>
		rxdr[i].count = rxdr->count;

	if (netif_running(adapter->netdev)) {
   103d1:	48 8b 83 f0 0b 00 00 	mov    0xbf0(%rbx),%rax
   103d8:	48 8b 40 48          	mov    0x48(%rax),%rax
   103dc:	a8 01                	test   $0x1,%al
   103de:	75 57                	jne    10437 <e1000_set_ringparam+0x227>
 */
static __always_inline void
clear_bit(long nr, volatile unsigned long *addr)
{
	if (IS_IMMEDIATE(nr)) {
		asm volatile(LOCK_PREFIX "andb %1,%0"
   103e0:	f0 80 a3 e8 0f 00 00 	lock andb $0xfd,0xfe8(%rbx)
   103e7:	fd 
		if (err)
			goto err_setup;
	}

	clear_bit(__E1000_RESETTING, &adapter->flags);
	return 0;
   103e8:	31 c0                	xor    %eax,%eax
   103ea:	e9 57 fe ff ff       	jmpq   10246 <e1000_set_ringparam+0x36>

	if ((ring->rx_mini_pending) || (ring->rx_jumbo_pending))
		return -EINVAL;

	while (test_and_set_bit(__E1000_RESETTING, &adapter->flags))
		msleep(1);
   103ef:	bf 01 00 00 00       	mov    $0x1,%edi
   103f4:	e8 00 00 00 00       	callq  103f9 <e1000_set_ringparam+0x1e9>
   103f9:	e9 5e fe ff ff       	jmpq   1025c <e1000_set_ringparam+0x4c>

	adapter->tx_ring = txdr;
	adapter->rx_ring = rxdr;

	rxdr->count = max(ring->rx_pending, (u32)E1000_MIN_RXD);
	rxdr->count = min(rxdr->count, (u32)(mac_type < e1000_82544 ?
   103fe:	3d 00 01 00 00       	cmp    $0x100,%eax
   10403:	ba 00 01 00 00       	mov    $0x100,%edx
   10408:	0f 46 d0             	cmovbe %eax,%edx
			  E1000_MAX_RXD : E1000_MAX_82544_RXD));
	rxdr->count = ALIGN(rxdr->count, REQ_RX_DESCRIPTOR_MULTIPLE);
   1040b:	8d 42 07             	lea    0x7(%rdx),%eax
   1040e:	83 e0 f8             	and    $0xfffffff8,%eax
   10411:	89 46 14             	mov    %eax,0x14(%rsi)
	txdr->count = max(ring->tx_pending, (u32)E1000_MIN_TXD);
   10414:	41 83 7c 24 20 30    	cmpl   $0x30,0x20(%r12)
	txdr->count = min(txdr->count, (u32)(mac_type < e1000_82544 ?
   1041a:	b8 00 01 00 00       	mov    $0x100,%eax

	rxdr->count = max(ring->rx_pending, (u32)E1000_MIN_RXD);
	rxdr->count = min(rxdr->count, (u32)(mac_type < e1000_82544 ?
			  E1000_MAX_RXD : E1000_MAX_82544_RXD));
	rxdr->count = ALIGN(rxdr->count, REQ_RX_DESCRIPTOR_MULTIPLE);
	txdr->count = max(ring->tx_pending, (u32)E1000_MIN_TXD);
   1041f:	41 0f 43 7c 24 20    	cmovae 0x20(%r12),%edi
   10425:	e9 3b ff ff ff       	jmpq   10365 <e1000_set_ringparam+0x155>

	while (test_and_set_bit(__E1000_RESETTING, &adapter->flags))
		msleep(1);

	if (netif_running(adapter->netdev))
		e1000_down(adapter);
   1042a:	4c 89 ef             	mov    %r13,%rdi
   1042d:	e8 00 00 00 00       	callq  10432 <e1000_set_ringparam+0x222>
   10432:	e9 4c fe ff ff       	jmpq   10283 <e1000_set_ringparam+0x73>
	for (i = 0; i < adapter->num_rx_queues; i++)
		rxdr[i].count = rxdr->count;

	if (netif_running(adapter->netdev)) {
		/* Try to get new resources before deleting old */
		err = e1000_setup_all_rx_resources(adapter);
   10437:	4c 89 ef             	mov    %r13,%rdi
   1043a:	48 89 75 c0          	mov    %rsi,-0x40(%rbp)
   1043e:	e8 00 00 00 00       	callq  10443 <e1000_set_ringparam+0x233>
		if (err)
   10443:	85 c0                	test   %eax,%eax
	for (i = 0; i < adapter->num_rx_queues; i++)
		rxdr[i].count = rxdr->count;

	if (netif_running(adapter->netdev)) {
		/* Try to get new resources before deleting old */
		err = e1000_setup_all_rx_resources(adapter);
   10445:	41 89 c4             	mov    %eax,%r12d
		if (err)
   10448:	48 8b 75 c0          	mov    -0x40(%rbp),%rsi
   1044c:	0f 85 8e 00 00 00    	jne    104e0 <e1000_set_ringparam+0x2d0>
			goto err_setup_rx;
		err = e1000_setup_all_tx_resources(adapter);
   10452:	4c 89 ef             	mov    %r13,%rdi
   10455:	e8 00 00 00 00       	callq  1045a <e1000_set_ringparam+0x24a>
		if (err)
   1045a:	85 c0                	test   %eax,%eax
	if (netif_running(adapter->netdev)) {
		/* Try to get new resources before deleting old */
		err = e1000_setup_all_rx_resources(adapter);
		if (err)
			goto err_setup_rx;
		err = e1000_setup_all_tx_resources(adapter);
   1045c:	41 89 c4             	mov    %eax,%r12d
		if (err)
   1045f:	48 8b 75 c0          	mov    -0x40(%rbp),%rsi
   10463:	75 6b                	jne    104d0 <e1000_set_ringparam+0x2c0>
		/* save the new, restore the old in order to free it,
		 * then restore the new back again
		 */

		adapter->rx_ring = rx_old;
		adapter->tx_ring = tx_old;
   10465:	4c 8b 65 d0          	mov    -0x30(%rbp),%r12

		/* save the new, restore the old in order to free it,
		 * then restore the new back again
		 */

		adapter->rx_ring = rx_old;
   10469:	4c 8b 7d c8          	mov    -0x38(%rbp),%r15
		adapter->tx_ring = tx_old;
		e1000_free_all_rx_resources(adapter);
   1046d:	4c 89 ef             	mov    %r13,%rdi
		/* save the new, restore the old in order to free it,
		 * then restore the new back again
		 */

		adapter->rx_ring = rx_old;
		adapter->tx_ring = tx_old;
   10470:	4c 89 a3 80 0a 00 00 	mov    %r12,0xa80(%rbx)

		/* save the new, restore the old in order to free it,
		 * then restore the new back again
		 */

		adapter->rx_ring = rx_old;
   10477:	4c 89 bb e8 0a 00 00 	mov    %r15,0xae8(%rbx)
		adapter->tx_ring = tx_old;
		e1000_free_all_rx_resources(adapter);
   1047e:	e8 00 00 00 00       	callq  10483 <e1000_set_ringparam+0x273>
		e1000_free_all_tx_resources(adapter);
   10483:	4c 89 ef             	mov    %r13,%rdi
   10486:	e8 00 00 00 00       	callq  1048b <e1000_set_ringparam+0x27b>
		kfree(tx_old);
   1048b:	4c 89 e7             	mov    %r12,%rdi
   1048e:	e8 00 00 00 00       	callq  10493 <e1000_set_ringparam+0x283>
		kfree(rx_old);
   10493:	4c 89 ff             	mov    %r15,%rdi
   10496:	e8 00 00 00 00       	callq  1049b <e1000_set_ringparam+0x28b>
		adapter->rx_ring = rxdr;
   1049b:	48 8b 75 c0          	mov    -0x40(%rbp),%rsi
		adapter->tx_ring = txdr;
   1049f:	4c 89 b3 80 0a 00 00 	mov    %r14,0xa80(%rbx)
		err = e1000_up(adapter);
   104a6:	4c 89 ef             	mov    %r13,%rdi
		adapter->tx_ring = tx_old;
		e1000_free_all_rx_resources(adapter);
		e1000_free_all_tx_resources(adapter);
		kfree(tx_old);
		kfree(rx_old);
		adapter->rx_ring = rxdr;
   104a9:	48 89 b3 e8 0a 00 00 	mov    %rsi,0xae8(%rbx)
		adapter->tx_ring = txdr;
		err = e1000_up(adapter);
   104b0:	e8 00 00 00 00       	callq  104b5 <e1000_set_ringparam+0x2a5>
		if (err)
   104b5:	85 c0                	test   %eax,%eax
		e1000_free_all_tx_resources(adapter);
		kfree(tx_old);
		kfree(rx_old);
		adapter->rx_ring = rxdr;
		adapter->tx_ring = txdr;
		err = e1000_up(adapter);
   104b7:	41 89 c4             	mov    %eax,%r12d
		if (err)
   104ba:	0f 84 20 ff ff ff    	je     103e0 <e1000_set_ringparam+0x1d0>
   104c0:	f0 80 a3 e8 0f 00 00 	lock andb $0xfd,0xfe8(%rbx)
   104c7:	fd 
	kfree(txdr);
err_alloc_tx:
	e1000_up(adapter);
err_setup:
	clear_bit(__E1000_RESETTING, &adapter->flags);
	return err;
   104c8:	44 89 e0             	mov    %r12d,%eax
   104cb:	e9 76 fd ff ff       	jmpq   10246 <e1000_set_ringparam+0x36>
	}

	clear_bit(__E1000_RESETTING, &adapter->flags);
	return 0;
err_setup_tx:
	e1000_free_all_rx_resources(adapter);
   104d0:	4c 89 ef             	mov    %r13,%rdi
   104d3:	48 89 75 c0          	mov    %rsi,-0x40(%rbp)
   104d7:	e8 00 00 00 00       	callq  104dc <e1000_set_ringparam+0x2cc>
   104dc:	48 8b 75 c0          	mov    -0x40(%rbp),%rsi
err_setup_rx:
	adapter->rx_ring = rx_old;
   104e0:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
	adapter->tx_ring = tx_old;
	kfree(rxdr);
   104e4:	48 89 f7             	mov    %rsi,%rdi
	clear_bit(__E1000_RESETTING, &adapter->flags);
	return 0;
err_setup_tx:
	e1000_free_all_rx_resources(adapter);
err_setup_rx:
	adapter->rx_ring = rx_old;
   104e7:	48 89 83 e8 0a 00 00 	mov    %rax,0xae8(%rbx)
	adapter->tx_ring = tx_old;
   104ee:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
   104f2:	48 89 83 80 0a 00 00 	mov    %rax,0xa80(%rbx)
	kfree(rxdr);
   104f9:	e8 00 00 00 00       	callq  104fe <e1000_set_ringparam+0x2ee>
err_alloc_rx:
	kfree(txdr);
   104fe:	4c 89 f7             	mov    %r14,%rdi
   10501:	e8 00 00 00 00       	callq  10506 <e1000_set_ringparam+0x2f6>
err_alloc_tx:
	e1000_up(adapter);
   10506:	4c 89 ef             	mov    %r13,%rdi
   10509:	e8 00 00 00 00       	callq  1050e <e1000_set_ringparam+0x2fe>
   1050e:	eb b0                	jmp    104c0 <e1000_set_ringparam+0x2b0>
		e1000_down(adapter);

	tx_old = adapter->tx_ring;
	rx_old = adapter->rx_ring;

	err = -ENOMEM;
   10510:	41 bc f4 ff ff ff    	mov    $0xfffffff4,%r12d
   10516:	eb ee                	jmp    10506 <e1000_set_ringparam+0x2f6>
   10518:	41 bc f4 ff ff ff    	mov    $0xfffffff4,%r12d
   1051e:	eb de                	jmp    104fe <e1000_set_ringparam+0x2ee>

0000000000010520 <e1000_set_eeprom>:
	return ret_val;
}

static int e1000_set_eeprom(struct net_device *netdev,
			    struct ethtool_eeprom *eeprom, u8 *bytes)
{
   10520:	e8 00 00 00 00       	callq  10525 <e1000_set_eeprom+0x5>
   10525:	55                   	push   %rbp
   10526:	48 89 e5             	mov    %rsp,%rbp
   10529:	41 57                	push   %r15
   1052b:	49 89 f7             	mov    %rsi,%r15
   1052e:	41 56                	push   %r14
	struct e1000_adapter *adapter = netdev_priv(netdev);
	struct e1000_hw *hw = &adapter->hw;
   10530:	4c 8d b7 00 0c 00 00 	lea    0xc00(%rdi),%r14
	return ret_val;
}

static int e1000_set_eeprom(struct net_device *netdev,
			    struct ethtool_eeprom *eeprom, u8 *bytes)
{
   10537:	41 55                	push   %r13
   10539:	41 54                	push   %r12
   1053b:	53                   	push   %rbx
   1053c:	48 83 ec 18          	sub    $0x18,%rsp
	u16 *eeprom_buff;
	void *ptr;
	int max_len, first_word, last_word, ret_val = 0;
	u16 i;

	if (eeprom->len == 0)
   10540:	8b 4e 0c             	mov    0xc(%rsi),%ecx
	return ret_val;
}

static int e1000_set_eeprom(struct net_device *netdev,
			    struct ethtool_eeprom *eeprom, u8 *bytes)
{
   10543:	48 89 55 d0          	mov    %rdx,-0x30(%rbp)
	u16 *eeprom_buff;
	void *ptr;
	int max_len, first_word, last_word, ret_val = 0;
	u16 i;

	if (eeprom->len == 0)
   10547:	85 c9                	test   %ecx,%ecx
   10549:	0f 84 7d 01 00 00    	je     106cc <e1000_set_eeprom+0x1ac>
		return -EOPNOTSUPP;

	if (eeprom->magic != (hw->vendor_id | (hw->device_id << 16)))
   1054f:	0f b7 97 e6 0c 00 00 	movzwl 0xce6(%rdi),%edx
   10556:	0f b7 87 e8 0c 00 00 	movzwl 0xce8(%rdi),%eax
   1055d:	c1 e2 10             	shl    $0x10,%edx
   10560:	09 c2                	or     %eax,%edx
   10562:	39 56 04             	cmp    %edx,0x4(%rsi)
		return -EFAULT;
   10565:	b8 f2 ff ff ff       	mov    $0xfffffff2,%eax
	u16 i;

	if (eeprom->len == 0)
		return -EOPNOTSUPP;

	if (eeprom->magic != (hw->vendor_id | (hw->device_id << 16)))
   1056a:	0f 85 bf 00 00 00    	jne    1062f <e1000_set_eeprom+0x10f>
		return -EFAULT;

	max_len = hw->eeprom.word_size * 2;
   10570:	0f b7 bf 54 0c 00 00 	movzwl 0xc54(%rdi),%edi

	first_word = eeprom->offset >> 1;
   10577:	8b 46 08             	mov    0x8(%rsi),%eax
			return kmem_cache_alloc_trace(kmalloc_caches[index],
					flags, size);
		}
#endif
	}
	return __kmalloc(size, flags);
   1057a:	be c0 00 40 02       	mov    $0x24000c0,%esi
	last_word = (eeprom->offset + eeprom->len - 1) >> 1;
   1057f:	8d 5c 01 ff          	lea    -0x1(%rcx,%rax,1),%ebx
	if (eeprom->magic != (hw->vendor_id | (hw->device_id << 16)))
		return -EFAULT;

	max_len = hw->eeprom.word_size * 2;

	first_word = eeprom->offset >> 1;
   10583:	41 89 c5             	mov    %eax,%r13d
		return -EOPNOTSUPP;

	if (eeprom->magic != (hw->vendor_id | (hw->device_id << 16)))
		return -EFAULT;

	max_len = hw->eeprom.word_size * 2;
   10586:	01 ff                	add    %edi,%edi

	first_word = eeprom->offset >> 1;
   10588:	41 d1 ed             	shr    %r13d
	last_word = (eeprom->offset + eeprom->len - 1) >> 1;
	eeprom_buff = kmalloc(max_len, GFP_KERNEL);
   1058b:	48 63 ff             	movslq %edi,%rdi
		return -EFAULT;

	max_len = hw->eeprom.word_size * 2;

	first_word = eeprom->offset >> 1;
	last_word = (eeprom->offset + eeprom->len - 1) >> 1;
   1058e:	d1 eb                	shr    %ebx
   10590:	e8 00 00 00 00       	callq  10595 <e1000_set_eeprom+0x75>
	eeprom_buff = kmalloc(max_len, GFP_KERNEL);
	if (!eeprom_buff)
   10595:	48 85 c0             	test   %rax,%rax
   10598:	49 89 c4             	mov    %rax,%r12
   1059b:	0f 84 35 01 00 00    	je     106d6 <e1000_set_eeprom+0x1b6>
		return -ENOMEM;

	ptr = (void *)eeprom_buff;

	if (eeprom->offset & 1) {
   105a1:	41 8b 47 08          	mov    0x8(%r15),%eax
   105a5:	a8 01                	test   $0x1,%al
   105a7:	0f 85 91 00 00 00    	jne    1063e <e1000_set_eeprom+0x11e>
		 */
		ret_val = e1000_read_eeprom(hw, first_word, 1,
					    &eeprom_buff[0]);
		ptr++;
	}
	if (((eeprom->offset + eeprom->len) & 1) && (ret_val == 0)) {
   105ad:	41 8b 57 0c          	mov    0xc(%r15),%edx
   105b1:	01 d0                	add    %edx,%eax
   105b3:	a8 01                	test   $0x1,%al
   105b5:	41 0f b7 c5          	movzwl %r13w,%eax
   105b9:	89 45 c8             	mov    %eax,-0x38(%rbp)
   105bc:	0f 84 1e 01 00 00    	je     106e0 <e1000_set_eeprom+0x1c0>
   105c2:	4d 89 e0             	mov    %r12,%r8
		/* need read/modify/write of last changed EEPROM word
		 * only the first byte of the word is being modified
		 */
		ret_val = e1000_read_eeprom(hw, last_word, 1,
					    &eeprom_buff[last_word - first_word]);
   105c5:	41 89 da             	mov    %ebx,%r10d
	}
	if (((eeprom->offset + eeprom->len) & 1) && (ret_val == 0)) {
		/* need read/modify/write of last changed EEPROM word
		 * only the first byte of the word is being modified
		 */
		ret_val = e1000_read_eeprom(hw, last_word, 1,
   105c8:	ba 01 00 00 00       	mov    $0x1,%edx
   105cd:	0f b7 f3             	movzwl %bx,%esi
					    &eeprom_buff[last_word - first_word]);
   105d0:	45 29 ea             	sub    %r13d,%r10d
	}
	if (((eeprom->offset + eeprom->len) & 1) && (ret_val == 0)) {
		/* need read/modify/write of last changed EEPROM word
		 * only the first byte of the word is being modified
		 */
		ret_val = e1000_read_eeprom(hw, last_word, 1,
   105d3:	4c 89 f7             	mov    %r14,%rdi
   105d6:	4c 89 45 c0          	mov    %r8,-0x40(%rbp)
   105da:	49 63 c2             	movslq %r10d,%rax
   105dd:	44 89 55 cc          	mov    %r10d,-0x34(%rbp)
   105e1:	49 8d 0c 44          	lea    (%r12,%rax,2),%rcx
   105e5:	e8 00 00 00 00       	callq  105ea <e1000_set_eeprom+0xca>
   105ea:	41 8b 57 0c          	mov    0xc(%r15),%edx
   105ee:	4c 8b 45 c0          	mov    -0x40(%rbp),%r8
   105f2:	44 8b 55 cc          	mov    -0x34(%rbp),%r10d
   105f6:	eb 79                	jmp    10671 <e1000_set_eeprom+0x151>

	/* Device's eeprom is always little-endian, word addressable */
	for (i = 0; i < last_word - first_word + 1; i++)
		le16_to_cpus(&eeprom_buff[i]);

	memcpy(ptr, bytes, eeprom->len);
   105f8:	48 8b 75 d0          	mov    -0x30(%rbp),%rsi
   105fc:	4c 89 c7             	mov    %r8,%rdi
   105ff:	e8 00 00 00 00       	callq  10604 <e1000_set_eeprom+0xe4>

	for (i = 0; i < last_word - first_word + 1; i++)
		eeprom_buff[i] = cpu_to_le16(eeprom_buff[i]);

	ret_val = e1000_write_eeprom(hw, first_word,
   10604:	44 29 eb             	sub    %r13d,%ebx
   10607:	8b 75 c8             	mov    -0x38(%rbp),%esi
   1060a:	4c 89 e1             	mov    %r12,%rcx
   1060d:	8d 53 01             	lea    0x1(%rbx),%edx
   10610:	4c 89 f7             	mov    %r14,%rdi
   10613:	0f b7 d2             	movzwl %dx,%edx
   10616:	e8 00 00 00 00       	callq  1061b <e1000_set_eeprom+0xfb>
				     last_word - first_word + 1, eeprom_buff);

	/* Update the checksum over the first part of the EEPROM if needed */
	if ((ret_val == 0) && (first_word <= EEPROM_CHECKSUM_REG))
   1061b:	85 c0                	test   %eax,%eax
	memcpy(ptr, bytes, eeprom->len);

	for (i = 0; i < last_word - first_word + 1; i++)
		eeprom_buff[i] = cpu_to_le16(eeprom_buff[i]);

	ret_val = e1000_write_eeprom(hw, first_word,
   1061d:	89 c3                	mov    %eax,%ebx
				     last_word - first_word + 1, eeprom_buff);

	/* Update the checksum over the first part of the EEPROM if needed */
	if ((ret_val == 0) && (first_word <= EEPROM_CHECKSUM_REG))
   1061f:	0f 84 90 00 00 00    	je     106b5 <e1000_set_eeprom+0x195>
		e1000_update_eeprom_checksum(hw);

	kfree(eeprom_buff);
   10625:	4c 89 e7             	mov    %r12,%rdi
   10628:	e8 00 00 00 00       	callq  1062d <e1000_set_eeprom+0x10d>
	memcpy(ptr, bytes, eeprom->len);

	for (i = 0; i < last_word - first_word + 1; i++)
		eeprom_buff[i] = cpu_to_le16(eeprom_buff[i]);

	ret_val = e1000_write_eeprom(hw, first_word,
   1062d:	89 d8                	mov    %ebx,%eax
	if ((ret_val == 0) && (first_word <= EEPROM_CHECKSUM_REG))
		e1000_update_eeprom_checksum(hw);

	kfree(eeprom_buff);
	return ret_val;
}
   1062f:	48 83 c4 18          	add    $0x18,%rsp
   10633:	5b                   	pop    %rbx
   10634:	41 5c                	pop    %r12
   10636:	41 5d                	pop    %r13
   10638:	41 5e                	pop    %r14
   1063a:	41 5f                	pop    %r15
   1063c:	5d                   	pop    %rbp
   1063d:	c3                   	retq   
   1063e:	41 0f b7 c5          	movzwl %r13w,%eax

	if (eeprom->offset & 1) {
		/* need read/modify/write of first changed EEPROM word
		 * only the second byte of the word is being modified
		 */
		ret_val = e1000_read_eeprom(hw, first_word, 1,
   10642:	4c 89 e1             	mov    %r12,%rcx
   10645:	ba 01 00 00 00       	mov    $0x1,%edx
   1064a:	89 c6                	mov    %eax,%esi
   1064c:	4c 89 f7             	mov    %r14,%rdi
   1064f:	89 45 c8             	mov    %eax,-0x38(%rbp)
   10652:	e8 00 00 00 00       	callq  10657 <e1000_set_eeprom+0x137>
					    &eeprom_buff[0]);
		ptr++;
	}
	if (((eeprom->offset + eeprom->len) & 1) && (ret_val == 0)) {
   10657:	41 8b 57 0c          	mov    0xc(%r15),%edx
   1065b:	41 8b 4f 08          	mov    0x8(%r15),%ecx
		/* need read/modify/write of first changed EEPROM word
		 * only the second byte of the word is being modified
		 */
		ret_val = e1000_read_eeprom(hw, first_word, 1,
					    &eeprom_buff[0]);
		ptr++;
   1065f:	4d 8d 44 24 01       	lea    0x1(%r12),%r8
	}
	if (((eeprom->offset + eeprom->len) & 1) && (ret_val == 0)) {
   10664:	01 d1                	add    %edx,%ecx
   10666:	83 e1 01             	and    $0x1,%ecx
   10669:	75 41                	jne    106ac <e1000_set_eeprom+0x18c>
   1066b:	41 89 da             	mov    %ebx,%r10d
   1066e:	45 29 ea             	sub    %r13d,%r10d
		ret_val = e1000_read_eeprom(hw, last_word, 1,
					    &eeprom_buff[last_word - first_word]);
	}

	/* Device's eeprom is always little-endian, word addressable */
	for (i = 0; i < last_word - first_word + 1; i++)
   10671:	41 8d 4a 01          	lea    0x1(%r10),%ecx
   10675:	85 c9                	test   %ecx,%ecx
   10677:	0f 8e 7b ff ff ff    	jle    105f8 <e1000_set_eeprom+0xd8>
   1067d:	31 c0                	xor    %eax,%eax
   1067f:	83 c0 01             	add    $0x1,%eax
   10682:	0f b7 f0             	movzwl %ax,%esi
   10685:	39 f1                	cmp    %esi,%ecx
   10687:	7f f6                	jg     1067f <e1000_set_eeprom+0x15f>
		le16_to_cpus(&eeprom_buff[i]);

	memcpy(ptr, bytes, eeprom->len);
   10689:	48 8b 75 d0          	mov    -0x30(%rbp),%rsi
   1068d:	4c 89 c7             	mov    %r8,%rdi
   10690:	89 4d cc             	mov    %ecx,-0x34(%rbp)
   10693:	e8 00 00 00 00       	callq  10698 <e1000_set_eeprom+0x178>
   10698:	8b 4d cc             	mov    -0x34(%rbp),%ecx

	for (i = 0; i < last_word - first_word + 1; i++)
   1069b:	31 c0                	xor    %eax,%eax
   1069d:	83 c0 01             	add    $0x1,%eax
   106a0:	0f b7 d0             	movzwl %ax,%edx
   106a3:	39 d1                	cmp    %edx,%ecx
   106a5:	7f f6                	jg     1069d <e1000_set_eeprom+0x17d>
   106a7:	e9 58 ff ff ff       	jmpq   10604 <e1000_set_eeprom+0xe4>
		 */
		ret_val = e1000_read_eeprom(hw, first_word, 1,
					    &eeprom_buff[0]);
		ptr++;
	}
	if (((eeprom->offset + eeprom->len) & 1) && (ret_val == 0)) {
   106ac:	85 c0                	test   %eax,%eax
   106ae:	75 bb                	jne    1066b <e1000_set_eeprom+0x14b>
   106b0:	e9 10 ff ff ff       	jmpq   105c5 <e1000_set_eeprom+0xa5>

	ret_val = e1000_write_eeprom(hw, first_word,
				     last_word - first_word + 1, eeprom_buff);

	/* Update the checksum over the first part of the EEPROM if needed */
	if ((ret_val == 0) && (first_word <= EEPROM_CHECKSUM_REG))
   106b5:	41 83 fd 3f          	cmp    $0x3f,%r13d
   106b9:	0f 8f 66 ff ff ff    	jg     10625 <e1000_set_eeprom+0x105>
		e1000_update_eeprom_checksum(hw);
   106bf:	4c 89 f7             	mov    %r14,%rdi
   106c2:	e8 00 00 00 00       	callq  106c7 <e1000_set_eeprom+0x1a7>
   106c7:	e9 59 ff ff ff       	jmpq   10625 <e1000_set_eeprom+0x105>
	void *ptr;
	int max_len, first_word, last_word, ret_val = 0;
	u16 i;

	if (eeprom->len == 0)
		return -EOPNOTSUPP;
   106cc:	b8 a1 ff ff ff       	mov    $0xffffffa1,%eax
   106d1:	e9 59 ff ff ff       	jmpq   1062f <e1000_set_eeprom+0x10f>

	first_word = eeprom->offset >> 1;
	last_word = (eeprom->offset + eeprom->len - 1) >> 1;
	eeprom_buff = kmalloc(max_len, GFP_KERNEL);
	if (!eeprom_buff)
		return -ENOMEM;
   106d6:	b8 f4 ff ff ff       	mov    $0xfffffff4,%eax
   106db:	e9 4f ff ff ff       	jmpq   1062f <e1000_set_eeprom+0x10f>
   106e0:	41 89 da             	mov    %ebx,%r10d
		 */
		ret_val = e1000_read_eeprom(hw, first_word, 1,
					    &eeprom_buff[0]);
		ptr++;
	}
	if (((eeprom->offset + eeprom->len) & 1) && (ret_val == 0)) {
   106e3:	4d 89 e0             	mov    %r12,%r8
   106e6:	45 29 ea             	sub    %r13d,%r10d
   106e9:	eb 86                	jmp    10671 <e1000_set_eeprom+0x151>
   106eb:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)

00000000000106f0 <e1000_free_desc_rings>:

	return *data;
}

static void e1000_free_desc_rings(struct e1000_adapter *adapter)
{
   106f0:	e8 00 00 00 00       	callq  106f5 <e1000_free_desc_rings+0x5>
   106f5:	55                   	push   %rbp
   106f6:	48 89 e5             	mov    %rsp,%rbp
   106f9:	41 57                	push   %r15
   106fb:	41 56                	push   %r14
   106fd:	41 55                	push   %r13
   106ff:	41 54                	push   %r12
   10701:	53                   	push   %rbx
   10702:	48 89 fb             	mov    %rdi,%rbx
   10705:	48 83 ec 10          	sub    $0x10,%rsp
	struct e1000_tx_ring *txdr = &adapter->test_tx_ring;
	struct e1000_rx_ring *rxdr = &adapter->test_rx_ring;
	struct pci_dev *pdev = adapter->pdev;
	int i;

	if (txdr->desc && txdr->buffer_info) {
   10709:	48 83 bf 38 07 00 00 	cmpq   $0x0,0x738(%rdi)
   10710:	00 

static void e1000_free_desc_rings(struct e1000_adapter *adapter)
{
	struct e1000_tx_ring *txdr = &adapter->test_tx_ring;
	struct e1000_rx_ring *rxdr = &adapter->test_rx_ring;
	struct pci_dev *pdev = adapter->pdev;
   10711:	4c 8b b7 b8 03 00 00 	mov    0x3b8(%rdi),%r14
	int i;

	if (txdr->desc && txdr->buffer_info) {
   10718:	0f 84 a2 00 00 00    	je     107c0 <e1000_free_desc_rings+0xd0>
   1071e:	48 8b 87 58 07 00 00 	mov    0x758(%rdi),%rax
   10725:	48 85 c0             	test   %rax,%rax
   10728:	0f 84 92 00 00 00    	je     107c0 <e1000_free_desc_rings+0xd0>
		for (i = 0; i < txdr->count; i++) {
   1072e:	8b 8f 4c 07 00 00    	mov    0x74c(%rdi),%ecx
   10734:	85 c9                	test   %ecx,%ecx
   10736:	0f 84 84 00 00 00    	je     107c0 <e1000_free_desc_rings+0xd0>
   1073c:	45 31 e4             	xor    %r12d,%r12d
			if (txdr->buffer_info[i].dma)
				dma_unmap_single(&pdev->dev,
   1073f:	4d 8d ae 98 00 00 00 	lea    0x98(%r14),%r13
   10746:	eb 21                	jmp    10769 <e1000_free_desc_rings+0x79>
						 txdr->buffer_info[i].dma,
						 txdr->buffer_info[i].length,
						 DMA_TO_DEVICE);
			if (txdr->buffer_info[i].skb)
   10748:	48 8b 38             	mov    (%rax),%rdi
   1074b:	48 85 ff             	test   %rdi,%rdi
   1074e:	74 05                	je     10755 <e1000_free_desc_rings+0x65>
				dev_kfree_skb(txdr->buffer_info[i].skb);
   10750:	e8 00 00 00 00       	callq  10755 <e1000_free_desc_rings+0x65>
	struct e1000_rx_ring *rxdr = &adapter->test_rx_ring;
	struct pci_dev *pdev = adapter->pdev;
	int i;

	if (txdr->desc && txdr->buffer_info) {
		for (i = 0; i < txdr->count; i++) {
   10755:	41 83 c4 01          	add    $0x1,%r12d
   10759:	44 3b a3 4c 07 00 00 	cmp    0x74c(%rbx),%r12d
   10760:	73 5e                	jae    107c0 <e1000_free_desc_rings+0xd0>
   10762:	48 8b 83 58 07 00 00 	mov    0x758(%rbx),%rax
			if (txdr->buffer_info[i].dma)
   10769:	49 63 d4             	movslq %r12d,%rdx
   1076c:	4c 8d 3c 92          	lea    (%rdx,%rdx,4),%r15
   10770:	49 c1 e7 03          	shl    $0x3,%r15
   10774:	4c 01 f8             	add    %r15,%rax
   10777:	48 8b 70 08          	mov    0x8(%rax),%rsi
   1077b:	48 85 f6             	test   %rsi,%rsi
   1077e:	74 c8                	je     10748 <e1000_free_desc_rings+0x58>
static inline struct dma_map_ops *get_dma_ops(struct device *dev)
{
#ifndef CONFIG_X86_DEV_DMA_OPS
	return dma_ops;
#else
	if (unlikely(!dev) || !dev->archdata.dma_ops)
   10780:	4d 85 ed             	test   %r13,%r13
				dma_unmap_single(&pdev->dev,
   10783:	0f b7 50 18          	movzwl 0x18(%rax),%edx
   10787:	0f 84 e8 01 00 00    	je     10975 <e1000_free_desc_rings+0x285>
   1078d:	49 8b 8e e8 02 00 00 	mov    0x2e8(%r14),%rcx
   10794:	48 85 c9             	test   %rcx,%rcx
   10797:	0f 84 d8 01 00 00    	je     10975 <e1000_free_desc_rings+0x285>
					  struct dma_attrs *attrs)
{
	struct dma_map_ops *ops = get_dma_ops(dev);

	BUG_ON(!valid_dma_direction(dir));
	if (ops->unmap_page)
   1079d:	4c 8b 49 28          	mov    0x28(%rcx),%r9
   107a1:	4d 85 c9             	test   %r9,%r9
   107a4:	74 a2                	je     10748 <e1000_free_desc_rings+0x58>
		ops->unmap_page(dev, addr, size, dir, attrs);
   107a6:	45 31 c0             	xor    %r8d,%r8d
   107a9:	b9 01 00 00 00       	mov    $0x1,%ecx
   107ae:	4c 89 ef             	mov    %r13,%rdi
   107b1:	41 ff d1             	callq  *%r9
   107b4:	4c 89 f8             	mov    %r15,%rax
   107b7:	48 03 83 58 07 00 00 	add    0x758(%rbx),%rax
   107be:	eb 88                	jmp    10748 <e1000_free_desc_rings+0x58>
			if (txdr->buffer_info[i].skb)
				dev_kfree_skb(txdr->buffer_info[i].skb);
		}
	}

	if (rxdr->desc && rxdr->buffer_info) {
   107c0:	48 83 bb 68 07 00 00 	cmpq   $0x0,0x768(%rbx)
   107c7:	00 
   107c8:	0f 84 96 00 00 00    	je     10864 <e1000_free_desc_rings+0x174>
   107ce:	48 8b 83 88 07 00 00 	mov    0x788(%rbx),%rax
   107d5:	48 85 c0             	test   %rax,%rax
   107d8:	0f 84 86 00 00 00    	je     10864 <e1000_free_desc_rings+0x174>
		for (i = 0; i < rxdr->count; i++) {
   107de:	8b 93 7c 07 00 00    	mov    0x77c(%rbx),%edx
   107e4:	85 d2                	test   %edx,%edx
   107e6:	74 7c                	je     10864 <e1000_free_desc_rings+0x174>
   107e8:	45 31 ed             	xor    %r13d,%r13d
			if (rxdr->buffer_info[i].dma)
				dma_unmap_single(&pdev->dev,
   107eb:	4d 8d be 98 00 00 00 	lea    0x98(%r14),%r15
   107f2:	eb 1c                	jmp    10810 <e1000_free_desc_rings+0x120>
						 rxdr->buffer_info[i].dma,
						 E1000_RXBUFFER_2048,
						 DMA_FROM_DEVICE);
			kfree(rxdr->buffer_info[i].rxbuf.data);
   107f4:	48 8b 38             	mov    (%rax),%rdi
				dev_kfree_skb(txdr->buffer_info[i].skb);
		}
	}

	if (rxdr->desc && rxdr->buffer_info) {
		for (i = 0; i < rxdr->count; i++) {
   107f7:	41 83 c5 01          	add    $0x1,%r13d
			if (rxdr->buffer_info[i].dma)
				dma_unmap_single(&pdev->dev,
						 rxdr->buffer_info[i].dma,
						 E1000_RXBUFFER_2048,
						 DMA_FROM_DEVICE);
			kfree(rxdr->buffer_info[i].rxbuf.data);
   107fb:	e8 00 00 00 00       	callq  10800 <e1000_free_desc_rings+0x110>
				dev_kfree_skb(txdr->buffer_info[i].skb);
		}
	}

	if (rxdr->desc && rxdr->buffer_info) {
		for (i = 0; i < rxdr->count; i++) {
   10800:	44 3b ab 7c 07 00 00 	cmp    0x77c(%rbx),%r13d
   10807:	73 5b                	jae    10864 <e1000_free_desc_rings+0x174>
   10809:	48 8b 83 88 07 00 00 	mov    0x788(%rbx),%rax
			if (rxdr->buffer_info[i].dma)
   10810:	4d 63 e5             	movslq %r13d,%r12
   10813:	49 c1 e4 04          	shl    $0x4,%r12
   10817:	4c 01 e0             	add    %r12,%rax
   1081a:	48 8b 70 08          	mov    0x8(%rax),%rsi
   1081e:	48 85 f6             	test   %rsi,%rsi
   10821:	74 d1                	je     107f4 <e1000_free_desc_rings+0x104>
   10823:	4d 85 ff             	test   %r15,%r15
   10826:	0f 84 55 01 00 00    	je     10981 <e1000_free_desc_rings+0x291>
   1082c:	49 8b 96 e8 02 00 00 	mov    0x2e8(%r14),%rdx
   10833:	48 85 d2             	test   %rdx,%rdx
   10836:	0f 84 45 01 00 00    	je     10981 <e1000_free_desc_rings+0x291>
					  struct dma_attrs *attrs)
{
	struct dma_map_ops *ops = get_dma_ops(dev);

	BUG_ON(!valid_dma_direction(dir));
	if (ops->unmap_page)
   1083c:	4c 8b 4a 28          	mov    0x28(%rdx),%r9
   10840:	4d 85 c9             	test   %r9,%r9
   10843:	74 af                	je     107f4 <e1000_free_desc_rings+0x104>
		ops->unmap_page(dev, addr, size, dir, attrs);
   10845:	45 31 c0             	xor    %r8d,%r8d
   10848:	b9 02 00 00 00       	mov    $0x2,%ecx
   1084d:	ba 00 08 00 00       	mov    $0x800,%edx
   10852:	4c 89 ff             	mov    %r15,%rdi
   10855:	41 ff d1             	callq  *%r9
   10858:	4c 89 e0             	mov    %r12,%rax
   1085b:	48 03 83 88 07 00 00 	add    0x788(%rbx),%rax
   10862:	eb 90                	jmp    107f4 <e1000_free_desc_rings+0x104>
						 DMA_FROM_DEVICE);
			kfree(rxdr->buffer_info[i].rxbuf.data);
		}
	}

	if (txdr->desc) {
   10864:	48 8b 93 38 07 00 00 	mov    0x738(%rbx),%rdx
   1086b:	48 85 d2             	test   %rdx,%rdx
   1086e:	74 5e                	je     108ce <e1000_free_desc_rings+0x1de>
   10870:	4d 89 f5             	mov    %r14,%r13
		dma_free_coherent(&pdev->dev, txdr->size, txdr->desc,
   10873:	48 8b 8b 40 07 00 00 	mov    0x740(%rbx),%rcx
   1087a:	44 8b bb 48 07 00 00 	mov    0x748(%rbx),%r15d
   10881:	49 81 c5 98 00 00 00 	add    $0x98,%r13
   10888:	0f 84 11 01 00 00    	je     1099f <e1000_free_desc_rings+0x2af>
   1088e:	4d 8b a6 e8 02 00 00 	mov    0x2e8(%r14),%r12
   10895:	4d 85 e4             	test   %r12,%r12
   10898:	0f 84 01 01 00 00    	je     1099f <e1000_free_desc_rings+0x2af>
#define __PV_IS_CALLEE_SAVE(func)			\
	((struct paravirt_callee_save) { func })

static inline notrace unsigned long arch_local_save_flags(void)
{
	return PVOP_CALLEE0(unsigned long, pv_irq_ops.save_fl);
   1089e:	ff 14 25 00 00 00 00 	callq  *0x0
				     struct dma_attrs *attrs)
{
	struct dma_map_ops *ops = get_dma_ops(dev);

	BUG_ON(!ops);
	WARN_ON(irqs_disabled());
   108a5:	f6 c4 02             	test   $0x2,%ah
   108a8:	0f 84 03 01 00 00    	je     109b1 <e1000_free_desc_rings+0x2c1>

	if (dma_release_from_coherent(dev, get_order(size), cpu_addr))
		return;

	if (!ops->free)
   108ae:	49 8b 44 24 08       	mov    0x8(%r12),%rax
   108b3:	48 85 c0             	test   %rax,%rax
   108b6:	74 0b                	je     108c3 <e1000_free_desc_rings+0x1d3>
		return;

	debug_dma_free_coherent(dev, size, cpu_addr, dma_handle);
	ops->free(dev, size, cpu_addr, dma_handle, attrs);
   108b8:	45 31 c0             	xor    %r8d,%r8d
   108bb:	4c 89 fe             	mov    %r15,%rsi
   108be:	4c 89 ef             	mov    %r13,%rdi
   108c1:	ff d0                	callq  *%rax
				  txdr->dma);
		txdr->desc = NULL;
   108c3:	48 c7 83 38 07 00 00 	movq   $0x0,0x738(%rbx)
   108ca:	00 00 00 00 
	}
	if (rxdr->desc) {
   108ce:	48 8b 93 68 07 00 00 	mov    0x768(%rbx),%rdx
   108d5:	48 85 d2             	test   %rdx,%rdx
   108d8:	74 5e                	je     10938 <e1000_free_desc_rings+0x248>
   108da:	4d 89 f5             	mov    %r14,%r13
		dma_free_coherent(&pdev->dev, rxdr->size, rxdr->desc,
   108dd:	48 8b 8b 70 07 00 00 	mov    0x770(%rbx),%rcx
   108e4:	44 8b bb 78 07 00 00 	mov    0x778(%rbx),%r15d
   108eb:	49 81 c5 98 00 00 00 	add    $0x98,%r13
   108f2:	0f 84 95 00 00 00    	je     1098d <e1000_free_desc_rings+0x29d>
   108f8:	4d 8b a6 e8 02 00 00 	mov    0x2e8(%r14),%r12
   108ff:	4d 85 e4             	test   %r12,%r12
   10902:	0f 84 85 00 00 00    	je     1098d <e1000_free_desc_rings+0x29d>
   10908:	ff 14 25 00 00 00 00 	callq  *0x0
				     struct dma_attrs *attrs)
{
	struct dma_map_ops *ops = get_dma_ops(dev);

	BUG_ON(!ops);
	WARN_ON(irqs_disabled());
   1090f:	f6 c4 02             	test   $0x2,%ah
   10912:	0f 84 bf 00 00 00    	je     109d7 <e1000_free_desc_rings+0x2e7>

	if (dma_release_from_coherent(dev, get_order(size), cpu_addr))
		return;

	if (!ops->free)
   10918:	49 8b 44 24 08       	mov    0x8(%r12),%rax
   1091d:	48 85 c0             	test   %rax,%rax
   10920:	74 0b                	je     1092d <e1000_free_desc_rings+0x23d>
		return;

	debug_dma_free_coherent(dev, size, cpu_addr, dma_handle);
	ops->free(dev, size, cpu_addr, dma_handle, attrs);
   10922:	45 31 c0             	xor    %r8d,%r8d
   10925:	4c 89 fe             	mov    %r15,%rsi
   10928:	4c 89 ef             	mov    %r13,%rdi
   1092b:	ff d0                	callq  *%rax
				  rxdr->dma);
		rxdr->desc = NULL;
   1092d:	48 c7 83 68 07 00 00 	movq   $0x0,0x768(%rbx)
   10934:	00 00 00 00 
	}

	kfree(txdr->buffer_info);
   10938:	48 8b bb 58 07 00 00 	mov    0x758(%rbx),%rdi
   1093f:	e8 00 00 00 00       	callq  10944 <e1000_free_desc_rings+0x254>
	txdr->buffer_info = NULL;
	kfree(rxdr->buffer_info);
   10944:	48 8b bb 88 07 00 00 	mov    0x788(%rbx),%rdi
				  rxdr->dma);
		rxdr->desc = NULL;
	}

	kfree(txdr->buffer_info);
	txdr->buffer_info = NULL;
   1094b:	48 c7 83 58 07 00 00 	movq   $0x0,0x758(%rbx)
   10952:	00 00 00 00 
	kfree(rxdr->buffer_info);
   10956:	e8 00 00 00 00       	callq  1095b <e1000_free_desc_rings+0x26b>
	rxdr->buffer_info = NULL;
   1095b:	48 c7 83 88 07 00 00 	movq   $0x0,0x788(%rbx)
   10962:	00 00 00 00 
}
   10966:	48 83 c4 10          	add    $0x10,%rsp
   1096a:	5b                   	pop    %rbx
   1096b:	41 5c                	pop    %r12
   1096d:	41 5d                	pop    %r13
   1096f:	41 5e                	pop    %r14
   10971:	41 5f                	pop    %r15
   10973:	5d                   	pop    %rbp
   10974:	c3                   	retq   
		return dma_ops;
   10975:	48 8b 0d 00 00 00 00 	mov    0x0(%rip),%rcx        # 1097c <e1000_free_desc_rings+0x28c>
   1097c:	e9 1c fe ff ff       	jmpq   1079d <e1000_free_desc_rings+0xad>
   10981:	48 8b 15 00 00 00 00 	mov    0x0(%rip),%rdx        # 10988 <e1000_free_desc_rings+0x298>
   10988:	e9 af fe ff ff       	jmpq   1083c <e1000_free_desc_rings+0x14c>
   1098d:	4c 8b 25 00 00 00 00 	mov    0x0(%rip),%r12        # 10994 <e1000_free_desc_rings+0x2a4>
				     void *cpu_addr, dma_addr_t dma_handle,
				     struct dma_attrs *attrs)
{
	struct dma_map_ops *ops = get_dma_ops(dev);

	BUG_ON(!ops);
   10994:	4d 85 e4             	test   %r12,%r12
   10997:	0f 85 6b ff ff ff    	jne    10908 <e1000_free_desc_rings+0x218>
   1099d:	0f 0b                	ud2    
   1099f:	4c 8b 25 00 00 00 00 	mov    0x0(%rip),%r12        # 109a6 <e1000_free_desc_rings+0x2b6>
   109a6:	4d 85 e4             	test   %r12,%r12
   109a9:	0f 85 ef fe ff ff    	jne    1089e <e1000_free_desc_rings+0x1ae>
   109af:	eb ec                	jmp    1099d <e1000_free_desc_rings+0x2ad>
	WARN_ON(irqs_disabled());
   109b1:	be 12 01 00 00       	mov    $0x112,%esi
   109b6:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
   109bd:	48 89 4d c8          	mov    %rcx,-0x38(%rbp)
   109c1:	48 89 55 d0          	mov    %rdx,-0x30(%rbp)
   109c5:	e8 00 00 00 00       	callq  109ca <e1000_free_desc_rings+0x2da>
   109ca:	48 8b 4d c8          	mov    -0x38(%rbp),%rcx
   109ce:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
   109d2:	e9 d7 fe ff ff       	jmpq   108ae <e1000_free_desc_rings+0x1be>
   109d7:	be 12 01 00 00       	mov    $0x112,%esi
   109dc:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
   109e3:	48 89 4d c8          	mov    %rcx,-0x38(%rbp)
   109e7:	48 89 55 d0          	mov    %rdx,-0x30(%rbp)
   109eb:	e8 00 00 00 00       	callq  109f0 <e1000_free_desc_rings+0x300>
   109f0:	48 8b 4d c8          	mov    -0x38(%rbp),%rcx
   109f4:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
   109f8:	e9 1b ff ff ff       	jmpq   10918 <e1000_free_desc_rings+0x228>
   109fd:	0f 1f 00             	nopl   (%rax)

0000000000010a00 <e1000_diag_test>:
	}
}

static void e1000_diag_test(struct net_device *netdev,
			    struct ethtool_test *eth_test, u64 *data)
{
   10a00:	e8 00 00 00 00       	callq  10a05 <e1000_diag_test+0x5>
   10a05:	55                   	push   %rbp
   10a06:	48 89 e5             	mov    %rsp,%rbp
   10a09:	41 57                	push   %r15
   10a0b:	49 89 ff             	mov    %rdi,%r15
   10a0e:	41 56                	push   %r14
   10a10:	41 55                	push   %r13
   10a12:	41 54                	push   %r12
   10a14:	53                   	push   %rbx
	struct e1000_adapter *adapter = netdev_priv(netdev);
   10a15:	48 8d 9f 40 08 00 00 	lea    0x840(%rdi),%rbx
	}
}

static void e1000_diag_test(struct net_device *netdev,
			    struct ethtool_test *eth_test, u64 *data)
{
   10a1c:	48 83 ec 70          	sub    $0x70,%rsp
	struct e1000_adapter *adapter = netdev_priv(netdev);
   10a20:	48 89 5d 90          	mov    %rbx,-0x70(%rbp)
	}
}

static void e1000_diag_test(struct net_device *netdev,
			    struct ethtool_test *eth_test, u64 *data)
{
   10a24:	48 89 75 88          	mov    %rsi,-0x78(%rbp)
   10a28:	48 89 55 a0          	mov    %rdx,-0x60(%rbp)
}

static __always_inline int constant_test_bit(long nr, const volatile unsigned long *addr)
{
	return ((1UL << (nr & (BITS_PER_LONG-1))) &
		(addr[nr >> _BITOPS_LONG_SHIFT])) != 0;
   10a2c:	48 8b 5f 48          	mov    0x48(%rdi),%rbx
 */
static __always_inline void
set_bit(long nr, volatile unsigned long *addr)
{
	if (IS_IMMEDIATE(nr)) {
		asm volatile(LOCK_PREFIX "orb %1,%0"
   10a30:	f0 80 8f e8 0f 00 00 	lock orb $0x1,0xfe8(%rdi)
   10a37:	01 
	struct e1000_adapter *adapter = netdev_priv(netdev);
	struct e1000_hw *hw = &adapter->hw;
	bool if_running = netif_running(netdev);

	set_bit(__E1000_TESTING, &adapter->flags);
	if (eth_test->flags == ETH_TEST_FL_OFFLINE) {
   10a38:	83 7e 04 01          	cmpl   $0x1,0x4(%rsi)
   10a3c:	74 71                	je     10aaf <e1000_diag_test+0xaf>
		e1000_reset(adapter);
		clear_bit(__E1000_TESTING, &adapter->flags);
		if (if_running)
			dev_open(netdev);
	} else {
		e_info(hw, "online testing starting\n");
   10a3e:	f6 87 e1 0f 00 00 20 	testb  $0x20,0xfe1(%rdi)
   10a45:	0f 85 fb 09 00 00    	jne    11446 <e1000_diag_test+0xa46>
		/* Online tests */
		if (e1000_link_test(adapter, &data[4]))
   10a4b:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
   10a4f:	48 8b 7d 90          	mov    -0x70(%rbp),%rdi
   10a53:	48 8d 70 20          	lea    0x20(%rax),%rsi
   10a57:	e8 a4 e9 ff ff       	callq  f400 <e1000_link_test>
   10a5c:	85 c0                	test   %eax,%eax
   10a5e:	75 45                	jne    10aa5 <e1000_diag_test+0xa5>
			eth_test->flags |= ETH_TEST_FL_FAILED;

		/* Online tests aren't run; pass by default */
		data[0] = 0;
   10a60:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
   10a64:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
		data[1] = 0;
   10a6b:	48 c7 40 08 00 00 00 	movq   $0x0,0x8(%rax)
   10a72:	00 
		data[2] = 0;
   10a73:	48 c7 40 10 00 00 00 	movq   $0x0,0x10(%rax)
   10a7a:	00 
		data[3] = 0;
   10a7b:	48 c7 40 18 00 00 00 	movq   $0x0,0x18(%rax)
   10a82:	00 
 */
static __always_inline void
clear_bit(long nr, volatile unsigned long *addr)
{
	if (IS_IMMEDIATE(nr)) {
		asm volatile(LOCK_PREFIX "andb %1,%0"
   10a83:	f0 41 80 a7 e8 0f 00 	lock andb $0xfe,0xfe8(%r15)
   10a8a:	00 fe 

		clear_bit(__E1000_TESTING, &adapter->flags);
	}
	msleep_interruptible(4 * 1000);
   10a8c:	bf a0 0f 00 00       	mov    $0xfa0,%edi
   10a91:	e8 00 00 00 00       	callq  10a96 <e1000_diag_test+0x96>
}
   10a96:	48 83 c4 70          	add    $0x70,%rsp
   10a9a:	5b                   	pop    %rbx
   10a9b:	41 5c                	pop    %r12
   10a9d:	41 5d                	pop    %r13
   10a9f:	41 5e                	pop    %r14
   10aa1:	41 5f                	pop    %r15
   10aa3:	5d                   	pop    %rbp
   10aa4:	c3                   	retq   
			dev_open(netdev);
	} else {
		e_info(hw, "online testing starting\n");
		/* Online tests */
		if (e1000_link_test(adapter, &data[4]))
			eth_test->flags |= ETH_TEST_FL_FAILED;
   10aa5:	48 8b 45 88          	mov    -0x78(%rbp),%rax
   10aa9:	83 48 04 02          	orl    $0x2,0x4(%rax)
   10aad:	eb b1                	jmp    10a60 <e1000_diag_test+0x60>
	set_bit(__E1000_TESTING, &adapter->flags);
	if (eth_test->flags == ETH_TEST_FL_OFFLINE) {
		/* Offline tests */

		/* save speed, duplex, autoneg settings */
		u16 autoneg_advertised = hw->autoneg_advertised;
   10aaf:	0f b7 87 d2 0c 00 00 	movzwl 0xcd2(%rdi),%eax
		u8 forced_speed_duplex = hw->forced_speed_duplex;
		u8 autoneg = hw->autoneg;

		e_info(hw, "offline testing starting\n");
   10ab6:	f6 87 e1 0f 00 00 20 	testb  $0x20,0xfe1(%rdi)
	set_bit(__E1000_TESTING, &adapter->flags);
	if (eth_test->flags == ETH_TEST_FL_OFFLINE) {
		/* Offline tests */

		/* save speed, duplex, autoneg settings */
		u16 autoneg_advertised = hw->autoneg_advertised;
   10abd:	66 89 45 86          	mov    %ax,-0x7a(%rbp)
		u8 forced_speed_duplex = hw->forced_speed_duplex;
   10ac1:	0f b6 87 f1 0c 00 00 	movzbl 0xcf1(%rdi),%eax
   10ac8:	88 45 85             	mov    %al,-0x7b(%rbp)
		u8 autoneg = hw->autoneg;
   10acb:	0f b6 87 ef 0c 00 00 	movzbl 0xcef(%rdi),%eax
   10ad2:	88 45 84             	mov    %al,-0x7c(%rbp)

		e_info(hw, "offline testing starting\n");
   10ad5:	0f 85 2e 0a 00 00    	jne    11509 <e1000_diag_test+0xb09>

		/* Link test performed before hardware reset so autoneg doesn't
		 * interfere with test result
		 */
		if (e1000_link_test(adapter, &data[4]))
   10adb:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
   10adf:	48 8b 7d 90          	mov    -0x70(%rbp),%rdi
   10ae3:	48 8d 70 20          	lea    0x20(%rax),%rsi
   10ae7:	e8 14 e9 ff ff       	callq  f400 <e1000_link_test>
   10aec:	85 c0                	test   %eax,%eax
   10aee:	74 08                	je     10af8 <e1000_diag_test+0xf8>
			eth_test->flags |= ETH_TEST_FL_FAILED;
   10af0:	48 8b 45 88          	mov    -0x78(%rbp),%rax
   10af4:	83 48 04 02          	orl    $0x2,0x4(%rax)

		if (if_running)
   10af8:	89 d8                	mov    %ebx,%eax
   10afa:	83 e0 01             	and    $0x1,%eax
   10afd:	88 45 83             	mov    %al,-0x7d(%rbp)
   10b00:	0f 85 5a 09 00 00    	jne    11460 <e1000_diag_test+0xa60>
			/* indicate we're in test mode */
			dev_close(netdev);
		else
			e1000_reset(adapter);
   10b06:	48 8b 7d 90          	mov    -0x70(%rbp),%rdi
   10b0a:	e8 00 00 00 00       	callq  10b0f <e1000_diag_test+0x10f>
	 */

	/* there are several bits on newer hardware that are r/w */
	toggle = 0xFFFFF833;

	before = er32(STATUS);
   10b0f:	49 8b 87 00 0c 00 00 	mov    0xc00(%r15),%rax
{ asm volatile("mov" size " %0,%1": :reg (val), \
"m" (*(volatile type __force *)addr) barrier); }

build_mmio_read(readb, "b", unsigned char, "=q", :"memory")
build_mmio_read(readw, "w", unsigned short, "=r", :"memory")
build_mmio_read(readl, "l", unsigned int, "=r", :"memory")
   10b16:	8b 70 08             	mov    0x8(%rax),%esi
	value = (er32(STATUS) & toggle);
   10b19:	49 8b 87 00 0c 00 00 	mov    0xc00(%r15),%rax
   10b20:	8b 48 08             	mov    0x8(%rax),%ecx
build_mmio_read(__readw, "w", unsigned short, "=r", )
build_mmio_read(__readl, "l", unsigned int, "=r", )

build_mmio_write(writeb, "b", unsigned char, "q", :"memory")
build_mmio_write(writew, "w", unsigned short, "r", :"memory")
build_mmio_write(writel, "l", unsigned int, "r", :"memory")
   10b23:	b8 33 f8 ff ff       	mov    $0xfffff833,%eax
   10b28:	81 e1 33 f8 ff ff    	and    $0xfffff833,%ecx
	ew32(STATUS, toggle);
   10b2e:	49 8b 97 00 0c 00 00 	mov    0xc00(%r15),%rdx
   10b35:	89 42 08             	mov    %eax,0x8(%rdx)
	after = er32(STATUS) & toggle;
   10b38:	49 8b 87 00 0c 00 00 	mov    0xc00(%r15),%rax
{ asm volatile("mov" size " %0,%1": :reg (val), \
"m" (*(volatile type __force *)addr) barrier); }

build_mmio_read(readb, "b", unsigned char, "=q", :"memory")
build_mmio_read(readw, "w", unsigned short, "=r", :"memory")
build_mmio_read(readl, "l", unsigned int, "=r", :"memory")
   10b3f:	8b 50 08             	mov    0x8(%rax),%edx
   10b42:	81 e2 33 f8 ff ff    	and    $0xfffff833,%edx
	if (value != after) {
   10b48:	39 d1                	cmp    %edx,%ecx
   10b4a:	0f 84 be 0a 00 00    	je     1160e <e1000_diag_test+0xc0e>
		e_err(drv, "failed STATUS register test got: "
   10b50:	41 f6 87 e0 0f 00 00 	testb  $0x1,0xfe0(%r15)
   10b57:	01 
   10b58:	74 15                	je     10b6f <e1000_diag_test+0x16f>
   10b5a:	49 8b bf f0 0b 00 00 	mov    0xbf0(%r15),%rdi
   10b61:	48 c7 c6 00 00 00 00 	mov    $0x0,%rsi
   10b68:	31 c0                	xor    %eax,%eax
   10b6a:	e8 00 00 00 00       	callq  10b6f <e1000_diag_test+0x16f>
		      "0x%08X expected: 0x%08X\n", after, value);
		*data = 1;
   10b6f:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
   10b73:	48 c7 00 01 00 00 00 	movq   $0x1,(%rax)
			dev_close(netdev);
		else
			e1000_reset(adapter);

		if (e1000_reg_test(adapter, &data[0]))
			eth_test->flags |= ETH_TEST_FL_FAILED;
   10b7a:	48 8b 45 88          	mov    -0x78(%rbp),%rax
   10b7e:	83 48 04 02          	orl    $0x2,0x4(%rax)

		e1000_reset(adapter);
   10b82:	48 8b 7d 90          	mov    -0x70(%rbp),%rdi
	struct e1000_hw *hw = &adapter->hw;
	u16 temp;
	u16 checksum = 0;
	u16 i;

	*data = 0;
   10b86:	45 31 e4             	xor    %r12d,%r12d
			e1000_reset(adapter);

		if (e1000_reg_test(adapter, &data[0]))
			eth_test->flags |= ETH_TEST_FL_FAILED;

		e1000_reset(adapter);
   10b89:	e8 00 00 00 00       	callq  10b8e <e1000_diag_test+0x18e>
	struct e1000_hw *hw = &adapter->hw;
	u16 temp;
	u16 checksum = 0;
	u16 i;

	*data = 0;
   10b8e:	48 8b 5d a0          	mov    -0x60(%rbp),%rbx
	return 0;
}

static int e1000_eeprom_test(struct e1000_adapter *adapter, u64 *data)
{
	struct e1000_hw *hw = &adapter->hw;
   10b92:	49 8d 87 00 0c 00 00 	lea    0xc00(%r15),%rax
   10b99:	48 89 85 70 ff ff ff 	mov    %rax,-0x90(%rbp)
   10ba0:	49 89 c5             	mov    %rax,%r13
	u16 temp;
	u16 checksum = 0;
	u16 i;

	*data = 0;
   10ba3:	48 c7 43 08 00 00 00 	movq   $0x0,0x8(%rbx)
   10baa:	00 

static int e1000_eeprom_test(struct e1000_adapter *adapter, u64 *data)
{
	struct e1000_hw *hw = &adapter->hw;
	u16 temp;
	u16 checksum = 0;
   10bab:	31 db                	xor    %ebx,%ebx
   10bad:	eb 12                	jmp    10bc1 <e1000_diag_test+0x1c1>
   10baf:	41 83 c4 01          	add    $0x1,%r12d
	for (i = 0; i < (EEPROM_CHECKSUM_REG + 1); i++) {
		if ((e1000_read_eeprom(hw, i, 1, &temp)) < 0) {
			*data = 1;
			break;
		}
		checksum += temp;
   10bb3:	66 03 5d d0          	add    -0x30(%rbp),%bx
	u16 checksum = 0;
	u16 i;

	*data = 0;
	/* Read and add up the contents of the EEPROM */
	for (i = 0; i < (EEPROM_CHECKSUM_REG + 1); i++) {
   10bb7:	41 83 fc 40          	cmp    $0x40,%r12d
   10bbb:	0f 84 62 09 00 00    	je     11523 <e1000_diag_test+0xb23>
		if ((e1000_read_eeprom(hw, i, 1, &temp)) < 0) {
   10bc1:	48 8d 4d d0          	lea    -0x30(%rbp),%rcx
   10bc5:	ba 01 00 00 00       	mov    $0x1,%edx
   10bca:	44 89 e6             	mov    %r12d,%esi
   10bcd:	4c 89 ef             	mov    %r13,%rdi
   10bd0:	e8 00 00 00 00       	callq  10bd5 <e1000_diag_test+0x1d5>
   10bd5:	85 c0                	test   %eax,%eax
   10bd7:	79 d6                	jns    10baf <e1000_diag_test+0x1af>
			*data = 1;
   10bd9:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
   10bdd:	48 c7 40 08 01 00 00 	movq   $0x1,0x8(%rax)
   10be4:	00 
		if (e1000_reg_test(adapter, &data[0]))
			eth_test->flags |= ETH_TEST_FL_FAILED;

		e1000_reset(adapter);
		if (e1000_eeprom_test(adapter, &data[1]))
			eth_test->flags |= ETH_TEST_FL_FAILED;
   10be5:	48 8b 45 88          	mov    -0x78(%rbp),%rax
   10be9:	83 48 04 02          	orl    $0x2,0x4(%rax)

		e1000_reset(adapter);
   10bed:	48 8b 7d 90          	mov    -0x70(%rbp),%rdi
   10bf1:	e8 00 00 00 00       	callq  10bf6 <e1000_diag_test+0x1f6>
	return IRQ_HANDLED;
}

static int e1000_intr_test(struct e1000_adapter *adapter, u64 *data)
{
	struct net_device *netdev = adapter->netdev;
   10bf6:	49 8b 87 f0 0b 00 00 	mov    0xbf0(%r15),%rax
	u32 mask, i = 0;
	bool shared_int = true;
	u32 irq = adapter->pdev->irq;
	struct e1000_hw *hw = &adapter->hw;

	*data = 0;
   10bfd:	48 8b 5d a0          	mov    -0x60(%rbp),%rbx
   10c01:	31 d2                	xor    %edx,%edx
   10c03:	b9 00 01 00 00       	mov    $0x100,%ecx
   10c08:	48 c7 c6 00 00 00 00 	mov    $0x0,%rsi
	return IRQ_HANDLED;
}

static int e1000_intr_test(struct e1000_adapter *adapter, u64 *data)
{
	struct net_device *netdev = adapter->netdev;
   10c0f:	49 89 c0             	mov    %rax,%r8
   10c12:	48 89 45 b0          	mov    %rax,-0x50(%rbp)
	u32 mask, i = 0;
	bool shared_int = true;
	u32 irq = adapter->pdev->irq;
   10c16:	49 8b 87 f8 0b 00 00 	mov    0xbf8(%r15),%rax
   10c1d:	4d 89 c1             	mov    %r8,%r9
   10c20:	8b 80 74 03 00 00    	mov    0x374(%rax),%eax
	struct e1000_hw *hw = &adapter->hw;

	*data = 0;
   10c26:	48 c7 43 10 00 00 00 	movq   $0x0,0x10(%rbx)
   10c2d:	00 
   10c2e:	89 c7                	mov    %eax,%edi
static int e1000_intr_test(struct e1000_adapter *adapter, u64 *data)
{
	struct net_device *netdev = adapter->netdev;
	u32 mask, i = 0;
	bool shared_int = true;
	u32 irq = adapter->pdev->irq;
   10c30:	89 45 a8             	mov    %eax,-0x58(%rbp)
   10c33:	e8 00 00 00 00       	callq  10c38 <e1000_diag_test+0x238>
	*data = 0;

	/* NOTE: we don't test MSI interrupts here, yet
	 * Hook up test interrupt handler just for this test
	 */
	if (!request_irq(irq, e1000_test_intr, IRQF_PROBE_SHARED, netdev->name,
   10c38:	85 c0                	test   %eax,%eax
   10c3a:	0f 85 6f 08 00 00    	jne    114af <e1000_diag_test+0xaaf>
			 netdev))
		shared_int = false;
   10c40:	45 31 e4             	xor    %r12d,%r12d
	else if (request_irq(irq, e1000_test_intr, IRQF_SHARED,
			     netdev->name, netdev)) {
		*data = 1;
		return -1;
	}
	e_info(hw, "testing %s interrupt\n", (shared_int ?
   10c43:	41 f6 87 e1 0f 00 00 	testb  $0x20,0xfe1(%r15)
   10c4a:	20 
   10c4b:	0f 85 ce 14 00 00    	jne    1211f <e1000_diag_test+0x171f>
	       "shared" : "unshared"));

	/* Disable all the interrupts */
	ew32(IMC, 0xFFFFFFFF);
   10c51:	49 8b 97 00 0c 00 00 	mov    0xc00(%r15),%rdx
build_mmio_read(__readw, "w", unsigned short, "=r", )
build_mmio_read(__readl, "l", unsigned int, "=r", )

build_mmio_write(writeb, "b", unsigned char, "q", :"memory")
build_mmio_write(writew, "w", unsigned short, "r", :"memory")
build_mmio_write(writel, "l", unsigned int, "r", :"memory")
   10c58:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
   10c5d:	89 82 d8 00 00 00    	mov    %eax,0xd8(%rdx)
	E1000_WRITE_FLUSH();
   10c63:	49 8b 87 00 0c 00 00 	mov    0xc00(%r15),%rax
{ asm volatile("mov" size " %0,%1": :reg (val), \
"m" (*(volatile type __force *)addr) barrier); }

build_mmio_read(readb, "b", unsigned char, "=q", :"memory")
build_mmio_read(readw, "w", unsigned short, "=r", :"memory")
build_mmio_read(readl, "l", unsigned int, "=r", :"memory")
   10c6a:	8b 40 08             	mov    0x8(%rax),%eax
	msleep(10);
   10c6d:	bf 0a 00 00 00       	mov    $0xa,%edi
}

static int e1000_intr_test(struct e1000_adapter *adapter, u64 *data)
{
	struct net_device *netdev = adapter->netdev;
	u32 mask, i = 0;
   10c72:	31 db                	xor    %ebx,%ebx
	msleep(10);

	/* Test each interrupt */
	for (; i < 10; i++) {
		/* Interrupt to test */
		mask = 1 << i;
   10c74:	41 bd 01 00 00 00    	mov    $0x1,%r13d
	       "shared" : "unshared"));

	/* Disable all the interrupts */
	ew32(IMC, 0xFFFFFFFF);
	E1000_WRITE_FLUSH();
	msleep(10);
   10c7a:	e8 00 00 00 00       	callq  10c7f <e1000_diag_test+0x27f>
   10c7f:	eb 0c                	jmp    10c8d <e1000_diag_test+0x28d>

	/* Test each interrupt */
	for (; i < 10; i++) {
   10c81:	83 c3 01             	add    $0x1,%ebx
   10c84:	83 fb 0a             	cmp    $0xa,%ebx
   10c87:	0f 84 07 01 00 00    	je     10d94 <e1000_diag_test+0x394>
		/* Interrupt to test */
		mask = 1 << i;
   10c8d:	45 89 ee             	mov    %r13d,%r14d
   10c90:	89 d9                	mov    %ebx,%ecx
   10c92:	41 d3 e6             	shl    %cl,%r14d

		if (!shared_int) {
   10c95:	45 84 e4             	test   %r12b,%r12b
   10c98:	75 48                	jne    10ce2 <e1000_diag_test+0x2e2>
			 * the cause register and then force the same
			 * interrupt and see if one gets posted.  If
			 * an interrupt was posted to the bus, the
			 * test failed.
			 */
			adapter->test_icr = 0;
   10c9a:	41 c7 87 70 0f 00 00 	movl   $0x0,0xf70(%r15)
   10ca1:	00 00 00 00 
			ew32(IMC, mask);
   10ca5:	49 8b 87 00 0c 00 00 	mov    0xc00(%r15),%rax
build_mmio_read(__readw, "w", unsigned short, "=r", )
build_mmio_read(__readl, "l", unsigned int, "=r", )

build_mmio_write(writeb, "b", unsigned char, "q", :"memory")
build_mmio_write(writew, "w", unsigned short, "r", :"memory")
build_mmio_write(writel, "l", unsigned int, "r", :"memory")
   10cac:	44 89 b0 d8 00 00 00 	mov    %r14d,0xd8(%rax)
			ew32(ICS, mask);
   10cb3:	49 8b 87 00 0c 00 00 	mov    0xc00(%r15),%rax
   10cba:	44 89 b0 c8 00 00 00 	mov    %r14d,0xc8(%rax)
			E1000_WRITE_FLUSH();
   10cc1:	49 8b 87 00 0c 00 00 	mov    0xc00(%r15),%rax
{ asm volatile("mov" size " %0,%1": :reg (val), \
"m" (*(volatile type __force *)addr) barrier); }

build_mmio_read(readb, "b", unsigned char, "=q", :"memory")
build_mmio_read(readw, "w", unsigned short, "=r", :"memory")
build_mmio_read(readl, "l", unsigned int, "=r", :"memory")
   10cc8:	8b 40 08             	mov    0x8(%rax),%eax
			msleep(10);
   10ccb:	bf 0a 00 00 00       	mov    $0xa,%edi
   10cd0:	e8 00 00 00 00       	callq  10cd5 <e1000_diag_test+0x2d5>

			if (adapter->test_icr & mask) {
   10cd5:	45 85 b7 70 0f 00 00 	test   %r14d,0xf70(%r15)
   10cdc:	0f 85 e1 0d 00 00    	jne    11ac3 <e1000_diag_test+0x10c3>
		 * the cause register and then force the same
		 * interrupt and see if one gets posted.  If
		 * an interrupt was not posted to the bus, the
		 * test failed.
		 */
		adapter->test_icr = 0;
   10ce2:	41 c7 87 70 0f 00 00 	movl   $0x0,0xf70(%r15)
   10ce9:	00 00 00 00 
		ew32(IMS, mask);
   10ced:	49 8b 87 00 0c 00 00 	mov    0xc00(%r15),%rax
build_mmio_read(__readw, "w", unsigned short, "=r", )
build_mmio_read(__readl, "l", unsigned int, "=r", )

build_mmio_write(writeb, "b", unsigned char, "q", :"memory")
build_mmio_write(writew, "w", unsigned short, "r", :"memory")
build_mmio_write(writel, "l", unsigned int, "r", :"memory")
   10cf4:	44 89 b0 d0 00 00 00 	mov    %r14d,0xd0(%rax)
		ew32(ICS, mask);
   10cfb:	49 8b 87 00 0c 00 00 	mov    0xc00(%r15),%rax
   10d02:	44 89 b0 c8 00 00 00 	mov    %r14d,0xc8(%rax)
		E1000_WRITE_FLUSH();
   10d09:	49 8b 87 00 0c 00 00 	mov    0xc00(%r15),%rax
{ asm volatile("mov" size " %0,%1": :reg (val), \
"m" (*(volatile type __force *)addr) barrier); }

build_mmio_read(readb, "b", unsigned char, "=q", :"memory")
build_mmio_read(readw, "w", unsigned short, "=r", :"memory")
build_mmio_read(readl, "l", unsigned int, "=r", :"memory")
   10d10:	8b 40 08             	mov    0x8(%rax),%eax
		msleep(10);
   10d13:	bf 0a 00 00 00       	mov    $0xa,%edi
   10d18:	e8 00 00 00 00       	callq  10d1d <e1000_diag_test+0x31d>

		if (!(adapter->test_icr & mask)) {
   10d1d:	45 85 b7 70 0f 00 00 	test   %r14d,0xf70(%r15)
   10d24:	0f 84 d3 08 00 00    	je     115fd <e1000_diag_test+0xbfd>
			*data = 4;
			break;
		}

		if (!shared_int) {
   10d2a:	45 84 e4             	test   %r12b,%r12b
   10d2d:	0f 85 4e ff ff ff    	jne    10c81 <e1000_diag_test+0x281>
			 * interrupts and see if any get posted.  If
			 * an interrupt was posted to the bus, the
			 * test failed.
			 */
			adapter->test_icr = 0;
			ew32(IMC, ~mask & 0x00007FFF);
   10d33:	41 f7 d6             	not    %r14d
			 * the cause register and then force the other
			 * interrupts and see if any get posted.  If
			 * an interrupt was posted to the bus, the
			 * test failed.
			 */
			adapter->test_icr = 0;
   10d36:	41 c7 87 70 0f 00 00 	movl   $0x0,0xf70(%r15)
   10d3d:	00 00 00 00 
			ew32(IMC, ~mask & 0x00007FFF);
   10d41:	49 8b 87 00 0c 00 00 	mov    0xc00(%r15),%rax
   10d48:	41 81 e6 ff 7f 00 00 	and    $0x7fff,%r14d
build_mmio_read(__readw, "w", unsigned short, "=r", )
build_mmio_read(__readl, "l", unsigned int, "=r", )

build_mmio_write(writeb, "b", unsigned char, "q", :"memory")
build_mmio_write(writew, "w", unsigned short, "r", :"memory")
build_mmio_write(writel, "l", unsigned int, "r", :"memory")
   10d4f:	44 89 b0 d8 00 00 00 	mov    %r14d,0xd8(%rax)
			ew32(ICS, ~mask & 0x00007FFF);
   10d56:	49 8b 87 00 0c 00 00 	mov    0xc00(%r15),%rax
   10d5d:	44 89 b0 c8 00 00 00 	mov    %r14d,0xc8(%rax)
			E1000_WRITE_FLUSH();
   10d64:	49 8b 87 00 0c 00 00 	mov    0xc00(%r15),%rax
{ asm volatile("mov" size " %0,%1": :reg (val), \
"m" (*(volatile type __force *)addr) barrier); }

build_mmio_read(readb, "b", unsigned char, "=q", :"memory")
build_mmio_read(readw, "w", unsigned short, "=r", :"memory")
build_mmio_read(readl, "l", unsigned int, "=r", :"memory")
   10d6b:	8b 40 08             	mov    0x8(%rax),%eax
			msleep(10);
   10d6e:	bf 0a 00 00 00       	mov    $0xa,%edi
   10d73:	e8 00 00 00 00       	callq  10d78 <e1000_diag_test+0x378>

			if (adapter->test_icr) {
   10d78:	45 8b b7 70 0f 00 00 	mov    0xf70(%r15),%r14d
   10d7f:	45 85 f6             	test   %r14d,%r14d
   10d82:	0f 84 f9 fe ff ff    	je     10c81 <e1000_diag_test+0x281>
				*data = 5;
   10d88:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
   10d8c:	48 c7 40 10 05 00 00 	movq   $0x5,0x10(%rax)
   10d93:	00 
			}
		}
	}

	/* Disable all the interrupts */
	ew32(IMC, 0xFFFFFFFF);
   10d94:	49 8b 97 00 0c 00 00 	mov    0xc00(%r15),%rdx
build_mmio_read(__readw, "w", unsigned short, "=r", )
build_mmio_read(__readl, "l", unsigned int, "=r", )

build_mmio_write(writeb, "b", unsigned char, "q", :"memory")
build_mmio_write(writew, "w", unsigned short, "r", :"memory")
build_mmio_write(writel, "l", unsigned int, "r", :"memory")
   10d9b:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
   10da0:	89 82 d8 00 00 00    	mov    %eax,0xd8(%rdx)
	E1000_WRITE_FLUSH();
   10da6:	49 8b 87 00 0c 00 00 	mov    0xc00(%r15),%rax
{ asm volatile("mov" size " %0,%1": :reg (val), \
"m" (*(volatile type __force *)addr) barrier); }

build_mmio_read(readb, "b", unsigned char, "=q", :"memory")
build_mmio_read(readw, "w", unsigned short, "=r", :"memory")
build_mmio_read(readl, "l", unsigned int, "=r", :"memory")
   10dad:	8b 40 08             	mov    0x8(%rax),%eax
	msleep(10);
   10db0:	bf 0a 00 00 00       	mov    $0xa,%edi
   10db5:	e8 00 00 00 00       	callq  10dba <e1000_diag_test+0x3ba>

	/* Unhook test interrupt handler */
	free_irq(irq, netdev);
   10dba:	48 8b 75 b0          	mov    -0x50(%rbp),%rsi
   10dbe:	8b 7d a8             	mov    -0x58(%rbp),%edi
   10dc1:	e8 00 00 00 00       	callq  10dc6 <e1000_diag_test+0x3c6>
		e1000_reset(adapter);
		if (e1000_eeprom_test(adapter, &data[1]))
			eth_test->flags |= ETH_TEST_FL_FAILED;

		e1000_reset(adapter);
		if (e1000_intr_test(adapter, &data[2]))
   10dc6:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
   10dca:	44 8b 60 10          	mov    0x10(%rax),%r12d
   10dce:	45 85 e4             	test   %r12d,%r12d
   10dd1:	74 08                	je     10ddb <e1000_diag_test+0x3db>
			eth_test->flags |= ETH_TEST_FL_FAILED;
   10dd3:	48 8b 45 88          	mov    -0x78(%rbp),%rax
   10dd7:	83 48 04 02          	orl    $0x2,0x4(%rax)

		e1000_reset(adapter);
   10ddb:	48 8b 5d 90          	mov    -0x70(%rbp),%rbx
   10ddf:	48 89 df             	mov    %rbx,%rdi
   10de2:	e8 00 00 00 00       	callq  10de7 <e1000_diag_test+0x3e7>
		/* make sure the phy is powered up */
		e1000_power_up_phy(adapter);
   10de7:	48 89 df             	mov    %rbx,%rdi
   10dea:	e8 00 00 00 00       	callq  10def <e1000_diag_test+0x3ef>
static int e1000_setup_desc_rings(struct e1000_adapter *adapter)
{
	struct e1000_hw *hw = &adapter->hw;
	struct e1000_tx_ring *txdr = &adapter->test_tx_ring;
	struct e1000_rx_ring *rxdr = &adapter->test_rx_ring;
	struct pci_dev *pdev = adapter->pdev;
   10def:	49 8b 87 f8 0b 00 00 	mov    0xbf8(%r15),%rax
   10df6:	48 89 45 a8          	mov    %rax,-0x58(%rbp)
	u32 rctl;
	int i, ret_val;

	/* Setup Tx descriptor ring and Tx buffers */

	if (!txdr->count)
   10dfa:	41 8b 87 8c 0f 00 00 	mov    0xf8c(%r15),%eax
   10e01:	85 c0                	test   %eax,%eax
   10e03:	0f 84 91 06 00 00    	je     1149a <e1000_diag_test+0xa9a>
   10e09:	48 8d 3c 80          	lea    (%rax,%rax,4),%rdi
   10e0d:	48 c1 e7 03          	shl    $0x3,%rdi
 */
static inline void *kmalloc_array(size_t n, size_t size, gfp_t flags)
{
	if (size != 0 && n > SIZE_MAX / size)
		return NULL;
	return __kmalloc(n * size, flags);
   10e11:	be c0 80 40 02       	mov    $0x24080c0,%esi
   10e16:	e8 00 00 00 00       	callq  10e1b <e1000_diag_test+0x41b>
		txdr->count = E1000_DEFAULT_TXD;

	txdr->buffer_info = kcalloc(txdr->count, sizeof(struct e1000_tx_buffer),
				    GFP_KERNEL);
	if (!txdr->buffer_info) {
   10e1b:	48 85 c0             	test   %rax,%rax
	/* Setup Tx descriptor ring and Tx buffers */

	if (!txdr->count)
		txdr->count = E1000_DEFAULT_TXD;

	txdr->buffer_info = kcalloc(txdr->count, sizeof(struct e1000_tx_buffer),
   10e1e:	49 89 87 98 0f 00 00 	mov    %rax,0xf98(%r15)
				    GFP_KERNEL);
	if (!txdr->buffer_info) {
   10e25:	0f 84 bb 11 00 00    	je     11fe6 <e1000_diag_test+0x15e6>
		ret_val = 1;
		goto err_nomem;
	}

	txdr->size = txdr->count * sizeof(struct e1000_tx_desc);
   10e2b:	41 8b 9f 8c 0f 00 00 	mov    0xf8c(%r15),%ebx
	txdr->size = ALIGN(txdr->size, 4096);
	txdr->desc = dma_zalloc_coherent(&pdev->dev, txdr->size, &txdr->dma,
   10e32:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
   10e36:	4d 8d af 80 0f 00 00 	lea    0xf80(%r15),%r13
   10e3d:	c7 45 c0 c0 80 40 02 	movl   $0x24080c0,-0x40(%rbp)
	if (!txdr->buffer_info) {
		ret_val = 1;
		goto err_nomem;
	}

	txdr->size = txdr->count * sizeof(struct e1000_tx_desc);
   10e44:	c1 e3 04             	shl    $0x4,%ebx
	txdr->size = ALIGN(txdr->size, 4096);
	txdr->desc = dma_zalloc_coherent(&pdev->dev, txdr->size, &txdr->dma,
   10e47:	4c 8d a0 98 00 00 00 	lea    0x98(%rax),%r12
		ret_val = 1;
		goto err_nomem;
	}

	txdr->size = txdr->count * sizeof(struct e1000_tx_desc);
	txdr->size = ALIGN(txdr->size, 4096);
   10e4e:	81 c3 ff 0f 00 00    	add    $0xfff,%ebx
   10e54:	81 e3 00 f0 ff ff    	and    $0xfffff000,%ebx
static inline struct dma_map_ops *get_dma_ops(struct device *dev)
{
#ifndef CONFIG_X86_DEV_DMA_OPS
	return dma_ops;
#else
	if (unlikely(!dev) || !dev->archdata.dma_ops)
   10e5a:	4d 85 e4             	test   %r12,%r12
   10e5d:	4c 89 65 c8          	mov    %r12,-0x38(%rbp)
   10e61:	41 89 9f 88 0f 00 00 	mov    %ebx,0xf88(%r15)
   10e68:	0f 84 2e 0c 00 00    	je     11a9c <e1000_diag_test+0x109c>
   10e6e:	4c 8b b0 e8 02 00 00 	mov    0x2e8(%rax),%r14
   10e75:	4d 85 f6             	test   %r14,%r14
   10e78:	0f 84 1e 0c 00 00    	je     11a9c <e1000_diag_test+0x109c>
	BUG_ON(!ops);

	if (dma_alloc_from_coherent(dev, size, dma_handle, &cpu_addr))
		return cpu_addr;

	if (!arch_dma_alloc_attrs(&dev, &flag))
   10e7e:	48 8d 75 c0          	lea    -0x40(%rbp),%rsi
   10e82:	48 8d 7d c8          	lea    -0x38(%rbp),%rdi
   10e86:	e8 00 00 00 00       	callq  10e8b <e1000_diag_test+0x48b>
   10e8b:	84 c0                	test   %al,%al
   10e8d:	0f 84 1b 0c 00 00    	je     11aae <e1000_diag_test+0x10ae>
		return NULL;
	if (!ops->alloc)
   10e93:	49 8b 06             	mov    (%r14),%rax
   10e96:	48 85 c0             	test   %rax,%rax
   10e99:	0f 84 0f 0c 00 00    	je     11aae <e1000_diag_test+0x10ae>
		return NULL;

	cpu_addr = ops->alloc(dev, size, dma_handle, flag, attrs);
   10e9f:	45 31 c0             	xor    %r8d,%r8d
   10ea2:	8b 4d c0             	mov    -0x40(%rbp),%ecx
   10ea5:	4c 89 ea             	mov    %r13,%rdx
   10ea8:	48 89 de             	mov    %rbx,%rsi
   10eab:	48 8b 7d c8          	mov    -0x38(%rbp),%rdi
   10eaf:	ff d0                	callq  *%rax
	txdr->desc = dma_zalloc_coherent(&pdev->dev, txdr->size, &txdr->dma,
					 GFP_KERNEL);
	if (!txdr->desc) {
   10eb1:	48 85 c0             	test   %rax,%rax
		goto err_nomem;
	}

	txdr->size = txdr->count * sizeof(struct e1000_tx_desc);
	txdr->size = ALIGN(txdr->size, 4096);
	txdr->desc = dma_zalloc_coherent(&pdev->dev, txdr->size, &txdr->dma,
   10eb4:	49 89 87 78 0f 00 00 	mov    %rax,0xf78(%r15)
					 GFP_KERNEL);
	if (!txdr->desc) {
   10ebb:	0f 84 91 11 00 00    	je     12052 <e1000_diag_test+0x1652>
		ret_val = 2;
		goto err_nomem;
	}
	txdr->next_to_use = txdr->next_to_clean = 0;

	ew32(TDBAL, ((u64)txdr->dma & 0x00000000FFFFFFFF));
   10ec1:	41 83 bf 18 0c 00 00 	cmpl   $0x3,0xc18(%r15)
   10ec8:	03 
					 GFP_KERNEL);
	if (!txdr->desc) {
		ret_val = 2;
		goto err_nomem;
	}
	txdr->next_to_use = txdr->next_to_clean = 0;
   10ec9:	41 c7 87 94 0f 00 00 	movl   $0x0,0xf94(%r15)
   10ed0:	00 00 00 00 
   10ed4:	41 c7 87 90 0f 00 00 	movl   $0x0,0xf90(%r15)
   10edb:	00 00 00 00 

	ew32(TDBAL, ((u64)txdr->dma & 0x00000000FFFFFFFF));
   10edf:	49 8b 97 80 0f 00 00 	mov    0xf80(%r15),%rdx
   10ee6:	48 19 c0             	sbb    %rax,%rax
   10ee9:	48 25 20 cc ff ff    	and    $0xffffffffffffcc20,%rax
   10eef:	48 05 00 38 00 00    	add    $0x3800,%rax
   10ef5:	49 03 87 00 0c 00 00 	add    0xc00(%r15),%rax
build_mmio_read(__readw, "w", unsigned short, "=r", )
build_mmio_read(__readl, "l", unsigned int, "=r", )

build_mmio_write(writeb, "b", unsigned char, "q", :"memory")
build_mmio_write(writew, "w", unsigned short, "r", :"memory")
build_mmio_write(writel, "l", unsigned int, "r", :"memory")
   10efc:	89 10                	mov    %edx,(%rax)
	ew32(TDBAH, ((u64)txdr->dma >> 32));
   10efe:	41 83 bf 18 0c 00 00 	cmpl   $0x3,0xc18(%r15)
   10f05:	03 
   10f06:	41 8b 97 84 0f 00 00 	mov    0xf84(%r15),%edx
   10f0d:	48 19 c0             	sbb    %rax,%rax
   10f10:	48 25 20 cc ff ff    	and    $0xffffffffffffcc20,%rax
   10f16:	48 05 04 38 00 00    	add    $0x3804,%rax
   10f1c:	49 03 87 00 0c 00 00 	add    0xc00(%r15),%rax
   10f23:	89 10                	mov    %edx,(%rax)
	ew32(TDLEN, txdr->count * sizeof(struct e1000_tx_desc));
   10f25:	41 83 bf 18 0c 00 00 	cmpl   $0x3,0xc18(%r15)
   10f2c:	03 
   10f2d:	41 8b 87 8c 0f 00 00 	mov    0xf8c(%r15),%eax
   10f34:	48 19 d2             	sbb    %rdx,%rdx
   10f37:	c1 e0 04             	shl    $0x4,%eax
   10f3a:	48 81 e2 20 cc ff ff 	and    $0xffffffffffffcc20,%rdx
   10f41:	48 81 c2 08 38 00 00 	add    $0x3808,%rdx
   10f48:	49 03 97 00 0c 00 00 	add    0xc00(%r15),%rdx
   10f4f:	89 02                	mov    %eax,(%rdx)
	ew32(TDH, 0);
   10f51:	41 83 bf 18 0c 00 00 	cmpl   $0x3,0xc18(%r15)
   10f58:	03 
   10f59:	48 19 c0             	sbb    %rax,%rax
   10f5c:	31 d2                	xor    %edx,%edx
   10f5e:	48 25 20 cc ff ff    	and    $0xffffffffffffcc20,%rax
   10f64:	48 05 10 38 00 00    	add    $0x3810,%rax
   10f6a:	49 03 87 00 0c 00 00 	add    0xc00(%r15),%rax
   10f71:	89 10                	mov    %edx,(%rax)
	ew32(TDT, 0);
   10f73:	41 83 bf 18 0c 00 00 	cmpl   $0x3,0xc18(%r15)
   10f7a:	03 
   10f7b:	48 19 c0             	sbb    %rax,%rax
   10f7e:	48 25 20 cc ff ff    	and    $0xffffffffffffcc20,%rax
   10f84:	48 05 18 38 00 00    	add    $0x3818,%rax
   10f8a:	49 03 87 00 0c 00 00 	add    0xc00(%r15),%rax
   10f91:	89 10                	mov    %edx,(%rax)
   10f93:	b8 fa f0 03 00       	mov    $0x3f0fa,%eax
	ew32(TCTL, E1000_TCTL_PSP | E1000_TCTL_EN |
   10f98:	49 8b 97 00 0c 00 00 	mov    0xc00(%r15),%rdx
   10f9f:	89 82 00 04 00 00    	mov    %eax,0x400(%rdx)
	     E1000_COLLISION_THRESHOLD << E1000_CT_SHIFT |
	     E1000_FDX_COLLISION_DISTANCE << E1000_COLD_SHIFT);

	for (i = 0; i < txdr->count; i++) {
   10fa5:	41 8b 9f 8c 0f 00 00 	mov    0xf8c(%r15),%ebx
   10fac:	c7 45 b0 00 00 00 00 	movl   $0x0,-0x50(%rbp)
   10fb3:	85 db                	test   %ebx,%ebx
   10fb5:	0f 84 8e 01 00 00    	je     11149 <e1000_diag_test+0x749>
   10fbb:	4c 89 f8             	mov    %r15,%rax
   10fbe:	4d 89 e7             	mov    %r12,%r15
   10fc1:	49 89 c4             	mov    %rax,%r12
		struct e1000_tx_desc *tx_desc = E1000_TX_DESC(*txdr, i);
   10fc4:	4c 63 75 b0          	movslq -0x50(%rbp),%r14
struct sk_buff *__build_skb(void *data, unsigned int frag_size);
struct sk_buff *build_skb(void *data, unsigned int frag_size);
static inline struct sk_buff *alloc_skb(unsigned int size,
					gfp_t priority)
{
	return __alloc_skb(size, priority, 0, NUMA_NO_NODE);
   10fc8:	31 d2                	xor    %edx,%edx
   10fca:	b9 ff ff ff ff       	mov    $0xffffffff,%ecx
   10fcf:	be c0 00 40 02       	mov    $0x24000c0,%esi
   10fd4:	bf 00 04 00 00       	mov    $0x400,%edi
   10fd9:	4d 89 f5             	mov    %r14,%r13
   10fdc:	49 c1 e5 04          	shl    $0x4,%r13
   10fe0:	4d 03 ac 24 78 0f 00 	add    0xf78(%r12),%r13
   10fe7:	00 
   10fe8:	e8 00 00 00 00       	callq  10fed <e1000_diag_test+0x5ed>
		struct sk_buff *skb;
		unsigned int size = 1024;

		skb = alloc_skb(size, GFP_KERNEL);
		if (!skb) {
   10fed:	48 85 c0             	test   %rax,%rax
   10ff0:	48 89 c3             	mov    %rax,%rbx
   10ff3:	0f 84 58 05 00 00    	je     11551 <e1000_diag_test+0xb51>
			ret_val = 3;
			goto err_nomem;
		}
		skb_put(skb, size);
   10ff9:	be 00 04 00 00       	mov    $0x400,%esi
   10ffe:	48 89 c7             	mov    %rax,%rdi
   11001:	e8 00 00 00 00       	callq  11006 <e1000_diag_test+0x606>
		txdr->buffer_info[i].skb = skb;
   11006:	49 8b 94 24 98 0f 00 	mov    0xf98(%r12),%rdx
   1100d:	00 
   1100e:	4b 8d 04 b6          	lea    (%r14,%r14,4),%rax
   11012:	4c 8d 34 c5 00 00 00 	lea    0x0(,%rax,8),%r14
   11019:	00 
   1101a:	48 89 1c c2          	mov    %rbx,(%rdx,%rax,8)
		txdr->buffer_info[i].length = skb->len;
   1101e:	49 8b 84 24 98 0f 00 	mov    0xf98(%r12),%rax
   11025:	00 
   11026:	8b 93 80 00 00 00    	mov    0x80(%rbx),%edx
		txdr->buffer_info[i].dma =
   1102c:	4d 89 f3             	mov    %r14,%r11
			ret_val = 3;
			goto err_nomem;
		}
		skb_put(skb, size);
		txdr->buffer_info[i].skb = skb;
		txdr->buffer_info[i].length = skb->len;
   1102f:	66 42 89 54 30 18    	mov    %dx,0x18(%rax,%r14,1)
		txdr->buffer_info[i].dma =
   11035:	4d 03 9c 24 98 0f 00 	add    0xf98(%r12),%r11
   1103c:	00 
   1103d:	4d 85 ff             	test   %r15,%r15
			dma_map_single(&pdev->dev, skb->data, skb->len,
   11040:	8b 8b 80 00 00 00    	mov    0x80(%rbx),%ecx
   11046:	48 8b b3 d8 00 00 00 	mov    0xd8(%rbx),%rsi
   1104d:	0f 84 1a 04 00 00    	je     1146d <e1000_diag_test+0xa6d>
   11053:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
   11057:	48 8b 80 e8 02 00 00 	mov    0x2e8(%rax),%rax
   1105e:	48 85 c0             	test   %rax,%rax
   11061:	0f 84 06 04 00 00    	je     1146d <e1000_diag_test+0xa6d>
	struct dma_map_ops *ops = get_dma_ops(dev);
	dma_addr_t addr;

	kmemcheck_mark_initialized(ptr, size);
	BUG_ON(!valid_dma_direction(dir));
	addr = ops->map_page(dev, virt_to_page(ptr),
   11067:	48 89 f2             	mov    %rsi,%rdx
   1106a:	bf 00 00 00 80       	mov    $0x80000000,%edi
   1106f:	4c 89 5d 98          	mov    %r11,-0x68(%rbp)
   11073:	81 e2 ff 0f 00 00    	and    $0xfff,%edx
   11079:	48 01 fe             	add    %rdi,%rsi
   1107c:	48 bf 00 00 00 80 ff 	movabs $0x77ff80000000,%rdi
   11083:	77 00 00 
   11086:	48 0f 42 3d 00 00 00 	cmovb  0x0(%rip),%rdi        # 1108e <e1000_diag_test+0x68e>
   1108d:	00 
   1108e:	41 b8 01 00 00 00    	mov    $0x1,%r8d
   11094:	45 31 c9             	xor    %r9d,%r9d
   11097:	48 01 fe             	add    %rdi,%rsi
   1109a:	48 bf 00 00 00 00 00 	movabs $0xffffea0000000000,%rdi
   110a1:	ea ff ff 
   110a4:	48 c1 ee 0c          	shr    $0xc,%rsi
   110a8:	48 c1 e6 06          	shl    $0x6,%rsi
   110ac:	48 01 fe             	add    %rdi,%rsi
   110af:	4c 89 ff             	mov    %r15,%rdi
   110b2:	ff 50 20             	callq  *0x20(%rax)
			goto err_nomem;
		}
		skb_put(skb, size);
		txdr->buffer_info[i].skb = skb;
		txdr->buffer_info[i].length = skb->len;
		txdr->buffer_info[i].dma =
   110b5:	4c 8b 5d 98          	mov    -0x68(%rbp),%r11
   110b9:	4d 85 ff             	test   %r15,%r15
   110bc:	49 89 43 08          	mov    %rax,0x8(%r11)
			dma_map_single(&pdev->dev, skb->data, skb->len,
				       DMA_TO_DEVICE);
		if (dma_mapping_error(&pdev->dev, txdr->buffer_info[i].dma)) {
   110c0:	49 8b 84 24 98 0f 00 	mov    0xf98(%r12),%rax
   110c7:	00 
   110c8:	4a 8b 74 30 08       	mov    0x8(%rax,%r14,1),%rsi
   110cd:	0f 84 a6 03 00 00    	je     11479 <e1000_diag_test+0xa79>
   110d3:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
   110d7:	48 8b 80 e8 02 00 00 	mov    0x2e8(%rax),%rax
   110de:	48 85 c0             	test   %rax,%rax
   110e1:	0f 84 92 03 00 00    	je     11479 <e1000_diag_test+0xa79>

static inline int dma_mapping_error(struct device *dev, dma_addr_t dma_addr)
{
	debug_dma_mapping_error(dev, dma_addr);

	if (get_dma_ops(dev)->mapping_error)
   110e7:	48 83 78 60 00       	cmpq   $0x0,0x60(%rax)
   110ec:	0f 84 9b 03 00 00    	je     1148d <e1000_diag_test+0xa8d>
   110f2:	48 8b 40 60          	mov    0x60(%rax),%rax
		return get_dma_ops(dev)->mapping_error(dev, dma_addr);
   110f6:	4c 89 ff             	mov    %r15,%rdi
   110f9:	ff d0                	callq  *%rax
   110fb:	85 c0                	test   %eax,%eax
   110fd:	0f 85 ba 04 00 00    	jne    115bd <e1000_diag_test+0xbbd>
			ret_val = 4;
			goto err_nomem;
		}
		tx_desc->buffer_addr = cpu_to_le64(txdr->buffer_info[i].dma);
   11103:	49 8b 84 24 98 0f 00 	mov    0xf98(%r12),%rax
   1110a:	00 
	ew32(TDT, 0);
	ew32(TCTL, E1000_TCTL_PSP | E1000_TCTL_EN |
	     E1000_COLLISION_THRESHOLD << E1000_CT_SHIFT |
	     E1000_FDX_COLLISION_DISTANCE << E1000_COLD_SHIFT);

	for (i = 0; i < txdr->count; i++) {
   1110b:	83 45 b0 01          	addl   $0x1,-0x50(%rbp)
				       DMA_TO_DEVICE);
		if (dma_mapping_error(&pdev->dev, txdr->buffer_info[i].dma)) {
			ret_val = 4;
			goto err_nomem;
		}
		tx_desc->buffer_addr = cpu_to_le64(txdr->buffer_info[i].dma);
   1110f:	4a 8b 44 30 08       	mov    0x8(%rax,%r14,1),%rax
   11114:	49 89 45 00          	mov    %rax,0x0(%r13)
		tx_desc->lower.data = cpu_to_le32(skb->len);
		tx_desc->lower.data |= cpu_to_le32(E1000_TXD_CMD_EOP |
   11118:	8b 83 80 00 00 00    	mov    0x80(%rbx),%eax
						   E1000_TXD_CMD_IFCS |
						   E1000_TXD_CMD_RPS);
		tx_desc->upper.data = 0;
   1111e:	41 c7 45 0c 00 00 00 	movl   $0x0,0xc(%r13)
   11125:	00 
			ret_val = 4;
			goto err_nomem;
		}
		tx_desc->buffer_addr = cpu_to_le64(txdr->buffer_info[i].dma);
		tx_desc->lower.data = cpu_to_le32(skb->len);
		tx_desc->lower.data |= cpu_to_le32(E1000_TXD_CMD_EOP |
   11126:	0d 00 00 00 13       	or     $0x13000000,%eax
   1112b:	41 89 45 08          	mov    %eax,0x8(%r13)
	ew32(TDT, 0);
	ew32(TCTL, E1000_TCTL_PSP | E1000_TCTL_EN |
	     E1000_COLLISION_THRESHOLD << E1000_CT_SHIFT |
	     E1000_FDX_COLLISION_DISTANCE << E1000_COLD_SHIFT);

	for (i = 0; i < txdr->count; i++) {
   1112f:	8b 45 b0             	mov    -0x50(%rbp),%eax
   11132:	41 3b 84 24 8c 0f 00 	cmp    0xf8c(%r12),%eax
   11139:	00 
   1113a:	0f 82 84 fe ff ff    	jb     10fc4 <e1000_diag_test+0x5c4>
   11140:	4c 89 e0             	mov    %r12,%rax
   11143:	4d 89 fc             	mov    %r15,%r12
   11146:	49 89 c7             	mov    %rax,%r15
		tx_desc->upper.data = 0;
	}

	/* Setup Rx descriptor ring and Rx buffers */

	if (!rxdr->count)
   11149:	41 8b bf bc 0f 00 00 	mov    0xfbc(%r15),%edi
   11150:	85 ff                	test   %edi,%edi
   11152:	0f 84 6f 04 00 00    	je     115c7 <e1000_diag_test+0xbc7>
   11158:	48 c1 e7 04          	shl    $0x4,%rdi
   1115c:	be c0 80 40 02       	mov    $0x24080c0,%esi
   11161:	e8 00 00 00 00       	callq  11166 <e1000_diag_test+0x766>
		rxdr->count = E1000_DEFAULT_RXD;

	rxdr->buffer_info = kcalloc(rxdr->count, sizeof(struct e1000_rx_buffer),
				    GFP_KERNEL);
	if (!rxdr->buffer_info) {
   11166:	48 85 c0             	test   %rax,%rax
	/* Setup Rx descriptor ring and Rx buffers */

	if (!rxdr->count)
		rxdr->count = E1000_DEFAULT_RXD;

	rxdr->buffer_info = kcalloc(rxdr->count, sizeof(struct e1000_rx_buffer),
   11169:	49 89 87 c8 0f 00 00 	mov    %rax,0xfc8(%r15)
				    GFP_KERNEL);
	if (!rxdr->buffer_info) {
   11170:	0f 84 66 0e 00 00    	je     11fdc <e1000_diag_test+0x15dc>
		ret_val = 5;
		goto err_nomem;
	}

	rxdr->size = rxdr->count * sizeof(struct e1000_rx_desc);
   11176:	41 8b 9f bc 0f 00 00 	mov    0xfbc(%r15),%ebx
	rxdr->desc = dma_zalloc_coherent(&pdev->dev, rxdr->size, &rxdr->dma,
   1117d:	4d 8d af b0 0f 00 00 	lea    0xfb0(%r15),%r13
   11184:	4c 89 65 d0          	mov    %r12,-0x30(%rbp)
   11188:	c7 45 c4 c0 80 40 02 	movl   $0x24080c0,-0x3c(%rbp)
	if (!rxdr->buffer_info) {
		ret_val = 5;
		goto err_nomem;
	}

	rxdr->size = rxdr->count * sizeof(struct e1000_rx_desc);
   1118f:	c1 e3 04             	shl    $0x4,%ebx
   11192:	4d 85 e4             	test   %r12,%r12
   11195:	41 89 9f b8 0f 00 00 	mov    %ebx,0xfb8(%r15)
   1119c:	0f 84 8a 0e 00 00    	je     1202c <e1000_diag_test+0x162c>
   111a2:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
   111a6:	4c 8b b0 e8 02 00 00 	mov    0x2e8(%rax),%r14
   111ad:	4d 85 f6             	test   %r14,%r14
   111b0:	0f 84 76 0e 00 00    	je     1202c <e1000_diag_test+0x162c>
	BUG_ON(!ops);

	if (dma_alloc_from_coherent(dev, size, dma_handle, &cpu_addr))
		return cpu_addr;

	if (!arch_dma_alloc_attrs(&dev, &flag))
   111b6:	48 8d 75 c4          	lea    -0x3c(%rbp),%rsi
   111ba:	48 8d 7d d0          	lea    -0x30(%rbp),%rdi
   111be:	e8 00 00 00 00       	callq  111c3 <e1000_diag_test+0x7c3>
   111c3:	84 c0                	test   %al,%al
   111c5:	0f 84 4c 0e 00 00    	je     12017 <e1000_diag_test+0x1617>
		return NULL;
	if (!ops->alloc)
   111cb:	49 8b 06             	mov    (%r14),%rax
   111ce:	48 85 c0             	test   %rax,%rax
   111d1:	0f 84 40 0e 00 00    	je     12017 <e1000_diag_test+0x1617>
		return NULL;

	cpu_addr = ops->alloc(dev, size, dma_handle, flag, attrs);
   111d7:	45 31 c0             	xor    %r8d,%r8d
   111da:	8b 4d c4             	mov    -0x3c(%rbp),%ecx
   111dd:	4c 89 ea             	mov    %r13,%rdx
   111e0:	48 89 de             	mov    %rbx,%rsi
   111e3:	48 8b 7d d0          	mov    -0x30(%rbp),%rdi
   111e7:	ff d0                	callq  *%rax
	rxdr->desc = dma_zalloc_coherent(&pdev->dev, rxdr->size, &rxdr->dma,
					 GFP_KERNEL);
	if (!rxdr->desc) {
   111e9:	48 85 c0             	test   %rax,%rax
		ret_val = 5;
		goto err_nomem;
	}

	rxdr->size = rxdr->count * sizeof(struct e1000_rx_desc);
	rxdr->desc = dma_zalloc_coherent(&pdev->dev, rxdr->size, &rxdr->dma,
   111ec:	49 89 87 a8 0f 00 00 	mov    %rax,0xfa8(%r15)
					 GFP_KERNEL);
	if (!rxdr->desc) {
   111f3:	0f 84 32 0f 00 00    	je     1212b <e1000_diag_test+0x172b>
		ret_val = 6;
		goto err_nomem;
	}
	rxdr->next_to_use = rxdr->next_to_clean = 0;
   111f9:	41 c7 87 c4 0f 00 00 	movl   $0x0,0xfc4(%r15)
   11200:	00 00 00 00 
   11204:	41 c7 87 c0 0f 00 00 	movl   $0x0,0xfc0(%r15)
   1120b:	00 00 00 00 

	rctl = er32(RCTL);
   1120f:	49 8b 87 00 0c 00 00 	mov    0xc00(%r15),%rax
{ asm volatile("mov" size " %0,%1": :reg (val), \
"m" (*(volatile type __force *)addr) barrier); }

build_mmio_read(readb, "b", unsigned char, "=q", :"memory")
build_mmio_read(readw, "w", unsigned short, "=r", :"memory")
build_mmio_read(readl, "l", unsigned int, "=r", :"memory")
   11216:	8b 80 00 01 00 00    	mov    0x100(%rax),%eax
	ew32(RCTL, rctl & ~E1000_RCTL_EN);
   1121c:	49 8b 97 00 0c 00 00 	mov    0xc00(%r15),%rdx
   11223:	83 e0 fd             	and    $0xfffffffd,%eax
build_mmio_read(__readw, "w", unsigned short, "=r", )
build_mmio_read(__readl, "l", unsigned int, "=r", )

build_mmio_write(writeb, "b", unsigned char, "q", :"memory")
build_mmio_write(writew, "w", unsigned short, "r", :"memory")
build_mmio_write(writel, "l", unsigned int, "r", :"memory")
   11226:	89 82 00 01 00 00    	mov    %eax,0x100(%rdx)
	ew32(RDBAL, ((u64)rxdr->dma & 0xFFFFFFFF));
   1122c:	41 83 bf 18 0c 00 00 	cmpl   $0x3,0xc18(%r15)
   11233:	03 
   11234:	49 8b 97 b0 0f 00 00 	mov    0xfb0(%r15),%rdx
   1123b:	48 19 c0             	sbb    %rax,%rax
   1123e:	48 25 10 d9 ff ff    	and    $0xffffffffffffd910,%rax
   11244:	48 05 00 28 00 00    	add    $0x2800,%rax
   1124a:	49 03 87 00 0c 00 00 	add    0xc00(%r15),%rax
   11251:	89 10                	mov    %edx,(%rax)
	ew32(RDBAH, ((u64)rxdr->dma >> 32));
   11253:	41 83 bf 18 0c 00 00 	cmpl   $0x3,0xc18(%r15)
   1125a:	03 
   1125b:	41 8b 97 b4 0f 00 00 	mov    0xfb4(%r15),%edx
   11262:	48 19 c0             	sbb    %rax,%rax
   11265:	48 25 10 d9 ff ff    	and    $0xffffffffffffd910,%rax
   1126b:	48 05 04 28 00 00    	add    $0x2804,%rax
   11271:	49 03 87 00 0c 00 00 	add    0xc00(%r15),%rax
   11278:	89 10                	mov    %edx,(%rax)
	ew32(RDLEN, rxdr->size);
   1127a:	41 83 bf 18 0c 00 00 	cmpl   $0x3,0xc18(%r15)
   11281:	03 
   11282:	41 8b 97 b8 0f 00 00 	mov    0xfb8(%r15),%edx
   11289:	48 19 c0             	sbb    %rax,%rax
   1128c:	48 25 10 d9 ff ff    	and    $0xffffffffffffd910,%rax
   11292:	48 05 08 28 00 00    	add    $0x2808,%rax
   11298:	49 03 87 00 0c 00 00 	add    0xc00(%r15),%rax
   1129f:	89 10                	mov    %edx,(%rax)
	ew32(RDH, 0);
   112a1:	41 83 bf 18 0c 00 00 	cmpl   $0x3,0xc18(%r15)
   112a8:	03 
   112a9:	48 19 c0             	sbb    %rax,%rax
   112ac:	31 d2                	xor    %edx,%edx
   112ae:	48 25 10 d9 ff ff    	and    $0xffffffffffffd910,%rax
   112b4:	48 05 10 28 00 00    	add    $0x2810,%rax
   112ba:	49 03 87 00 0c 00 00 	add    0xc00(%r15),%rax
   112c1:	89 10                	mov    %edx,(%rax)
	ew32(RDT, 0);
   112c3:	41 83 bf 18 0c 00 00 	cmpl   $0x3,0xc18(%r15)
   112ca:	03 
   112cb:	48 19 c0             	sbb    %rax,%rax
   112ce:	48 25 10 d9 ff ff    	and    $0xffffffffffffd910,%rax
   112d4:	48 05 18 28 00 00    	add    $0x2818,%rax
   112da:	49 03 87 00 0c 00 00 	add    0xc00(%r15),%rax
   112e1:	89 10                	mov    %edx,(%rax)
	rctl = E1000_RCTL_EN | E1000_RCTL_BAM | E1000_RCTL_SZ_2048 |
		E1000_RCTL_LBM_NO | E1000_RCTL_RDMTS_HALF |
		(hw->mc_filter_type << E1000_RCTL_MO_SHIFT);
   112e3:	41 8b 87 a0 0c 00 00 	mov    0xca0(%r15),%eax
	ew32(RCTL, rctl);
   112ea:	49 8b 97 00 0c 00 00 	mov    0xc00(%r15),%rdx
	ew32(RDLEN, rxdr->size);
	ew32(RDH, 0);
	ew32(RDT, 0);
	rctl = E1000_RCTL_EN | E1000_RCTL_BAM | E1000_RCTL_SZ_2048 |
		E1000_RCTL_LBM_NO | E1000_RCTL_RDMTS_HALF |
		(hw->mc_filter_type << E1000_RCTL_MO_SHIFT);
   112f1:	c1 e0 0c             	shl    $0xc,%eax
	ew32(RDBAL, ((u64)rxdr->dma & 0xFFFFFFFF));
	ew32(RDBAH, ((u64)rxdr->dma >> 32));
	ew32(RDLEN, rxdr->size);
	ew32(RDH, 0);
	ew32(RDT, 0);
	rctl = E1000_RCTL_EN | E1000_RCTL_BAM | E1000_RCTL_SZ_2048 |
   112f4:	0d 02 80 00 00       	or     $0x8002,%eax
   112f9:	89 82 00 01 00 00    	mov    %eax,0x100(%rdx)
		E1000_RCTL_LBM_NO | E1000_RCTL_RDMTS_HALF |
		(hw->mc_filter_type << E1000_RCTL_MO_SHIFT);
	ew32(RCTL, rctl);

	for (i = 0; i < rxdr->count; i++) {
   112ff:	45 8b 9f bc 0f 00 00 	mov    0xfbc(%r15),%r11d
   11306:	45 85 db             	test   %r11d,%r11d
   11309:	0f 84 c8 07 00 00    	je     11ad7 <e1000_diag_test+0x10d7>
   1130f:	31 db                	xor    %ebx,%ebx
	struct dma_map_ops *ops = get_dma_ops(dev);
	dma_addr_t addr;

	kmemcheck_mark_initialized(ptr, size);
	BUG_ON(!valid_dma_direction(dir));
	addr = ops->map_page(dev, virt_to_page(ptr),
   11311:	4d 89 fe             	mov    %r15,%r14
   11314:	e9 bb 00 00 00       	jmpq   113d4 <e1000_diag_test+0x9d4>
   11319:	48 89 f2             	mov    %rsi,%rdx
   1131c:	b9 00 00 00 80       	mov    $0x80000000,%ecx
   11321:	41 b8 02 00 00 00    	mov    $0x2,%r8d
   11327:	81 e2 ff 0f 00 00    	and    $0xfff,%edx
   1132d:	48 01 ce             	add    %rcx,%rsi
   11330:	48 b9 00 00 00 80 ff 	movabs $0x77ff80000000,%rcx
   11337:	77 00 00 
   1133a:	48 0f 42 0d 00 00 00 	cmovb  0x0(%rip),%rcx        # 11342 <e1000_diag_test+0x942>
   11341:	00 
   11342:	4c 89 e7             	mov    %r12,%rdi
   11345:	45 31 c9             	xor    %r9d,%r9d
   11348:	48 01 ce             	add    %rcx,%rsi
   1134b:	48 b9 00 00 00 00 00 	movabs $0xffffea0000000000,%rcx
   11352:	ea ff ff 
   11355:	48 c1 ee 0c          	shr    $0xc,%rsi
   11359:	48 c1 e6 06          	shl    $0x6,%rsi
   1135d:	48 01 ce             	add    %rcx,%rsi
   11360:	b9 00 08 00 00       	mov    $0x800,%ecx
   11365:	ff 50 20             	callq  *0x20(%rax)
			ret_val = 7;
			goto err_nomem;
		}
		rxdr->buffer_info[i].rxbuf.data = buf;

		rxdr->buffer_info[i].dma =
   11368:	49 89 47 08          	mov    %rax,0x8(%r15)
			dma_map_single(&pdev->dev,
				       buf + NET_SKB_PAD + NET_IP_ALIGN,
				       E1000_RXBUFFER_2048, DMA_FROM_DEVICE);
		if (dma_mapping_error(&pdev->dev, rxdr->buffer_info[i].dma)) {
   1136c:	49 8b 86 c8 0f 00 00 	mov    0xfc8(%r14),%rax
   11373:	4d 85 e4             	test   %r12,%r12
   11376:	4a 8b 74 28 08       	mov    0x8(%rax,%r13,1),%rsi
   1137b:	0f 84 5b 02 00 00    	je     115dc <e1000_diag_test+0xbdc>
   11381:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
   11385:	48 8b 80 e8 02 00 00 	mov    0x2e8(%rax),%rax
   1138c:	48 85 c0             	test   %rax,%rax
   1138f:	0f 84 47 02 00 00    	je     115dc <e1000_diag_test+0xbdc>

static inline int dma_mapping_error(struct device *dev, dma_addr_t dma_addr)
{
	debug_dma_mapping_error(dev, dma_addr);

	if (get_dma_ops(dev)->mapping_error)
   11395:	48 83 78 60 00       	cmpq   $0x0,0x60(%rax)
   1139a:	0f 84 50 02 00 00    	je     115f0 <e1000_diag_test+0xbf0>
   113a0:	48 8b 40 60          	mov    0x60(%rax),%rax
		return get_dma_ops(dev)->mapping_error(dev, dma_addr);
   113a4:	4c 89 e7             	mov    %r12,%rdi
   113a7:	ff d0                	callq  *%rax
   113a9:	85 c0                	test   %eax,%eax
   113ab:	0f 85 4c 0c 00 00    	jne    11ffd <e1000_diag_test+0x15fd>
			ret_val = 8;
			goto err_nomem;
		}
		rx_desc->buffer_addr = cpu_to_le64(rxdr->buffer_info[i].dma);
   113b1:	49 8b 86 c8 0f 00 00 	mov    0xfc8(%r14),%rax
   113b8:	48 8b 75 b0          	mov    -0x50(%rbp),%rsi
	rctl = E1000_RCTL_EN | E1000_RCTL_BAM | E1000_RCTL_SZ_2048 |
		E1000_RCTL_LBM_NO | E1000_RCTL_RDMTS_HALF |
		(hw->mc_filter_type << E1000_RCTL_MO_SHIFT);
	ew32(RCTL, rctl);

	for (i = 0; i < rxdr->count; i++) {
   113bc:	83 c3 01             	add    $0x1,%ebx
				       E1000_RXBUFFER_2048, DMA_FROM_DEVICE);
		if (dma_mapping_error(&pdev->dev, rxdr->buffer_info[i].dma)) {
			ret_val = 8;
			goto err_nomem;
		}
		rx_desc->buffer_addr = cpu_to_le64(rxdr->buffer_info[i].dma);
   113bf:	4a 8b 44 28 08       	mov    0x8(%rax,%r13,1),%rax
   113c4:	48 89 06             	mov    %rax,(%rsi)
	rctl = E1000_RCTL_EN | E1000_RCTL_BAM | E1000_RCTL_SZ_2048 |
		E1000_RCTL_LBM_NO | E1000_RCTL_RDMTS_HALF |
		(hw->mc_filter_type << E1000_RCTL_MO_SHIFT);
	ew32(RCTL, rctl);

	for (i = 0; i < rxdr->count; i++) {
   113c7:	41 3b 9e bc 0f 00 00 	cmp    0xfbc(%r14),%ebx
   113ce:	0f 83 00 07 00 00    	jae    11ad4 <e1000_diag_test+0x10d4>
		struct e1000_rx_desc *rx_desc = E1000_RX_DESC(*rxdr, i);
   113d4:	4c 63 eb             	movslq %ebx,%r13
			int index = kmalloc_index(size);

			if (!index)
				return ZERO_SIZE_PTR;

			return kmem_cache_alloc_trace(kmalloc_caches[index],
   113d7:	48 8b 3d 00 00 00 00 	mov    0x0(%rip),%rdi        # 113de <e1000_diag_test+0x9de>
   113de:	ba 40 08 00 00       	mov    $0x840,%edx
   113e3:	49 c1 e5 04          	shl    $0x4,%r13
   113e7:	be c0 80 40 02       	mov    $0x24080c0,%esi
   113ec:	4c 89 e8             	mov    %r13,%rax
   113ef:	49 03 86 a8 0f 00 00 	add    0xfa8(%r14),%rax
   113f6:	48 89 45 b0          	mov    %rax,-0x50(%rbp)
   113fa:	e8 00 00 00 00       	callq  113ff <e1000_diag_test+0x9ff>
		u8 *buf;

		buf = kzalloc(E1000_RXBUFFER_2048 + NET_SKB_PAD + NET_IP_ALIGN,
			      GFP_KERNEL);
		if (!buf) {
   113ff:	48 85 c0             	test   %rax,%rax
   11402:	0f 84 e8 0b 00 00    	je     11ff0 <e1000_diag_test+0x15f0>
			ret_val = 7;
			goto err_nomem;
		}
		rxdr->buffer_info[i].rxbuf.data = buf;
   11408:	49 8b 96 c8 0f 00 00 	mov    0xfc8(%r14),%rdx

		rxdr->buffer_info[i].dma =
   1140f:	4d 89 ef             	mov    %r13,%r15
			dma_map_single(&pdev->dev,
   11412:	48 8d 70 40          	lea    0x40(%rax),%rsi
			      GFP_KERNEL);
		if (!buf) {
			ret_val = 7;
			goto err_nomem;
		}
		rxdr->buffer_info[i].rxbuf.data = buf;
   11416:	4a 89 04 2a          	mov    %rax,(%rdx,%r13,1)

		rxdr->buffer_info[i].dma =
   1141a:	4d 03 be c8 0f 00 00 	add    0xfc8(%r14),%r15
   11421:	4d 85 e4             	test   %r12,%r12
   11424:	74 14                	je     1143a <e1000_diag_test+0xa3a>
   11426:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
   1142a:	48 8b 80 e8 02 00 00 	mov    0x2e8(%rax),%rax
   11431:	48 85 c0             	test   %rax,%rax
   11434:	0f 85 df fe ff ff    	jne    11319 <e1000_diag_test+0x919>
		return dma_ops;
   1143a:	48 8b 05 00 00 00 00 	mov    0x0(%rip),%rax        # 11441 <e1000_diag_test+0xa41>
   11441:	e9 d3 fe ff ff       	jmpq   11319 <e1000_diag_test+0x919>
		e1000_reset(adapter);
		clear_bit(__E1000_TESTING, &adapter->flags);
		if (if_running)
			dev_open(netdev);
	} else {
		e_info(hw, "online testing starting\n");
   11446:	48 8b bf f0 0b 00 00 	mov    0xbf0(%rdi),%rdi
   1144d:	48 c7 c6 00 00 00 00 	mov    $0x0,%rsi
   11454:	31 c0                	xor    %eax,%eax
   11456:	e8 00 00 00 00       	callq  1145b <e1000_diag_test+0xa5b>
   1145b:	e9 eb f5 ff ff       	jmpq   10a4b <e1000_diag_test+0x4b>
		if (e1000_link_test(adapter, &data[4]))
			eth_test->flags |= ETH_TEST_FL_FAILED;

		if (if_running)
			/* indicate we're in test mode */
			dev_close(netdev);
   11460:	4c 89 ff             	mov    %r15,%rdi
   11463:	e8 00 00 00 00       	callq  11468 <e1000_diag_test+0xa68>
   11468:	e9 a2 f6 ff ff       	jmpq   10b0f <e1000_diag_test+0x10f>
   1146d:	48 8b 05 00 00 00 00 	mov    0x0(%rip),%rax        # 11474 <e1000_diag_test+0xa74>
   11474:	e9 ee fb ff ff       	jmpq   11067 <e1000_diag_test+0x667>

static inline int dma_mapping_error(struct device *dev, dma_addr_t dma_addr)
{
	debug_dma_mapping_error(dev, dma_addr);

	if (get_dma_ops(dev)->mapping_error)
   11479:	48 8b 05 00 00 00 00 	mov    0x0(%rip),%rax        # 11480 <e1000_diag_test+0xa80>
   11480:	48 8b 40 60          	mov    0x60(%rax),%rax
   11484:	48 85 c0             	test   %rax,%rax
   11487:	0f 85 69 fc ff ff    	jne    110f6 <e1000_diag_test+0x6f6>
		return get_dma_ops(dev)->mapping_error(dev, dma_addr);

#ifdef DMA_ERROR_CODE
	return dma_addr == DMA_ERROR_CODE;
   1148d:	31 c0                	xor    %eax,%eax
   1148f:	48 85 f6             	test   %rsi,%rsi
   11492:	0f 94 c0             	sete   %al
   11495:	e9 61 fc ff ff       	jmpq   110fb <e1000_diag_test+0x6fb>
	int i, ret_val;

	/* Setup Tx descriptor ring and Tx buffers */

	if (!txdr->count)
		txdr->count = E1000_DEFAULT_TXD;
   1149a:	41 c7 87 8c 0f 00 00 	movl   $0x100,0xf8c(%r15)
   114a1:	00 01 00 00 
   114a5:	bf 00 28 00 00       	mov    $0x2800,%edi
   114aa:	e9 62 f9 ff ff       	jmpq   10e11 <e1000_diag_test+0x411>
   114af:	4c 8b 45 b0          	mov    -0x50(%rbp),%r8
   114b3:	8b 7d a8             	mov    -0x58(%rbp),%edi
   114b6:	31 d2                	xor    %edx,%edx
   114b8:	b9 80 00 00 00       	mov    $0x80,%ecx
   114bd:	48 c7 c6 00 00 00 00 	mov    $0x0,%rsi
   114c4:	4d 89 c1             	mov    %r8,%r9
   114c7:	e8 00 00 00 00       	callq  114cc <e1000_diag_test+0xacc>
	 * Hook up test interrupt handler just for this test
	 */
	if (!request_irq(irq, e1000_test_intr, IRQF_PROBE_SHARED, netdev->name,
			 netdev))
		shared_int = false;
	else if (request_irq(irq, e1000_test_intr, IRQF_SHARED,
   114cc:	85 c0                	test   %eax,%eax
   114ce:	0f 85 6d 0b 00 00    	jne    12041 <e1000_diag_test+0x1641>
			     netdev->name, netdev)) {
		*data = 1;
		return -1;
	}
	e_info(hw, "testing %s interrupt\n", (shared_int ?
   114d4:	41 f6 87 e1 0f 00 00 	testb  $0x20,0xfe1(%r15)
   114db:	20 

static int e1000_intr_test(struct e1000_adapter *adapter, u64 *data)
{
	struct net_device *netdev = adapter->netdev;
	u32 mask, i = 0;
	bool shared_int = true;
   114dc:	41 bc 01 00 00 00    	mov    $0x1,%r12d
	else if (request_irq(irq, e1000_test_intr, IRQF_SHARED,
			     netdev->name, netdev)) {
		*data = 1;
		return -1;
	}
	e_info(hw, "testing %s interrupt\n", (shared_int ?
   114e2:	0f 84 69 f7 ff ff    	je     10c51 <e1000_diag_test+0x251>
   114e8:	48 c7 c2 00 00 00 00 	mov    $0x0,%rdx
   114ef:	49 8b bf f0 0b 00 00 	mov    0xbf0(%r15),%rdi
   114f6:	48 c7 c6 00 00 00 00 	mov    $0x0,%rsi
   114fd:	31 c0                	xor    %eax,%eax
   114ff:	e8 00 00 00 00       	callq  11504 <e1000_diag_test+0xb04>
   11504:	e9 48 f7 ff ff       	jmpq   10c51 <e1000_diag_test+0x251>
		/* save speed, duplex, autoneg settings */
		u16 autoneg_advertised = hw->autoneg_advertised;
		u8 forced_speed_duplex = hw->forced_speed_duplex;
		u8 autoneg = hw->autoneg;

		e_info(hw, "offline testing starting\n");
   11509:	48 8b bf f0 0b 00 00 	mov    0xbf0(%rdi),%rdi
   11510:	48 c7 c6 00 00 00 00 	mov    $0x0,%rsi
   11517:	31 c0                	xor    %eax,%eax
   11519:	e8 00 00 00 00       	callq  1151e <e1000_diag_test+0xb1e>
   1151e:	e9 b8 f5 ff ff       	jmpq   10adb <e1000_diag_test+0xdb>
   11523:	48 8b 75 a0          	mov    -0x60(%rbp),%rsi
		}
		checksum += temp;
	}

	/* If Checksum is not Correct return error else test passed */
	if ((checksum != (u16)EEPROM_SUM) && !(*data))
   11527:	66 81 fb ba ba       	cmp    $0xbaba,%bx
   1152c:	48 8b 46 08          	mov    0x8(%rsi),%rax
   11530:	74 12                	je     11544 <e1000_diag_test+0xb44>
   11532:	48 85 c0             	test   %rax,%rax
   11535:	75 0d                	jne    11544 <e1000_diag_test+0xb44>
		*data = 2;
   11537:	48 c7 46 08 02 00 00 	movq   $0x2,0x8(%rsi)
   1153e:	00 
   1153f:	e9 a1 f6 ff ff       	jmpq   10be5 <e1000_diag_test+0x1e5>

		if (e1000_reg_test(adapter, &data[0]))
			eth_test->flags |= ETH_TEST_FL_FAILED;

		e1000_reset(adapter);
		if (e1000_eeprom_test(adapter, &data[1]))
   11544:	85 c0                	test   %eax,%eax
   11546:	0f 84 a1 f6 ff ff    	je     10bed <e1000_diag_test+0x1ed>
   1154c:	e9 94 f6 ff ff       	jmpq   10be5 <e1000_diag_test+0x1e5>
   11551:	4d 89 e7             	mov    %r12,%r15
		struct e1000_tx_desc *tx_desc = E1000_TX_DESC(*txdr, i);
		struct sk_buff *skb;
		unsigned int size = 1024;

		skb = alloc_skb(size, GFP_KERNEL);
		if (!skb) {
   11554:	bb 03 00 00 00       	mov    $0x3,%ebx
	}

	return 0;

err_nomem:
	e1000_free_desc_rings(adapter);
   11559:	48 8b 7d 90          	mov    -0x70(%rbp),%rdi
   1155d:	e8 8e f1 ff ff       	callq  106f0 <e1000_free_desc_rings>
	return ret_val;
}

static int e1000_loopback_test(struct e1000_adapter *adapter, u64 *data)
{
	*data = e1000_setup_desc_rings(adapter);
   11562:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
   11566:	48 89 58 18          	mov    %rbx,0x18(%rax)

		e1000_reset(adapter);
		/* make sure the phy is powered up */
		e1000_power_up_phy(adapter);
		if (e1000_loopback_test(adapter, &data[3]))
			eth_test->flags |= ETH_TEST_FL_FAILED;
   1156a:	48 8b 45 88          	mov    -0x78(%rbp),%rax
   1156e:	83 48 04 02          	orl    $0x2,0x4(%rax)

		/* restore speed, duplex, autoneg settings */
		hw->autoneg_advertised = autoneg_advertised;
   11572:	0f b7 45 86          	movzwl -0x7a(%rbp),%eax
		hw->forced_speed_duplex = forced_speed_duplex;
		hw->autoneg = autoneg;

		e1000_reset(adapter);
   11576:	48 8b 7d 90          	mov    -0x70(%rbp),%rdi
		e1000_power_up_phy(adapter);
		if (e1000_loopback_test(adapter, &data[3]))
			eth_test->flags |= ETH_TEST_FL_FAILED;

		/* restore speed, duplex, autoneg settings */
		hw->autoneg_advertised = autoneg_advertised;
   1157a:	66 41 89 87 d2 0c 00 	mov    %ax,0xcd2(%r15)
   11581:	00 
		hw->forced_speed_duplex = forced_speed_duplex;
   11582:	0f b6 45 85          	movzbl -0x7b(%rbp),%eax
   11586:	41 88 87 f1 0c 00 00 	mov    %al,0xcf1(%r15)
		hw->autoneg = autoneg;
   1158d:	0f b6 45 84          	movzbl -0x7c(%rbp),%eax
   11591:	41 88 87 ef 0c 00 00 	mov    %al,0xcef(%r15)

		e1000_reset(adapter);
   11598:	e8 00 00 00 00       	callq  1159d <e1000_diag_test+0xb9d>
   1159d:	f0 41 80 a7 e8 0f 00 	lock andb $0xfe,0xfe8(%r15)
   115a4:	00 fe 
		clear_bit(__E1000_TESTING, &adapter->flags);
		if (if_running)
   115a6:	80 7d 83 00          	cmpb   $0x0,-0x7d(%rbp)
   115aa:	0f 84 dc f4 ff ff    	je     10a8c <e1000_diag_test+0x8c>
			dev_open(netdev);
   115b0:	4c 89 ff             	mov    %r15,%rdi
   115b3:	e8 00 00 00 00       	callq  115b8 <e1000_diag_test+0xbb8>
   115b8:	e9 cf f4 ff ff       	jmpq   10a8c <e1000_diag_test+0x8c>
   115bd:	4d 89 e7             	mov    %r12,%r15
		txdr->buffer_info[i].skb = skb;
		txdr->buffer_info[i].length = skb->len;
		txdr->buffer_info[i].dma =
			dma_map_single(&pdev->dev, skb->data, skb->len,
				       DMA_TO_DEVICE);
		if (dma_mapping_error(&pdev->dev, txdr->buffer_info[i].dma)) {
   115c0:	bb 04 00 00 00       	mov    $0x4,%ebx
   115c5:	eb 92                	jmp    11559 <e1000_diag_test+0xb59>
	}

	/* Setup Rx descriptor ring and Rx buffers */

	if (!rxdr->count)
		rxdr->count = E1000_DEFAULT_RXD;
   115c7:	41 c7 87 bc 0f 00 00 	movl   $0x100,0xfbc(%r15)
   115ce:	00 01 00 00 
   115d2:	bf 00 10 00 00       	mov    $0x1000,%edi
   115d7:	e9 80 fb ff ff       	jmpq   1115c <e1000_diag_test+0x75c>

static inline int dma_mapping_error(struct device *dev, dma_addr_t dma_addr)
{
	debug_dma_mapping_error(dev, dma_addr);

	if (get_dma_ops(dev)->mapping_error)
   115dc:	48 8b 05 00 00 00 00 	mov    0x0(%rip),%rax        # 115e3 <e1000_diag_test+0xbe3>
   115e3:	48 8b 40 60          	mov    0x60(%rax),%rax
   115e7:	48 85 c0             	test   %rax,%rax
   115ea:	0f 85 b4 fd ff ff    	jne    113a4 <e1000_diag_test+0x9a4>
		return get_dma_ops(dev)->mapping_error(dev, dma_addr);

#ifdef DMA_ERROR_CODE
	return dma_addr == DMA_ERROR_CODE;
   115f0:	31 c0                	xor    %eax,%eax
   115f2:	48 85 f6             	test   %rsi,%rsi
   115f5:	0f 94 c0             	sete   %al
   115f8:	e9 ac fd ff ff       	jmpq   113a9 <e1000_diag_test+0x9a9>
		ew32(ICS, mask);
		E1000_WRITE_FLUSH();
		msleep(10);

		if (!(adapter->test_icr & mask)) {
			*data = 4;
   115fd:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
   11601:	48 c7 40 10 04 00 00 	movq   $0x4,0x10(%rax)
   11608:	00 
   11609:	e9 86 f7 ff ff       	jmpq   10d94 <e1000_diag_test+0x394>
		      "0x%08X expected: 0x%08X\n", after, value);
		*data = 1;
		return 1;
	}
	/* restore previous status */
	ew32(STATUS, before);
   1160e:	49 8b 87 00 0c 00 00 	mov    0xc00(%r15),%rax
   11615:	89 70 08             	mov    %esi,0x8(%rax)

	REG_PATTERN_TEST(FCAL, 0xFFFFFFFF, 0xFFFFFFFF);
   11618:	48 8b 75 a0          	mov    -0x60(%rbp),%rsi
   1161c:	48 8b 7d 90          	mov    -0x70(%rbp),%rdi
   11620:	41 b8 ff ff ff ff    	mov    $0xffffffff,%r8d
   11626:	44 89 c1             	mov    %r8d,%ecx
   11629:	ba 28 00 00 00       	mov    $0x28,%edx
   1162e:	e8 fd d7 ff ff       	callq  ee30 <reg_pattern_test>
   11633:	84 c0                	test   %al,%al
   11635:	0f 85 3f f5 ff ff    	jne    10b7a <e1000_diag_test+0x17a>
	REG_PATTERN_TEST(FCAH, 0x0000FFFF, 0xFFFFFFFF);
   1163b:	48 8b 75 a0          	mov    -0x60(%rbp),%rsi
   1163f:	48 8b 7d 90          	mov    -0x70(%rbp),%rdi
   11643:	41 b8 ff ff ff ff    	mov    $0xffffffff,%r8d
   11649:	b9 ff ff 00 00       	mov    $0xffff,%ecx
   1164e:	ba 2c 00 00 00       	mov    $0x2c,%edx
   11653:	e8 d8 d7 ff ff       	callq  ee30 <reg_pattern_test>
   11658:	84 c0                	test   %al,%al
   1165a:	0f 85 1a f5 ff ff    	jne    10b7a <e1000_diag_test+0x17a>
	REG_PATTERN_TEST(FCT, 0x0000FFFF, 0xFFFFFFFF);
   11660:	48 8b 75 a0          	mov    -0x60(%rbp),%rsi
   11664:	48 8b 7d 90          	mov    -0x70(%rbp),%rdi
   11668:	41 b8 ff ff ff ff    	mov    $0xffffffff,%r8d
   1166e:	b9 ff ff 00 00       	mov    $0xffff,%ecx
   11673:	ba 30 00 00 00       	mov    $0x30,%edx
   11678:	e8 b3 d7 ff ff       	callq  ee30 <reg_pattern_test>
   1167d:	84 c0                	test   %al,%al
   1167f:	0f 85 f5 f4 ff ff    	jne    10b7a <e1000_diag_test+0x17a>
	REG_PATTERN_TEST(VET, 0x0000FFFF, 0xFFFFFFFF);
   11685:	4c 8b 75 a0          	mov    -0x60(%rbp),%r14
   11689:	48 8b 5d 90          	mov    -0x70(%rbp),%rbx
   1168d:	41 b8 ff ff ff ff    	mov    $0xffffffff,%r8d
   11693:	b9 ff ff 00 00       	mov    $0xffff,%ecx
   11698:	ba 38 00 00 00       	mov    $0x38,%edx
   1169d:	4c 89 f6             	mov    %r14,%rsi
   116a0:	48 89 df             	mov    %rbx,%rdi
   116a3:	e8 88 d7 ff ff       	callq  ee30 <reg_pattern_test>
   116a8:	84 c0                	test   %al,%al
   116aa:	0f 85 ca f4 ff ff    	jne    10b7a <e1000_diag_test+0x17a>

	REG_PATTERN_TEST(RDTR, 0x0000FFFF, 0xFFFFFFFF);
   116b0:	41 83 bf 18 0c 00 00 	cmpl   $0x3,0xc18(%r15)
   116b7:	03 
   116b8:	41 b8 ff ff ff ff    	mov    $0xffffffff,%r8d
   116be:	b9 ff ff 00 00       	mov    $0xffff,%ecx
   116c3:	4c 89 f6             	mov    %r14,%rsi
   116c6:	48 89 df             	mov    %rbx,%rdi
   116c9:	19 d2                	sbb    %edx,%edx
   116cb:	81 e2 e8 d8 ff ff    	and    $0xffffd8e8,%edx
   116d1:	81 c2 20 28 00 00    	add    $0x2820,%edx
   116d7:	e8 54 d7 ff ff       	callq  ee30 <reg_pattern_test>
   116dc:	84 c0                	test   %al,%al
   116de:	0f 85 96 f4 ff ff    	jne    10b7a <e1000_diag_test+0x17a>
	REG_PATTERN_TEST(RDBAH, 0xFFFFFFFF, 0xFFFFFFFF);
   116e4:	41 83 bf 18 0c 00 00 	cmpl   $0x3,0xc18(%r15)
   116eb:	03 
   116ec:	41 b8 ff ff ff ff    	mov    $0xffffffff,%r8d
   116f2:	4c 89 f6             	mov    %r14,%rsi
   116f5:	44 89 c1             	mov    %r8d,%ecx
   116f8:	48 89 df             	mov    %rbx,%rdi
   116fb:	19 d2                	sbb    %edx,%edx
   116fd:	81 e2 10 d9 ff ff    	and    $0xffffd910,%edx
   11703:	81 c2 04 28 00 00    	add    $0x2804,%edx
   11709:	e8 22 d7 ff ff       	callq  ee30 <reg_pattern_test>
   1170e:	84 c0                	test   %al,%al
   11710:	0f 85 64 f4 ff ff    	jne    10b7a <e1000_diag_test+0x17a>
	REG_PATTERN_TEST(RDLEN, 0x000FFF80, 0x000FFFFF);
   11716:	41 83 bf 18 0c 00 00 	cmpl   $0x3,0xc18(%r15)
   1171d:	03 
   1171e:	41 b8 ff ff 0f 00    	mov    $0xfffff,%r8d
   11724:	b9 80 ff 0f 00       	mov    $0xfff80,%ecx
   11729:	4c 89 f6             	mov    %r14,%rsi
   1172c:	48 89 df             	mov    %rbx,%rdi
   1172f:	19 d2                	sbb    %edx,%edx
   11731:	81 e2 10 d9 ff ff    	and    $0xffffd910,%edx
   11737:	81 c2 08 28 00 00    	add    $0x2808,%edx
   1173d:	e8 ee d6 ff ff       	callq  ee30 <reg_pattern_test>
   11742:	84 c0                	test   %al,%al
   11744:	0f 85 30 f4 ff ff    	jne    10b7a <e1000_diag_test+0x17a>
	REG_PATTERN_TEST(RDH, 0x0000FFFF, 0x0000FFFF);
   1174a:	41 83 bf 18 0c 00 00 	cmpl   $0x3,0xc18(%r15)
   11751:	03 
   11752:	41 b8 ff ff 00 00    	mov    $0xffff,%r8d
   11758:	b9 ff ff 00 00       	mov    $0xffff,%ecx
   1175d:	4c 89 f6             	mov    %r14,%rsi
   11760:	48 89 df             	mov    %rbx,%rdi
   11763:	19 d2                	sbb    %edx,%edx
   11765:	81 e2 10 d9 ff ff    	and    $0xffffd910,%edx
   1176b:	81 c2 10 28 00 00    	add    $0x2810,%edx
   11771:	e8 ba d6 ff ff       	callq  ee30 <reg_pattern_test>
   11776:	84 c0                	test   %al,%al
   11778:	0f 85 fc f3 ff ff    	jne    10b7a <e1000_diag_test+0x17a>
	REG_PATTERN_TEST(RDT, 0x0000FFFF, 0x0000FFFF);
   1177e:	41 83 bf 18 0c 00 00 	cmpl   $0x3,0xc18(%r15)
   11785:	03 
   11786:	41 b8 ff ff 00 00    	mov    $0xffff,%r8d
   1178c:	b9 ff ff 00 00       	mov    $0xffff,%ecx
   11791:	4c 89 f6             	mov    %r14,%rsi
   11794:	48 89 df             	mov    %rbx,%rdi
   11797:	19 d2                	sbb    %edx,%edx
   11799:	81 e2 10 d9 ff ff    	and    $0xffffd910,%edx
   1179f:	81 c2 18 28 00 00    	add    $0x2818,%edx
   117a5:	e8 86 d6 ff ff       	callq  ee30 <reg_pattern_test>
   117aa:	84 c0                	test   %al,%al
   117ac:	0f 85 c8 f3 ff ff    	jne    10b7a <e1000_diag_test+0x17a>
	REG_PATTERN_TEST(FCRTH, 0x0000FFF8, 0x0000FFF8);
   117b2:	41 83 bf 18 0c 00 00 	cmpl   $0x3,0xc18(%r15)
   117b9:	03 
   117ba:	41 b8 f8 ff 00 00    	mov    $0xfff8,%r8d
   117c0:	b9 f8 ff 00 00       	mov    $0xfff8,%ecx
   117c5:	4c 89 f6             	mov    %r14,%rsi
   117c8:	48 89 df             	mov    %rbx,%rdi
   117cb:	19 d2                	sbb    %edx,%edx
   117cd:	81 e2 f8 df ff ff    	and    $0xffffdff8,%edx
   117d3:	81 c2 68 21 00 00    	add    $0x2168,%edx
   117d9:	e8 52 d6 ff ff       	callq  ee30 <reg_pattern_test>
   117de:	84 c0                	test   %al,%al
   117e0:	0f 85 94 f3 ff ff    	jne    10b7a <e1000_diag_test+0x17a>
	REG_PATTERN_TEST(FCTTV, 0x0000FFFF, 0x0000FFFF);
   117e6:	48 8b 75 a0          	mov    -0x60(%rbp),%rsi
   117ea:	48 8b 7d 90          	mov    -0x70(%rbp),%rdi
   117ee:	41 b8 ff ff 00 00    	mov    $0xffff,%r8d
   117f4:	b9 ff ff 00 00       	mov    $0xffff,%ecx
   117f9:	ba 70 01 00 00       	mov    $0x170,%edx
   117fe:	e8 2d d6 ff ff       	callq  ee30 <reg_pattern_test>
   11803:	84 c0                	test   %al,%al
   11805:	0f 85 6f f3 ff ff    	jne    10b7a <e1000_diag_test+0x17a>
	REG_PATTERN_TEST(TIPG, 0x3FFFFFFF, 0x3FFFFFFF);
   1180b:	4c 8b 75 a0          	mov    -0x60(%rbp),%r14
   1180f:	48 8b 5d 90          	mov    -0x70(%rbp),%rbx
   11813:	41 b8 ff ff ff 3f    	mov    $0x3fffffff,%r8d
   11819:	b9 ff ff ff 3f       	mov    $0x3fffffff,%ecx
   1181e:	ba 10 04 00 00       	mov    $0x410,%edx
   11823:	4c 89 f6             	mov    %r14,%rsi
   11826:	48 89 df             	mov    %rbx,%rdi
   11829:	e8 02 d6 ff ff       	callq  ee30 <reg_pattern_test>
   1182e:	84 c0                	test   %al,%al
   11830:	0f 85 44 f3 ff ff    	jne    10b7a <e1000_diag_test+0x17a>
	REG_PATTERN_TEST(TDBAH, 0xFFFFFFFF, 0xFFFFFFFF);
   11836:	41 83 bf 18 0c 00 00 	cmpl   $0x3,0xc18(%r15)
   1183d:	03 
   1183e:	41 b8 ff ff ff ff    	mov    $0xffffffff,%r8d
   11844:	4c 89 f6             	mov    %r14,%rsi
   11847:	44 89 c1             	mov    %r8d,%ecx
   1184a:	48 89 df             	mov    %rbx,%rdi
   1184d:	19 d2                	sbb    %edx,%edx
   1184f:	81 e2 20 cc ff ff    	and    $0xffffcc20,%edx
   11855:	81 c2 04 38 00 00    	add    $0x3804,%edx
   1185b:	e8 d0 d5 ff ff       	callq  ee30 <reg_pattern_test>
   11860:	84 c0                	test   %al,%al
   11862:	0f 85 12 f3 ff ff    	jne    10b7a <e1000_diag_test+0x17a>
	REG_PATTERN_TEST(TDLEN, 0x000FFF80, 0x000FFFFF);
   11868:	41 83 bf 18 0c 00 00 	cmpl   $0x3,0xc18(%r15)
   1186f:	03 
   11870:	41 b8 ff ff 0f 00    	mov    $0xfffff,%r8d
   11876:	b9 80 ff 0f 00       	mov    $0xfff80,%ecx
   1187b:	4c 89 f6             	mov    %r14,%rsi
   1187e:	48 89 df             	mov    %rbx,%rdi
   11881:	19 d2                	sbb    %edx,%edx
   11883:	81 e2 20 cc ff ff    	and    $0xffffcc20,%edx
   11889:	81 c2 08 38 00 00    	add    $0x3808,%edx
   1188f:	e8 9c d5 ff ff       	callq  ee30 <reg_pattern_test>
   11894:	84 c0                	test   %al,%al
   11896:	0f 85 de f2 ff ff    	jne    10b7a <e1000_diag_test+0x17a>

	REG_SET_AND_CHECK(RCTL, 0xFFFFFFFF, 0x00000000);
   1189c:	48 8b 75 a0          	mov    -0x60(%rbp),%rsi
   118a0:	48 8b 7d 90          	mov    -0x70(%rbp),%rdi
   118a4:	45 31 c0             	xor    %r8d,%r8d
   118a7:	b9 ff ff ff ff       	mov    $0xffffffff,%ecx
   118ac:	ba 00 01 00 00       	mov    $0x100,%edx
   118b1:	e8 00 00 00 00       	callq  118b6 <e1000_diag_test+0xeb6>
   118b6:	84 c0                	test   %al,%al
   118b8:	0f 85 bc f2 ff ff    	jne    10b7a <e1000_diag_test+0x17a>

	before = 0x06DFB3FE;
	REG_SET_AND_CHECK(RCTL, before, 0x003FFFFB);
   118be:	48 8b 75 a0          	mov    -0x60(%rbp),%rsi
   118c2:	48 8b 7d 90          	mov    -0x70(%rbp),%rdi
   118c6:	41 b8 fb ff 3f 00    	mov    $0x3ffffb,%r8d
   118cc:	b9 fe b3 df 06       	mov    $0x6dfb3fe,%ecx
   118d1:	ba 00 01 00 00       	mov    $0x100,%edx
   118d6:	e8 00 00 00 00       	callq  118db <e1000_diag_test+0xedb>
   118db:	84 c0                	test   %al,%al
   118dd:	0f 85 97 f2 ff ff    	jne    10b7a <e1000_diag_test+0x17a>
	REG_SET_AND_CHECK(TCTL, 0xFFFFFFFF, 0x00000000);
   118e3:	48 8b 75 a0          	mov    -0x60(%rbp),%rsi
   118e7:	48 8b 7d 90          	mov    -0x70(%rbp),%rdi
   118eb:	45 31 c0             	xor    %r8d,%r8d
   118ee:	b9 ff ff ff ff       	mov    $0xffffffff,%ecx
   118f3:	ba 00 04 00 00       	mov    $0x400,%edx
   118f8:	e8 00 00 00 00       	callq  118fd <e1000_diag_test+0xefd>
   118fd:	84 c0                	test   %al,%al
   118ff:	0f 85 75 f2 ff ff    	jne    10b7a <e1000_diag_test+0x17a>

	if (hw->mac_type >= e1000_82543) {
   11905:	41 83 bf 18 0c 00 00 	cmpl   $0x2,0xc18(%r15)
   1190c:	02 
   1190d:	0f 86 49 07 00 00    	jbe    1205c <e1000_diag_test+0x165c>
		REG_SET_AND_CHECK(RCTL, before, 0xFFFFFFFF);
   11913:	4c 8b 75 a0          	mov    -0x60(%rbp),%r14
   11917:	48 8b 5d 90          	mov    -0x70(%rbp),%rbx
   1191b:	41 b8 ff ff ff ff    	mov    $0xffffffff,%r8d
   11921:	b9 fe b3 df 06       	mov    $0x6dfb3fe,%ecx
   11926:	ba 00 01 00 00       	mov    $0x100,%edx
   1192b:	4c 89 f6             	mov    %r14,%rsi
   1192e:	48 89 df             	mov    %rbx,%rdi
   11931:	e8 00 00 00 00       	callq  11936 <e1000_diag_test+0xf36>
   11936:	84 c0                	test   %al,%al
   11938:	0f 85 3c f2 ff ff    	jne    10b7a <e1000_diag_test+0x17a>
		REG_PATTERN_TEST(RDBAL, 0xFFFFFFF0, 0xFFFFFFFF);
   1193e:	41 83 bf 18 0c 00 00 	cmpl   $0x3,0xc18(%r15)
   11945:	03 
   11946:	41 b8 ff ff ff ff    	mov    $0xffffffff,%r8d
   1194c:	b9 f0 ff ff ff       	mov    $0xfffffff0,%ecx
   11951:	4c 89 f6             	mov    %r14,%rsi
   11954:	48 89 df             	mov    %rbx,%rdi
   11957:	19 d2                	sbb    %edx,%edx
   11959:	81 e2 10 d9 ff ff    	and    $0xffffd910,%edx
   1195f:	81 c2 00 28 00 00    	add    $0x2800,%edx
   11965:	e8 c6 d4 ff ff       	callq  ee30 <reg_pattern_test>
   1196a:	84 c0                	test   %al,%al
   1196c:	0f 85 08 f2 ff ff    	jne    10b7a <e1000_diag_test+0x17a>
		REG_PATTERN_TEST(TXCW, 0xC000FFFF, 0x0000FFFF);
   11972:	4c 8b 75 a0          	mov    -0x60(%rbp),%r14
   11976:	48 8b 5d 90          	mov    -0x70(%rbp),%rbx
   1197a:	41 b8 ff ff 00 00    	mov    $0xffff,%r8d
   11980:	b9 ff ff 00 c0       	mov    $0xc000ffff,%ecx
   11985:	ba 78 01 00 00       	mov    $0x178,%edx
   1198a:	4c 89 f6             	mov    %r14,%rsi
   1198d:	48 89 df             	mov    %rbx,%rdi
   11990:	e8 9b d4 ff ff       	callq  ee30 <reg_pattern_test>
   11995:	84 c0                	test   %al,%al
   11997:	0f 85 dd f1 ff ff    	jne    10b7a <e1000_diag_test+0x17a>
		REG_PATTERN_TEST(TDBAL, 0xFFFFFFF0, 0xFFFFFFFF);
   1199d:	41 83 bf 18 0c 00 00 	cmpl   $0x3,0xc18(%r15)
   119a4:	03 
   119a5:	41 b8 ff ff ff ff    	mov    $0xffffffff,%r8d
   119ab:	b9 f0 ff ff ff       	mov    $0xfffffff0,%ecx
   119b0:	4c 89 f6             	mov    %r14,%rsi
   119b3:	48 89 df             	mov    %rbx,%rdi
   119b6:	19 d2                	sbb    %edx,%edx
   119b8:	81 e2 20 cc ff ff    	and    $0xffffcc20,%edx
   119be:	81 c2 00 38 00 00    	add    $0x3800,%edx
   119c4:	e8 67 d4 ff ff       	callq  ee30 <reg_pattern_test>
   119c9:	84 c0                	test   %al,%al
   119cb:	0f 85 a9 f1 ff ff    	jne    10b7a <e1000_diag_test+0x17a>
		REG_PATTERN_TEST(TIDV, 0x0000FFFF, 0x0000FFFF);
   119d1:	41 83 bf 18 0c 00 00 	cmpl   $0x3,0xc18(%r15)
   119d8:	03 
   119d9:	41 b8 ff ff 00 00    	mov    $0xffff,%r8d
   119df:	b9 ff ff 00 00       	mov    $0xffff,%ecx
   119e4:	4c 89 f6             	mov    %r14,%rsi
   119e7:	48 89 df             	mov    %rbx,%rdi
   119ea:	19 d2                	sbb    %edx,%edx
   119ec:	81 e2 20 cc ff ff    	and    $0xffffcc20,%edx
   119f2:	81 c2 20 38 00 00    	add    $0x3820,%edx
   119f8:	e8 33 d4 ff ff       	callq  ee30 <reg_pattern_test>
   119fd:	84 c0                	test   %al,%al
   119ff:	0f 85 75 f1 ff ff    	jne    10b7a <e1000_diag_test+0x17a>
   11a05:	31 db                	xor    %ebx,%ebx
		value = E1000_RAR_ENTRIES;
		for (i = 0; i < value; i++) {
			REG_PATTERN_TEST(RA + (((i << 1) + 1) << 2),
   11a07:	41 83 bf 18 0c 00 00 	cmpl   $0x3,0xc18(%r15)
   11a0e:	03 
   11a0f:	8d 04 dd 44 00 00 00 	lea    0x44(,%rbx,8),%eax
   11a16:	8d 14 dd 04 54 00 00 	lea    0x5404(,%rbx,8),%edx
   11a1d:	48 8b 75 a0          	mov    -0x60(%rbp),%rsi
   11a21:	48 8b 7d 90          	mov    -0x70(%rbp),%rdi
   11a25:	41 b8 ff ff ff ff    	mov    $0xffffffff,%r8d
   11a2b:	b9 ff ff 03 80       	mov    $0x8003ffff,%ecx
   11a30:	0f 42 d0             	cmovb  %eax,%edx
   11a33:	e8 f8 d3 ff ff       	callq  ee30 <reg_pattern_test>
   11a38:	84 c0                	test   %al,%al
   11a3a:	0f 85 3a f1 ff ff    	jne    10b7a <e1000_diag_test+0x17a>
		REG_PATTERN_TEST(RDBAL, 0xFFFFFFF0, 0xFFFFFFFF);
		REG_PATTERN_TEST(TXCW, 0xC000FFFF, 0x0000FFFF);
		REG_PATTERN_TEST(TDBAL, 0xFFFFFFF0, 0xFFFFFFFF);
		REG_PATTERN_TEST(TIDV, 0x0000FFFF, 0x0000FFFF);
		value = E1000_RAR_ENTRIES;
		for (i = 0; i < value; i++) {
   11a40:	83 c3 01             	add    $0x1,%ebx
   11a43:	83 fb 0f             	cmp    $0xf,%ebx
   11a46:	75 bf                	jne    11a07 <e1000_diag_test+0x1007>
		}
	} else {
		REG_SET_AND_CHECK(RCTL, 0xFFFFFFFF, 0x01FFFFFF);
		REG_PATTERN_TEST(RDBAL, 0xFFFFF000, 0xFFFFFFFF);
		REG_PATTERN_TEST(TXCW, 0x0000FFFF, 0x0000FFFF);
		REG_PATTERN_TEST(TDBAL, 0xFFFFF000, 0xFFFFFFFF);
   11a48:	31 db                	xor    %ebx,%ebx
	}

	value = E1000_MC_TBL_SIZE;
	for (i = 0; i < value; i++)
		REG_PATTERN_TEST(MTA + (i << 2), 0xFFFFFFFF, 0xFFFFFFFF);
   11a4a:	41 83 bf 18 0c 00 00 	cmpl   $0x3,0xc18(%r15)
   11a51:	03 
   11a52:	8d 04 9d 00 02 00 00 	lea    0x200(,%rbx,4),%eax
   11a59:	8d 14 9d 00 52 00 00 	lea    0x5200(,%rbx,4),%edx
   11a60:	48 8b 75 a0          	mov    -0x60(%rbp),%rsi
   11a64:	48 8b 7d 90          	mov    -0x70(%rbp),%rdi
   11a68:	41 b8 ff ff ff ff    	mov    $0xffffffff,%r8d
   11a6e:	44 89 c1             	mov    %r8d,%ecx
   11a71:	0f 42 d0             	cmovb  %eax,%edx
   11a74:	e8 b7 d3 ff ff       	callq  ee30 <reg_pattern_test>
   11a79:	84 c0                	test   %al,%al
   11a7b:	0f 85 f9 f0 ff ff    	jne    10b7a <e1000_diag_test+0x17a>
		REG_PATTERN_TEST(TXCW, 0x0000FFFF, 0x0000FFFF);
		REG_PATTERN_TEST(TDBAL, 0xFFFFF000, 0xFFFFFFFF);
	}

	value = E1000_MC_TBL_SIZE;
	for (i = 0; i < value; i++)
   11a81:	83 c3 01             	add    $0x1,%ebx
   11a84:	81 fb 80 00 00 00    	cmp    $0x80,%ebx
   11a8a:	75 be                	jne    11a4a <e1000_diag_test+0x104a>
		REG_PATTERN_TEST(MTA + (i << 2), 0xFFFFFFFF, 0xFFFFFFFF);

	*data = 0;
   11a8c:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
   11a90:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
   11a97:	e9 e6 f0 ff ff       	jmpq   10b82 <e1000_diag_test+0x182>
   11a9c:	4c 8b 35 00 00 00 00 	mov    0x0(%rip),%r14        # 11aa3 <e1000_diag_test+0x10a3>
				       struct dma_attrs *attrs)
{
	struct dma_map_ops *ops = get_dma_ops(dev);
	void *cpu_addr;

	BUG_ON(!ops);
   11aa3:	4d 85 f6             	test   %r14,%r14
   11aa6:	0f 85 d2 f3 ff ff    	jne    10e7e <e1000_diag_test+0x47e>
   11aac:	0f 0b                	ud2    
		goto err_nomem;
	}

	txdr->size = txdr->count * sizeof(struct e1000_tx_desc);
	txdr->size = ALIGN(txdr->size, 4096);
	txdr->desc = dma_zalloc_coherent(&pdev->dev, txdr->size, &txdr->dma,
   11aae:	49 c7 87 78 0f 00 00 	movq   $0x0,0xf78(%r15)
   11ab5:	00 00 00 00 
   11ab9:	bb 02 00 00 00       	mov    $0x2,%ebx
   11abe:	e9 96 fa ff ff       	jmpq   11559 <e1000_diag_test+0xb59>
			ew32(ICS, mask);
			E1000_WRITE_FLUSH();
			msleep(10);

			if (adapter->test_icr & mask) {
				*data = 3;
   11ac3:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
   11ac7:	48 c7 40 10 03 00 00 	movq   $0x3,0x10(%rax)
   11ace:	00 
   11acf:	e9 c0 f2 ff ff       	jmpq   10d94 <e1000_diag_test+0x394>
   11ad4:	4d 89 f7             	mov    %r14,%r15
	return ret_val;
}

static int e1000_loopback_test(struct e1000_adapter *adapter, u64 *data)
{
	*data = e1000_setup_desc_rings(adapter);
   11ad7:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
   11adb:	48 c7 40 18 00 00 00 	movq   $0x0,0x18(%rax)
   11ae2:	00 
static int e1000_setup_loopback_test(struct e1000_adapter *adapter)
{
	struct e1000_hw *hw = &adapter->hw;
	u32 rctl;

	if (hw->media_type == e1000_media_type_fiber ||
   11ae3:	41 8b 87 24 0c 00 00 	mov    0xc24(%r15),%eax
   11aea:	8d 50 ff             	lea    -0x1(%rax),%edx
   11aed:	83 fa 01             	cmp    $0x1,%edx
   11af0:	76 31                	jbe    11b23 <e1000_diag_test+0x1123>
			rctl = er32(RCTL);
			rctl |= E1000_RCTL_LBM_TCVR;
			ew32(RCTL, rctl);
			return 0;
		}
	} else if (hw->media_type == e1000_media_type_copper) {
   11af2:	85 c0                	test   %eax,%eax
   11af4:	0f 84 af 04 00 00    	je     11fa9 <e1000_diag_test+0x15a9>
static int e1000_loopback_test(struct e1000_adapter *adapter, u64 *data)
{
	*data = e1000_setup_desc_rings(adapter);
	if (*data)
		goto out;
	*data = e1000_setup_loopback_test(adapter);
   11afa:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
   11afe:	48 c7 40 18 07 00 00 	movq   $0x7,0x18(%rax)
   11b05:	00 
		goto err_loopback;
	*data = e1000_run_loopback_test(adapter);
	e1000_loopback_cleanup(adapter);

err_loopback:
	e1000_free_desc_rings(adapter);
   11b06:	48 8b 7d 90          	mov    -0x70(%rbp),%rdi
   11b0a:	e8 e1 eb ff ff       	callq  106f0 <e1000_free_desc_rings>
			eth_test->flags |= ETH_TEST_FL_FAILED;

		e1000_reset(adapter);
		/* make sure the phy is powered up */
		e1000_power_up_phy(adapter);
		if (e1000_loopback_test(adapter, &data[3]))
   11b0f:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
   11b13:	8b 40 18             	mov    0x18(%rax),%eax
   11b16:	85 c0                	test   %eax,%eax
   11b18:	0f 84 54 fa ff ff    	je     11572 <e1000_diag_test+0xb72>
   11b1e:	e9 47 fa ff ff       	jmpq   1156a <e1000_diag_test+0xb6a>
   11b23:	41 8b 87 18 0c 00 00 	mov    0xc18(%r15),%eax
   11b2a:	8d 48 fa             	lea    -0x6(%rax),%ecx
   11b2d:	83 f9 04             	cmp    $0x4,%ecx
   11b30:	77 10                	ja     11b42 <e1000_diag_test+0x1142>
   11b32:	b8 01 00 00 00       	mov    $0x1,%eax
   11b37:	48 d3 e0             	shl    %cl,%rax
   11b3a:	a8 17                	test   $0x17,%al
   11b3c:	0f 85 67 04 00 00    	jne    11fa9 <e1000_diag_test+0x15a9>
		case e1000_82546:
		case e1000_82545_rev_3:
		case e1000_82546_rev_3:
			return e1000_set_phy_loopback(adapter);
		default:
			rctl = er32(RCTL);
   11b42:	49 8b 87 00 0c 00 00 	mov    0xc00(%r15),%rax
{ asm volatile("mov" size " %0,%1": :reg (val), \
"m" (*(volatile type __force *)addr) barrier); }

build_mmio_read(readb, "b", unsigned char, "=q", :"memory")
build_mmio_read(readw, "w", unsigned short, "=r", :"memory")
build_mmio_read(readl, "l", unsigned int, "=r", :"memory")
   11b49:	8b 80 00 01 00 00    	mov    0x100(%rax),%eax
			rctl |= E1000_RCTL_LBM_TCVR;
   11b4f:	0c c0                	or     $0xc0,%al
			ew32(RCTL, rctl);
   11b51:	49 8b 97 00 0c 00 00 	mov    0xc00(%r15),%rdx
build_mmio_read(__readw, "w", unsigned short, "=r", )
build_mmio_read(__readl, "l", unsigned int, "=r", )

build_mmio_write(writeb, "b", unsigned char, "q", :"memory")
build_mmio_write(writew, "w", unsigned short, "r", :"memory")
build_mmio_write(writel, "l", unsigned int, "r", :"memory")
   11b58:	89 82 00 01 00 00    	mov    %eax,0x100(%rdx)
static int e1000_loopback_test(struct e1000_adapter *adapter, u64 *data)
{
	*data = e1000_setup_desc_rings(adapter);
	if (*data)
		goto out;
	*data = e1000_setup_loopback_test(adapter);
   11b5e:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
   11b62:	48 c7 40 18 00 00 00 	movq   $0x0,0x18(%rax)
   11b69:	00 
	struct e1000_rx_ring *rxdr = &adapter->test_rx_ring;
	struct pci_dev *pdev = adapter->pdev;
	int i, j, k, l, lc, good_cnt, ret_val = 0;
	unsigned long time;

	ew32(RDT, rxdr->count - 1);
   11b6a:	41 83 bf 18 0c 00 00 	cmpl   $0x3,0xc18(%r15)
   11b71:	03 
   11b72:	41 8b 9f bc 0f 00 00 	mov    0xfbc(%r15),%ebx
static int e1000_run_loopback_test(struct e1000_adapter *adapter)
{
	struct e1000_hw *hw = &adapter->hw;
	struct e1000_tx_ring *txdr = &adapter->test_tx_ring;
	struct e1000_rx_ring *rxdr = &adapter->test_rx_ring;
	struct pci_dev *pdev = adapter->pdev;
   11b79:	4d 8b a7 f8 0b 00 00 	mov    0xbf8(%r15),%r12
	int i, j, k, l, lc, good_cnt, ret_val = 0;
	unsigned long time;

	ew32(RDT, rxdr->count - 1);
   11b80:	8d 53 ff             	lea    -0x1(%rbx),%edx
   11b83:	48 19 c0             	sbb    %rax,%rax
   11b86:	48 25 10 d9 ff ff    	and    $0xffffffffffffd910,%rax
   11b8c:	48 05 18 28 00 00    	add    $0x2818,%rax
   11b92:	49 03 87 00 0c 00 00 	add    0xc00(%r15),%rax
   11b99:	89 10                	mov    %edx,(%rax)
	/* Calculate the loop count based on the largest descriptor ring
	 * The idea is to wrap the largest ring a number of times using 64
	 * send/receive pairs during each loop
	 */

	if (rxdr->count <= txdr->count)
   11b9b:	41 8b 87 bc 0f 00 00 	mov    0xfbc(%r15),%eax
   11ba2:	41 8b 97 8c 0f 00 00 	mov    0xf8c(%r15),%edx
   11ba9:	39 d0                	cmp    %edx,%eax
   11bab:	0f 87 19 04 00 00    	ja     11fca <e1000_diag_test+0x15ca>
		lc = ((txdr->count / 64) * 2) + 1;
   11bb1:	c1 ea 06             	shr    $0x6,%edx
   11bb4:	8d 44 12 01          	lea    0x1(%rdx,%rdx,1),%eax
   11bb8:	89 85 6c ff ff ff    	mov    %eax,-0x94(%rbp)
	else
		lc = ((rxdr->count / 64) * 2) + 1;

	k = l = 0;
   11bbe:	45 31 ed             	xor    %r13d,%r13d
   11bc1:	49 8d 9c 24 98 00 00 	lea    0x98(%r12),%rbx
   11bc8:	00 
   11bc9:	4d 89 fe             	mov    %r15,%r14
   11bcc:	c7 85 7c ff ff ff 00 	movl   $0x0,-0x84(%rbp)
   11bd3:	00 00 00 
	for (j = 0; j <= lc; j++) { /* loop count loop */
   11bd6:	c7 45 98 00 00 00 00 	movl   $0x0,-0x68(%rbp)
   11bdd:	45 89 ef             	mov    %r13d,%r15d
	struct e1000_rx_ring *rxdr = &adapter->test_rx_ring;
	struct pci_dev *pdev = adapter->pdev;
	int i, j, k, l, lc, good_cnt, ret_val = 0;
	unsigned long time;

	ew32(RDT, rxdr->count - 1);
   11be0:	45 31 ed             	xor    %r13d,%r13d
   11be3:	eb 38                	jmp    11c1d <e1000_diag_test+0x121d>
					      enum dma_data_direction dir)
{
	struct dma_map_ops *ops = get_dma_ops(dev);

	BUG_ON(!valid_dma_direction(dir));
	if (ops->sync_single_for_device)
   11be5:	48 8b 40 48          	mov    0x48(%rax),%rax
   11be9:	48 85 c0             	test   %rax,%rax
   11bec:	74 0a                	je     11bf8 <e1000_diag_test+0x11f8>
		ops->sync_single_for_device(dev, addr, size, dir);
   11bee:	b9 01 00 00 00       	mov    $0x1,%ecx
   11bf3:	48 89 df             	mov    %rbx,%rdi
   11bf6:	ff d0                	callq  *%rax
						  1024);
			dma_sync_single_for_device(&pdev->dev,
						   txdr->buffer_info[k].dma,
						   txdr->buffer_info[k].length,
						   DMA_TO_DEVICE);
			if (unlikely(++k == txdr->count))
   11bf8:	41 83 c7 01          	add    $0x1,%r15d
				k = 0;
   11bfc:	45 3b be 8c 0f 00 00 	cmp    0xf8c(%r14),%r15d
   11c03:	b8 00 00 00 00       	mov    $0x0,%eax
   11c08:	44 0f 44 f8          	cmove  %eax,%r15d
   11c0c:	49 83 c5 28          	add    $0x28,%r13
	else
		lc = ((rxdr->count / 64) * 2) + 1;

	k = l = 0;
	for (j = 0; j <= lc; j++) { /* loop count loop */
		for (i = 0; i < 64; i++) { /* send the packets */
   11c10:	49 81 fd 00 0a 00 00 	cmp    $0xa00,%r13
   11c17:	0f 84 aa 01 00 00    	je     11dc7 <e1000_diag_test+0x13c7>
			e1000_create_lbtest_frame(txdr->buffer_info[i].skb,
   11c1d:	49 8b 86 98 0f 00 00 	mov    0xf98(%r14),%rax
}

static void e1000_create_lbtest_frame(struct sk_buff *skb,
				      unsigned int frame_size)
{
	memset(skb->data, 0xFF, frame_size);
   11c24:	ba 00 04 00 00       	mov    $0x400,%edx
		lc = ((rxdr->count / 64) * 2) + 1;

	k = l = 0;
	for (j = 0; j <= lc; j++) { /* loop count loop */
		for (i = 0; i < 64; i++) { /* send the packets */
			e1000_create_lbtest_frame(txdr->buffer_info[i].skb,
   11c29:	4a 8b 34 28          	mov    (%rax,%r13,1),%rsi
}

static void e1000_create_lbtest_frame(struct sk_buff *skb,
				      unsigned int frame_size)
{
	memset(skb->data, 0xFF, frame_size);
   11c2d:	48 8b be d8 00 00 00 	mov    0xd8(%rsi),%rdi
   11c34:	40 f6 c7 01          	test   $0x1,%dil
   11c38:	0f 85 79 01 00 00    	jne    11db7 <e1000_diag_test+0x13b7>
   11c3e:	40 f6 c7 02          	test   $0x2,%dil
   11c42:	0f 85 58 01 00 00    	jne    11da0 <e1000_diag_test+0x13a0>
   11c48:	40 f6 c7 04          	test   $0x4,%dil
   11c4c:	0f 85 3c 01 00 00    	jne    11d8e <e1000_diag_test+0x138e>
   11c52:	89 d1                	mov    %edx,%ecx
   11c54:	48 c7 c0 ff ff ff ff 	mov    $0xffffffffffffffff,%rax
   11c5b:	c1 e9 03             	shr    $0x3,%ecx
   11c5e:	f6 c2 04             	test   $0x4,%dl
   11c61:	f3 48 ab             	rep stos %rax,%es:(%rdi)
   11c64:	74 0a                	je     11c70 <e1000_diag_test+0x1270>
   11c66:	c7 07 ff ff ff ff    	movl   $0xffffffff,(%rdi)
   11c6c:	48 83 c7 04          	add    $0x4,%rdi
   11c70:	f6 c2 02             	test   $0x2,%dl
   11c73:	74 0f                	je     11c84 <e1000_diag_test+0x1284>
   11c75:	41 b9 ff ff ff ff    	mov    $0xffffffff,%r9d
   11c7b:	48 83 c7 02          	add    $0x2,%rdi
   11c7f:	66 44 89 4f fe       	mov    %r9w,-0x2(%rdi)
   11c84:	83 e2 01             	and    $0x1,%edx
   11c87:	74 03                	je     11c8c <e1000_diag_test+0x128c>
   11c89:	c6 07 ff             	movb   $0xff,(%rdi)
	frame_size &= ~1;
	memset(&skb->data[frame_size / 2], 0xAA, frame_size / 2 - 1);
   11c8c:	48 8b 86 d8 00 00 00 	mov    0xd8(%rsi),%rax
   11c93:	ba ff 01 00 00       	mov    $0x1ff,%edx
   11c98:	48 8d b8 00 02 00 00 	lea    0x200(%rax),%rdi
   11c9f:	40 f6 c7 01          	test   $0x1,%dil
   11ca3:	0f 85 d0 00 00 00    	jne    11d79 <e1000_diag_test+0x1379>
   11ca9:	40 f6 c7 02          	test   $0x2,%dil
   11cad:	0f 85 af 00 00 00    	jne    11d62 <e1000_diag_test+0x1362>
   11cb3:	40 f6 c7 04          	test   $0x4,%dil
   11cb7:	0f 85 93 00 00 00    	jne    11d50 <e1000_diag_test+0x1350>
   11cbd:	89 d1                	mov    %edx,%ecx
   11cbf:	48 b8 aa aa aa aa aa 	movabs $0xaaaaaaaaaaaaaaaa,%rax
   11cc6:	aa aa aa 
   11cc9:	c1 e9 03             	shr    $0x3,%ecx
   11ccc:	f6 c2 04             	test   $0x4,%dl
   11ccf:	f3 48 ab             	rep stos %rax,%es:(%rdi)
   11cd2:	74 0a                	je     11cde <e1000_diag_test+0x12de>
   11cd4:	c7 07 aa aa aa aa    	movl   $0xaaaaaaaa,(%rdi)
   11cda:	48 83 c7 04          	add    $0x4,%rdi
   11cde:	f6 c2 02             	test   $0x2,%dl
   11ce1:	74 0d                	je     11cf0 <e1000_diag_test+0x12f0>
   11ce3:	b9 aa aa ff ff       	mov    $0xffffaaaa,%ecx
   11ce8:	48 83 c7 02          	add    $0x2,%rdi
   11cec:	66 89 4f fe          	mov    %cx,-0x2(%rdi)
   11cf0:	83 e2 01             	and    $0x1,%edx
   11cf3:	74 03                	je     11cf8 <e1000_diag_test+0x12f8>
   11cf5:	c6 07 aa             	movb   $0xaa,(%rdi)
	memset(&skb->data[frame_size / 2 + 10], 0xBE, 1);
   11cf8:	48 8b 86 d8 00 00 00 	mov    0xd8(%rsi),%rax
static inline struct dma_map_ops *get_dma_ops(struct device *dev)
{
#ifndef CONFIG_X86_DEV_DMA_OPS
	return dma_ops;
#else
	if (unlikely(!dev) || !dev->archdata.dma_ops)
   11cff:	48 85 db             	test   %rbx,%rbx
   11d02:	c6 80 0a 02 00 00 be 	movb   $0xbe,0x20a(%rax)
	memset(&skb->data[frame_size / 2 + 12], 0xAF, 1);
   11d09:	48 8b 86 d8 00 00 00 	mov    0xd8(%rsi),%rax
   11d10:	c6 80 0c 02 00 00 af 	movb   $0xaf,0x20c(%rax)
		for (i = 0; i < 64; i++) { /* send the packets */
			e1000_create_lbtest_frame(txdr->buffer_info[i].skb,
						  1024);
			dma_sync_single_for_device(&pdev->dev,
						   txdr->buffer_info[k].dma,
						   txdr->buffer_info[k].length,
   11d17:	49 63 c7             	movslq %r15d,%rax
   11d1a:	48 8d 14 80          	lea    (%rax,%rax,4),%rdx
   11d1e:	49 8b 86 98 0f 00 00 	mov    0xf98(%r14),%rax
   11d25:	48 8d 04 d0          	lea    (%rax,%rdx,8),%rax
	k = l = 0;
	for (j = 0; j <= lc; j++) { /* loop count loop */
		for (i = 0; i < 64; i++) { /* send the packets */
			e1000_create_lbtest_frame(txdr->buffer_info[i].skb,
						  1024);
			dma_sync_single_for_device(&pdev->dev,
   11d29:	0f b7 50 18          	movzwl 0x18(%rax),%edx
   11d2d:	48 8b 70 08          	mov    0x8(%rax),%rsi
   11d31:	74 11                	je     11d44 <e1000_diag_test+0x1344>
   11d33:	49 8b 84 24 e8 02 00 	mov    0x2e8(%r12),%rax
   11d3a:	00 
   11d3b:	48 85 c0             	test   %rax,%rax
   11d3e:	0f 85 a1 fe ff ff    	jne    11be5 <e1000_diag_test+0x11e5>
		return dma_ops;
   11d44:	48 8b 05 00 00 00 00 	mov    0x0(%rip),%rax        # 11d4b <e1000_diag_test+0x134b>
   11d4b:	e9 95 fe ff ff       	jmpq   11be5 <e1000_diag_test+0x11e5>
static void e1000_create_lbtest_frame(struct sk_buff *skb,
				      unsigned int frame_size)
{
	memset(skb->data, 0xFF, frame_size);
	frame_size &= ~1;
	memset(&skb->data[frame_size / 2], 0xAA, frame_size / 2 - 1);
   11d50:	c7 07 aa aa aa aa    	movl   $0xaaaaaaaa,(%rdi)
   11d56:	83 ea 04             	sub    $0x4,%edx
   11d59:	48 83 c7 04          	add    $0x4,%rdi
   11d5d:	e9 5b ff ff ff       	jmpq   11cbd <e1000_diag_test+0x12bd>
   11d62:	41 b8 aa aa ff ff    	mov    $0xffffaaaa,%r8d
   11d68:	48 83 c7 02          	add    $0x2,%rdi
   11d6c:	83 ea 02             	sub    $0x2,%edx
   11d6f:	66 44 89 47 fe       	mov    %r8w,-0x2(%rdi)
   11d74:	e9 3a ff ff ff       	jmpq   11cb3 <e1000_diag_test+0x12b3>
   11d79:	c6 80 00 02 00 00 aa 	movb   $0xaa,0x200(%rax)
   11d80:	48 8d b8 01 02 00 00 	lea    0x201(%rax),%rdi
   11d87:	b2 fe                	mov    $0xfe,%dl
   11d89:	e9 1b ff ff ff       	jmpq   11ca9 <e1000_diag_test+0x12a9>
}

static void e1000_create_lbtest_frame(struct sk_buff *skb,
				      unsigned int frame_size)
{
	memset(skb->data, 0xFF, frame_size);
   11d8e:	c7 07 ff ff ff ff    	movl   $0xffffffff,(%rdi)
   11d94:	83 ea 04             	sub    $0x4,%edx
   11d97:	48 83 c7 04          	add    $0x4,%rdi
   11d9b:	e9 b2 fe ff ff       	jmpq   11c52 <e1000_diag_test+0x1252>
   11da0:	41 ba ff ff ff ff    	mov    $0xffffffff,%r10d
   11da6:	48 83 c7 02          	add    $0x2,%rdi
   11daa:	83 ea 02             	sub    $0x2,%edx
   11dad:	66 44 89 57 fe       	mov    %r10w,-0x2(%rdi)
   11db2:	e9 91 fe ff ff       	jmpq   11c48 <e1000_diag_test+0x1248>
   11db7:	c6 07 ff             	movb   $0xff,(%rdi)
   11dba:	66 ba ff 03          	mov    $0x3ff,%dx
   11dbe:	48 83 c7 01          	add    $0x1,%rdi
   11dc2:	e9 77 fe ff ff       	jmpq   11c3e <e1000_diag_test+0x123e>
						   txdr->buffer_info[k].length,
						   DMA_TO_DEVICE);
			if (unlikely(++k == txdr->count))
				k = 0;
		}
		ew32(TDT, k);
   11dc7:	41 83 be 18 0c 00 00 	cmpl   $0x3,0xc18(%r14)
   11dce:	03 
   11dcf:	48 19 c0             	sbb    %rax,%rax
   11dd2:	48 25 20 cc ff ff    	and    $0xffffffffffffcc20,%rax
   11dd8:	48 05 18 38 00 00    	add    $0x3818,%rax
   11dde:	49 03 86 00 0c 00 00 	add    0xc00(%r14),%rax
   11de5:	44 89 38             	mov    %r15d,(%rax)
		E1000_WRITE_FLUSH();
   11de8:	49 8b 86 00 0c 00 00 	mov    0xc00(%r14),%rax
{ asm volatile("mov" size " %0,%1": :reg (val), \
"m" (*(volatile type __force *)addr) barrier); }

build_mmio_read(readb, "b", unsigned char, "=q", :"memory")
build_mmio_read(readw, "w", unsigned short, "=r", :"memory")
build_mmio_read(readl, "l", unsigned int, "=r", :"memory")
   11def:	8b 40 08             	mov    0x8(%rax),%eax
		msleep(200);
   11df2:	bf c8 00 00 00       	mov    $0xc8,%edi
   11df7:	e8 00 00 00 00       	callq  11dfc <e1000_diag_test+0x13fc>
		time = jiffies; /* set the start time for the receive */
   11dfc:	48 8b 05 00 00 00 00 	mov    0x0(%rip),%rax        # 11e03 <e1000_diag_test+0x1403>
   11e03:	49 8b be c8 0f 00 00 	mov    0xfc8(%r14),%rdi
		good_cnt = 0;
   11e0a:	44 89 bd 78 ff ff ff 	mov    %r15d,-0x88(%rbp)
   11e11:	c7 45 b0 00 00 00 00 	movl   $0x0,-0x50(%rbp)
   11e18:	4d 89 f7             	mov    %r14,%r15
   11e1b:	44 8b ad 7c ff ff ff 	mov    -0x84(%rbp),%r13d
   11e22:	49 89 de             	mov    %rbx,%r14
				k = 0;
		}
		ew32(TDT, k);
		E1000_WRITE_FLUSH();
		msleep(200);
		time = jiffies; /* set the start time for the receive */
   11e25:	48 89 45 a8          	mov    %rax,-0x58(%rbp)
   11e29:	eb 33                	jmp    11e5e <e1000_diag_test+0x145e>
					rxdr->buffer_info[l].rxbuf.data +
					NET_SKB_PAD + NET_IP_ALIGN,
					1024);
			if (!ret_val)
				good_cnt++;
			if (unlikely(++l == rxdr->count))
   11e2b:	41 83 c5 01          	add    $0x1,%r13d
				l = 0;
   11e2f:	45 3b af bc 0f 00 00 	cmp    0xfbc(%r15),%r13d
   11e36:	b8 00 00 00 00       	mov    $0x0,%eax
   11e3b:	44 0f 44 e8          	cmove  %eax,%r13d
			/* time + 20 msecs (200 msecs on 2.4) is more than
			 * enough time to complete the receives, if it's
			 * exceeded, break and error off
			 */
		} while (good_cnt < 64 && time_after(time + 20, jiffies));
   11e3f:	83 7d b0 3f          	cmpl   $0x3f,-0x50(%rbp)
   11e43:	0f 8f 9a 00 00 00    	jg     11ee3 <e1000_diag_test+0x14e3>
   11e49:	48 8b 05 00 00 00 00 	mov    0x0(%rip),%rax        # 11e50 <e1000_diag_test+0x1450>
   11e50:	48 83 e8 14          	sub    $0x14,%rax
   11e54:	48 3b 45 a8          	cmp    -0x58(%rbp),%rax
   11e58:	0f 89 44 01 00 00    	jns    11fa2 <e1000_diag_test+0x15a2>
		msleep(200);
		time = jiffies; /* set the start time for the receive */
		good_cnt = 0;
		do { /* receive the sent packets */
			dma_sync_single_for_cpu(&pdev->dev,
						rxdr->buffer_info[l].dma,
   11e5e:	49 63 dd             	movslq %r13d,%rbx
   11e61:	48 c1 e3 04          	shl    $0x4,%rbx
static inline struct dma_map_ops *get_dma_ops(struct device *dev)
{
#ifndef CONFIG_X86_DEV_DMA_OPS
	return dma_ops;
#else
	if (unlikely(!dev) || !dev->archdata.dma_ops)
   11e65:	4d 85 f6             	test   %r14,%r14
   11e68:	48 8d 14 1f          	lea    (%rdi,%rbx,1),%rdx
		E1000_WRITE_FLUSH();
		msleep(200);
		time = jiffies; /* set the start time for the receive */
		good_cnt = 0;
		do { /* receive the sent packets */
			dma_sync_single_for_cpu(&pdev->dev,
   11e6c:	48 8b 72 08          	mov    0x8(%rdx),%rsi
   11e70:	74 68                	je     11eda <e1000_diag_test+0x14da>
   11e72:	49 8b 8c 24 e8 02 00 	mov    0x2e8(%r12),%rcx
   11e79:	00 
   11e7a:	48 85 c9             	test   %rcx,%rcx
   11e7d:	74 5b                	je     11eda <e1000_diag_test+0x14da>
					   enum dma_data_direction dir)
{
	struct dma_map_ops *ops = get_dma_ops(dev);

	BUG_ON(!valid_dma_direction(dir));
	if (ops->sync_single_for_cpu)
   11e7f:	4c 8b 51 40          	mov    0x40(%rcx),%r10
   11e83:	4d 85 d2             	test   %r10,%r10
   11e86:	74 1b                	je     11ea3 <e1000_diag_test+0x14a3>
		ops->sync_single_for_cpu(dev, addr, size, dir);
   11e88:	ba 00 08 00 00       	mov    $0x800,%edx
   11e8d:	4c 89 f7             	mov    %r14,%rdi
   11e90:	b9 02 00 00 00       	mov    $0x2,%ecx
   11e95:	41 ff d2             	callq  *%r10
   11e98:	49 8b bf c8 0f 00 00 	mov    0xfc8(%r15),%rdi
   11e9f:	48 8d 14 1f          	lea    (%rdi,%rbx,1),%rdx
						rxdr->buffer_info[l].dma,
						E1000_RXBUFFER_2048,
						DMA_FROM_DEVICE);

			ret_val = e1000_check_lbtest_frame(
					rxdr->buffer_info[l].rxbuf.data +
   11ea3:	48 8b 02             	mov    (%rdx),%rax

static int e1000_check_lbtest_frame(const unsigned char *data,
				    unsigned int frame_size)
{
	frame_size &= ~1;
	if (*(data + 3) == 0xFF) {
   11ea6:	ba 0d 00 00 00       	mov    $0xd,%edx
   11eab:	80 78 43 ff          	cmpb   $0xff,0x43(%rax)
   11eaf:	0f 85 76 ff ff ff    	jne    11e2b <e1000_diag_test+0x142b>
		if ((*(data + frame_size / 2 + 10) == 0xBE) &&
   11eb5:	80 b8 4a 02 00 00 be 	cmpb   $0xbe,0x24a(%rax)
   11ebc:	0f 85 69 ff ff ff    	jne    11e2b <e1000_diag_test+0x142b>
   11ec2:	80 b8 4c 02 00 00 af 	cmpb   $0xaf,0x24c(%rax)
   11ec9:	0f 85 5c ff ff ff    	jne    11e2b <e1000_diag_test+0x142b>
			ret_val = e1000_check_lbtest_frame(
					rxdr->buffer_info[l].rxbuf.data +
					NET_SKB_PAD + NET_IP_ALIGN,
					1024);
			if (!ret_val)
				good_cnt++;
   11ecf:	83 45 b0 01          	addl   $0x1,-0x50(%rbp)
{
	frame_size &= ~1;
	if (*(data + 3) == 0xFF) {
		if ((*(data + frame_size / 2 + 10) == 0xBE) &&
		    (*(data + frame_size / 2 + 12) == 0xAF)) {
			return 0;
   11ed3:	31 d2                	xor    %edx,%edx
   11ed5:	e9 51 ff ff ff       	jmpq   11e2b <e1000_diag_test+0x142b>
		return dma_ops;
   11eda:	48 8b 0d 00 00 00 00 	mov    0x0(%rip),%rcx        # 11ee1 <e1000_diag_test+0x14e1>
   11ee1:	eb 9c                	jmp    11e7f <e1000_diag_test+0x147f>
			 * enough time to complete the receives, if it's
			 * exceeded, break and error off
			 */
		} while (good_cnt < 64 && time_after(time + 20, jiffies));

		if (good_cnt != 64) {
   11ee3:	83 7d b0 40          	cmpl   $0x40,-0x50(%rbp)
   11ee7:	4c 89 f3             	mov    %r14,%rbx
   11eea:	44 89 ad 7c ff ff ff 	mov    %r13d,-0x84(%rbp)
   11ef1:	4d 89 fe             	mov    %r15,%r14
   11ef4:	44 8b bd 78 ff ff ff 	mov    -0x88(%rbp),%r15d
   11efb:	0f 85 9e 00 00 00    	jne    11f9f <e1000_diag_test+0x159f>
			ret_val = 13; /* ret_val is the same as mis-compare */
			break;
		}
		if (time_after_eq(jiffies, time + 2)) {
   11f01:	48 8b 05 00 00 00 00 	mov    0x0(%rip),%rax        # 11f08 <e1000_diag_test+0x1508>
   11f08:	48 83 e8 02          	sub    $0x2,%rax
   11f0c:	48 3b 45 a8          	cmp    -0x58(%rbp),%rax
   11f10:	0f 89 f4 00 00 00    	jns    1200a <e1000_diag_test+0x160a>
		lc = ((txdr->count / 64) * 2) + 1;
	else
		lc = ((rxdr->count / 64) * 2) + 1;

	k = l = 0;
	for (j = 0; j <= lc; j++) { /* loop count loop */
   11f16:	83 45 98 01          	addl   $0x1,-0x68(%rbp)
   11f1a:	8b 85 6c ff ff ff    	mov    -0x94(%rbp),%eax
   11f20:	39 45 98             	cmp    %eax,-0x68(%rbp)
   11f23:	0f 8e b7 fc ff ff    	jle    11be0 <e1000_diag_test+0x11e0>
   11f29:	4d 89 f7             	mov    %r14,%r15
	if (*data)
		goto out;
	*data = e1000_setup_loopback_test(adapter);
	if (*data)
		goto err_loopback;
	*data = e1000_run_loopback_test(adapter);
   11f2c:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
   11f30:	48 89 50 18          	mov    %rdx,0x18(%rax)
{
	struct e1000_hw *hw = &adapter->hw;
	u32 rctl;
	u16 phy_reg;

	rctl = er32(RCTL);
   11f34:	49 8b 87 00 0c 00 00 	mov    0xc00(%r15),%rax
   11f3b:	8b 80 00 01 00 00    	mov    0x100(%rax),%eax
	rctl &= ~(E1000_RCTL_LBM_TCVR | E1000_RCTL_LBM_MAC);
   11f41:	24 3f                	and    $0x3f,%al
	ew32(RCTL, rctl);
   11f43:	49 8b 97 00 0c 00 00 	mov    0xc00(%r15),%rdx
build_mmio_read(__readw, "w", unsigned short, "=r", )
build_mmio_read(__readl, "l", unsigned int, "=r", )

build_mmio_write(writeb, "b", unsigned char, "q", :"memory")
build_mmio_write(writew, "w", unsigned short, "r", :"memory")
build_mmio_write(writel, "l", unsigned int, "r", :"memory")
   11f4a:	89 82 00 01 00 00    	mov    %eax,0x100(%rdx)
	case e1000_82546:
	case e1000_82545_rev_3:
	case e1000_82546_rev_3:
	default:
		hw->autoneg = true;
		e1000_read_phy_reg(hw, PHY_CTRL, &phy_reg);
   11f50:	48 8b bd 70 ff ff ff 	mov    -0x90(%rbp),%rdi
   11f57:	48 8d 55 be          	lea    -0x42(%rbp),%rdx
   11f5b:	31 f6                	xor    %esi,%esi
	case e1000_82545:
	case e1000_82546:
	case e1000_82545_rev_3:
	case e1000_82546_rev_3:
	default:
		hw->autoneg = true;
   11f5d:	41 c6 87 ef 0c 00 00 	movb   $0x1,0xcef(%r15)
   11f64:	01 
		e1000_read_phy_reg(hw, PHY_CTRL, &phy_reg);
   11f65:	e8 00 00 00 00       	callq  11f6a <e1000_diag_test+0x156a>
		if (phy_reg & MII_CR_LOOPBACK) {
   11f6a:	0f b7 45 be          	movzwl -0x42(%rbp),%eax
   11f6e:	f6 c4 40             	test   $0x40,%ah
   11f71:	0f 84 8f fb ff ff    	je     11b06 <e1000_diag_test+0x1106>
			phy_reg &= ~MII_CR_LOOPBACK;
			e1000_write_phy_reg(hw, PHY_CTRL, phy_reg);
   11f77:	48 8b 9d 70 ff ff ff 	mov    -0x90(%rbp),%rbx
	case e1000_82546_rev_3:
	default:
		hw->autoneg = true;
		e1000_read_phy_reg(hw, PHY_CTRL, &phy_reg);
		if (phy_reg & MII_CR_LOOPBACK) {
			phy_reg &= ~MII_CR_LOOPBACK;
   11f7e:	80 e4 bf             	and    $0xbf,%ah
			e1000_write_phy_reg(hw, PHY_CTRL, phy_reg);
   11f81:	31 f6                	xor    %esi,%esi
   11f83:	0f b7 d0             	movzwl %ax,%edx
	case e1000_82546_rev_3:
	default:
		hw->autoneg = true;
		e1000_read_phy_reg(hw, PHY_CTRL, &phy_reg);
		if (phy_reg & MII_CR_LOOPBACK) {
			phy_reg &= ~MII_CR_LOOPBACK;
   11f86:	66 89 45 be          	mov    %ax,-0x42(%rbp)
			e1000_write_phy_reg(hw, PHY_CTRL, phy_reg);
   11f8a:	48 89 df             	mov    %rbx,%rdi
   11f8d:	e8 00 00 00 00       	callq  11f92 <e1000_diag_test+0x1592>
			e1000_phy_reset(hw);
   11f92:	48 89 df             	mov    %rbx,%rdi
   11f95:	e8 00 00 00 00       	callq  11f9a <e1000_diag_test+0x159a>
   11f9a:	e9 67 fb ff ff       	jmpq   11b06 <e1000_diag_test+0x1106>
   11f9f:	4d 89 f7             	mov    %r14,%r15
			 * enough time to complete the receives, if it's
			 * exceeded, break and error off
			 */
		} while (good_cnt < 64 && time_after(time + 20, jiffies));

		if (good_cnt != 64) {
   11fa2:	ba 0d 00 00 00       	mov    $0xd,%edx
   11fa7:	eb 83                	jmp    11f2c <e1000_diag_test+0x152c>
			rctl |= E1000_RCTL_LBM_TCVR;
			ew32(RCTL, rctl);
			return 0;
		}
	} else if (hw->media_type == e1000_media_type_copper) {
		return e1000_set_phy_loopback(adapter);
   11fa9:	48 8b 7d 90          	mov    -0x70(%rbp),%rdi
   11fad:	e8 6e de ff ff       	callq  fe20 <e1000_set_phy_loopback>
static int e1000_loopback_test(struct e1000_adapter *adapter, u64 *data)
{
	*data = e1000_setup_desc_rings(adapter);
	if (*data)
		goto out;
	*data = e1000_setup_loopback_test(adapter);
   11fb2:	48 8b 5d a0          	mov    -0x60(%rbp),%rbx
   11fb6:	48 98                	cltq   
	if (*data)
   11fb8:	48 85 c0             	test   %rax,%rax
static int e1000_loopback_test(struct e1000_adapter *adapter, u64 *data)
{
	*data = e1000_setup_desc_rings(adapter);
	if (*data)
		goto out;
	*data = e1000_setup_loopback_test(adapter);
   11fbb:	48 89 43 18          	mov    %rax,0x18(%rbx)
	if (*data)
   11fbf:	0f 85 41 fb ff ff    	jne    11b06 <e1000_diag_test+0x1106>
   11fc5:	e9 a0 fb ff ff       	jmpq   11b6a <e1000_diag_test+0x116a>
	 */

	if (rxdr->count <= txdr->count)
		lc = ((txdr->count / 64) * 2) + 1;
	else
		lc = ((rxdr->count / 64) * 2) + 1;
   11fca:	c1 e8 06             	shr    $0x6,%eax
   11fcd:	8d 44 00 01          	lea    0x1(%rax,%rax,1),%eax
   11fd1:	89 85 6c ff ff ff    	mov    %eax,-0x94(%rbp)
   11fd7:	e9 e2 fb ff ff       	jmpq   11bbe <e1000_diag_test+0x11be>
	if (!rxdr->count)
		rxdr->count = E1000_DEFAULT_RXD;

	rxdr->buffer_info = kcalloc(rxdr->count, sizeof(struct e1000_rx_buffer),
				    GFP_KERNEL);
	if (!rxdr->buffer_info) {
   11fdc:	bb 05 00 00 00       	mov    $0x5,%ebx
   11fe1:	e9 73 f5 ff ff       	jmpq   11559 <e1000_diag_test+0xb59>
	if (!txdr->count)
		txdr->count = E1000_DEFAULT_TXD;

	txdr->buffer_info = kcalloc(txdr->count, sizeof(struct e1000_tx_buffer),
				    GFP_KERNEL);
	if (!txdr->buffer_info) {
   11fe6:	bb 01 00 00 00       	mov    $0x1,%ebx
   11feb:	e9 69 f5 ff ff       	jmpq   11559 <e1000_diag_test+0xb59>
   11ff0:	4d 89 f7             	mov    %r14,%r15
		struct e1000_rx_desc *rx_desc = E1000_RX_DESC(*rxdr, i);
		u8 *buf;

		buf = kzalloc(E1000_RXBUFFER_2048 + NET_SKB_PAD + NET_IP_ALIGN,
			      GFP_KERNEL);
		if (!buf) {
   11ff3:	bb 07 00 00 00       	mov    $0x7,%ebx
   11ff8:	e9 5c f5 ff ff       	jmpq   11559 <e1000_diag_test+0xb59>
   11ffd:	4d 89 f7             	mov    %r14,%r15

		rxdr->buffer_info[i].dma =
			dma_map_single(&pdev->dev,
				       buf + NET_SKB_PAD + NET_IP_ALIGN,
				       E1000_RXBUFFER_2048, DMA_FROM_DEVICE);
		if (dma_mapping_error(&pdev->dev, rxdr->buffer_info[i].dma)) {
   12000:	bb 08 00 00 00       	mov    $0x8,%ebx
   12005:	e9 4f f5 ff ff       	jmpq   11559 <e1000_diag_test+0xb59>
   1200a:	4d 89 f7             	mov    %r14,%r15

		if (good_cnt != 64) {
			ret_val = 13; /* ret_val is the same as mis-compare */
			break;
		}
		if (time_after_eq(jiffies, time + 2)) {
   1200d:	ba 0e 00 00 00       	mov    $0xe,%edx
   12012:	e9 15 ff ff ff       	jmpq   11f2c <e1000_diag_test+0x152c>
		ret_val = 5;
		goto err_nomem;
	}

	rxdr->size = rxdr->count * sizeof(struct e1000_rx_desc);
	rxdr->desc = dma_zalloc_coherent(&pdev->dev, rxdr->size, &rxdr->dma,
   12017:	49 c7 87 a8 0f 00 00 	movq   $0x0,0xfa8(%r15)
   1201e:	00 00 00 00 
   12022:	bb 06 00 00 00       	mov    $0x6,%ebx
   12027:	e9 2d f5 ff ff       	jmpq   11559 <e1000_diag_test+0xb59>
   1202c:	4c 8b 35 00 00 00 00 	mov    0x0(%rip),%r14        # 12033 <e1000_diag_test+0x1633>
				       struct dma_attrs *attrs)
{
	struct dma_map_ops *ops = get_dma_ops(dev);
	void *cpu_addr;

	BUG_ON(!ops);
   12033:	4d 85 f6             	test   %r14,%r14
   12036:	0f 85 7a f1 ff ff    	jne    111b6 <e1000_diag_test+0x7b6>
   1203c:	e9 6b fa ff ff       	jmpq   11aac <e1000_diag_test+0x10ac>
	if (!request_irq(irq, e1000_test_intr, IRQF_PROBE_SHARED, netdev->name,
			 netdev))
		shared_int = false;
	else if (request_irq(irq, e1000_test_intr, IRQF_SHARED,
			     netdev->name, netdev)) {
		*data = 1;
   12041:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
   12045:	48 c7 40 10 01 00 00 	movq   $0x1,0x10(%rax)
   1204c:	00 
   1204d:	e9 81 ed ff ff       	jmpq   10dd3 <e1000_diag_test+0x3d3>

	txdr->size = txdr->count * sizeof(struct e1000_tx_desc);
	txdr->size = ALIGN(txdr->size, 4096);
	txdr->desc = dma_zalloc_coherent(&pdev->dev, txdr->size, &txdr->dma,
					 GFP_KERNEL);
	if (!txdr->desc) {
   12052:	bb 02 00 00 00       	mov    $0x2,%ebx
   12057:	e9 fd f4 ff ff       	jmpq   11559 <e1000_diag_test+0xb59>
		for (i = 0; i < value; i++) {
			REG_PATTERN_TEST(RA + (((i << 1) + 1) << 2),
					 0x8003FFFF, 0xFFFFFFFF);
		}
	} else {
		REG_SET_AND_CHECK(RCTL, 0xFFFFFFFF, 0x01FFFFFF);
   1205c:	4c 8b 75 a0          	mov    -0x60(%rbp),%r14
   12060:	48 8b 5d 90          	mov    -0x70(%rbp),%rbx
   12064:	41 b8 ff ff ff 01    	mov    $0x1ffffff,%r8d
   1206a:	b9 ff ff ff ff       	mov    $0xffffffff,%ecx
   1206f:	ba 00 01 00 00       	mov    $0x100,%edx
   12074:	4c 89 f6             	mov    %r14,%rsi
   12077:	48 89 df             	mov    %rbx,%rdi
   1207a:	e8 00 00 00 00       	callq  1207f <e1000_diag_test+0x167f>
   1207f:	84 c0                	test   %al,%al
   12081:	0f 85 f3 ea ff ff    	jne    10b7a <e1000_diag_test+0x17a>
		REG_PATTERN_TEST(RDBAL, 0xFFFFF000, 0xFFFFFFFF);
   12087:	41 83 bf 18 0c 00 00 	cmpl   $0x3,0xc18(%r15)
   1208e:	03 
   1208f:	41 b8 ff ff ff ff    	mov    $0xffffffff,%r8d
   12095:	b9 00 f0 ff ff       	mov    $0xfffff000,%ecx
   1209a:	4c 89 f6             	mov    %r14,%rsi
   1209d:	48 89 df             	mov    %rbx,%rdi
   120a0:	19 d2                	sbb    %edx,%edx
   120a2:	81 e2 10 d9 ff ff    	and    $0xffffd910,%edx
   120a8:	81 c2 00 28 00 00    	add    $0x2800,%edx
   120ae:	e8 7d cd ff ff       	callq  ee30 <reg_pattern_test>
   120b3:	84 c0                	test   %al,%al
   120b5:	0f 85 bf ea ff ff    	jne    10b7a <e1000_diag_test+0x17a>
		REG_PATTERN_TEST(TXCW, 0x0000FFFF, 0x0000FFFF);
   120bb:	4c 8b 75 a0          	mov    -0x60(%rbp),%r14
   120bf:	48 8b 5d 90          	mov    -0x70(%rbp),%rbx
   120c3:	41 b8 ff ff 00 00    	mov    $0xffff,%r8d
   120c9:	b9 ff ff 00 00       	mov    $0xffff,%ecx
   120ce:	ba 78 01 00 00       	mov    $0x178,%edx
   120d3:	4c 89 f6             	mov    %r14,%rsi
   120d6:	48 89 df             	mov    %rbx,%rdi
   120d9:	e8 52 cd ff ff       	callq  ee30 <reg_pattern_test>
   120de:	84 c0                	test   %al,%al
   120e0:	0f 85 94 ea ff ff    	jne    10b7a <e1000_diag_test+0x17a>
		REG_PATTERN_TEST(TDBAL, 0xFFFFF000, 0xFFFFFFFF);
   120e6:	41 83 bf 18 0c 00 00 	cmpl   $0x3,0xc18(%r15)
   120ed:	03 
   120ee:	41 b8 ff ff ff ff    	mov    $0xffffffff,%r8d
   120f4:	b9 00 f0 ff ff       	mov    $0xfffff000,%ecx
   120f9:	4c 89 f6             	mov    %r14,%rsi
   120fc:	48 89 df             	mov    %rbx,%rdi
   120ff:	19 d2                	sbb    %edx,%edx
   12101:	81 e2 20 cc ff ff    	and    $0xffffcc20,%edx
   12107:	81 c2 00 38 00 00    	add    $0x3800,%edx
   1210d:	e8 1e cd ff ff       	callq  ee30 <reg_pattern_test>
   12112:	84 c0                	test   %al,%al
   12114:	0f 84 2e f9 ff ff    	je     11a48 <e1000_diag_test+0x1048>
   1211a:	e9 5b ea ff ff       	jmpq   10b7a <e1000_diag_test+0x17a>
	else if (request_irq(irq, e1000_test_intr, IRQF_SHARED,
			     netdev->name, netdev)) {
		*data = 1;
		return -1;
	}
	e_info(hw, "testing %s interrupt\n", (shared_int ?
   1211f:	48 c7 c2 00 00 00 00 	mov    $0x0,%rdx
   12126:	e9 c4 f3 ff ff       	jmpq   114ef <e1000_diag_test+0xaef>
	}

	rxdr->size = rxdr->count * sizeof(struct e1000_rx_desc);
	rxdr->desc = dma_zalloc_coherent(&pdev->dev, rxdr->size, &rxdr->dma,
					 GFP_KERNEL);
	if (!rxdr->desc) {
   1212b:	bb 06 00 00 00       	mov    $0x6,%ebx
   12130:	e9 24 f4 ff ff       	jmpq   11559 <e1000_diag_test+0xb59>
   12135:	66 66 2e 0f 1f 84 00 	data32 nopw %cs:0x0(%rax,%rax,1)
   1213c:	00 00 00 00 

0000000000012140 <e1000_set_ethtool_ops>:
   12140:	e8 00 00 00 00       	callq  12145 <e1000_set_ethtool_ops+0x5>
   12145:	55                   	push   %rbp
   12146:	48 c7 87 08 02 00 00 	movq   $0x0,0x208(%rdi)
   1214d:	00 00 00 00 
   12151:	48 89 e5             	mov    %rsp,%rbp
   12154:	5d                   	pop    %rbp
   12155:	c3                   	retq   
   12156:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
   1215d:	00 00 00 

0000000000012160 <e1000_validate_option.isra.1>:
			const struct e1000_opt_list { int i; char *str; } *p;
		} l;
	} arg;
};

static int e1000_validate_option(unsigned int *value,
   12160:	e8 00 00 00 00       	callq  12165 <e1000_validate_option.isra.1+0x5>
   12165:	55                   	push   %rbp
   12166:	48 89 e5             	mov    %rsp,%rbp
   12169:	41 54                	push   %r12
   1216b:	49 89 fc             	mov    %rdi,%r12
   1216e:	53                   	push   %rbx
				 const struct e1000_option *opt,
				 struct e1000_adapter *adapter)
{
	if (*value == OPTION_UNSET) {
   1216f:	8b 0f                	mov    (%rdi),%ecx
			const struct e1000_opt_list { int i; char *str; } *p;
		} l;
	} arg;
};

static int e1000_validate_option(unsigned int *value,
   12171:	48 89 f3             	mov    %rsi,%rbx
				 const struct e1000_option *opt,
				 struct e1000_adapter *adapter)
{
	if (*value == OPTION_UNSET) {
   12174:	83 f9 ff             	cmp    $0xffffffff,%ecx
   12177:	0f 84 08 01 00 00    	je     12285 <e1000_validate_option.isra.1+0x125>
		*value = opt->def;
		return 0;
	}

	switch (opt->type) {
   1217d:	8b 06                	mov    (%rsi),%eax
   1217f:	83 f8 01             	cmp    $0x1,%eax
   12182:	0f 84 a8 00 00 00    	je     12230 <e1000_validate_option.isra.1+0xd0>
   12188:	72 78                	jb     12202 <e1000_validate_option.isra.1+0xa2>
   1218a:	83 f8 02             	cmp    $0x2,%eax
   1218d:	0f 1f 00             	nopl   (%rax)
   12190:	0f 85 98 00 00 00    	jne    1222e <e1000_validate_option.isra.1+0xce>
		break;
	case list_option: {
		int i;
		const struct e1000_opt_list *ent;

		for (i = 0; i < opt->arg.l.nr; i++) {
   12196:	8b 76 20             	mov    0x20(%rsi),%esi
   12199:	85 f6                	test   %esi,%esi
   1219b:	7e 32                	jle    121cf <e1000_validate_option.isra.1+0x6f>
			ent = &opt->arg.l.p[i];
   1219d:	4c 8b 43 28          	mov    0x28(%rbx),%r8
			if (*value == ent->i) {
   121a1:	41 3b 08             	cmp    (%r8),%ecx
   121a4:	0f 84 e9 00 00 00    	je     12293 <e1000_validate_option.isra.1+0x133>
   121aa:	49 8d 40 10          	lea    0x10(%r8),%rax
   121ae:	83 ee 01             	sub    $0x1,%esi
   121b1:	48 c1 e6 04          	shl    $0x4,%rsi
   121b5:	48 01 c6             	add    %rax,%rsi
   121b8:	eb 10                	jmp    121ca <e1000_validate_option.isra.1+0x6a>
	case list_option: {
		int i;
		const struct e1000_opt_list *ent;

		for (i = 0; i < opt->arg.l.nr; i++) {
			ent = &opt->arg.l.p[i];
   121ba:	49 89 c0             	mov    %rax,%r8
   121bd:	48 83 c0 10          	add    $0x10,%rax
			if (*value == ent->i) {
   121c1:	41 3b 08             	cmp    (%r8),%ecx
   121c4:	0f 84 c9 00 00 00    	je     12293 <e1000_validate_option.isra.1+0x133>
		break;
	case list_option: {
		int i;
		const struct e1000_opt_list *ent;

		for (i = 0; i < opt->arg.l.nr; i++) {
   121ca:	48 39 f0             	cmp    %rsi,%rax
   121cd:	75 eb                	jne    121ba <e1000_validate_option.isra.1+0x5a>
		break;
	default:
		BUG();
	}

	e_dev_info("Invalid %s value specified (%i) %s\n",
   121cf:	48 8b 3a             	mov    (%rdx),%rdi
   121d2:	4c 8b 43 10          	mov    0x10(%rbx),%r8
   121d6:	31 c0                	xor    %eax,%eax
   121d8:	48 8b 53 08          	mov    0x8(%rbx),%rdx
   121dc:	48 c7 c6 00 00 00 00 	mov    $0x0,%rsi
   121e3:	48 81 c7 98 00 00 00 	add    $0x98,%rdi
   121ea:	e8 00 00 00 00       	callq  121ef <e1000_validate_option.isra.1+0x8f>
	       opt->name, *value, opt->err);
	*value = opt->def;
   121ef:	8b 43 18             	mov    0x18(%rbx),%eax
	return -1;
   121f2:	bb ff ff ff ff       	mov    $0xffffffff,%ebx
		BUG();
	}

	e_dev_info("Invalid %s value specified (%i) %s\n",
	       opt->name, *value, opt->err);
	*value = opt->def;
   121f7:	41 89 04 24          	mov    %eax,(%r12)
	return -1;
}
   121fb:	89 d8                	mov    %ebx,%eax
   121fd:	5b                   	pop    %rbx
   121fe:	41 5c                	pop    %r12
   12200:	5d                   	pop    %rbp
   12201:	c3                   	retq   
		return 0;
	}

	switch (opt->type) {
	case enable_option:
		switch (*value) {
   12202:	85 c9                	test   %ecx,%ecx
   12204:	74 5c                	je     12262 <e1000_validate_option.isra.1+0x102>
   12206:	83 f9 01             	cmp    $0x1,%ecx
   12209:	75 c4                	jne    121cf <e1000_validate_option.isra.1+0x6f>
		case OPTION_ENABLED:
			e_dev_info("%s Enabled\n", opt->name);
   1220b:	48 8b 46 08          	mov    0x8(%rsi),%rax
   1220f:	48 8b 3a             	mov    (%rdx),%rdi
   12212:	48 c7 c6 00 00 00 00 	mov    $0x0,%rsi
			return 0;
   12219:	31 db                	xor    %ebx,%ebx

	switch (opt->type) {
	case enable_option:
		switch (*value) {
		case OPTION_ENABLED:
			e_dev_info("%s Enabled\n", opt->name);
   1221b:	48 89 c2             	mov    %rax,%rdx
   1221e:	48 81 c7 98 00 00 00 	add    $0x98,%rdi
   12225:	31 c0                	xor    %eax,%eax
   12227:	e8 00 00 00 00       	callq  1222c <e1000_validate_option.isra.1+0xcc>
   1222c:	eb 2d                	jmp    1225b <e1000_validate_option.isra.1+0xfb>
			}
		}
	}
		break;
	default:
		BUG();
   1222e:	0f 0b                	ud2    
			e_dev_info("%s Disabled\n", opt->name);
			return 0;
		}
		break;
	case range_option:
		if (*value >= opt->arg.r.min && *value <= opt->arg.r.max) {
   12230:	3b 4e 20             	cmp    0x20(%rsi),%ecx
   12233:	72 9a                	jb     121cf <e1000_validate_option.isra.1+0x6f>
   12235:	3b 4e 24             	cmp    0x24(%rsi),%ecx
   12238:	77 95                	ja     121cf <e1000_validate_option.isra.1+0x6f>
			e_dev_info("%s set to %i\n", opt->name, *value);
   1223a:	48 8b 46 08          	mov    0x8(%rsi),%rax
   1223e:	48 8b 3a             	mov    (%rdx),%rdi
   12241:	48 c7 c6 00 00 00 00 	mov    $0x0,%rsi
			return 0;
   12248:	31 db                	xor    %ebx,%ebx
			return 0;
		}
		break;
	case range_option:
		if (*value >= opt->arg.r.min && *value <= opt->arg.r.max) {
			e_dev_info("%s set to %i\n", opt->name, *value);
   1224a:	48 89 c2             	mov    %rax,%rdx
   1224d:	48 81 c7 98 00 00 00 	add    $0x98,%rdi
   12254:	31 c0                	xor    %eax,%eax
   12256:	e8 00 00 00 00       	callq  1225b <e1000_validate_option.isra.1+0xfb>

	e_dev_info("Invalid %s value specified (%i) %s\n",
	       opt->name, *value, opt->err);
	*value = opt->def;
	return -1;
}
   1225b:	89 d8                	mov    %ebx,%eax
   1225d:	5b                   	pop    %rbx
   1225e:	41 5c                	pop    %r12
   12260:	5d                   	pop    %rbp
   12261:	c3                   	retq   
		switch (*value) {
		case OPTION_ENABLED:
			e_dev_info("%s Enabled\n", opt->name);
			return 0;
		case OPTION_DISABLED:
			e_dev_info("%s Disabled\n", opt->name);
   12262:	48 8b 46 08          	mov    0x8(%rsi),%rax
   12266:	48 8b 3a             	mov    (%rdx),%rdi
   12269:	48 c7 c6 00 00 00 00 	mov    $0x0,%rsi
			return 0;
   12270:	31 db                	xor    %ebx,%ebx
		switch (*value) {
		case OPTION_ENABLED:
			e_dev_info("%s Enabled\n", opt->name);
			return 0;
		case OPTION_DISABLED:
			e_dev_info("%s Disabled\n", opt->name);
   12272:	48 89 c2             	mov    %rax,%rdx
   12275:	48 81 c7 98 00 00 00 	add    $0x98,%rdi
   1227c:	31 c0                	xor    %eax,%eax
   1227e:	e8 00 00 00 00       	callq  12283 <e1000_validate_option.isra.1+0x123>
   12283:	eb d6                	jmp    1225b <e1000_validate_option.isra.1+0xfb>
static int e1000_validate_option(unsigned int *value,
				 const struct e1000_option *opt,
				 struct e1000_adapter *adapter)
{
	if (*value == OPTION_UNSET) {
		*value = opt->def;
   12285:	8b 46 18             	mov    0x18(%rsi),%eax
		return 0;
   12288:	31 db                	xor    %ebx,%ebx
static int e1000_validate_option(unsigned int *value,
				 const struct e1000_option *opt,
				 struct e1000_adapter *adapter)
{
	if (*value == OPTION_UNSET) {
		*value = opt->def;
   1228a:	89 07                	mov    %eax,(%rdi)

	e_dev_info("Invalid %s value specified (%i) %s\n",
	       opt->name, *value, opt->err);
	*value = opt->def;
	return -1;
}
   1228c:	89 d8                	mov    %ebx,%eax
   1228e:	5b                   	pop    %rbx
   1228f:	41 5c                	pop    %r12
   12291:	5d                   	pop    %rbp
   12292:	c3                   	retq   
		const struct e1000_opt_list *ent;

		for (i = 0; i < opt->arg.l.nr; i++) {
			ent = &opt->arg.l.p[i];
			if (*value == ent->i) {
				if (ent->str[0] != '\0')
   12293:	49 8b 40 08          	mov    0x8(%r8),%rax
					e_dev_info("%s\n", ent->str);
				return 0;
   12297:	31 db                	xor    %ebx,%ebx
		const struct e1000_opt_list *ent;

		for (i = 0; i < opt->arg.l.nr; i++) {
			ent = &opt->arg.l.p[i];
			if (*value == ent->i) {
				if (ent->str[0] != '\0')
   12299:	80 38 00             	cmpb   $0x0,(%rax)
   1229c:	74 bd                	je     1225b <e1000_validate_option.isra.1+0xfb>
					e_dev_info("%s\n", ent->str);
   1229e:	48 8b 3a             	mov    (%rdx),%rdi
   122a1:	48 c7 c6 00 00 00 00 	mov    $0x0,%rsi
   122a8:	48 89 c2             	mov    %rax,%rdx
   122ab:	31 c0                	xor    %eax,%eax
   122ad:	48 81 c7 98 00 00 00 	add    $0x98,%rdi
   122b4:	e8 00 00 00 00       	callq  122b9 <e1000_validate_option.isra.1+0x159>
   122b9:	eb a0                	jmp    1225b <e1000_validate_option.isra.1+0xfb>
   122bb:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)

00000000000122c0 <e1000_check_copper_options>:
 * @adapter: board private structure
 *
 * Handles speed and duplex options on copper adapters
 **/
static void e1000_check_copper_options(struct e1000_adapter *adapter)
{
   122c0:	e8 00 00 00 00       	callq  122c5 <e1000_check_copper_options+0x5>
   122c5:	55                   	push   %rbp
   122c6:	48 89 e5             	mov    %rsp,%rbp
   122c9:	41 54                	push   %r12
   122cb:	53                   	push   %rbx
   122cc:	48 89 fb             	mov    %rdi,%rbx
   122cf:	48 83 ec 40          	sub    $0x40,%rsp
	struct e1000_option opt;
	unsigned int speed, dplx, an;
	int bd = adapter->bd_number;
   122d3:	44 8b a7 04 02 00 00 	mov    0x204(%rdi),%r12d
			.def  = 0,
			.arg  = { .l = { .nr = ARRAY_SIZE(speed_list),
					 .p = speed_list }}
		};

		if (num_Speed > bd) {
   122da:	44 3b 25 00 00 00 00 	cmp    0x0(%rip),%r12d        # 122e1 <e1000_check_copper_options+0x21>
			{          0, "" },
			{   SPEED_10, "" },
			{  SPEED_100, "" },
			{ SPEED_1000, "" }};

		opt = (struct e1000_option) {
   122e1:	c7 45 c0 02 00 00 00 	movl   $0x2,-0x40(%rbp)
   122e8:	48 c7 45 c8 00 00 00 	movq   $0x0,-0x38(%rbp)
   122ef:	00 
   122f0:	48 c7 45 d0 00 00 00 	movq   $0x0,-0x30(%rbp)
   122f7:	00 
   122f8:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%rbp)
   122ff:	c7 45 e0 04 00 00 00 	movl   $0x4,-0x20(%rbp)
   12306:	48 c7 45 e8 00 00 00 	movq   $0x0,-0x18(%rbp)
   1230d:	00 
			.def  = 0,
			.arg  = { .l = { .nr = ARRAY_SIZE(speed_list),
					 .p = speed_list }}
		};

		if (num_Speed > bd) {
   1230e:	0f 82 ce 01 00 00    	jb     124e2 <e1000_check_copper_options+0x222>
			speed = Speed[bd];
			e1000_validate_option(&speed, &opt, adapter);
		} else {
			speed = opt.def;
   12314:	c7 45 b4 00 00 00 00 	movl   $0x0,-0x4c(%rbp)
			.def  = 0,
			.arg  = { .l = { .nr = ARRAY_SIZE(dplx_list),
					 .p = dplx_list }}
		};

		if (num_Duplex > bd) {
   1231b:	44 3b 25 00 00 00 00 	cmp    0x0(%rip),%r12d        # 12322 <e1000_check_copper_options+0x62>
		static const struct e1000_opt_list dplx_list[] = {
			{           0, "" },
			{ HALF_DUPLEX, "" },
			{ FULL_DUPLEX, "" }};

		opt = (struct e1000_option) {
   12322:	c7 45 c0 02 00 00 00 	movl   $0x2,-0x40(%rbp)
   12329:	48 c7 45 c8 00 00 00 	movq   $0x0,-0x38(%rbp)
   12330:	00 
   12331:	48 c7 45 d0 00 00 00 	movq   $0x0,-0x30(%rbp)
   12338:	00 
   12339:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%rbp)
   12340:	c7 45 e0 03 00 00 00 	movl   $0x3,-0x20(%rbp)
   12347:	48 c7 45 e8 00 00 00 	movq   $0x0,-0x18(%rbp)
   1234e:	00 
			.def  = 0,
			.arg  = { .l = { .nr = ARRAY_SIZE(dplx_list),
					 .p = dplx_list }}
		};

		if (num_Duplex > bd) {
   1234f:	0f 82 67 01 00 00    	jb     124bc <e1000_check_copper_options+0x1fc>
			dplx = Duplex[bd];
			e1000_validate_option(&dplx, &opt, adapter);
		} else {
			dplx = opt.def;
   12355:	c7 45 b8 00 00 00 00 	movl   $0x0,-0x48(%rbp)
		}
	}

	if ((num_AutoNeg > bd) && (speed != 0 || dplx != 0)) {
   1235c:	44 3b 25 00 00 00 00 	cmp    0x0(%rip),%r12d        # 12363 <e1000_check_copper_options+0xa3>
   12363:	73 3c                	jae    123a1 <e1000_check_copper_options+0xe1>
   12365:	8b 45 b4             	mov    -0x4c(%rbp),%eax
   12368:	85 c0                	test   %eax,%eax
   1236a:	75 0b                	jne    12377 <e1000_check_copper_options+0xb7>
   1236c:	8b 45 b8             	mov    -0x48(%rbp),%eax
   1236f:	85 c0                	test   %eax,%eax
   12371:	0f 84 91 01 00 00    	je     12508 <e1000_check_copper_options+0x248>
		e_dev_info("AutoNeg specified along with Speed or Duplex, "
   12377:	48 8b 83 b8 03 00 00 	mov    0x3b8(%rbx),%rax
   1237e:	48 c7 c6 00 00 00 00 	mov    $0x0,%rsi
   12385:	48 8d b8 98 00 00 00 	lea    0x98(%rax),%rdi
   1238c:	31 c0                	xor    %eax,%eax
   1238e:	e8 00 00 00 00       	callq  12393 <e1000_check_copper_options+0xd3>
			   "parameter ignored\n");
		adapter->hw.autoneg_advertised = AUTONEG_ADV_DEFAULT;
   12393:	b8 2f 00 00 00       	mov    $0x2f,%eax
   12398:	66 89 83 92 04 00 00 	mov    %ax,0x492(%rbx)
   1239f:	eb 40                	jmp    123e1 <e1000_check_copper_options+0x121>
			 { 0x2c, AA "1000/FD, 100/FD, 100/HD" },
			 { 0x2d, AA "1000/FD, 100/FD, 100/HD, 10/HD" },
			 { 0x2e, AA "1000/FD, 100/FD, 100/HD, 10/FD" },
			 { 0x2f, AA "1000/FD, 100/FD, 100/HD, 10/FD, 10/HD" }};

		opt = (struct e1000_option) {
   123a1:	c7 45 c0 02 00 00 00 	movl   $0x2,-0x40(%rbp)
   123a8:	48 c7 45 c8 00 00 00 	movq   $0x0,-0x38(%rbp)
   123af:	00 

		if (num_AutoNeg > bd) {
			an = AutoNeg[bd];
			e1000_validate_option(&an, &opt, adapter);
		} else {
			an = opt.def;
   123b0:	b8 2f 00 00 00       	mov    $0x2f,%eax
			 { 0x2c, AA "1000/FD, 100/FD, 100/HD" },
			 { 0x2d, AA "1000/FD, 100/FD, 100/HD, 10/HD" },
			 { 0x2e, AA "1000/FD, 100/FD, 100/HD, 10/FD" },
			 { 0x2f, AA "1000/FD, 100/FD, 100/HD, 10/FD, 10/HD" }};

		opt = (struct e1000_option) {
   123b5:	48 c7 45 d0 00 00 00 	movq   $0x0,-0x30(%rbp)
   123bc:	00 
   123bd:	c7 45 d8 2f 00 00 00 	movl   $0x2f,-0x28(%rbp)
   123c4:	c7 45 e0 1f 00 00 00 	movl   $0x1f,-0x20(%rbp)
   123cb:	48 c7 45 e8 00 00 00 	movq   $0x0,-0x18(%rbp)
   123d2:	00 

		if (num_AutoNeg > bd) {
			an = AutoNeg[bd];
			e1000_validate_option(&an, &opt, adapter);
		} else {
			an = opt.def;
   123d3:	c7 45 bc 2f 00 00 00 	movl   $0x2f,-0x44(%rbp)
		}
		adapter->hw.autoneg_advertised = an;
   123da:	66 89 83 92 04 00 00 	mov    %ax,0x492(%rbx)
	}

	switch (speed + dplx) {
   123e1:	8b 55 b4             	mov    -0x4c(%rbp),%edx
   123e4:	8b 4d b8             	mov    -0x48(%rbp),%ecx
   123e7:	8d 04 11             	lea    (%rcx,%rdx,1),%eax
   123ea:	83 f8 0c             	cmp    $0xc,%eax
   123ed:	0f 84 da 02 00 00    	je     126cd <e1000_check_copper_options+0x40d>
   123f3:	76 34                	jbe    12429 <e1000_check_copper_options+0x169>
   123f5:	83 f8 66             	cmp    $0x66,%eax
   123f8:	0f 84 b4 01 00 00    	je     125b2 <e1000_check_copper_options+0x2f2>
   123fe:	66 90                	xchg   %ax,%ax
   12400:	0f 86 76 02 00 00    	jbe    1267c <e1000_check_copper_options+0x3bc>
   12406:	3d e9 03 00 00       	cmp    $0x3e9,%eax
   1240b:	0f 84 e0 01 00 00    	je     125f1 <e1000_check_copper_options+0x331>
   12411:	3d ea 03 00 00       	cmp    $0x3ea,%eax
   12416:	0f 84 f1 01 00 00    	je     1260d <e1000_check_copper_options+0x34d>
   1241c:	3d e8 03 00 00       	cmp    $0x3e8,%eax
   12421:	0f 84 ee 03 00 00    	je     12815 <e1000_check_copper_options+0x555>
			   "only\n");
		adapter->hw.autoneg = adapter->fc_autoneg = 1;
		adapter->hw.autoneg_advertised = ADVERTISE_1000_FULL;
		break;
	default:
		BUG();
   12427:	0f 0b                	ud2    
			an = opt.def;
		}
		adapter->hw.autoneg_advertised = an;
	}

	switch (speed + dplx) {
   12429:	83 f8 02             	cmp    $0x2,%eax
   1242c:	0f 84 31 03 00 00    	je     12763 <e1000_check_copper_options+0x4a3>
   12432:	0f 87 27 01 00 00    	ja     1255f <e1000_check_copper_options+0x29f>
   12438:	85 c0                	test   %eax,%eax
   1243a:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)
   12440:	0f 84 f0 03 00 00    	je     12836 <e1000_check_copper_options+0x576>
   12446:	83 f8 01             	cmp    $0x1,%eax
   12449:	75 dc                	jne    12427 <e1000_check_copper_options+0x167>
		if ((num_Speed > bd) && (speed != 0 || dplx != 0))
			e_dev_info("Speed and duplex autonegotiation "
				   "enabled\n");
		break;
	case HALF_DUPLEX:
		e_dev_info("Half Duplex specified without Speed\n");
   1244b:	48 8b 83 b8 03 00 00 	mov    0x3b8(%rbx),%rax
   12452:	48 c7 c6 00 00 00 00 	mov    $0x0,%rsi
   12459:	48 8d b8 98 00 00 00 	lea    0x98(%rax),%rdi
   12460:	31 c0                	xor    %eax,%eax
   12462:	e8 00 00 00 00       	callq  12467 <e1000_check_copper_options+0x1a7>
		e_dev_info("Using Autonegotiation at Half Duplex only\n");
   12467:	48 8b 83 b8 03 00 00 	mov    0x3b8(%rbx),%rax
   1246e:	48 c7 c6 00 00 00 00 	mov    $0x0,%rsi
   12475:	48 8d b8 98 00 00 00 	lea    0x98(%rax),%rdi
   1247c:	31 c0                	xor    %eax,%eax
   1247e:	e8 00 00 00 00       	callq  12483 <e1000_check_copper_options+0x1c3>
		adapter->hw.autoneg = adapter->fc_autoneg = 1;
		adapter->hw.autoneg_advertised = ADVERTISE_10_HALF |
   12483:	41 bb 05 00 00 00    	mov    $0x5,%r11d
				   "enabled\n");
		break;
	case HALF_DUPLEX:
		e_dev_info("Half Duplex specified without Speed\n");
		e_dev_info("Using Autonegotiation at Half Duplex only\n");
		adapter->hw.autoneg = adapter->fc_autoneg = 1;
   12489:	c6 83 3c 02 00 00 01 	movb   $0x1,0x23c(%rbx)
   12490:	c6 83 af 04 00 00 01 	movb   $0x1,0x4af(%rbx)
		adapter->hw.autoneg_advertised = ADVERTISE_10_HALF |
   12497:	66 44 89 9b 92 04 00 	mov    %r11w,0x492(%rbx)
   1249e:	00 
	default:
		BUG();
	}

	/* Speed, AutoNeg and MDI/MDI-X must all play nice */
	if (e1000_validate_mdi_setting(&(adapter->hw)) < 0) {
   1249f:	48 8d bb c0 03 00 00 	lea    0x3c0(%rbx),%rdi
   124a6:	e8 00 00 00 00       	callq  124ab <e1000_check_copper_options+0x1eb>
   124ab:	85 c0                	test   %eax,%eax
   124ad:	0f 88 a4 01 00 00    	js     12657 <e1000_check_copper_options+0x397>
		e_dev_info("Speed, AutoNeg and MDI-X specs are incompatible. "
			   "Setting MDI-X to a compatible value.\n");
	}
}
   124b3:	48 83 c4 40          	add    $0x40,%rsp
   124b7:	5b                   	pop    %rbx
   124b8:	41 5c                	pop    %r12
   124ba:	5d                   	pop    %rbp
   124bb:	c3                   	retq   
			.arg  = { .l = { .nr = ARRAY_SIZE(dplx_list),
					 .p = dplx_list }}
		};

		if (num_Duplex > bd) {
			dplx = Duplex[bd];
   124bc:	49 63 c4             	movslq %r12d,%rax
   124bf:	48 8d 93 b8 03 00 00 	lea    0x3b8(%rbx),%rdx
			e1000_validate_option(&dplx, &opt, adapter);
   124c6:	48 8d 75 c0          	lea    -0x40(%rbp),%rsi
			.arg  = { .l = { .nr = ARRAY_SIZE(dplx_list),
					 .p = dplx_list }}
		};

		if (num_Duplex > bd) {
			dplx = Duplex[bd];
   124ca:	8b 04 85 00 00 00 00 	mov    0x0(,%rax,4),%eax
			e1000_validate_option(&dplx, &opt, adapter);
   124d1:	48 8d 7d b8          	lea    -0x48(%rbp),%rdi
			.arg  = { .l = { .nr = ARRAY_SIZE(dplx_list),
					 .p = dplx_list }}
		};

		if (num_Duplex > bd) {
			dplx = Duplex[bd];
   124d5:	89 45 b8             	mov    %eax,-0x48(%rbp)
			e1000_validate_option(&dplx, &opt, adapter);
   124d8:	e8 83 fc ff ff       	callq  12160 <e1000_validate_option.isra.1>
   124dd:	e9 7a fe ff ff       	jmpq   1235c <e1000_check_copper_options+0x9c>
			.arg  = { .l = { .nr = ARRAY_SIZE(speed_list),
					 .p = speed_list }}
		};

		if (num_Speed > bd) {
			speed = Speed[bd];
   124e2:	49 63 c4             	movslq %r12d,%rax
   124e5:	48 8d 97 b8 03 00 00 	lea    0x3b8(%rdi),%rdx
			e1000_validate_option(&speed, &opt, adapter);
   124ec:	48 8d 75 c0          	lea    -0x40(%rbp),%rsi
			.arg  = { .l = { .nr = ARRAY_SIZE(speed_list),
					 .p = speed_list }}
		};

		if (num_Speed > bd) {
			speed = Speed[bd];
   124f0:	8b 04 85 00 00 00 00 	mov    0x0(,%rax,4),%eax
			e1000_validate_option(&speed, &opt, adapter);
   124f7:	48 8d 7d b4          	lea    -0x4c(%rbp),%rdi
			.arg  = { .l = { .nr = ARRAY_SIZE(speed_list),
					 .p = speed_list }}
		};

		if (num_Speed > bd) {
			speed = Speed[bd];
   124fb:	89 45 b4             	mov    %eax,-0x4c(%rbp)
			e1000_validate_option(&speed, &opt, adapter);
   124fe:	e8 5d fc ff ff       	callq  12160 <e1000_validate_option.isra.1>
   12503:	e9 13 fe ff ff       	jmpq   1231b <e1000_check_copper_options+0x5b>
			.arg  = { .l = { .nr = ARRAY_SIZE(an_list),
					 .p = an_list }}
		};

		if (num_AutoNeg > bd) {
			an = AutoNeg[bd];
   12508:	49 63 c4             	movslq %r12d,%rax
   1250b:	48 8d 93 b8 03 00 00 	lea    0x3b8(%rbx),%rdx
			e1000_validate_option(&an, &opt, adapter);
   12512:	48 8d 75 c0          	lea    -0x40(%rbp),%rsi
			.arg  = { .l = { .nr = ARRAY_SIZE(an_list),
					 .p = an_list }}
		};

		if (num_AutoNeg > bd) {
			an = AutoNeg[bd];
   12516:	8b 04 85 00 00 00 00 	mov    0x0(,%rax,4),%eax
			e1000_validate_option(&an, &opt, adapter);
   1251d:	48 8d 7d bc          	lea    -0x44(%rbp),%rdi
			 { 0x2c, AA "1000/FD, 100/FD, 100/HD" },
			 { 0x2d, AA "1000/FD, 100/FD, 100/HD, 10/HD" },
			 { 0x2e, AA "1000/FD, 100/FD, 100/HD, 10/FD" },
			 { 0x2f, AA "1000/FD, 100/FD, 100/HD, 10/FD, 10/HD" }};

		opt = (struct e1000_option) {
   12521:	c7 45 c0 02 00 00 00 	movl   $0x2,-0x40(%rbp)
   12528:	48 c7 45 c8 00 00 00 	movq   $0x0,-0x38(%rbp)
   1252f:	00 
   12530:	48 c7 45 d0 00 00 00 	movq   $0x0,-0x30(%rbp)
   12537:	00 
   12538:	c7 45 d8 2f 00 00 00 	movl   $0x2f,-0x28(%rbp)
   1253f:	c7 45 e0 1f 00 00 00 	movl   $0x1f,-0x20(%rbp)
   12546:	48 c7 45 e8 00 00 00 	movq   $0x0,-0x18(%rbp)
   1254d:	00 
			.arg  = { .l = { .nr = ARRAY_SIZE(an_list),
					 .p = an_list }}
		};

		if (num_AutoNeg > bd) {
			an = AutoNeg[bd];
   1254e:	89 45 bc             	mov    %eax,-0x44(%rbp)
			e1000_validate_option(&an, &opt, adapter);
   12551:	e8 0a fc ff ff       	callq  12160 <e1000_validate_option.isra.1>
   12556:	0f b7 45 bc          	movzwl -0x44(%rbp),%eax
   1255a:	e9 7b fe ff ff       	jmpq   123da <e1000_check_copper_options+0x11a>
			an = opt.def;
		}
		adapter->hw.autoneg_advertised = an;
	}

	switch (speed + dplx) {
   1255f:	83 f8 0a             	cmp    $0xa,%eax
   12562:	0f 84 54 02 00 00    	je     127bc <e1000_check_copper_options+0x4fc>
   12568:	83 f8 0b             	cmp    $0xb,%eax
   1256b:	0f 85 b6 fe ff ff    	jne    12427 <e1000_check_copper_options+0x167>
		adapter->hw.autoneg = adapter->fc_autoneg = 1;
		adapter->hw.autoneg_advertised = ADVERTISE_10_HALF |
						 ADVERTISE_10_FULL;
		break;
	case SPEED_10 + HALF_DUPLEX:
		e_dev_info("Forcing to 10 Mbps Half Duplex\n");
   12571:	48 8b 83 b8 03 00 00 	mov    0x3b8(%rbx),%rax
   12578:	48 c7 c6 00 00 00 00 	mov    $0x0,%rsi
   1257f:	48 8d b8 98 00 00 00 	lea    0x98(%rax),%rdi
   12586:	31 c0                	xor    %eax,%eax
   12588:	e8 00 00 00 00       	callq  1258d <e1000_check_copper_options+0x2cd>
		adapter->hw.autoneg = adapter->fc_autoneg = 0;
		adapter->hw.forced_speed_duplex = e1000_10_half;
		adapter->hw.autoneg_advertised = 0;
   1258d:	45 31 c0             	xor    %r8d,%r8d
		adapter->hw.autoneg_advertised = ADVERTISE_10_HALF |
						 ADVERTISE_10_FULL;
		break;
	case SPEED_10 + HALF_DUPLEX:
		e_dev_info("Forcing to 10 Mbps Half Duplex\n");
		adapter->hw.autoneg = adapter->fc_autoneg = 0;
   12590:	c6 83 3c 02 00 00 00 	movb   $0x0,0x23c(%rbx)
   12597:	c6 83 af 04 00 00 00 	movb   $0x0,0x4af(%rbx)
		adapter->hw.forced_speed_duplex = e1000_10_half;
   1259e:	c6 83 b1 04 00 00 00 	movb   $0x0,0x4b1(%rbx)
		adapter->hw.autoneg_advertised = 0;
   125a5:	66 44 89 83 92 04 00 	mov    %r8w,0x492(%rbx)
   125ac:	00 
		break;
   125ad:	e9 ed fe ff ff       	jmpq   1249f <e1000_check_copper_options+0x1df>
		adapter->hw.autoneg = adapter->fc_autoneg = 0;
		adapter->hw.forced_speed_duplex = e1000_100_half;
		adapter->hw.autoneg_advertised = 0;
		break;
	case SPEED_100 + FULL_DUPLEX:
		e_dev_info("Forcing to 100 Mbps Full Duplex\n");
   125b2:	48 8b 83 b8 03 00 00 	mov    0x3b8(%rbx),%rax
   125b9:	48 c7 c6 00 00 00 00 	mov    $0x0,%rsi
   125c0:	48 8d b8 98 00 00 00 	lea    0x98(%rax),%rdi
   125c7:	31 c0                	xor    %eax,%eax
   125c9:	e8 00 00 00 00       	callq  125ce <e1000_check_copper_options+0x30e>
		adapter->hw.autoneg = adapter->fc_autoneg = 0;
		adapter->hw.forced_speed_duplex = e1000_100_full;
		adapter->hw.autoneg_advertised = 0;
   125ce:	31 d2                	xor    %edx,%edx
		adapter->hw.forced_speed_duplex = e1000_100_half;
		adapter->hw.autoneg_advertised = 0;
		break;
	case SPEED_100 + FULL_DUPLEX:
		e_dev_info("Forcing to 100 Mbps Full Duplex\n");
		adapter->hw.autoneg = adapter->fc_autoneg = 0;
   125d0:	c6 83 3c 02 00 00 00 	movb   $0x0,0x23c(%rbx)
   125d7:	c6 83 af 04 00 00 00 	movb   $0x0,0x4af(%rbx)
		adapter->hw.forced_speed_duplex = e1000_100_full;
   125de:	c6 83 b1 04 00 00 03 	movb   $0x3,0x4b1(%rbx)
		adapter->hw.autoneg_advertised = 0;
   125e5:	66 89 93 92 04 00 00 	mov    %dx,0x492(%rbx)
		break;
   125ec:	e9 ae fe ff ff       	jmpq   1249f <e1000_check_copper_options+0x1df>
	case SPEED_1000:
		e_dev_info("1000 Mbps Speed specified without Duplex\n");
		goto full_duplex_only;
	case SPEED_1000 + HALF_DUPLEX:
		e_dev_info("Half Duplex is not supported at 1000 Mbps\n");
   125f1:	48 8b 83 b8 03 00 00 	mov    0x3b8(%rbx),%rax
   125f8:	48 c7 c6 00 00 00 00 	mov    $0x0,%rsi
   125ff:	48 8d b8 98 00 00 00 	lea    0x98(%rax),%rdi
   12606:	31 c0                	xor    %eax,%eax
   12608:	e8 00 00 00 00       	callq  1260d <e1000_check_copper_options+0x34d>
		/* fall through */
	case SPEED_1000 + FULL_DUPLEX:
full_duplex_only:
		e_dev_info("Using Autonegotiation at 1000 Mbps Full Duplex "
   1260d:	48 8b 83 b8 03 00 00 	mov    0x3b8(%rbx),%rax
   12614:	48 c7 c6 00 00 00 00 	mov    $0x0,%rsi
   1261b:	48 8d b8 98 00 00 00 	lea    0x98(%rax),%rdi
   12622:	31 c0                	xor    %eax,%eax
   12624:	e8 00 00 00 00       	callq  12629 <e1000_check_copper_options+0x369>
			   "only\n");
		adapter->hw.autoneg = adapter->fc_autoneg = 1;
		adapter->hw.autoneg_advertised = ADVERTISE_1000_FULL;
   12629:	b8 20 00 00 00       	mov    $0x20,%eax
	default:
		BUG();
	}

	/* Speed, AutoNeg and MDI/MDI-X must all play nice */
	if (e1000_validate_mdi_setting(&(adapter->hw)) < 0) {
   1262e:	48 8d bb c0 03 00 00 	lea    0x3c0(%rbx),%rdi
		/* fall through */
	case SPEED_1000 + FULL_DUPLEX:
full_duplex_only:
		e_dev_info("Using Autonegotiation at 1000 Mbps Full Duplex "
			   "only\n");
		adapter->hw.autoneg = adapter->fc_autoneg = 1;
   12635:	c6 83 3c 02 00 00 01 	movb   $0x1,0x23c(%rbx)
   1263c:	c6 83 af 04 00 00 01 	movb   $0x1,0x4af(%rbx)
		adapter->hw.autoneg_advertised = ADVERTISE_1000_FULL;
   12643:	66 89 83 92 04 00 00 	mov    %ax,0x492(%rbx)
	default:
		BUG();
	}

	/* Speed, AutoNeg and MDI/MDI-X must all play nice */
	if (e1000_validate_mdi_setting(&(adapter->hw)) < 0) {
   1264a:	e8 00 00 00 00       	callq  1264f <e1000_check_copper_options+0x38f>
   1264f:	85 c0                	test   %eax,%eax
   12651:	0f 89 5c fe ff ff    	jns    124b3 <e1000_check_copper_options+0x1f3>
		e_dev_info("Speed, AutoNeg and MDI-X specs are incompatible. "
   12657:	48 8b bb b8 03 00 00 	mov    0x3b8(%rbx),%rdi
   1265e:	48 c7 c6 00 00 00 00 	mov    $0x0,%rsi
   12665:	31 c0                	xor    %eax,%eax
   12667:	48 81 c7 98 00 00 00 	add    $0x98,%rdi
   1266e:	e8 00 00 00 00       	callq  12673 <e1000_check_copper_options+0x3b3>
			   "Setting MDI-X to a compatible value.\n");
	}
}
   12673:	48 83 c4 40          	add    $0x40,%rsp
   12677:	5b                   	pop    %rbx
   12678:	41 5c                	pop    %r12
   1267a:	5d                   	pop    %rbp
   1267b:	c3                   	retq   
			an = opt.def;
		}
		adapter->hw.autoneg_advertised = an;
	}

	switch (speed + dplx) {
   1267c:	83 f8 64             	cmp    $0x64,%eax
   1267f:	0f 84 87 00 00 00    	je     1270c <e1000_check_copper_options+0x44c>
   12685:	83 f8 65             	cmp    $0x65,%eax
   12688:	0f 85 99 fd ff ff    	jne    12427 <e1000_check_copper_options+0x167>
		adapter->hw.autoneg = adapter->fc_autoneg = 1;
		adapter->hw.autoneg_advertised = ADVERTISE_100_HALF |
						 ADVERTISE_100_FULL;
		break;
	case SPEED_100 + HALF_DUPLEX:
		e_dev_info("Forcing to 100 Mbps Half Duplex\n");
   1268e:	48 8b 83 b8 03 00 00 	mov    0x3b8(%rbx),%rax
   12695:	48 c7 c6 00 00 00 00 	mov    $0x0,%rsi
   1269c:	48 8d b8 98 00 00 00 	lea    0x98(%rax),%rdi
   126a3:	31 c0                	xor    %eax,%eax
   126a5:	e8 00 00 00 00       	callq  126aa <e1000_check_copper_options+0x3ea>
		adapter->hw.autoneg = adapter->fc_autoneg = 0;
		adapter->hw.forced_speed_duplex = e1000_100_half;
		adapter->hw.autoneg_advertised = 0;
   126aa:	31 c9                	xor    %ecx,%ecx
		adapter->hw.autoneg_advertised = ADVERTISE_100_HALF |
						 ADVERTISE_100_FULL;
		break;
	case SPEED_100 + HALF_DUPLEX:
		e_dev_info("Forcing to 100 Mbps Half Duplex\n");
		adapter->hw.autoneg = adapter->fc_autoneg = 0;
   126ac:	c6 83 3c 02 00 00 00 	movb   $0x0,0x23c(%rbx)
   126b3:	c6 83 af 04 00 00 00 	movb   $0x0,0x4af(%rbx)
		adapter->hw.forced_speed_duplex = e1000_100_half;
   126ba:	c6 83 b1 04 00 00 02 	movb   $0x2,0x4b1(%rbx)
		adapter->hw.autoneg_advertised = 0;
   126c1:	66 89 8b 92 04 00 00 	mov    %cx,0x492(%rbx)
		break;
   126c8:	e9 d2 fd ff ff       	jmpq   1249f <e1000_check_copper_options+0x1df>
		adapter->hw.autoneg = adapter->fc_autoneg = 0;
		adapter->hw.forced_speed_duplex = e1000_10_half;
		adapter->hw.autoneg_advertised = 0;
		break;
	case SPEED_10 + FULL_DUPLEX:
		e_dev_info("Forcing to 10 Mbps Full Duplex\n");
   126cd:	48 8b 83 b8 03 00 00 	mov    0x3b8(%rbx),%rax
   126d4:	48 c7 c6 00 00 00 00 	mov    $0x0,%rsi
   126db:	48 8d b8 98 00 00 00 	lea    0x98(%rax),%rdi
   126e2:	31 c0                	xor    %eax,%eax
   126e4:	e8 00 00 00 00       	callq  126e9 <e1000_check_copper_options+0x429>
		adapter->hw.autoneg = adapter->fc_autoneg = 0;
		adapter->hw.forced_speed_duplex = e1000_10_full;
		adapter->hw.autoneg_advertised = 0;
   126e9:	31 ff                	xor    %edi,%edi
		adapter->hw.forced_speed_duplex = e1000_10_half;
		adapter->hw.autoneg_advertised = 0;
		break;
	case SPEED_10 + FULL_DUPLEX:
		e_dev_info("Forcing to 10 Mbps Full Duplex\n");
		adapter->hw.autoneg = adapter->fc_autoneg = 0;
   126eb:	c6 83 3c 02 00 00 00 	movb   $0x0,0x23c(%rbx)
   126f2:	c6 83 af 04 00 00 00 	movb   $0x0,0x4af(%rbx)
		adapter->hw.forced_speed_duplex = e1000_10_full;
   126f9:	c6 83 b1 04 00 00 01 	movb   $0x1,0x4b1(%rbx)
		adapter->hw.autoneg_advertised = 0;
   12700:	66 89 bb 92 04 00 00 	mov    %di,0x492(%rbx)
		break;
   12707:	e9 93 fd ff ff       	jmpq   1249f <e1000_check_copper_options+0x1df>
	case SPEED_100:
		e_dev_info("100 Mbps Speed specified without Duplex\n");
   1270c:	48 8b 83 b8 03 00 00 	mov    0x3b8(%rbx),%rax
   12713:	48 c7 c6 00 00 00 00 	mov    $0x0,%rsi
   1271a:	48 8d b8 98 00 00 00 	lea    0x98(%rax),%rdi
   12721:	31 c0                	xor    %eax,%eax
   12723:	e8 00 00 00 00       	callq  12728 <e1000_check_copper_options+0x468>
		e_dev_info("Using Autonegotiation at 100 Mbps only\n");
   12728:	48 8b 83 b8 03 00 00 	mov    0x3b8(%rbx),%rax
   1272f:	48 c7 c6 00 00 00 00 	mov    $0x0,%rsi
   12736:	48 8d b8 98 00 00 00 	lea    0x98(%rax),%rdi
   1273d:	31 c0                	xor    %eax,%eax
   1273f:	e8 00 00 00 00       	callq  12744 <e1000_check_copper_options+0x484>
		adapter->hw.autoneg = adapter->fc_autoneg = 1;
		adapter->hw.autoneg_advertised = ADVERTISE_100_HALF |
   12744:	be 0c 00 00 00       	mov    $0xc,%esi
		adapter->hw.autoneg_advertised = 0;
		break;
	case SPEED_100:
		e_dev_info("100 Mbps Speed specified without Duplex\n");
		e_dev_info("Using Autonegotiation at 100 Mbps only\n");
		adapter->hw.autoneg = adapter->fc_autoneg = 1;
   12749:	c6 83 3c 02 00 00 01 	movb   $0x1,0x23c(%rbx)
   12750:	c6 83 af 04 00 00 01 	movb   $0x1,0x4af(%rbx)
		adapter->hw.autoneg_advertised = ADVERTISE_100_HALF |
   12757:	66 89 b3 92 04 00 00 	mov    %si,0x492(%rbx)
						 ADVERTISE_100_FULL;
		break;
   1275e:	e9 3c fd ff ff       	jmpq   1249f <e1000_check_copper_options+0x1df>
		adapter->hw.autoneg = adapter->fc_autoneg = 1;
		adapter->hw.autoneg_advertised = ADVERTISE_10_HALF |
						 ADVERTISE_100_HALF;
		break;
	case FULL_DUPLEX:
		e_dev_info("Full Duplex specified without Speed\n");
   12763:	48 8b 83 b8 03 00 00 	mov    0x3b8(%rbx),%rax
   1276a:	48 c7 c6 00 00 00 00 	mov    $0x0,%rsi
   12771:	48 8d b8 98 00 00 00 	lea    0x98(%rax),%rdi
   12778:	31 c0                	xor    %eax,%eax
   1277a:	e8 00 00 00 00       	callq  1277f <e1000_check_copper_options+0x4bf>
		e_dev_info("Using Autonegotiation at Full Duplex only\n");
   1277f:	48 8b 83 b8 03 00 00 	mov    0x3b8(%rbx),%rax
   12786:	48 c7 c6 00 00 00 00 	mov    $0x0,%rsi
   1278d:	48 8d b8 98 00 00 00 	lea    0x98(%rax),%rdi
   12794:	31 c0                	xor    %eax,%eax
   12796:	e8 00 00 00 00       	callq  1279b <e1000_check_copper_options+0x4db>
		adapter->hw.autoneg = adapter->fc_autoneg = 1;
		adapter->hw.autoneg_advertised = ADVERTISE_10_FULL |
   1279b:	41 ba 2a 00 00 00    	mov    $0x2a,%r10d
						 ADVERTISE_100_HALF;
		break;
	case FULL_DUPLEX:
		e_dev_info("Full Duplex specified without Speed\n");
		e_dev_info("Using Autonegotiation at Full Duplex only\n");
		adapter->hw.autoneg = adapter->fc_autoneg = 1;
   127a1:	c6 83 3c 02 00 00 01 	movb   $0x1,0x23c(%rbx)
   127a8:	c6 83 af 04 00 00 01 	movb   $0x1,0x4af(%rbx)
		adapter->hw.autoneg_advertised = ADVERTISE_10_FULL |
   127af:	66 44 89 93 92 04 00 	mov    %r10w,0x492(%rbx)
   127b6:	00 
						 ADVERTISE_100_FULL |
						 ADVERTISE_1000_FULL;
		break;
   127b7:	e9 e3 fc ff ff       	jmpq   1249f <e1000_check_copper_options+0x1df>
	case SPEED_10:
		e_dev_info("10 Mbps Speed specified without Duplex\n");
   127bc:	48 8b 83 b8 03 00 00 	mov    0x3b8(%rbx),%rax
   127c3:	48 c7 c6 00 00 00 00 	mov    $0x0,%rsi
   127ca:	48 8d b8 98 00 00 00 	lea    0x98(%rax),%rdi
   127d1:	31 c0                	xor    %eax,%eax
   127d3:	e8 00 00 00 00       	callq  127d8 <e1000_check_copper_options+0x518>
		e_dev_info("Using Autonegotiation at 10 Mbps only\n");
   127d8:	48 8b 83 b8 03 00 00 	mov    0x3b8(%rbx),%rax
   127df:	48 c7 c6 00 00 00 00 	mov    $0x0,%rsi
   127e6:	48 8d b8 98 00 00 00 	lea    0x98(%rax),%rdi
   127ed:	31 c0                	xor    %eax,%eax
   127ef:	e8 00 00 00 00       	callq  127f4 <e1000_check_copper_options+0x534>
		adapter->hw.autoneg = adapter->fc_autoneg = 1;
		adapter->hw.autoneg_advertised = ADVERTISE_10_HALF |
   127f4:	41 b9 03 00 00 00    	mov    $0x3,%r9d
						 ADVERTISE_1000_FULL;
		break;
	case SPEED_10:
		e_dev_info("10 Mbps Speed specified without Duplex\n");
		e_dev_info("Using Autonegotiation at 10 Mbps only\n");
		adapter->hw.autoneg = adapter->fc_autoneg = 1;
   127fa:	c6 83 3c 02 00 00 01 	movb   $0x1,0x23c(%rbx)
   12801:	c6 83 af 04 00 00 01 	movb   $0x1,0x4af(%rbx)
		adapter->hw.autoneg_advertised = ADVERTISE_10_HALF |
   12808:	66 44 89 8b 92 04 00 	mov    %r9w,0x492(%rbx)
   1280f:	00 
						 ADVERTISE_10_FULL;
		break;
   12810:	e9 8a fc ff ff       	jmpq   1249f <e1000_check_copper_options+0x1df>
		adapter->hw.autoneg = adapter->fc_autoneg = 0;
		adapter->hw.forced_speed_duplex = e1000_100_full;
		adapter->hw.autoneg_advertised = 0;
		break;
	case SPEED_1000:
		e_dev_info("1000 Mbps Speed specified without Duplex\n");
   12815:	48 8b 83 b8 03 00 00 	mov    0x3b8(%rbx),%rax
   1281c:	48 c7 c6 00 00 00 00 	mov    $0x0,%rsi
   12823:	48 8d b8 98 00 00 00 	lea    0x98(%rax),%rdi
   1282a:	31 c0                	xor    %eax,%eax
   1282c:	e8 00 00 00 00       	callq  12831 <e1000_check_copper_options+0x571>
		goto full_duplex_only;
   12831:	e9 d7 fd ff ff       	jmpq   1260d <e1000_check_copper_options+0x34d>
	}

	switch (speed + dplx) {
	case 0:
		adapter->hw.autoneg = adapter->fc_autoneg = 1;
		if ((num_Speed > bd) && (speed != 0 || dplx != 0))
   12836:	44 3b 25 00 00 00 00 	cmp    0x0(%rip),%r12d        # 1283d <e1000_check_copper_options+0x57d>
		adapter->hw.autoneg_advertised = an;
	}

	switch (speed + dplx) {
	case 0:
		adapter->hw.autoneg = adapter->fc_autoneg = 1;
   1283d:	c6 83 3c 02 00 00 01 	movb   $0x1,0x23c(%rbx)
   12844:	c6 83 af 04 00 00 01 	movb   $0x1,0x4af(%rbx)
		if ((num_Speed > bd) && (speed != 0 || dplx != 0))
   1284b:	0f 83 4e fc ff ff    	jae    1249f <e1000_check_copper_options+0x1df>
   12851:	85 d2                	test   %edx,%edx
   12853:	75 08                	jne    1285d <e1000_check_copper_options+0x59d>
   12855:	85 c9                	test   %ecx,%ecx
   12857:	0f 84 42 fc ff ff    	je     1249f <e1000_check_copper_options+0x1df>
			e_dev_info("Speed and duplex autonegotiation "
   1285d:	48 8b 83 b8 03 00 00 	mov    0x3b8(%rbx),%rax
   12864:	48 c7 c6 00 00 00 00 	mov    $0x0,%rsi
   1286b:	48 8d b8 98 00 00 00 	lea    0x98(%rax),%rdi
   12872:	31 c0                	xor    %eax,%eax
   12874:	e8 00 00 00 00       	callq  12879 <e1000_check_copper_options+0x5b9>
   12879:	e9 21 fc ff ff       	jmpq   1249f <e1000_check_copper_options+0x1df>
   1287e:	66 90                	xchg   %ax,%ax

0000000000012880 <e1000_check_options>:
 * input.  If an invalid value is given, or if no user specified
 * value exists, a default value is used.  The final value is stored
 * in a variable in the adapter structure.
 **/
void e1000_check_options(struct e1000_adapter *adapter)
{
   12880:	e8 00 00 00 00       	callq  12885 <e1000_check_options+0x5>
   12885:	55                   	push   %rbp
   12886:	48 89 e5             	mov    %rsp,%rbp
   12889:	41 56                	push   %r14
   1288b:	41 55                	push   %r13
   1288d:	41 54                	push   %r12
   1288f:	53                   	push   %rbx
   12890:	48 89 fb             	mov    %rdi,%rbx
   12893:	48 83 ec 38          	sub    $0x38,%rsp
	struct e1000_option opt;
	int bd = adapter->bd_number;
   12897:	4c 63 af 04 02 00 00 	movslq 0x204(%rdi),%r13

	if (bd >= E1000_MAX_NIC) {
   1289e:	41 83 fd 1f          	cmp    $0x1f,%r13d
   128a2:	0f 8f e5 05 00 00    	jg     12e8d <e1000_check_options+0x60d>
			.err  = "using default of "
				__MODULE_STRING(E1000_DEFAULT_TXD),
			.def  = E1000_DEFAULT_TXD,
			.arg  = { .r = {
				.min = E1000_MIN_TXD,
				.max = mac_type < e1000_82544 ? E1000_MAX_TXD : E1000_MAX_82544_TXD
   128a8:	83 bb d8 03 00 00 04 	cmpl   $0x4,0x3d8(%rbx)
	{ /* Transmit Descriptor Count */
		struct e1000_tx_ring *tx_ring = adapter->tx_ring;
		int i;
		e1000_mac_type mac_type = adapter->hw.mac_type;

		opt = (struct e1000_option) {
   128af:	4c 8d 65 b0          	lea    -0x50(%rbp),%r12
   128b3:	b9 06 00 00 00       	mov    $0x6,%ecx
		e_dev_warn("Warning: no configuration for board #%i "
			   "using defaults for all values\n", bd);
	}

	{ /* Transmit Descriptor Count */
		struct e1000_tx_ring *tx_ring = adapter->tx_ring;
   128b8:	4c 8b b3 40 02 00 00 	mov    0x240(%rbx),%r14
		int i;
		e1000_mac_type mac_type = adapter->hw.mac_type;

		opt = (struct e1000_option) {
   128bf:	4c 89 e7             	mov    %r12,%rdi
			.err  = "using default of "
				__MODULE_STRING(E1000_DEFAULT_TXD),
			.def  = E1000_DEFAULT_TXD,
			.arg  = { .r = {
				.min = E1000_MIN_TXD,
				.max = mac_type < e1000_82544 ? E1000_MAX_TXD : E1000_MAX_82544_TXD
   128c2:	19 d2                	sbb    %edx,%edx
	{ /* Transmit Descriptor Count */
		struct e1000_tx_ring *tx_ring = adapter->tx_ring;
		int i;
		e1000_mac_type mac_type = adapter->hw.mac_type;

		opt = (struct e1000_option) {
   128c4:	31 c0                	xor    %eax,%eax
			.err  = "using default of "
				__MODULE_STRING(E1000_DEFAULT_TXD),
			.def  = E1000_DEFAULT_TXD,
			.arg  = { .r = {
				.min = E1000_MIN_TXD,
				.max = mac_type < e1000_82544 ? E1000_MAX_TXD : E1000_MAX_82544_TXD
   128c6:	81 e2 00 f1 ff ff    	and    $0xfffff100,%edx
   128cc:	81 c2 00 10 00 00    	add    $0x1000,%edx
				}}
		};

		if (num_TxDescriptors > bd) {
   128d2:	44 3b 2d 00 00 00 00 	cmp    0x0(%rip),%r13d        # 128d9 <e1000_check_options+0x59>
	{ /* Transmit Descriptor Count */
		struct e1000_tx_ring *tx_ring = adapter->tx_ring;
		int i;
		e1000_mac_type mac_type = adapter->hw.mac_type;

		opt = (struct e1000_option) {
   128d9:	f3 48 ab             	rep stos %rax,%es:(%rdi)
   128dc:	c7 45 b0 01 00 00 00 	movl   $0x1,-0x50(%rbp)
   128e3:	48 c7 45 b8 00 00 00 	movq   $0x0,-0x48(%rbp)
   128ea:	00 
   128eb:	48 c7 45 c0 00 00 00 	movq   $0x0,-0x40(%rbp)
   128f2:	00 
   128f3:	c7 45 c8 00 01 00 00 	movl   $0x100,-0x38(%rbp)
   128fa:	c7 45 d0 30 00 00 00 	movl   $0x30,-0x30(%rbp)
   12901:	89 55 d4             	mov    %edx,-0x2c(%rbp)
				.min = E1000_MIN_TXD,
				.max = mac_type < e1000_82544 ? E1000_MAX_TXD : E1000_MAX_82544_TXD
				}}
		};

		if (num_TxDescriptors > bd) {
   12904:	0f 82 4f 05 00 00    	jb     12e59 <e1000_check_options+0x5d9>
			tx_ring->count = TxDescriptors[bd];
			e1000_validate_option(&tx_ring->count, &opt, adapter);
			tx_ring->count = ALIGN(tx_ring->count,
						REQ_TX_DESCRIPTOR_MULTIPLE);
		} else {
			tx_ring->count = opt.def;
   1290a:	41 c7 46 14 00 01 00 	movl   $0x100,0x14(%r14)
   12911:	00 
		}
		for (i = 0; i < adapter->num_tx_queues; i++)
   12912:	8b b3 78 03 00 00    	mov    0x378(%rbx),%esi
   12918:	31 c0                	xor    %eax,%eax
   1291a:	85 f6                	test   %esi,%esi
   1291c:	7e 1f                	jle    1293d <e1000_check_options+0xbd>
			tx_ring[i].count = tx_ring->count;
   1291e:	48 63 c8             	movslq %eax,%rcx
   12921:	41 8b 56 14          	mov    0x14(%r14),%edx
			tx_ring->count = ALIGN(tx_ring->count,
						REQ_TX_DESCRIPTOR_MULTIPLE);
		} else {
			tx_ring->count = opt.def;
		}
		for (i = 0; i < adapter->num_tx_queues; i++)
   12925:	83 c0 01             	add    $0x1,%eax
			tx_ring[i].count = tx_ring->count;
   12928:	48 8d 0c 49          	lea    (%rcx,%rcx,2),%rcx
   1292c:	48 c1 e1 04          	shl    $0x4,%rcx
   12930:	41 89 54 0e 14       	mov    %edx,0x14(%r14,%rcx,1)
			tx_ring->count = ALIGN(tx_ring->count,
						REQ_TX_DESCRIPTOR_MULTIPLE);
		} else {
			tx_ring->count = opt.def;
		}
		for (i = 0; i < adapter->num_tx_queues; i++)
   12935:	39 83 78 03 00 00    	cmp    %eax,0x378(%rbx)
   1293b:	7f e1                	jg     1291e <e1000_check_options+0x9e>
			.err  = "using default of "
				__MODULE_STRING(E1000_DEFAULT_RXD),
			.def  = E1000_DEFAULT_RXD,
			.arg  = { .r = {
				.min = E1000_MIN_RXD,
				.max = mac_type < e1000_82544 ? E1000_MAX_RXD :
   1293d:	83 bb d8 03 00 00 04 	cmpl   $0x4,0x3d8(%rbx)
	{ /* Receive Descriptor Count */
		struct e1000_rx_ring *rx_ring = adapter->rx_ring;
		int i;
		e1000_mac_type mac_type = adapter->hw.mac_type;

		opt = (struct e1000_option) {
   12944:	b9 06 00 00 00       	mov    $0x6,%ecx
   12949:	4c 89 e7             	mov    %r12,%rdi
		}
		for (i = 0; i < adapter->num_tx_queues; i++)
			tx_ring[i].count = tx_ring->count;
	}
	{ /* Receive Descriptor Count */
		struct e1000_rx_ring *rx_ring = adapter->rx_ring;
   1294c:	4c 8b b3 a8 02 00 00 	mov    0x2a8(%rbx),%r14
			.err  = "using default of "
				__MODULE_STRING(E1000_DEFAULT_RXD),
			.def  = E1000_DEFAULT_RXD,
			.arg  = { .r = {
				.min = E1000_MIN_RXD,
				.max = mac_type < e1000_82544 ? E1000_MAX_RXD :
   12953:	19 d2                	sbb    %edx,%edx
	{ /* Receive Descriptor Count */
		struct e1000_rx_ring *rx_ring = adapter->rx_ring;
		int i;
		e1000_mac_type mac_type = adapter->hw.mac_type;

		opt = (struct e1000_option) {
   12955:	31 c0                	xor    %eax,%eax
			.err  = "using default of "
				__MODULE_STRING(E1000_DEFAULT_RXD),
			.def  = E1000_DEFAULT_RXD,
			.arg  = { .r = {
				.min = E1000_MIN_RXD,
				.max = mac_type < e1000_82544 ? E1000_MAX_RXD :
   12957:	81 e2 00 f1 ff ff    	and    $0xfffff100,%edx
   1295d:	81 c2 00 10 00 00    	add    $0x1000,%edx
				       E1000_MAX_82544_RXD
			}}
		};

		if (num_RxDescriptors > bd) {
   12963:	44 3b 2d 00 00 00 00 	cmp    0x0(%rip),%r13d        # 1296a <e1000_check_options+0xea>
	{ /* Receive Descriptor Count */
		struct e1000_rx_ring *rx_ring = adapter->rx_ring;
		int i;
		e1000_mac_type mac_type = adapter->hw.mac_type;

		opt = (struct e1000_option) {
   1296a:	f3 48 ab             	rep stos %rax,%es:(%rdi)
   1296d:	c7 45 b0 01 00 00 00 	movl   $0x1,-0x50(%rbp)
   12974:	48 c7 45 b8 00 00 00 	movq   $0x0,-0x48(%rbp)
   1297b:	00 
   1297c:	48 c7 45 c0 00 00 00 	movq   $0x0,-0x40(%rbp)
   12983:	00 
   12984:	c7 45 c8 00 01 00 00 	movl   $0x100,-0x38(%rbp)
   1298b:	c7 45 d0 30 00 00 00 	movl   $0x30,-0x30(%rbp)
   12992:	89 55 d4             	mov    %edx,-0x2c(%rbp)
				.max = mac_type < e1000_82544 ? E1000_MAX_RXD :
				       E1000_MAX_82544_RXD
			}}
		};

		if (num_RxDescriptors > bd) {
   12995:	0f 82 8a 04 00 00    	jb     12e25 <e1000_check_options+0x5a5>
			rx_ring->count = RxDescriptors[bd];
			e1000_validate_option(&rx_ring->count, &opt, adapter);
			rx_ring->count = ALIGN(rx_ring->count,
						REQ_RX_DESCRIPTOR_MULTIPLE);
		} else {
			rx_ring->count = opt.def;
   1299b:	41 c7 46 14 00 01 00 	movl   $0x100,0x14(%r14)
   129a2:	00 
		}
		for (i = 0; i < adapter->num_rx_queues; i++)
   129a3:	8b 8b 7c 03 00 00    	mov    0x37c(%rbx),%ecx
   129a9:	31 c0                	xor    %eax,%eax
   129ab:	85 c9                	test   %ecx,%ecx
   129ad:	7e 26                	jle    129d5 <e1000_check_options+0x155>
			rx_ring[i].count = rx_ring->count;
   129af:	48 63 c8             	movslq %eax,%rcx
   129b2:	41 8b 56 14          	mov    0x14(%r14),%edx
			rx_ring->count = ALIGN(rx_ring->count,
						REQ_RX_DESCRIPTOR_MULTIPLE);
		} else {
			rx_ring->count = opt.def;
		}
		for (i = 0; i < adapter->num_rx_queues; i++)
   129b6:	83 c0 01             	add    $0x1,%eax
			rx_ring[i].count = rx_ring->count;
   129b9:	48 8d 34 cd 00 00 00 	lea    0x0(,%rcx,8),%rsi
   129c0:	00 
   129c1:	48 c1 e1 06          	shl    $0x6,%rcx
   129c5:	48 29 f1             	sub    %rsi,%rcx
   129c8:	41 89 54 0e 14       	mov    %edx,0x14(%r14,%rcx,1)
			rx_ring->count = ALIGN(rx_ring->count,
						REQ_RX_DESCRIPTOR_MULTIPLE);
		} else {
			rx_ring->count = opt.def;
		}
		for (i = 0; i < adapter->num_rx_queues; i++)
   129cd:	39 83 7c 03 00 00    	cmp    %eax,0x37c(%rbx)
   129d3:	7f da                	jg     129af <e1000_check_options+0x12f>
			rx_ring[i].count = rx_ring->count;
	}
	{ /* Checksum Offload Enable/Disable */
		opt = (struct e1000_option) {
   129d5:	31 c0                	xor    %eax,%eax
			.name = "Checksum Offload",
			.err  = "defaulting to Enabled",
			.def  = OPTION_ENABLED
		};

		if (num_XsumRX > bd) {
   129d7:	44 3b 2d 00 00 00 00 	cmp    0x0(%rip),%r13d        # 129de <e1000_check_options+0x15e>
		}
		for (i = 0; i < adapter->num_rx_queues; i++)
			rx_ring[i].count = rx_ring->count;
	}
	{ /* Checksum Offload Enable/Disable */
		opt = (struct e1000_option) {
   129de:	b9 06 00 00 00       	mov    $0x6,%ecx
   129e3:	4c 89 e7             	mov    %r12,%rdi
   129e6:	f3 48 ab             	rep stos %rax,%es:(%rdi)
   129e9:	48 c7 45 b8 00 00 00 	movq   $0x0,-0x48(%rbp)
   129f0:	00 
   129f1:	48 c7 45 c0 00 00 00 	movq   $0x0,-0x40(%rbp)
   129f8:	00 
   129f9:	c7 45 c8 01 00 00 00 	movl   $0x1,-0x38(%rbp)
			.name = "Checksum Offload",
			.err  = "defaulting to Enabled",
			.def  = OPTION_ENABLED
		};

		if (num_XsumRX > bd) {
   12a00:	0f 82 ee 03 00 00    	jb     12df4 <e1000_check_options+0x574>
			unsigned int rx_csum = XsumRX[bd];
			e1000_validate_option(&rx_csum, &opt, adapter);
			adapter->rx_csum = rx_csum;
		} else {
			adapter->rx_csum = opt.def;
   12a06:	c6 83 9c 03 00 00 01 	movb   $0x1,0x39c(%rbx)
			.def  = E1000_FC_DEFAULT,
			.arg  = { .l = { .nr = ARRAY_SIZE(fc_list),
					 .p = fc_list }}
		};

		if (num_FlowControl > bd) {
   12a0d:	44 3b 2d 00 00 00 00 	cmp    0x0(%rip),%r13d        # 12a14 <e1000_check_options+0x194>
		       { E1000_FC_TX_PAUSE, "Flow Control Transmit Only" },
		       { E1000_FC_FULL, "Flow Control Enabled" },
		       { E1000_FC_DEFAULT, "Flow Control Hardware Default" }
		};

		opt = (struct e1000_option) {
   12a14:	c7 45 b0 02 00 00 00 	movl   $0x2,-0x50(%rbp)
   12a1b:	48 c7 45 b8 00 00 00 	movq   $0x0,-0x48(%rbp)
   12a22:	00 
   12a23:	48 c7 45 c0 00 00 00 	movq   $0x0,-0x40(%rbp)
   12a2a:	00 
   12a2b:	c7 45 c8 ff 00 00 00 	movl   $0xff,-0x38(%rbp)
   12a32:	c7 45 d0 05 00 00 00 	movl   $0x5,-0x30(%rbp)
   12a39:	48 c7 45 d8 00 00 00 	movq   $0x0,-0x28(%rbp)
   12a40:	00 
			.def  = E1000_FC_DEFAULT,
			.arg  = { .l = { .nr = ARRAY_SIZE(fc_list),
					 .p = fc_list }}
		};

		if (num_FlowControl > bd) {
   12a41:	0f 82 79 03 00 00    	jb     12dc0 <e1000_check_options+0x540>
			unsigned int fc = FlowControl[bd];
			e1000_validate_option(&fc, &opt, adapter);
			adapter->hw.fc = adapter->hw.original_fc = fc;
		} else {
			adapter->hw.fc = adapter->hw.original_fc = opt.def;
   12a47:	c7 83 4c 04 00 00 ff 	movl   $0xff,0x44c(%rbx)
   12a4e:	00 00 00 
   12a51:	c7 83 00 04 00 00 ff 	movl   $0xff,0x400(%rbx)
   12a58:	00 00 00 
		}
	}
	{ /* Transmit Interrupt Delay */
		opt = (struct e1000_option) {
   12a5b:	31 c0                	xor    %eax,%eax
			.def  = DEFAULT_TIDV,
			.arg  = { .r = { .min = MIN_TXDELAY,
					 .max = MAX_TXDELAY }}
		};

		if (num_TxIntDelay > bd) {
   12a5d:	44 3b 2d 00 00 00 00 	cmp    0x0(%rip),%r13d        # 12a64 <e1000_check_options+0x1e4>
		} else {
			adapter->hw.fc = adapter->hw.original_fc = opt.def;
		}
	}
	{ /* Transmit Interrupt Delay */
		opt = (struct e1000_option) {
   12a64:	b9 06 00 00 00       	mov    $0x6,%ecx
   12a69:	4c 89 e7             	mov    %r12,%rdi
   12a6c:	f3 48 ab             	rep stos %rax,%es:(%rdi)
   12a6f:	c7 45 b0 01 00 00 00 	movl   $0x1,-0x50(%rbp)
   12a76:	48 c7 45 b8 00 00 00 	movq   $0x0,-0x48(%rbp)
   12a7d:	00 
   12a7e:	48 c7 45 c0 00 00 00 	movq   $0x0,-0x40(%rbp)
   12a85:	00 
   12a86:	c7 45 c8 08 00 00 00 	movl   $0x8,-0x38(%rbp)
   12a8d:	c7 45 d4 ff ff 00 00 	movl   $0xffff,-0x2c(%rbp)
			.def  = DEFAULT_TIDV,
			.arg  = { .r = { .min = MIN_TXDELAY,
					 .max = MAX_TXDELAY }}
		};

		if (num_TxIntDelay > bd) {
   12a94:	0f 82 fb 02 00 00    	jb     12d95 <e1000_check_options+0x515>
			adapter->tx_int_delay = TxIntDelay[bd];
			e1000_validate_option(&adapter->tx_int_delay, &opt,
			                      adapter);
		} else {
			adapter->tx_int_delay = opt.def;
   12a9a:	c7 83 50 02 00 00 08 	movl   $0x8,0x250(%rbx)
   12aa1:	00 00 00 
		}
	}
	{ /* Transmit Absolute Interrupt Delay */
		opt = (struct e1000_option) {
   12aa4:	31 c0                	xor    %eax,%eax
			.def  = DEFAULT_TADV,
			.arg  = { .r = { .min = MIN_TXABSDELAY,
					 .max = MAX_TXABSDELAY }}
		};

		if (num_TxAbsIntDelay > bd) {
   12aa6:	44 3b 2d 00 00 00 00 	cmp    0x0(%rip),%r13d        # 12aad <e1000_check_options+0x22d>
		} else {
			adapter->tx_int_delay = opt.def;
		}
	}
	{ /* Transmit Absolute Interrupt Delay */
		opt = (struct e1000_option) {
   12aad:	b9 06 00 00 00       	mov    $0x6,%ecx
   12ab2:	4c 89 e7             	mov    %r12,%rdi
   12ab5:	f3 48 ab             	rep stos %rax,%es:(%rdi)
   12ab8:	c7 45 b0 01 00 00 00 	movl   $0x1,-0x50(%rbp)
   12abf:	48 c7 45 b8 00 00 00 	movq   $0x0,-0x48(%rbp)
   12ac6:	00 
   12ac7:	48 c7 45 c0 00 00 00 	movq   $0x0,-0x40(%rbp)
   12ace:	00 
   12acf:	c7 45 c8 20 00 00 00 	movl   $0x20,-0x38(%rbp)
   12ad6:	c7 45 d4 ff ff 00 00 	movl   $0xffff,-0x2c(%rbp)
			.def  = DEFAULT_TADV,
			.arg  = { .r = { .min = MIN_TXABSDELAY,
					 .max = MAX_TXABSDELAY }}
		};

		if (num_TxAbsIntDelay > bd) {
   12add:	0f 82 87 02 00 00    	jb     12d6a <e1000_check_options+0x4ea>
			adapter->tx_abs_int_delay = TxAbsIntDelay[bd];
			e1000_validate_option(&adapter->tx_abs_int_delay, &opt,
					      adapter);
		} else {
			adapter->tx_abs_int_delay = opt.def;
   12ae3:	c7 83 54 02 00 00 20 	movl   $0x20,0x254(%rbx)
   12aea:	00 00 00 
		}
	}
	{ /* Receive Interrupt Delay */
		opt = (struct e1000_option) {
   12aed:	31 c0                	xor    %eax,%eax
			.def  = DEFAULT_RDTR,
			.arg  = { .r = { .min = MIN_RXDELAY,
					 .max = MAX_RXDELAY }}
		};

		if (num_RxIntDelay > bd) {
   12aef:	44 3b 2d 00 00 00 00 	cmp    0x0(%rip),%r13d        # 12af6 <e1000_check_options+0x276>
		} else {
			adapter->tx_abs_int_delay = opt.def;
		}
	}
	{ /* Receive Interrupt Delay */
		opt = (struct e1000_option) {
   12af6:	b9 06 00 00 00       	mov    $0x6,%ecx
   12afb:	4c 89 e7             	mov    %r12,%rdi
   12afe:	f3 48 ab             	rep stos %rax,%es:(%rdi)
   12b01:	c7 45 b0 01 00 00 00 	movl   $0x1,-0x50(%rbp)
   12b08:	48 c7 45 b8 00 00 00 	movq   $0x0,-0x48(%rbp)
   12b0f:	00 
   12b10:	48 c7 45 c0 00 00 00 	movq   $0x0,-0x40(%rbp)
   12b17:	00 
   12b18:	c7 45 d4 ff ff 00 00 	movl   $0xffff,-0x2c(%rbp)
			.def  = DEFAULT_RDTR,
			.arg  = { .r = { .min = MIN_RXDELAY,
					 .max = MAX_RXDELAY }}
		};

		if (num_RxIntDelay > bd) {
   12b1f:	0f 82 1a 02 00 00    	jb     12d3f <e1000_check_options+0x4bf>
			adapter->rx_int_delay = RxIntDelay[bd];
			e1000_validate_option(&adapter->rx_int_delay, &opt,
					      adapter);
		} else {
			adapter->rx_int_delay = opt.def;
   12b25:	c7 83 94 03 00 00 00 	movl   $0x0,0x394(%rbx)
   12b2c:	00 00 00 
		}
	}
	{ /* Receive Absolute Interrupt Delay */
		opt = (struct e1000_option) {
   12b2f:	31 c0                	xor    %eax,%eax
			.def  = DEFAULT_RADV,
			.arg  = { .r = { .min = MIN_RXABSDELAY,
					 .max = MAX_RXABSDELAY }}
		};

		if (num_RxAbsIntDelay > bd) {
   12b31:	44 3b 2d 00 00 00 00 	cmp    0x0(%rip),%r13d        # 12b38 <e1000_check_options+0x2b8>
		} else {
			adapter->rx_int_delay = opt.def;
		}
	}
	{ /* Receive Absolute Interrupt Delay */
		opt = (struct e1000_option) {
   12b38:	b9 06 00 00 00       	mov    $0x6,%ecx
   12b3d:	4c 89 e7             	mov    %r12,%rdi
   12b40:	f3 48 ab             	rep stos %rax,%es:(%rdi)
   12b43:	c7 45 b0 01 00 00 00 	movl   $0x1,-0x50(%rbp)
   12b4a:	48 c7 45 b8 00 00 00 	movq   $0x0,-0x48(%rbp)
   12b51:	00 
   12b52:	48 c7 45 c0 00 00 00 	movq   $0x0,-0x40(%rbp)
   12b59:	00 
   12b5a:	c7 45 c8 08 00 00 00 	movl   $0x8,-0x38(%rbp)
   12b61:	c7 45 d4 ff ff 00 00 	movl   $0xffff,-0x2c(%rbp)
			.def  = DEFAULT_RADV,
			.arg  = { .r = { .min = MIN_RXABSDELAY,
					 .max = MAX_RXABSDELAY }}
		};

		if (num_RxAbsIntDelay > bd) {
   12b68:	0f 82 77 01 00 00    	jb     12ce5 <e1000_check_options+0x465>
			adapter->rx_abs_int_delay = RxAbsIntDelay[bd];
			e1000_validate_option(&adapter->rx_abs_int_delay, &opt,
					      adapter);
		} else {
			adapter->rx_abs_int_delay = opt.def;
   12b6e:	c7 83 98 03 00 00 08 	movl   $0x8,0x398(%rbx)
   12b75:	00 00 00 
		}
	}
	{ /* Interrupt Throttling Rate */
		opt = (struct e1000_option) {
   12b78:	31 c0                	xor    %eax,%eax
			.def  = DEFAULT_ITR,
			.arg  = { .r = { .min = MIN_ITR,
					 .max = MAX_ITR }}
		};

		if (num_InterruptThrottleRate > bd) {
   12b7a:	44 3b 2d 00 00 00 00 	cmp    0x0(%rip),%r13d        # 12b81 <e1000_check_options+0x301>
		} else {
			adapter->rx_abs_int_delay = opt.def;
		}
	}
	{ /* Interrupt Throttling Rate */
		opt = (struct e1000_option) {
   12b81:	b9 06 00 00 00       	mov    $0x6,%ecx
   12b86:	4c 89 e7             	mov    %r12,%rdi
   12b89:	f3 48 ab             	rep stos %rax,%es:(%rdi)
   12b8c:	c7 45 b0 01 00 00 00 	movl   $0x1,-0x50(%rbp)
   12b93:	48 c7 45 b8 00 00 00 	movq   $0x0,-0x48(%rbp)
   12b9a:	00 
   12b9b:	48 c7 45 c0 00 00 00 	movq   $0x0,-0x40(%rbp)
   12ba2:	00 
   12ba3:	c7 45 c8 03 00 00 00 	movl   $0x3,-0x38(%rbp)
   12baa:	c7 45 d0 64 00 00 00 	movl   $0x64,-0x30(%rbp)
   12bb1:	c7 45 d4 a0 86 01 00 	movl   $0x186a0,-0x2c(%rbp)
			.def  = DEFAULT_ITR,
			.arg  = { .r = { .min = MIN_ITR,
					 .max = MAX_ITR }}
		};

		if (num_InterruptThrottleRate > bd) {
   12bb8:	73 62                	jae    12c1c <e1000_check_options+0x39c>
			adapter->itr = InterruptThrottleRate[bd];
   12bba:	49 63 c5             	movslq %r13d,%rax
   12bbd:	8b 04 85 00 00 00 00 	mov    0x0(,%rax,4),%eax
			switch (adapter->itr) {
   12bc4:	83 f8 01             	cmp    $0x1,%eax
			.arg  = { .r = { .min = MIN_ITR,
					 .max = MAX_ITR }}
		};

		if (num_InterruptThrottleRate > bd) {
			adapter->itr = InterruptThrottleRate[bd];
   12bc7:	89 83 30 02 00 00    	mov    %eax,0x230(%rbx)
			switch (adapter->itr) {
   12bcd:	0f 84 08 03 00 00    	je     12edb <e1000_check_options+0x65b>
   12bd3:	0f 82 5e 03 00 00    	jb     12f37 <e1000_check_options+0x6b7>
   12bd9:	83 f8 03             	cmp    $0x3,%eax
   12bdc:	0f 84 37 03 00 00    	je     12f19 <e1000_check_options+0x699>
   12be2:	83 f8 04             	cmp    $0x4,%eax
   12be5:	0f 85 c6 02 00 00    	jne    12eb1 <e1000_check_options+0x631>
					   "mode\n", opt.name);
				adapter->itr_setting = adapter->itr;
				adapter->itr = 20000;
				break;
			case 4:
				e_dev_info("%s set to simplified "
   12beb:	48 8b 83 b8 03 00 00 	mov    0x3b8(%rbx),%rax
   12bf2:	48 c7 c2 00 00 00 00 	mov    $0x0,%rdx
   12bf9:	48 c7 c6 00 00 00 00 	mov    $0x0,%rsi
   12c00:	48 8d b8 98 00 00 00 	lea    0x98(%rax),%rdi
   12c07:	31 c0                	xor    %eax,%eax
   12c09:	e8 00 00 00 00       	callq  12c0e <e1000_check_options+0x38e>
					   "(2000-8000) ints mode\n", opt.name);
				adapter->itr_setting = adapter->itr;
   12c0e:	8b 83 30 02 00 00    	mov    0x230(%rbx),%eax
   12c14:	89 83 34 02 00 00    	mov    %eax,0x234(%rbx)
				break;
   12c1a:	eb 14                	jmp    12c30 <e1000_check_options+0x3b0>
				 */
				adapter->itr_setting = adapter->itr & ~3;
				break;
			}
		} else {
			adapter->itr_setting = opt.def;
   12c1c:	c7 83 34 02 00 00 03 	movl   $0x3,0x234(%rbx)
   12c23:	00 00 00 
			adapter->itr = 20000;
   12c26:	c7 83 30 02 00 00 20 	movl   $0x4e20,0x230(%rbx)
   12c2d:	4e 00 00 
		}
	}
	{ /* Smart Power Down */
		opt = (struct e1000_option) {
   12c30:	31 c0                	xor    %eax,%eax
			.name = "PHY Smart Power Down",
			.err  = "defaulting to Disabled",
			.def  = OPTION_DISABLED
		};

		if (num_SmartPowerDownEnable > bd) {
   12c32:	44 3b 2d 00 00 00 00 	cmp    0x0(%rip),%r13d        # 12c39 <e1000_check_options+0x3b9>
			adapter->itr_setting = opt.def;
			adapter->itr = 20000;
		}
	}
	{ /* Smart Power Down */
		opt = (struct e1000_option) {
   12c39:	b9 06 00 00 00       	mov    $0x6,%ecx
   12c3e:	4c 89 e7             	mov    %r12,%rdi
   12c41:	f3 48 ab             	rep stos %rax,%es:(%rdi)
   12c44:	48 c7 45 b8 00 00 00 	movq   $0x0,-0x48(%rbp)
   12c4b:	00 
   12c4c:	48 c7 45 c0 00 00 00 	movq   $0x0,-0x40(%rbp)
   12c53:	00 
			.name = "PHY Smart Power Down",
			.err  = "defaulting to Disabled",
			.def  = OPTION_DISABLED
		};

		if (num_SmartPowerDownEnable > bd) {
   12c54:	0f 82 b6 00 00 00    	jb     12d10 <e1000_check_options+0x490>
			unsigned int spd = SmartPowerDownEnable[bd];
			e1000_validate_option(&spd, &opt, adapter);
			adapter->smart_power_down = spd;
		} else {
			adapter->smart_power_down = opt.def;
   12c5a:	c6 83 a5 07 00 00 00 	movb   $0x0,0x7a5(%rbx)
		}
	}

	switch (adapter->hw.media_type) {
   12c61:	8b 83 e4 03 00 00    	mov    0x3e4(%rbx),%eax
   12c67:	85 c0                	test   %eax,%eax
   12c69:	74 65                	je     12cd0 <e1000_check_options+0x450>
   12c6b:	83 f8 02             	cmp    $0x2,%eax
   12c6e:	77 5e                	ja     12cce <e1000_check_options+0x44e>
 * This routine checks all command line parameters for valid user
 * input.  If an invalid value is given, or if no user specified
 * value exists, a default value is used.  The final value is stored
 * in a variable in the adapter structure.
 **/
void e1000_check_options(struct e1000_adapter *adapter)
   12c70:	4c 63 a3 04 02 00 00 	movslq 0x204(%rbx),%r12
 * Handles speed and duplex options on fiber adapters
 **/
static void e1000_check_fiber_options(struct e1000_adapter *adapter)
{
	int bd = adapter->bd_number;
	if (num_Speed > bd) {
   12c77:	44 3b 25 00 00 00 00 	cmp    0x0(%rip),%r12d        # 12c7e <e1000_check_options+0x3fe>
   12c7e:	0f 82 fc 02 00 00    	jb     12f80 <e1000_check_options+0x700>
		e_dev_info("Speed not valid for fiber adapters, parameter "
			   "ignored\n");
	}

	if (num_Duplex > bd) {
   12c84:	44 3b 25 00 00 00 00 	cmp    0x0(%rip),%r12d        # 12c8b <e1000_check_options+0x40b>
   12c8b:	0f 82 ce 02 00 00    	jb     12f5f <e1000_check_options+0x6df>
		e_dev_info("Duplex not valid for fiber adapters, parameter "
			   "ignored\n");
	}

	if ((num_AutoNeg > bd) && (AutoNeg[bd] != 0x20)) {
   12c91:	44 3b 25 00 00 00 00 	cmp    0x0(%rip),%r12d        # 12c98 <e1000_check_options+0x418>
   12c98:	73 27                	jae    12cc1 <e1000_check_options+0x441>
   12c9a:	42 83 3c a5 00 00 00 	cmpl   $0x20,0x0(,%r12,4)
   12ca1:	00 20 
   12ca3:	74 1c                	je     12cc1 <e1000_check_options+0x441>
		e_dev_info("AutoNeg other than 1000/Full is not valid for fiber"
   12ca5:	48 8b bb b8 03 00 00 	mov    0x3b8(%rbx),%rdi
   12cac:	48 c7 c6 00 00 00 00 	mov    $0x0,%rsi
   12cb3:	31 c0                	xor    %eax,%eax
   12cb5:	48 81 c7 98 00 00 00 	add    $0x98,%rdi
   12cbc:	e8 00 00 00 00       	callq  12cc1 <e1000_check_options+0x441>
		e1000_check_copper_options(adapter);
		break;
	default:
		BUG();
	}
}
   12cc1:	48 83 c4 38          	add    $0x38,%rsp
   12cc5:	5b                   	pop    %rbx
   12cc6:	41 5c                	pop    %r12
   12cc8:	41 5d                	pop    %r13
   12cca:	41 5e                	pop    %r14
   12ccc:	5d                   	pop    %rbp
   12ccd:	c3                   	retq   
		break;
	case e1000_media_type_copper:
		e1000_check_copper_options(adapter);
		break;
	default:
		BUG();
   12cce:	0f 0b                	ud2    
	case e1000_media_type_fiber:
	case e1000_media_type_internal_serdes:
		e1000_check_fiber_options(adapter);
		break;
	case e1000_media_type_copper:
		e1000_check_copper_options(adapter);
   12cd0:	48 89 df             	mov    %rbx,%rdi
   12cd3:	e8 e8 f5 ff ff       	callq  122c0 <e1000_check_copper_options>
		break;
	default:
		BUG();
	}
}
   12cd8:	48 83 c4 38          	add    $0x38,%rsp
   12cdc:	5b                   	pop    %rbx
   12cdd:	41 5c                	pop    %r12
   12cdf:	41 5d                	pop    %r13
   12ce1:	41 5e                	pop    %r14
   12ce3:	5d                   	pop    %rbp
   12ce4:	c3                   	retq   
			.arg  = { .r = { .min = MIN_RXABSDELAY,
					 .max = MAX_RXABSDELAY }}
		};

		if (num_RxAbsIntDelay > bd) {
			adapter->rx_abs_int_delay = RxAbsIntDelay[bd];
   12ce5:	49 63 c5             	movslq %r13d,%rax
   12ce8:	48 8d 93 b8 03 00 00 	lea    0x3b8(%rbx),%rdx
			e1000_validate_option(&adapter->rx_abs_int_delay, &opt,
   12cef:	48 8d bb 98 03 00 00 	lea    0x398(%rbx),%rdi
			.arg  = { .r = { .min = MIN_RXABSDELAY,
					 .max = MAX_RXABSDELAY }}
		};

		if (num_RxAbsIntDelay > bd) {
			adapter->rx_abs_int_delay = RxAbsIntDelay[bd];
   12cf6:	8b 04 85 00 00 00 00 	mov    0x0(,%rax,4),%eax
			e1000_validate_option(&adapter->rx_abs_int_delay, &opt,
   12cfd:	4c 89 e6             	mov    %r12,%rsi
			.arg  = { .r = { .min = MIN_RXABSDELAY,
					 .max = MAX_RXABSDELAY }}
		};

		if (num_RxAbsIntDelay > bd) {
			adapter->rx_abs_int_delay = RxAbsIntDelay[bd];
   12d00:	89 83 98 03 00 00    	mov    %eax,0x398(%rbx)
			e1000_validate_option(&adapter->rx_abs_int_delay, &opt,
   12d06:	e8 55 f4 ff ff       	callq  12160 <e1000_validate_option.isra.1>
   12d0b:	e9 68 fe ff ff       	jmpq   12b78 <e1000_check_options+0x2f8>
			.err  = "defaulting to Disabled",
			.def  = OPTION_DISABLED
		};

		if (num_SmartPowerDownEnable > bd) {
			unsigned int spd = SmartPowerDownEnable[bd];
   12d10:	42 8b 04 ad 00 00 00 	mov    0x0(,%r13,4),%eax
   12d17:	00 
   12d18:	48 8d 93 b8 03 00 00 	lea    0x3b8(%rbx),%rdx
			e1000_validate_option(&spd, &opt, adapter);
   12d1f:	48 8d 7d ac          	lea    -0x54(%rbp),%rdi
   12d23:	4c 89 e6             	mov    %r12,%rsi
			.err  = "defaulting to Disabled",
			.def  = OPTION_DISABLED
		};

		if (num_SmartPowerDownEnable > bd) {
			unsigned int spd = SmartPowerDownEnable[bd];
   12d26:	89 45 ac             	mov    %eax,-0x54(%rbp)
			e1000_validate_option(&spd, &opt, adapter);
   12d29:	e8 32 f4 ff ff       	callq  12160 <e1000_validate_option.isra.1>
			adapter->smart_power_down = spd;
   12d2e:	8b 45 ac             	mov    -0x54(%rbp),%eax
   12d31:	85 c0                	test   %eax,%eax
   12d33:	0f 95 83 a5 07 00 00 	setne  0x7a5(%rbx)
   12d3a:	e9 22 ff ff ff       	jmpq   12c61 <e1000_check_options+0x3e1>
			.arg  = { .r = { .min = MIN_RXDELAY,
					 .max = MAX_RXDELAY }}
		};

		if (num_RxIntDelay > bd) {
			adapter->rx_int_delay = RxIntDelay[bd];
   12d3f:	49 63 c5             	movslq %r13d,%rax
   12d42:	48 8d 93 b8 03 00 00 	lea    0x3b8(%rbx),%rdx
			e1000_validate_option(&adapter->rx_int_delay, &opt,
   12d49:	48 8d bb 94 03 00 00 	lea    0x394(%rbx),%rdi
			.arg  = { .r = { .min = MIN_RXDELAY,
					 .max = MAX_RXDELAY }}
		};

		if (num_RxIntDelay > bd) {
			adapter->rx_int_delay = RxIntDelay[bd];
   12d50:	8b 04 85 00 00 00 00 	mov    0x0(,%rax,4),%eax
			e1000_validate_option(&adapter->rx_int_delay, &opt,
   12d57:	4c 89 e6             	mov    %r12,%rsi
			.arg  = { .r = { .min = MIN_RXDELAY,
					 .max = MAX_RXDELAY }}
		};

		if (num_RxIntDelay > bd) {
			adapter->rx_int_delay = RxIntDelay[bd];
   12d5a:	89 83 94 03 00 00    	mov    %eax,0x394(%rbx)
			e1000_validate_option(&adapter->rx_int_delay, &opt,
   12d60:	e8 fb f3 ff ff       	callq  12160 <e1000_validate_option.isra.1>
   12d65:	e9 c5 fd ff ff       	jmpq   12b2f <e1000_check_options+0x2af>
			.arg  = { .r = { .min = MIN_TXABSDELAY,
					 .max = MAX_TXABSDELAY }}
		};

		if (num_TxAbsIntDelay > bd) {
			adapter->tx_abs_int_delay = TxAbsIntDelay[bd];
   12d6a:	49 63 c5             	movslq %r13d,%rax
   12d6d:	48 8d 93 b8 03 00 00 	lea    0x3b8(%rbx),%rdx
			e1000_validate_option(&adapter->tx_abs_int_delay, &opt,
   12d74:	48 8d bb 54 02 00 00 	lea    0x254(%rbx),%rdi
			.arg  = { .r = { .min = MIN_TXABSDELAY,
					 .max = MAX_TXABSDELAY }}
		};

		if (num_TxAbsIntDelay > bd) {
			adapter->tx_abs_int_delay = TxAbsIntDelay[bd];
   12d7b:	8b 04 85 00 00 00 00 	mov    0x0(,%rax,4),%eax
			e1000_validate_option(&adapter->tx_abs_int_delay, &opt,
   12d82:	4c 89 e6             	mov    %r12,%rsi
			.arg  = { .r = { .min = MIN_TXABSDELAY,
					 .max = MAX_TXABSDELAY }}
		};

		if (num_TxAbsIntDelay > bd) {
			adapter->tx_abs_int_delay = TxAbsIntDelay[bd];
   12d85:	89 83 54 02 00 00    	mov    %eax,0x254(%rbx)
			e1000_validate_option(&adapter->tx_abs_int_delay, &opt,
   12d8b:	e8 d0 f3 ff ff       	callq  12160 <e1000_validate_option.isra.1>
   12d90:	e9 58 fd ff ff       	jmpq   12aed <e1000_check_options+0x26d>
			.arg  = { .r = { .min = MIN_TXDELAY,
					 .max = MAX_TXDELAY }}
		};

		if (num_TxIntDelay > bd) {
			adapter->tx_int_delay = TxIntDelay[bd];
   12d95:	49 63 c5             	movslq %r13d,%rax
   12d98:	48 8d 93 b8 03 00 00 	lea    0x3b8(%rbx),%rdx
			e1000_validate_option(&adapter->tx_int_delay, &opt,
   12d9f:	48 8d bb 50 02 00 00 	lea    0x250(%rbx),%rdi
			.arg  = { .r = { .min = MIN_TXDELAY,
					 .max = MAX_TXDELAY }}
		};

		if (num_TxIntDelay > bd) {
			adapter->tx_int_delay = TxIntDelay[bd];
   12da6:	8b 04 85 00 00 00 00 	mov    0x0(,%rax,4),%eax
			e1000_validate_option(&adapter->tx_int_delay, &opt,
   12dad:	4c 89 e6             	mov    %r12,%rsi
			.arg  = { .r = { .min = MIN_TXDELAY,
					 .max = MAX_TXDELAY }}
		};

		if (num_TxIntDelay > bd) {
			adapter->tx_int_delay = TxIntDelay[bd];
   12db0:	89 83 50 02 00 00    	mov    %eax,0x250(%rbx)
			e1000_validate_option(&adapter->tx_int_delay, &opt,
   12db6:	e8 a5 f3 ff ff       	callq  12160 <e1000_validate_option.isra.1>
   12dbb:	e9 e4 fc ff ff       	jmpq   12aa4 <e1000_check_options+0x224>
			.arg  = { .l = { .nr = ARRAY_SIZE(fc_list),
					 .p = fc_list }}
		};

		if (num_FlowControl > bd) {
			unsigned int fc = FlowControl[bd];
   12dc0:	49 63 c5             	movslq %r13d,%rax
   12dc3:	48 8d 93 b8 03 00 00 	lea    0x3b8(%rbx),%rdx
			e1000_validate_option(&fc, &opt, adapter);
   12dca:	48 8d 7d ac          	lea    -0x54(%rbp),%rdi
			.arg  = { .l = { .nr = ARRAY_SIZE(fc_list),
					 .p = fc_list }}
		};

		if (num_FlowControl > bd) {
			unsigned int fc = FlowControl[bd];
   12dce:	8b 04 85 00 00 00 00 	mov    0x0(,%rax,4),%eax
			e1000_validate_option(&fc, &opt, adapter);
   12dd5:	4c 89 e6             	mov    %r12,%rsi
			.arg  = { .l = { .nr = ARRAY_SIZE(fc_list),
					 .p = fc_list }}
		};

		if (num_FlowControl > bd) {
			unsigned int fc = FlowControl[bd];
   12dd8:	89 45 ac             	mov    %eax,-0x54(%rbp)
			e1000_validate_option(&fc, &opt, adapter);
   12ddb:	e8 80 f3 ff ff       	callq  12160 <e1000_validate_option.isra.1>
			adapter->hw.fc = adapter->hw.original_fc = fc;
   12de0:	8b 45 ac             	mov    -0x54(%rbp),%eax
   12de3:	89 83 4c 04 00 00    	mov    %eax,0x44c(%rbx)
   12de9:	89 83 00 04 00 00    	mov    %eax,0x400(%rbx)
   12def:	e9 67 fc ff ff       	jmpq   12a5b <e1000_check_options+0x1db>
			.err  = "defaulting to Enabled",
			.def  = OPTION_ENABLED
		};

		if (num_XsumRX > bd) {
			unsigned int rx_csum = XsumRX[bd];
   12df4:	49 63 c5             	movslq %r13d,%rax
   12df7:	48 8d 93 b8 03 00 00 	lea    0x3b8(%rbx),%rdx
			e1000_validate_option(&rx_csum, &opt, adapter);
   12dfe:	48 8d 7d ac          	lea    -0x54(%rbp),%rdi
			.err  = "defaulting to Enabled",
			.def  = OPTION_ENABLED
		};

		if (num_XsumRX > bd) {
			unsigned int rx_csum = XsumRX[bd];
   12e02:	8b 04 85 00 00 00 00 	mov    0x0(,%rax,4),%eax
			e1000_validate_option(&rx_csum, &opt, adapter);
   12e09:	4c 89 e6             	mov    %r12,%rsi
			.err  = "defaulting to Enabled",
			.def  = OPTION_ENABLED
		};

		if (num_XsumRX > bd) {
			unsigned int rx_csum = XsumRX[bd];
   12e0c:	89 45 ac             	mov    %eax,-0x54(%rbp)
			e1000_validate_option(&rx_csum, &opt, adapter);
   12e0f:	e8 4c f3 ff ff       	callq  12160 <e1000_validate_option.isra.1>
			adapter->rx_csum = rx_csum;
   12e14:	8b 55 ac             	mov    -0x54(%rbp),%edx
   12e17:	85 d2                	test   %edx,%edx
   12e19:	0f 95 83 9c 03 00 00 	setne  0x39c(%rbx)
   12e20:	e9 e8 fb ff ff       	jmpq   12a0d <e1000_check_options+0x18d>
				       E1000_MAX_82544_RXD
			}}
		};

		if (num_RxDescriptors > bd) {
			rx_ring->count = RxDescriptors[bd];
   12e25:	49 63 c5             	movslq %r13d,%rax
   12e28:	48 8d 93 b8 03 00 00 	lea    0x3b8(%rbx),%rdx
			e1000_validate_option(&rx_ring->count, &opt, adapter);
   12e2f:	49 8d 7e 14          	lea    0x14(%r14),%rdi
				       E1000_MAX_82544_RXD
			}}
		};

		if (num_RxDescriptors > bd) {
			rx_ring->count = RxDescriptors[bd];
   12e33:	8b 04 85 00 00 00 00 	mov    0x0(,%rax,4),%eax
			e1000_validate_option(&rx_ring->count, &opt, adapter);
   12e3a:	4c 89 e6             	mov    %r12,%rsi
				       E1000_MAX_82544_RXD
			}}
		};

		if (num_RxDescriptors > bd) {
			rx_ring->count = RxDescriptors[bd];
   12e3d:	41 89 46 14          	mov    %eax,0x14(%r14)
			e1000_validate_option(&rx_ring->count, &opt, adapter);
   12e41:	e8 1a f3 ff ff       	callq  12160 <e1000_validate_option.isra.1>
			rx_ring->count = ALIGN(rx_ring->count,
   12e46:	41 8b 46 14          	mov    0x14(%r14),%eax
   12e4a:	83 c0 07             	add    $0x7,%eax
   12e4d:	83 e0 f8             	and    $0xfffffff8,%eax
   12e50:	41 89 46 14          	mov    %eax,0x14(%r14)
   12e54:	e9 4a fb ff ff       	jmpq   129a3 <e1000_check_options+0x123>
				.max = mac_type < e1000_82544 ? E1000_MAX_TXD : E1000_MAX_82544_TXD
				}}
		};

		if (num_TxDescriptors > bd) {
			tx_ring->count = TxDescriptors[bd];
   12e59:	49 63 c5             	movslq %r13d,%rax
   12e5c:	48 8d 93 b8 03 00 00 	lea    0x3b8(%rbx),%rdx
			e1000_validate_option(&tx_ring->count, &opt, adapter);
   12e63:	49 8d 7e 14          	lea    0x14(%r14),%rdi
				.max = mac_type < e1000_82544 ? E1000_MAX_TXD : E1000_MAX_82544_TXD
				}}
		};

		if (num_TxDescriptors > bd) {
			tx_ring->count = TxDescriptors[bd];
   12e67:	8b 04 85 00 00 00 00 	mov    0x0(,%rax,4),%eax
			e1000_validate_option(&tx_ring->count, &opt, adapter);
   12e6e:	4c 89 e6             	mov    %r12,%rsi
				.max = mac_type < e1000_82544 ? E1000_MAX_TXD : E1000_MAX_82544_TXD
				}}
		};

		if (num_TxDescriptors > bd) {
			tx_ring->count = TxDescriptors[bd];
   12e71:	41 89 46 14          	mov    %eax,0x14(%r14)
			e1000_validate_option(&tx_ring->count, &opt, adapter);
   12e75:	e8 e6 f2 ff ff       	callq  12160 <e1000_validate_option.isra.1>
			tx_ring->count = ALIGN(tx_ring->count,
   12e7a:	41 8b 46 14          	mov    0x14(%r14),%eax
   12e7e:	83 c0 07             	add    $0x7,%eax
   12e81:	83 e0 f8             	and    $0xfffffff8,%eax
   12e84:	41 89 46 14          	mov    %eax,0x14(%r14)
   12e88:	e9 85 fa ff ff       	jmpq   12912 <e1000_check_options+0x92>
{
	struct e1000_option opt;
	int bd = adapter->bd_number;

	if (bd >= E1000_MAX_NIC) {
		e_dev_warn("Warning: no configuration for board #%i "
   12e8d:	48 8b 87 b8 03 00 00 	mov    0x3b8(%rdi),%rax
   12e94:	44 89 ea             	mov    %r13d,%edx
   12e97:	48 c7 c6 00 00 00 00 	mov    $0x0,%rsi
   12e9e:	48 8d b8 98 00 00 00 	lea    0x98(%rax),%rdi
   12ea5:	31 c0                	xor    %eax,%eax
   12ea7:	e8 00 00 00 00       	callq  12eac <e1000_check_options+0x62c>
   12eac:	e9 f7 f9 ff ff       	jmpq   128a8 <e1000_check_options+0x28>
   12eb1:	48 8d 93 b8 03 00 00 	lea    0x3b8(%rbx),%rdx
				e_dev_info("%s set to simplified "
					   "(2000-8000) ints mode\n", opt.name);
				adapter->itr_setting = adapter->itr;
				break;
			default:
				e1000_validate_option(&adapter->itr, &opt,
   12eb8:	48 8d bb 30 02 00 00 	lea    0x230(%rbx),%rdi
   12ebf:	4c 89 e6             	mov    %r12,%rsi
   12ec2:	e8 99 f2 ff ff       	callq  12160 <e1000_validate_option.isra.1>
				/* save the setting, because the dynamic bits
				 * change itr.
				 * clear the lower two bits because they are
				 * used as control
				 */
				adapter->itr_setting = adapter->itr & ~3;
   12ec7:	8b 83 30 02 00 00    	mov    0x230(%rbx),%eax
   12ecd:	83 e0 fc             	and    $0xfffffffc,%eax
   12ed0:	89 83 34 02 00 00    	mov    %eax,0x234(%rbx)
				break;
   12ed6:	e9 55 fd ff ff       	jmpq   12c30 <e1000_check_options+0x3b0>
			switch (adapter->itr) {
			case 0:
				e_dev_info("%s turned off\n", opt.name);
				break;
			case 1:
				e_dev_info("%s set to dynamic mode\n",
   12edb:	48 8b 83 b8 03 00 00 	mov    0x3b8(%rbx),%rax
   12ee2:	48 c7 c2 00 00 00 00 	mov    $0x0,%rdx
   12ee9:	48 c7 c6 00 00 00 00 	mov    $0x0,%rsi
   12ef0:	48 8d b8 98 00 00 00 	lea    0x98(%rax),%rdi
					   opt.name);
				adapter->itr_setting = adapter->itr;
				adapter->itr = 20000;
				break;
			case 3:
				e_dev_info("%s set to dynamic conservative "
   12ef7:	31 c0                	xor    %eax,%eax
   12ef9:	e8 00 00 00 00       	callq  12efe <e1000_check_options+0x67e>
					   "mode\n", opt.name);
				adapter->itr_setting = adapter->itr;
   12efe:	8b 83 30 02 00 00    	mov    0x230(%rbx),%eax
				adapter->itr = 20000;
   12f04:	c7 83 30 02 00 00 20 	movl   $0x4e20,0x230(%rbx)
   12f0b:	4e 00 00 
				adapter->itr = 20000;
				break;
			case 3:
				e_dev_info("%s set to dynamic conservative "
					   "mode\n", opt.name);
				adapter->itr_setting = adapter->itr;
   12f0e:	89 83 34 02 00 00    	mov    %eax,0x234(%rbx)
				adapter->itr = 20000;
				break;
   12f14:	e9 17 fd ff ff       	jmpq   12c30 <e1000_check_options+0x3b0>
					   opt.name);
				adapter->itr_setting = adapter->itr;
				adapter->itr = 20000;
				break;
			case 3:
				e_dev_info("%s set to dynamic conservative "
   12f19:	48 8b 83 b8 03 00 00 	mov    0x3b8(%rbx),%rax
   12f20:	48 c7 c2 00 00 00 00 	mov    $0x0,%rdx
   12f27:	48 c7 c6 00 00 00 00 	mov    $0x0,%rsi
   12f2e:	48 8d b8 98 00 00 00 	lea    0x98(%rax),%rdi
   12f35:	eb c0                	jmp    12ef7 <e1000_check_options+0x677>

		if (num_InterruptThrottleRate > bd) {
			adapter->itr = InterruptThrottleRate[bd];
			switch (adapter->itr) {
			case 0:
				e_dev_info("%s turned off\n", opt.name);
   12f37:	48 8b 83 b8 03 00 00 	mov    0x3b8(%rbx),%rax
   12f3e:	48 c7 c2 00 00 00 00 	mov    $0x0,%rdx
   12f45:	48 c7 c6 00 00 00 00 	mov    $0x0,%rsi
   12f4c:	48 8d b8 98 00 00 00 	lea    0x98(%rax),%rdi
   12f53:	31 c0                	xor    %eax,%eax
   12f55:	e8 00 00 00 00       	callq  12f5a <e1000_check_options+0x6da>
				break;
   12f5a:	e9 d1 fc ff ff       	jmpq   12c30 <e1000_check_options+0x3b0>
		e_dev_info("Speed not valid for fiber adapters, parameter "
			   "ignored\n");
	}

	if (num_Duplex > bd) {
		e_dev_info("Duplex not valid for fiber adapters, parameter "
   12f5f:	48 8b 83 b8 03 00 00 	mov    0x3b8(%rbx),%rax
   12f66:	48 c7 c6 00 00 00 00 	mov    $0x0,%rsi
   12f6d:	48 8d b8 98 00 00 00 	lea    0x98(%rax),%rdi
   12f74:	31 c0                	xor    %eax,%eax
   12f76:	e8 00 00 00 00       	callq  12f7b <e1000_check_options+0x6fb>
   12f7b:	e9 11 fd ff ff       	jmpq   12c91 <e1000_check_options+0x411>
 **/
static void e1000_check_fiber_options(struct e1000_adapter *adapter)
{
	int bd = adapter->bd_number;
	if (num_Speed > bd) {
		e_dev_info("Speed not valid for fiber adapters, parameter "
   12f80:	48 8b 83 b8 03 00 00 	mov    0x3b8(%rbx),%rax
   12f87:	48 c7 c6 00 00 00 00 	mov    $0x0,%rsi
   12f8e:	48 8d b8 98 00 00 00 	lea    0x98(%rax),%rdi
   12f95:	31 c0                	xor    %eax,%eax
   12f97:	e8 00 00 00 00       	callq  12f9c <e1000_check_options+0x71c>
   12f9c:	e9 e3 fc ff ff       	jmpq   12c84 <e1000_check_options+0x404>

Disassembly of section .text.unlikely:

0000000000000000 <e1000_regdump>:
	return NETDEV_TX_OK;
}

#define NUM_REGS 38 /* 1 based count */
static void e1000_regdump(struct e1000_adapter *adapter)
{
   0:	e8 00 00 00 00       	callq  5 <e1000_regdump+0x5>
   5:	55                   	push   %rbp
   6:	48 89 e5             	mov    %rsp,%rbp
   9:	53                   	push   %rbx
   a:	48 81 ec 98 00 00 00 	sub    $0x98,%rsp
		"CTRL_EXT", "ERT", "RDBAL", "RDBAH",
		"TDFH", "TDFT", "TDFHS", "TDFTS", "TDFPC",
		"RDFH", "RDFT", "RDFHS", "RDFTS", "RDFPC"
	};

	regs_buff[0]  = er32(CTRL);
  11:	48 8b 87 c0 03 00 00 	mov    0x3c0(%rdi),%rax
{ asm volatile("mov" size " %0,%1": :reg (val), \
"m" (*(volatile type __force *)addr) barrier); }

build_mmio_read(readb, "b", unsigned char, "=q", :"memory")
build_mmio_read(readw, "w", unsigned short, "=r", :"memory")
build_mmio_read(readl, "l", unsigned int, "=r", :"memory")
  18:	8b 00                	mov    (%rax),%eax
  1a:	89 85 60 ff ff ff    	mov    %eax,-0xa0(%rbp)
	regs_buff[1]  = er32(STATUS);
  20:	48 8b 87 c0 03 00 00 	mov    0x3c0(%rdi),%rax
  27:	8b 40 08             	mov    0x8(%rax),%eax
  2a:	89 85 64 ff ff ff    	mov    %eax,-0x9c(%rbp)

	regs_buff[2]  = er32(RCTL);
  30:	48 8b 87 c0 03 00 00 	mov    0x3c0(%rdi),%rax
  37:	8b 80 00 01 00 00    	mov    0x100(%rax),%eax
	regs_buff[3]  = er32(RDLEN);
  3d:	83 bf d8 03 00 00 03 	cmpl   $0x3,0x3d8(%rdi)
	};

	regs_buff[0]  = er32(CTRL);
	regs_buff[1]  = er32(STATUS);

	regs_buff[2]  = er32(RCTL);
  44:	89 85 68 ff ff ff    	mov    %eax,-0x98(%rbp)
	regs_buff[3]  = er32(RDLEN);
  4a:	48 19 c0             	sbb    %rax,%rax
  4d:	48 25 10 d9 ff ff    	and    $0xffffffffffffd910,%rax
  53:	48 05 08 28 00 00    	add    $0x2808,%rax
  59:	48 03 87 c0 03 00 00 	add    0x3c0(%rdi),%rax
  60:	8b 00                	mov    (%rax),%eax
	regs_buff[4]  = er32(RDH);
  62:	83 bf d8 03 00 00 03 	cmpl   $0x3,0x3d8(%rdi)

	regs_buff[0]  = er32(CTRL);
	regs_buff[1]  = er32(STATUS);

	regs_buff[2]  = er32(RCTL);
	regs_buff[3]  = er32(RDLEN);
  69:	89 85 6c ff ff ff    	mov    %eax,-0x94(%rbp)
	regs_buff[4]  = er32(RDH);
  6f:	48 19 c0             	sbb    %rax,%rax
  72:	48 25 10 d9 ff ff    	and    $0xffffffffffffd910,%rax
  78:	48 05 10 28 00 00    	add    $0x2810,%rax
  7e:	48 03 87 c0 03 00 00 	add    0x3c0(%rdi),%rax
  85:	8b 00                	mov    (%rax),%eax
	regs_buff[5]  = er32(RDT);
  87:	83 bf d8 03 00 00 03 	cmpl   $0x3,0x3d8(%rdi)
	regs_buff[0]  = er32(CTRL);
	regs_buff[1]  = er32(STATUS);

	regs_buff[2]  = er32(RCTL);
	regs_buff[3]  = er32(RDLEN);
	regs_buff[4]  = er32(RDH);
  8e:	89 85 70 ff ff ff    	mov    %eax,-0x90(%rbp)
	regs_buff[5]  = er32(RDT);
  94:	48 19 c0             	sbb    %rax,%rax
  97:	48 25 10 d9 ff ff    	and    $0xffffffffffffd910,%rax
  9d:	48 05 18 28 00 00    	add    $0x2818,%rax
  a3:	48 03 87 c0 03 00 00 	add    0x3c0(%rdi),%rax
  aa:	8b 00                	mov    (%rax),%eax
	regs_buff[6]  = er32(RDTR);
  ac:	83 bf d8 03 00 00 03 	cmpl   $0x3,0x3d8(%rdi)
	regs_buff[1]  = er32(STATUS);

	regs_buff[2]  = er32(RCTL);
	regs_buff[3]  = er32(RDLEN);
	regs_buff[4]  = er32(RDH);
	regs_buff[5]  = er32(RDT);
  b3:	89 85 74 ff ff ff    	mov    %eax,-0x8c(%rbp)
	regs_buff[6]  = er32(RDTR);
  b9:	48 19 c0             	sbb    %rax,%rax
  bc:	48 25 e8 d8 ff ff    	and    $0xffffffffffffd8e8,%rax
  c2:	48 05 20 28 00 00    	add    $0x2820,%rax
  c8:	48 03 87 c0 03 00 00 	add    0x3c0(%rdi),%rax
  cf:	8b 00                	mov    (%rax),%eax
  d1:	89 85 78 ff ff ff    	mov    %eax,-0x88(%rbp)

	regs_buff[7]  = er32(TCTL);
  d7:	48 8b 87 c0 03 00 00 	mov    0x3c0(%rdi),%rax
  de:	8b 80 00 04 00 00    	mov    0x400(%rax),%eax
	regs_buff[8]  = er32(TDBAL);
  e4:	83 bf d8 03 00 00 03 	cmpl   $0x3,0x3d8(%rdi)
	regs_buff[3]  = er32(RDLEN);
	regs_buff[4]  = er32(RDH);
	regs_buff[5]  = er32(RDT);
	regs_buff[6]  = er32(RDTR);

	regs_buff[7]  = er32(TCTL);
  eb:	89 85 7c ff ff ff    	mov    %eax,-0x84(%rbp)
	regs_buff[8]  = er32(TDBAL);
  f1:	48 19 c0             	sbb    %rax,%rax
  f4:	48 25 20 cc ff ff    	and    $0xffffffffffffcc20,%rax
  fa:	48 05 00 38 00 00    	add    $0x3800,%rax
 100:	48 03 87 c0 03 00 00 	add    0x3c0(%rdi),%rax
 107:	8b 00                	mov    (%rax),%eax
	regs_buff[9]  = er32(TDBAH);
 109:	83 bf d8 03 00 00 03 	cmpl   $0x3,0x3d8(%rdi)
	regs_buff[4]  = er32(RDH);
	regs_buff[5]  = er32(RDT);
	regs_buff[6]  = er32(RDTR);

	regs_buff[7]  = er32(TCTL);
	regs_buff[8]  = er32(TDBAL);
 110:	89 45 80             	mov    %eax,-0x80(%rbp)
	regs_buff[9]  = er32(TDBAH);
 113:	48 19 c0             	sbb    %rax,%rax
 116:	48 25 20 cc ff ff    	and    $0xffffffffffffcc20,%rax
 11c:	48 05 04 38 00 00    	add    $0x3804,%rax
 122:	48 03 87 c0 03 00 00 	add    0x3c0(%rdi),%rax
 129:	8b 00                	mov    (%rax),%eax
	regs_buff[10] = er32(TDLEN);
 12b:	83 bf d8 03 00 00 03 	cmpl   $0x3,0x3d8(%rdi)
	regs_buff[5]  = er32(RDT);
	regs_buff[6]  = er32(RDTR);

	regs_buff[7]  = er32(TCTL);
	regs_buff[8]  = er32(TDBAL);
	regs_buff[9]  = er32(TDBAH);
 132:	89 45 84             	mov    %eax,-0x7c(%rbp)
	regs_buff[10] = er32(TDLEN);
 135:	48 19 c0             	sbb    %rax,%rax
 138:	48 25 20 cc ff ff    	and    $0xffffffffffffcc20,%rax
 13e:	48 05 08 38 00 00    	add    $0x3808,%rax
 144:	48 03 87 c0 03 00 00 	add    0x3c0(%rdi),%rax
 14b:	8b 00                	mov    (%rax),%eax
	regs_buff[11] = er32(TDH);
 14d:	83 bf d8 03 00 00 03 	cmpl   $0x3,0x3d8(%rdi)
	regs_buff[6]  = er32(RDTR);

	regs_buff[7]  = er32(TCTL);
	regs_buff[8]  = er32(TDBAL);
	regs_buff[9]  = er32(TDBAH);
	regs_buff[10] = er32(TDLEN);
 154:	89 45 88             	mov    %eax,-0x78(%rbp)
	regs_buff[11] = er32(TDH);
 157:	48 19 c0             	sbb    %rax,%rax
 15a:	48 25 20 cc ff ff    	and    $0xffffffffffffcc20,%rax
 160:	48 05 10 38 00 00    	add    $0x3810,%rax
 166:	48 03 87 c0 03 00 00 	add    0x3c0(%rdi),%rax
 16d:	8b 00                	mov    (%rax),%eax
	regs_buff[12] = er32(TDT);
 16f:	83 bf d8 03 00 00 03 	cmpl   $0x3,0x3d8(%rdi)

	regs_buff[7]  = er32(TCTL);
	regs_buff[8]  = er32(TDBAL);
	regs_buff[9]  = er32(TDBAH);
	regs_buff[10] = er32(TDLEN);
	regs_buff[11] = er32(TDH);
 176:	89 45 8c             	mov    %eax,-0x74(%rbp)
	regs_buff[12] = er32(TDT);
 179:	48 19 c0             	sbb    %rax,%rax
 17c:	48 25 20 cc ff ff    	and    $0xffffffffffffcc20,%rax
 182:	48 05 18 38 00 00    	add    $0x3818,%rax
 188:	48 03 87 c0 03 00 00 	add    0x3c0(%rdi),%rax
 18f:	8b 00                	mov    (%rax),%eax
	regs_buff[13] = er32(TIDV);
 191:	83 bf d8 03 00 00 03 	cmpl   $0x3,0x3d8(%rdi)
	regs_buff[7]  = er32(TCTL);
	regs_buff[8]  = er32(TDBAL);
	regs_buff[9]  = er32(TDBAH);
	regs_buff[10] = er32(TDLEN);
	regs_buff[11] = er32(TDH);
	regs_buff[12] = er32(TDT);
 198:	89 45 90             	mov    %eax,-0x70(%rbp)
	regs_buff[13] = er32(TIDV);
 19b:	48 19 c0             	sbb    %rax,%rax
 19e:	48 25 20 cc ff ff    	and    $0xffffffffffffcc20,%rax
 1a4:	48 05 20 38 00 00    	add    $0x3820,%rax
 1aa:	48 03 87 c0 03 00 00 	add    0x3c0(%rdi),%rax
 1b1:	8b 00                	mov    (%rax),%eax
 1b3:	89 45 94             	mov    %eax,-0x6c(%rbp)
	regs_buff[14] = er32(TXDCTL);
 1b6:	48 8b 87 c0 03 00 00 	mov    0x3c0(%rdi),%rax
 1bd:	8b 80 28 38 00 00    	mov    0x3828(%rax),%eax
 1c3:	89 45 98             	mov    %eax,-0x68(%rbp)
	regs_buff[15] = er32(TADV);
 1c6:	48 8b 87 c0 03 00 00 	mov    0x3c0(%rdi),%rax
 1cd:	8b 80 2c 38 00 00    	mov    0x382c(%rax),%eax
 1d3:	89 45 9c             	mov    %eax,-0x64(%rbp)
	regs_buff[16] = er32(TARC0);
 1d6:	48 8b 87 c0 03 00 00 	mov    0x3c0(%rdi),%rax
 1dd:	8b 80 40 38 00 00    	mov    0x3840(%rax),%eax
 1e3:	89 45 a0             	mov    %eax,-0x60(%rbp)

	regs_buff[17] = er32(TDBAL1);
 1e6:	48 8b 87 c0 03 00 00 	mov    0x3c0(%rdi),%rax
 1ed:	8b 80 00 39 00 00    	mov    0x3900(%rax),%eax
 1f3:	89 45 a4             	mov    %eax,-0x5c(%rbp)
	regs_buff[18] = er32(TDBAH1);
 1f6:	48 8b 87 c0 03 00 00 	mov    0x3c0(%rdi),%rax
 1fd:	8b 80 04 39 00 00    	mov    0x3904(%rax),%eax
 203:	89 45 a8             	mov    %eax,-0x58(%rbp)
	regs_buff[19] = er32(TDLEN1);
 206:	48 8b 87 c0 03 00 00 	mov    0x3c0(%rdi),%rax
 20d:	8b 80 08 39 00 00    	mov    0x3908(%rax),%eax
 213:	89 45 ac             	mov    %eax,-0x54(%rbp)
	regs_buff[20] = er32(TDH1);
 216:	48 8b 87 c0 03 00 00 	mov    0x3c0(%rdi),%rax
 21d:	8b 80 10 39 00 00    	mov    0x3910(%rax),%eax
 223:	89 45 b0             	mov    %eax,-0x50(%rbp)
	regs_buff[21] = er32(TDT1);
 226:	48 8b 87 c0 03 00 00 	mov    0x3c0(%rdi),%rax
 22d:	8b 80 18 39 00 00    	mov    0x3918(%rax),%eax
 233:	89 45 b4             	mov    %eax,-0x4c(%rbp)
	regs_buff[22] = er32(TXDCTL1);
 236:	48 8b 87 c0 03 00 00 	mov    0x3c0(%rdi),%rax
 23d:	8b 80 28 39 00 00    	mov    0x3928(%rax),%eax
 243:	89 45 b8             	mov    %eax,-0x48(%rbp)
	regs_buff[23] = er32(TARC1);
 246:	48 8b 87 c0 03 00 00 	mov    0x3c0(%rdi),%rax
 24d:	8b 80 40 39 00 00    	mov    0x3940(%rax),%eax
 253:	89 45 bc             	mov    %eax,-0x44(%rbp)
	regs_buff[24] = er32(CTRL_EXT);
 256:	48 8b 87 c0 03 00 00 	mov    0x3c0(%rdi),%rax
 25d:	8b 40 18             	mov    0x18(%rax),%eax
 260:	89 45 c0             	mov    %eax,-0x40(%rbp)
	regs_buff[25] = er32(ERT);
 263:	48 8b 87 c0 03 00 00 	mov    0x3c0(%rdi),%rax
 26a:	8b 80 08 20 00 00    	mov    0x2008(%rax),%eax
	regs_buff[26] = er32(RDBAL0);
 270:	83 bf d8 03 00 00 03 	cmpl   $0x3,0x3d8(%rdi)
	regs_buff[20] = er32(TDH1);
	regs_buff[21] = er32(TDT1);
	regs_buff[22] = er32(TXDCTL1);
	regs_buff[23] = er32(TARC1);
	regs_buff[24] = er32(CTRL_EXT);
	regs_buff[25] = er32(ERT);
 277:	89 45 c4             	mov    %eax,-0x3c(%rbp)
	regs_buff[26] = er32(RDBAL0);
 27a:	48 19 c0             	sbb    %rax,%rax
 27d:	48 25 10 d9 ff ff    	and    $0xffffffffffffd910,%rax
 283:	48 05 00 28 00 00    	add    $0x2800,%rax
 289:	48 03 87 c0 03 00 00 	add    0x3c0(%rdi),%rax
 290:	8b 00                	mov    (%rax),%eax
	regs_buff[27] = er32(RDBAH0);
 292:	83 bf d8 03 00 00 03 	cmpl   $0x3,0x3d8(%rdi)
	regs_buff[21] = er32(TDT1);
	regs_buff[22] = er32(TXDCTL1);
	regs_buff[23] = er32(TARC1);
	regs_buff[24] = er32(CTRL_EXT);
	regs_buff[25] = er32(ERT);
	regs_buff[26] = er32(RDBAL0);
 299:	89 45 c8             	mov    %eax,-0x38(%rbp)
	regs_buff[27] = er32(RDBAH0);
 29c:	48 19 c0             	sbb    %rax,%rax
 29f:	48 25 10 d9 ff ff    	and    $0xffffffffffffd910,%rax
 2a5:	48 05 04 28 00 00    	add    $0x2804,%rax
 2ab:	48 03 87 c0 03 00 00 	add    0x3c0(%rdi),%rax
 2b2:	8b 00                	mov    (%rax),%eax
	regs_buff[28] = er32(TDFH);
 2b4:	83 bf d8 03 00 00 03 	cmpl   $0x3,0x3d8(%rdi)
	regs_buff[22] = er32(TXDCTL1);
	regs_buff[23] = er32(TARC1);
	regs_buff[24] = er32(CTRL_EXT);
	regs_buff[25] = er32(ERT);
	regs_buff[26] = er32(RDBAL0);
	regs_buff[27] = er32(RDBAH0);
 2bb:	89 45 cc             	mov    %eax,-0x34(%rbp)
	regs_buff[28] = er32(TDFH);
 2be:	48 19 c0             	sbb    %rax,%rax
 2c1:	25 00 4c 00 00       	and    $0x4c00,%eax
 2c6:	48 05 10 34 00 00    	add    $0x3410,%rax
 2cc:	48 03 87 c0 03 00 00 	add    0x3c0(%rdi),%rax
 2d3:	8b 00                	mov    (%rax),%eax
	regs_buff[29] = er32(TDFT);
 2d5:	83 bf d8 03 00 00 03 	cmpl   $0x3,0x3d8(%rdi)
	regs_buff[23] = er32(TARC1);
	regs_buff[24] = er32(CTRL_EXT);
	regs_buff[25] = er32(ERT);
	regs_buff[26] = er32(RDBAL0);
	regs_buff[27] = er32(RDBAH0);
	regs_buff[28] = er32(TDFH);
 2dc:	89 45 d0             	mov    %eax,-0x30(%rbp)
	regs_buff[29] = er32(TDFT);
 2df:	48 19 c0             	sbb    %rax,%rax
 2e2:	25 00 4c 00 00       	and    $0x4c00,%eax
 2e7:	48 05 18 34 00 00    	add    $0x3418,%rax
 2ed:	48 03 87 c0 03 00 00 	add    0x3c0(%rdi),%rax
 2f4:	8b 00                	mov    (%rax),%eax
 2f6:	89 45 d4             	mov    %eax,-0x2c(%rbp)
	regs_buff[30] = er32(TDFHS);
 2f9:	48 8b 87 c0 03 00 00 	mov    0x3c0(%rdi),%rax
 300:	8b 80 20 34 00 00    	mov    0x3420(%rax),%eax
 306:	89 45 d8             	mov    %eax,-0x28(%rbp)
	regs_buff[31] = er32(TDFTS);
 309:	48 8b 87 c0 03 00 00 	mov    0x3c0(%rdi),%rax
 310:	8b 80 28 34 00 00    	mov    0x3428(%rax),%eax
 316:	89 45 dc             	mov    %eax,-0x24(%rbp)
	regs_buff[32] = er32(TDFPC);
 319:	48 8b 87 c0 03 00 00 	mov    0x3c0(%rdi),%rax
 320:	8b 80 30 34 00 00    	mov    0x3430(%rax),%eax
 326:	89 45 e0             	mov    %eax,-0x20(%rbp)
	regs_buff[33] = er32(RDFH);
 329:	48 8b 87 c0 03 00 00 	mov    0x3c0(%rdi),%rax
 330:	8b 80 10 24 00 00    	mov    0x2410(%rax),%eax
 336:	89 45 e4             	mov    %eax,-0x1c(%rbp)
	regs_buff[34] = er32(RDFT);
 339:	48 8b 87 c0 03 00 00 	mov    0x3c0(%rdi),%rax
 340:	8b 80 18 24 00 00    	mov    0x2418(%rax),%eax
 346:	89 45 e8             	mov    %eax,-0x18(%rbp)
	regs_buff[35] = er32(RDFHS);
 349:	48 8b 87 c0 03 00 00 	mov    0x3c0(%rdi),%rax
 350:	8b 80 20 24 00 00    	mov    0x2420(%rax),%eax
 356:	89 45 ec             	mov    %eax,-0x14(%rbp)
	regs_buff[36] = er32(RDFTS);
 359:	48 8b 87 c0 03 00 00 	mov    0x3c0(%rdi),%rax
 360:	8b 80 28 24 00 00    	mov    0x2428(%rax),%eax
 366:	89 45 f0             	mov    %eax,-0x10(%rbp)
	regs_buff[37] = er32(RDFPC);
 369:	48 8b 87 c0 03 00 00 	mov    0x3c0(%rdi),%rax
 370:	8b 80 30 24 00 00    	mov    0x2430(%rax),%eax

	pr_info("Register dump\n");
 376:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
	regs_buff[32] = er32(TDFPC);
	regs_buff[33] = er32(RDFH);
	regs_buff[34] = er32(RDFT);
	regs_buff[35] = er32(RDFHS);
	regs_buff[36] = er32(RDFTS);
	regs_buff[37] = er32(RDFPC);
 37d:	89 45 f4             	mov    %eax,-0xc(%rbp)

	pr_info("Register dump\n");
 380:	31 db                	xor    %ebx,%ebx
 382:	31 c0                	xor    %eax,%eax
 384:	e8 00 00 00 00       	callq  389 <e1000_regdump+0x389>
	for (i = 0; i < NUM_REGS; i++)
		pr_info("%-15s  %08x\n", reg_name[i], regs_buff[i]);
 389:	8b 94 1d 60 ff ff ff 	mov    -0xa0(%rbp,%rbx,1),%edx
 390:	48 8b b4 1b 00 00 00 	mov    0x0(%rbx,%rbx,1),%rsi
 397:	00 
 398:	31 c0                	xor    %eax,%eax
 39a:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
 3a1:	48 83 c3 04          	add    $0x4,%rbx
 3a5:	e8 00 00 00 00       	callq  3aa <e1000_regdump+0x3aa>
	regs_buff[35] = er32(RDFHS);
	regs_buff[36] = er32(RDFTS);
	regs_buff[37] = er32(RDFPC);

	pr_info("Register dump\n");
	for (i = 0; i < NUM_REGS; i++)
 3aa:	48 81 fb 98 00 00 00 	cmp    $0x98,%rbx
 3b1:	75 d6                	jne    389 <e1000_regdump+0x389>
		pr_info("%-15s  %08x\n", reg_name[i], regs_buff[i]);
}
 3b3:	48 81 c4 98 00 00 00 	add    $0x98,%rsp
 3ba:	5b                   	pop    %rbx
 3bb:	5d                   	pop    %rbp
 3bc:	c3                   	retq   

00000000000003bd <__e1000_maybe_stop_tx>:
		adapter->tx_fifo_head -= adapter->tx_fifo_size;
	return 0;
}

static int __e1000_maybe_stop_tx(struct net_device *netdev, int size)
{
 3bd:	e8 00 00 00 00       	callq  3c2 <__e1000_maybe_stop_tx+0x5>
 3c2:	55                   	push   %rbp
	struct e1000_adapter *adapter = netdev_priv(netdev);
	struct e1000_tx_ring *tx_ring = adapter->tx_ring;
 3c3:	48 8b 97 80 0a 00 00 	mov    0xa80(%rdi),%rdx
static __always_inline void
set_bit(long nr, volatile unsigned long *addr)
{
	if (IS_IMMEDIATE(nr)) {
		asm volatile(LOCK_PREFIX "orb %1,%0"
			: CONST_MASK_ADDR(nr, addr)
 3ca:	48 8b 87 c0 03 00 00 	mov    0x3c0(%rdi),%rax
		adapter->tx_fifo_head -= adapter->tx_fifo_size;
	return 0;
}

static int __e1000_maybe_stop_tx(struct net_device *netdev, int size)
{
 3d1:	48 89 e5             	mov    %rsp,%rbp
 */
static __always_inline void
set_bit(long nr, volatile unsigned long *addr)
{
	if (IS_IMMEDIATE(nr)) {
		asm volatile(LOCK_PREFIX "orb %1,%0"
 3d4:	f0 80 88 98 00 00 00 	lock orb $0x1,0x98(%rax)
 3db:	01 
	netif_stop_queue(netdev);
	/* Herbert's original patch had:
	 *  smp_mb__after_netif_stop_queue();
	 * but since that doesn't exist yet, just open code it.
	 */
	smp_mb();
 3dc:	0f ae f0             	mfence 

	/* We need to check again in a case another CPU has just
	 * made room available.
	 */
	if (likely(E1000_DESC_UNUSED(tx_ring) < size))
 3df:	8b 42 1c             	mov    0x1c(%rdx),%eax
 3e2:	8b 4a 18             	mov    0x18(%rdx),%ecx
 3e5:	45 31 c0             	xor    %r8d,%r8d
 3e8:	39 c8                	cmp    %ecx,%eax
 3ea:	77 04                	ja     3f0 <__e1000_maybe_stop_tx+0x33>
 3ec:	44 8b 42 14          	mov    0x14(%rdx),%r8d
 3f0:	ff c8                	dec    %eax
 3f2:	29 c8                	sub    %ecx,%eax
 3f4:	41 01 c0             	add    %eax,%r8d
		return -EBUSY;
 3f7:	b8 f0 ff ff ff       	mov    $0xfffffff0,%eax
	smp_mb();

	/* We need to check again in a case another CPU has just
	 * made room available.
	 */
	if (likely(E1000_DESC_UNUSED(tx_ring) < size))
 3fc:	41 39 f0             	cmp    %esi,%r8d
 3ff:	72 17                	jb     418 <__e1000_maybe_stop_tx+0x5b>
static __always_inline void
clear_bit(long nr, volatile unsigned long *addr)
{
	if (IS_IMMEDIATE(nr)) {
		asm volatile(LOCK_PREFIX "andb %1,%0"
			: CONST_MASK_ADDR(nr, addr)
 401:	48 8b 87 c0 03 00 00 	mov    0x3c0(%rdi),%rax
 */
static __always_inline void
clear_bit(long nr, volatile unsigned long *addr)
{
	if (IS_IMMEDIATE(nr)) {
		asm volatile(LOCK_PREFIX "andb %1,%0"
 408:	f0 80 a0 98 00 00 00 	lock andb $0xfe,0x98(%rax)
 40f:	fe 
		return -EBUSY;

	/* A reprieve! */
	netif_start_queue(netdev);
	++adapter->restart_queue;
 410:	ff 87 88 0a 00 00    	incl   0xa88(%rdi)
	return 0;
 416:	31 c0                	xor    %eax,%eax
}
 418:	5d                   	pop    %rbp
 419:	c3                   	retq   

000000000000041a <dma_unmap_single_attrs.part.43>:
			   (unsigned long)ptr & ~PAGE_MASK, size,
			   dir, addr, true);
	return addr;
}

static inline void dma_unmap_single_attrs(struct device *dev, dma_addr_t addr,
 41a:	55                   	push   %rbp
 41b:	48 89 e5             	mov    %rsp,%rbp
					  enum dma_data_direction dir,
					  struct dma_attrs *attrs)
{
	struct dma_map_ops *ops = get_dma_ops(dev);

	BUG_ON(!valid_dma_direction(dir));
 41e:	0f 0b                	ud2    

0000000000000420 <dma_unmap_page.part.44>:
	debug_dma_map_page(dev, page, offset, size, dir, addr, false);

	return addr;
}

static inline void dma_unmap_page(struct device *dev, dma_addr_t addr,
 420:	55                   	push   %rbp
 421:	48 89 e5             	mov    %rsp,%rbp
				  size_t size, enum dma_data_direction dir)
{
	struct dma_map_ops *ops = get_dma_ops(dev);

	BUG_ON(!valid_dma_direction(dir));
 424:	0f 0b                	ud2    

0000000000000426 <dma_map_single_attrs.part.45>:
#include <linux/scatterlist.h>
#include <linux/dma-debug.h>
#include <linux/dma-attrs.h>
#include <asm-generic/dma-coherent.h>

static inline dma_addr_t dma_map_single_attrs(struct device *dev, void *ptr,
 426:	55                   	push   %rbp
 427:	48 89 e5             	mov    %rsp,%rbp
{
	struct dma_map_ops *ops = get_dma_ops(dev);
	dma_addr_t addr;

	kmemcheck_mark_initialized(ptr, size);
	BUG_ON(!valid_dma_direction(dir));
 42a:	0f 0b                	ud2    

000000000000042c <dma_map_page.part.46>:
	debug_dma_unmap_sg(dev, sg, nents, dir);
	if (ops->unmap_sg)
		ops->unmap_sg(dev, sg, nents, dir, attrs);
}

static inline dma_addr_t dma_map_page(struct device *dev, struct page *page,
 42c:	55                   	push   %rbp
 42d:	48 89 e5             	mov    %rsp,%rbp
{
	struct dma_map_ops *ops = get_dma_ops(dev);
	dma_addr_t addr;

	kmemcheck_mark_initialized(page_address(page) + offset, size);
	BUG_ON(!valid_dma_direction(dir));
 430:	0f 0b                	ud2    

0000000000000432 <napi_enable.part.48>:
 *	@n: napi context
 *
 * Resume NAPI from being scheduled on this context.
 * Must be paired with napi_disable.
 */
static inline void napi_enable(struct napi_struct *n)
 432:	55                   	push   %rbp
 433:	48 89 e5             	mov    %rsp,%rbp
{
	BUG_ON(!test_bit(NAPI_STATE_SCHED, &n->state));
 436:	0f 0b                	ud2    

0000000000000438 <skb_fill_page_desc.constprop.63>:
 * @skb to point to @size bytes at offset @off within @page. In
 * addition updates @skb such that @i is the last fragment.
 *
 * Does not take any additional reference on the fragment.
 */
static inline void skb_fill_page_desc(struct sk_buff *skb, int i,
 438:	55                   	push   %rbp
}

#ifdef NET_SKBUFF_DATA_USES_OFFSET
static inline unsigned char *skb_end_pointer(const struct sk_buff *skb)
{
	return skb->head + skb->end;
 439:	44 8b 87 cc 00 00 00 	mov    0xcc(%rdi),%r8d
 * Does not take any additional reference on the fragment.
 */
static inline void __skb_fill_page_desc(struct sk_buff *skb, int i,
					struct page *page, int off, int size)
{
	skb_frag_t *frag = &skb_shinfo(skb)->frags[i];
 440:	48 63 c6             	movslq %esi,%rax
}

#ifdef NET_SKBUFF_DATA_USES_OFFSET
static inline unsigned char *skb_end_pointer(const struct sk_buff *skb)
{
	return skb->head + skb->end;
 443:	4c 03 87 d0 00 00 00 	add    0xd0(%rdi),%r8
 * Does not take any additional reference on the fragment.
 */
static inline void __skb_fill_page_desc(struct sk_buff *skb, int i,
					struct page *page, int off, int size)
{
	skb_frag_t *frag = &skb_shinfo(skb)->frags[i];
 44a:	48 83 c0 03          	add    $0x3,%rax
 44e:	48 c1 e0 04          	shl    $0x4,%rax
 * @skb to point to @size bytes at offset @off within @page. In
 * addition updates @skb such that @i is the last fragment.
 *
 * Does not take any additional reference on the fragment.
 */
static inline void skb_fill_page_desc(struct sk_buff *skb, int i,
 452:	48 89 e5             	mov    %rsp,%rbp
 * Does not take any additional reference on the fragment.
 */
static inline void __skb_fill_page_desc(struct sk_buff *skb, int i,
					struct page *page, int off, int size)
{
	skb_frag_t *frag = &skb_shinfo(skb)->frags[i];
 455:	4c 01 c0             	add    %r8,%rax
	/*
	 * Propagate page pfmemalloc to the skb if we can. The problem is
	 * that not all callers have unique ownership of the page but rely
	 * on page_is_pfmemalloc doing the right thing(tm).
	 */
	frag->page.p		  = page;
 458:	48 89 10             	mov    %rdx,(%rax)
	frag->page_offset	  = off;
 45b:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%rax)
	return frag->size;
}

static inline void skb_frag_size_set(skb_frag_t *frag, unsigned int size)
{
	frag->size = size;
 462:	89 48 0c             	mov    %ecx,0xc(%rax)
})

static __always_inline
void __read_once_size(const volatile void *p, void *res, int size)
{
	__READ_ONCE_SIZE;
 465:	48 8b 4a 20          	mov    0x20(%rdx),%rcx
static inline struct page *compound_head(struct page *page)
{
	unsigned long head = READ_ONCE(page->compound_head);

	if (unlikely(head & 1))
		return (struct page *) (head - 1);
 469:	48 8d 41 ff          	lea    -0x1(%rcx),%rax
 46d:	80 e1 01             	and    $0x1,%cl
 470:	48 0f 44 c2          	cmove  %rdx,%rax
	frag->page.p		  = page;
	frag->page_offset	  = off;
	skb_frag_size_set(frag, size);

	page = compound_head(page);
	if (page_is_pfmemalloc(page))
 474:	48 83 78 10 ff       	cmpq   $0xffffffffffffffff,0x10(%rax)
 479:	75 07                	jne    482 <skb_fill_page_desc.constprop.63+0x4a>
		skb->pfmemalloc	= true;
 47b:	80 8f 90 00 00 00 08 	orb    $0x8,0x90(%rdi)
}

#ifdef NET_SKBUFF_DATA_USES_OFFSET
static inline unsigned char *skb_end_pointer(const struct sk_buff *skb)
{
	return skb->head + skb->end;
 482:	8b 87 cc 00 00 00    	mov    0xcc(%rdi),%eax
 */
static inline void skb_fill_page_desc(struct sk_buff *skb, int i,
				      struct page *page, int off, int size)
{
	__skb_fill_page_desc(skb, i, page, off, size);
	skb_shinfo(skb)->nr_frags = i + 1;
 488:	48 8b 97 d0 00 00 00 	mov    0xd0(%rdi),%rdx
 48f:	ff c6                	inc    %esi
 491:	40 88 34 02          	mov    %sil,(%rdx,%rax,1)
}
 495:	5d                   	pop    %rbp
 496:	c3                   	retq   

0000000000000497 <e1000_polarity_reversal_workaround>:

static s32 e1000_polarity_reversal_workaround(struct e1000_hw *hw)
{
 497:	e8 00 00 00 00       	callq  49c <e1000_polarity_reversal_workaround+0x5>
 49c:	55                   	push   %rbp

	/* Polarity reversal workaround for forced 10F/10H links. */

	/* Disable the transmitter on the PHY */

	ret_val = e1000_write_phy_reg(hw, M88E1000_PHY_PAGE_SELECT, 0x0019);
 49d:	ba 19 00 00 00       	mov    $0x19,%edx
 4a2:	be 1d 00 00 00       	mov    $0x1d,%esi
	}
	return false;
}

static s32 e1000_polarity_reversal_workaround(struct e1000_hw *hw)
{
 4a7:	48 89 e5             	mov    %rsp,%rbp
 4aa:	41 54                	push   %r12
 4ac:	53                   	push   %rbx
 4ad:	48 89 fb             	mov    %rdi,%rbx
 4b0:	51                   	push   %rcx

	/* Polarity reversal workaround for forced 10F/10H links. */

	/* Disable the transmitter on the PHY */

	ret_val = e1000_write_phy_reg(hw, M88E1000_PHY_PAGE_SELECT, 0x0019);
 4b1:	e8 00 00 00 00       	callq  4b6 <e1000_polarity_reversal_workaround+0x1f>
	if (ret_val)
 4b6:	85 c0                	test   %eax,%eax
 4b8:	0f 85 6c 01 00 00    	jne    62a <e1000_polarity_reversal_workaround+0x193>
		return ret_val;
	ret_val = e1000_write_phy_reg(hw, M88E1000_PHY_GEN_CONTROL, 0xFFFF);
 4be:	ba ff ff 00 00       	mov    $0xffff,%edx
 4c3:	be 1e 00 00 00       	mov    $0x1e,%esi
 4c8:	48 89 df             	mov    %rbx,%rdi
 4cb:	e8 00 00 00 00       	callq  4d0 <e1000_polarity_reversal_workaround+0x39>
	if (ret_val)
 4d0:	85 c0                	test   %eax,%eax
 4d2:	0f 85 52 01 00 00    	jne    62a <e1000_polarity_reversal_workaround+0x193>
		return ret_val;

	ret_val = e1000_write_phy_reg(hw, M88E1000_PHY_PAGE_SELECT, 0x0000);
 4d8:	31 d2                	xor    %edx,%edx
 4da:	be 1d 00 00 00       	mov    $0x1d,%esi
 4df:	48 89 df             	mov    %rbx,%rdi
 4e2:	e8 00 00 00 00       	callq  4e7 <e1000_polarity_reversal_workaround+0x50>
	if (ret_val)
 4e7:	85 c0                	test   %eax,%eax
 4e9:	0f 85 3b 01 00 00    	jne    62a <e1000_polarity_reversal_workaround+0x193>
 4ef:	41 bc 14 00 00 00    	mov    $0x14,%r12d
	for (i = PHY_FORCE_TIME; i > 0; i--) {
		/* Read the MII Status Register and wait for Link Status bit
		 * to be clear.
		 */

		ret_val = e1000_read_phy_reg(hw, PHY_STATUS, &mii_status_reg);
 4f5:	48 8d 55 ee          	lea    -0x12(%rbp),%rdx
 4f9:	be 01 00 00 00       	mov    $0x1,%esi
 4fe:	48 89 df             	mov    %rbx,%rdi
 501:	e8 00 00 00 00       	callq  506 <e1000_polarity_reversal_workaround+0x6f>
		if (ret_val)
 506:	85 c0                	test   %eax,%eax
 508:	0f 85 1c 01 00 00    	jne    62a <e1000_polarity_reversal_workaround+0x193>
			return ret_val;

		ret_val = e1000_read_phy_reg(hw, PHY_STATUS, &mii_status_reg);
 50e:	48 8d 55 ee          	lea    -0x12(%rbp),%rdx
 512:	be 01 00 00 00       	mov    $0x1,%esi
 517:	48 89 df             	mov    %rbx,%rdi
 51a:	e8 00 00 00 00       	callq  51f <e1000_polarity_reversal_workaround+0x88>
		if (ret_val)
 51f:	85 c0                	test   %eax,%eax
 521:	0f 85 03 01 00 00    	jne    62a <e1000_polarity_reversal_workaround+0x193>
			return ret_val;

		if ((mii_status_reg & ~MII_SR_LINK_STATUS) == 0)
 527:	0f b7 45 ee          	movzwl -0x12(%rbp),%eax
 52b:	a9 fb ff 00 00       	test   $0xfffb,%eax
 530:	75 26                	jne    558 <e1000_polarity_reversal_workaround+0xc1>
			break;
		msleep(100);
	}

	/* Recommended delay time after link has been lost */
	msleep(1000);
 532:	bf e8 03 00 00       	mov    $0x3e8,%edi
 537:	e8 00 00 00 00       	callq  53c <e1000_polarity_reversal_workaround+0xa5>

	/* Now we will re-enable th transmitter on the PHY */

	ret_val = e1000_write_phy_reg(hw, M88E1000_PHY_PAGE_SELECT, 0x0019);
 53c:	ba 19 00 00 00       	mov    $0x19,%edx
 541:	be 1d 00 00 00       	mov    $0x1d,%esi
 546:	48 89 df             	mov    %rbx,%rdi
 549:	e8 00 00 00 00       	callq  54e <e1000_polarity_reversal_workaround+0xb7>
	if (ret_val)
 54e:	85 c0                	test   %eax,%eax
 550:	0f 85 d4 00 00 00    	jne    62a <e1000_polarity_reversal_workaround+0x193>
 556:	eb 12                	jmp    56a <e1000_polarity_reversal_workaround+0xd3>
		if (ret_val)
			return ret_val;

		if ((mii_status_reg & ~MII_SR_LINK_STATUS) == 0)
			break;
		msleep(100);
 558:	bf 64 00 00 00       	mov    $0x64,%edi
 55d:	e8 00 00 00 00       	callq  562 <e1000_polarity_reversal_workaround+0xcb>
	ret_val = e1000_write_phy_reg(hw, M88E1000_PHY_PAGE_SELECT, 0x0000);
	if (ret_val)
		return ret_val;

	/* This loop will early-out if the NO link condition has been met. */
	for (i = PHY_FORCE_TIME; i > 0; i--) {
 562:	66 41 ff cc          	dec    %r12w
 566:	75 8d                	jne    4f5 <e1000_polarity_reversal_workaround+0x5e>
 568:	eb c8                	jmp    532 <e1000_polarity_reversal_workaround+0x9b>
	/* Now we will re-enable th transmitter on the PHY */

	ret_val = e1000_write_phy_reg(hw, M88E1000_PHY_PAGE_SELECT, 0x0019);
	if (ret_val)
		return ret_val;
	msleep(50);
 56a:	bf 32 00 00 00       	mov    $0x32,%edi
 56f:	e8 00 00 00 00       	callq  574 <e1000_polarity_reversal_workaround+0xdd>
	ret_val = e1000_write_phy_reg(hw, M88E1000_PHY_GEN_CONTROL, 0xFFF0);
 574:	ba f0 ff 00 00       	mov    $0xfff0,%edx
 579:	be 1e 00 00 00       	mov    $0x1e,%esi
 57e:	48 89 df             	mov    %rbx,%rdi
 581:	e8 00 00 00 00       	callq  586 <e1000_polarity_reversal_workaround+0xef>
	if (ret_val)
 586:	85 c0                	test   %eax,%eax
 588:	0f 85 9c 00 00 00    	jne    62a <e1000_polarity_reversal_workaround+0x193>
		return ret_val;
	msleep(50);
 58e:	bf 32 00 00 00       	mov    $0x32,%edi
 593:	e8 00 00 00 00       	callq  598 <e1000_polarity_reversal_workaround+0x101>
	ret_val = e1000_write_phy_reg(hw, M88E1000_PHY_GEN_CONTROL, 0xFF00);
 598:	ba 00 ff 00 00       	mov    $0xff00,%edx
 59d:	be 1e 00 00 00       	mov    $0x1e,%esi
 5a2:	48 89 df             	mov    %rbx,%rdi
 5a5:	e8 00 00 00 00       	callq  5aa <e1000_polarity_reversal_workaround+0x113>
	if (ret_val)
 5aa:	85 c0                	test   %eax,%eax
 5ac:	75 7c                	jne    62a <e1000_polarity_reversal_workaround+0x193>
		return ret_val;
	msleep(50);
 5ae:	bf 32 00 00 00       	mov    $0x32,%edi
 5b3:	e8 00 00 00 00       	callq  5b8 <e1000_polarity_reversal_workaround+0x121>
	ret_val = e1000_write_phy_reg(hw, M88E1000_PHY_GEN_CONTROL, 0x0000);
 5b8:	31 d2                	xor    %edx,%edx
 5ba:	be 1e 00 00 00       	mov    $0x1e,%esi
 5bf:	48 89 df             	mov    %rbx,%rdi
 5c2:	e8 00 00 00 00       	callq  5c7 <e1000_polarity_reversal_workaround+0x130>
	if (ret_val)
 5c7:	85 c0                	test   %eax,%eax
 5c9:	75 5f                	jne    62a <e1000_polarity_reversal_workaround+0x193>
		return ret_val;

	ret_val = e1000_write_phy_reg(hw, M88E1000_PHY_PAGE_SELECT, 0x0000);
 5cb:	31 d2                	xor    %edx,%edx
 5cd:	be 1d 00 00 00       	mov    $0x1d,%esi
 5d2:	48 89 df             	mov    %rbx,%rdi
 5d5:	e8 00 00 00 00       	callq  5da <e1000_polarity_reversal_workaround+0x143>
	if (ret_val)
 5da:	85 c0                	test   %eax,%eax
 5dc:	75 4c                	jne    62a <e1000_polarity_reversal_workaround+0x193>
 5de:	41 bc 14 00 00 00    	mov    $0x14,%r12d
	for (i = PHY_FORCE_TIME; i > 0; i--) {
		/* Read the MII Status Register and wait for Link Status bit
		 * to be set.
		 */

		ret_val = e1000_read_phy_reg(hw, PHY_STATUS, &mii_status_reg);
 5e4:	48 8d 55 ee          	lea    -0x12(%rbp),%rdx
 5e8:	be 01 00 00 00       	mov    $0x1,%esi
 5ed:	48 89 df             	mov    %rbx,%rdi
 5f0:	e8 00 00 00 00       	callq  5f5 <e1000_polarity_reversal_workaround+0x15e>
		if (ret_val)
 5f5:	85 c0                	test   %eax,%eax
 5f7:	75 31                	jne    62a <e1000_polarity_reversal_workaround+0x193>
			return ret_val;

		ret_val = e1000_read_phy_reg(hw, PHY_STATUS, &mii_status_reg);
 5f9:	48 8d 55 ee          	lea    -0x12(%rbp),%rdx
 5fd:	be 01 00 00 00       	mov    $0x1,%esi
 602:	48 89 df             	mov    %rbx,%rdi
 605:	e8 00 00 00 00       	callq  60a <e1000_polarity_reversal_workaround+0x173>
		if (ret_val)
 60a:	85 c0                	test   %eax,%eax
 60c:	75 1c                	jne    62a <e1000_polarity_reversal_workaround+0x193>
			return ret_val;

		if (mii_status_reg & MII_SR_LINK_STATUS)
 60e:	f6 45 ee 04          	testb  $0x4,-0x12(%rbp)
 612:	74 04                	je     618 <e1000_polarity_reversal_workaround+0x181>
			break;
		msleep(100);
	}
	return E1000_SUCCESS;
 614:	31 c0                	xor    %eax,%eax
 616:	eb 12                	jmp    62a <e1000_polarity_reversal_workaround+0x193>
		if (ret_val)
			return ret_val;

		if (mii_status_reg & MII_SR_LINK_STATUS)
			break;
		msleep(100);
 618:	bf 64 00 00 00       	mov    $0x64,%edi
 61d:	e8 00 00 00 00       	callq  622 <e1000_polarity_reversal_workaround+0x18b>
	ret_val = e1000_write_phy_reg(hw, M88E1000_PHY_PAGE_SELECT, 0x0000);
	if (ret_val)
		return ret_val;

	/* This loop will early-out if the link condition has been met. */
	for (i = PHY_FORCE_TIME; i > 0; i--) {
 622:	66 41 ff cc          	dec    %r12w
 626:	75 bc                	jne    5e4 <e1000_polarity_reversal_workaround+0x14d>
 628:	eb ea                	jmp    614 <e1000_polarity_reversal_workaround+0x17d>
		if (mii_status_reg & MII_SR_LINK_STATUS)
			break;
		msleep(100);
	}
	return E1000_SUCCESS;
}
 62a:	5a                   	pop    %rdx
 62b:	5b                   	pop    %rbx
 62c:	41 5c                	pop    %r12
 62e:	5d                   	pop    %rbp
 62f:	c3                   	retq   

0000000000000630 <reg_set_and_check>:
	return false;
}

static bool reg_set_and_check(struct e1000_adapter *adapter, u64 *data, int reg,
			      u32 mask, u32 write)
{
 630:	e8 00 00 00 00       	callq  635 <reg_set_and_check+0x5>
 635:	55                   	push   %rbp
 636:	48 89 e5             	mov    %rsp,%rbp
 639:	41 54                	push   %r12
 63b:	49 89 f4             	mov    %rsi,%r12
	struct e1000_hw *hw = &adapter->hw;
	u8 __iomem *address = hw->hw_addr + reg;
	u32 read;

	writel(write & mask, address);
 63e:	44 89 c6             	mov    %r8d,%esi
	return false;
}

static bool reg_set_and_check(struct e1000_adapter *adapter, u64 *data, int reg,
			      u32 mask, u32 write)
{
 641:	53                   	push   %rbx
	struct e1000_hw *hw = &adapter->hw;
	u8 __iomem *address = hw->hw_addr + reg;
 642:	48 63 da             	movslq %edx,%rbx
	u32 read;

	writel(write & mask, address);
 645:	21 ce                	and    %ecx,%esi

static bool reg_set_and_check(struct e1000_adapter *adapter, u64 *data, int reg,
			      u32 mask, u32 write)
{
	struct e1000_hw *hw = &adapter->hw;
	u8 __iomem *address = hw->hw_addr + reg;
 647:	48 89 d8             	mov    %rbx,%rax
 64a:	48 03 87 c0 03 00 00 	add    0x3c0(%rdi),%rax
build_mmio_read(__readw, "w", unsigned short, "=r", )
build_mmio_read(__readl, "l", unsigned int, "=r", )

build_mmio_write(writeb, "b", unsigned char, "q", :"memory")
build_mmio_write(writew, "w", unsigned short, "r", :"memory")
build_mmio_write(writel, "l", unsigned int, "r", :"memory")
 651:	89 30                	mov    %esi,(%rax)
{ asm volatile("mov" size " %0,%1": :reg (val), \
"m" (*(volatile type __force *)addr) barrier); }

build_mmio_read(readb, "b", unsigned char, "=q", :"memory")
build_mmio_read(readw, "w", unsigned short, "=r", :"memory")
build_mmio_read(readl, "l", unsigned int, "=r", :"memory")
 653:	44 8b 08             	mov    (%rax),%r9d
	u32 read;

	writel(write & mask, address);
	read = readl(address);
	if ((read & mask) != (write & mask)) {
 656:	45 31 c8             	xor    %r9d,%r8d
		      "got 0x%08X expected 0x%08X\n",
		      reg, (read & mask), (write & mask));
		*data = reg;
		return true;
	}
	return false;
 659:	31 c0                	xor    %eax,%eax
	u8 __iomem *address = hw->hw_addr + reg;
	u32 read;

	writel(write & mask, address);
	read = readl(address);
	if ((read & mask) != (write & mask)) {
 65b:	41 85 c8             	test   %ecx,%r8d
 65e:	74 28                	je     688 <reg_set_and_check+0x58>
		e_err(drv, "set/check reg %04X test failed: "
 660:	f6 87 a0 07 00 00 01 	testb  $0x1,0x7a0(%rdi)
 667:	74 19                	je     682 <reg_set_and_check+0x52>
 669:	48 8b bf b0 03 00 00 	mov    0x3b0(%rdi),%rdi
 670:	41 89 f0             	mov    %esi,%r8d
 673:	44 21 c9             	and    %r9d,%ecx
 676:	48 c7 c6 00 00 00 00 	mov    $0x0,%rsi
 67d:	e8 00 00 00 00       	callq  682 <reg_set_and_check+0x52>
		      "got 0x%08X expected 0x%08X\n",
		      reg, (read & mask), (write & mask));
		*data = reg;
 682:	49 89 1c 24          	mov    %rbx,(%r12)
		return true;
 686:	b0 01                	mov    $0x1,%al
	}
	return false;
}
 688:	5b                   	pop    %rbx
 689:	41 5c                	pop    %r12
 68b:	5d                   	pop    %rbp
 68c:	c3                   	retq   

000000000000068d <dma_map_single_attrs.part.15>:
#include <linux/scatterlist.h>
#include <linux/dma-debug.h>
#include <linux/dma-attrs.h>
#include <asm-generic/dma-coherent.h>

static inline dma_addr_t dma_map_single_attrs(struct device *dev, void *ptr,
 68d:	55                   	push   %rbp
 68e:	48 89 e5             	mov    %rsp,%rbp
{
	struct dma_map_ops *ops = get_dma_ops(dev);
	dma_addr_t addr;

	kmemcheck_mark_initialized(ptr, size);
	BUG_ON(!valid_dma_direction(dir));
 691:	0f 0b                	ud2    

0000000000000693 <dma_unmap_single_attrs.part.16>:
			   (unsigned long)ptr & ~PAGE_MASK, size,
			   dir, addr, true);
	return addr;
}

static inline void dma_unmap_single_attrs(struct device *dev, dma_addr_t addr,
 693:	55                   	push   %rbp
 694:	48 89 e5             	mov    %rsp,%rbp
					  enum dma_data_direction dir,
					  struct dma_attrs *attrs)
{
	struct dma_map_ops *ops = get_dma_ops(dev);

	BUG_ON(!valid_dma_direction(dir));
 697:	0f 0b                	ud2    

Disassembly of section .init.text:

0000000000000000 <init_module>:
 *
 * e1000_init_module is the first routine called when the driver is
 * loaded. All it does is register with the PCI subsystem.
 **/
static int __init e1000_init_module(void)
{
   0:	55                   	push   %rbp
	int ret;
	pr_info("%s - version %s\n", e1000_driver_string, e1000_driver_version);
   1:	48 c7 c2 00 00 00 00 	mov    $0x0,%rdx
   8:	48 c7 c6 00 00 00 00 	mov    $0x0,%rsi
   f:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
  16:	31 c0                	xor    %eax,%eax
 *
 * e1000_init_module is the first routine called when the driver is
 * loaded. All it does is register with the PCI subsystem.
 **/
static int __init e1000_init_module(void)
{
  18:	48 89 e5             	mov    %rsp,%rbp
  1b:	53                   	push   %rbx
	int ret;
	pr_info("%s - version %s\n", e1000_driver_string, e1000_driver_version);
  1c:	e8 00 00 00 00       	callq  21 <init_module+0x21>

	pr_info("%s\n", e1000_copyright);
  21:	48 c7 c6 00 00 00 00 	mov    $0x0,%rsi
  28:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
  2f:	31 c0                	xor    %eax,%eax
  31:	e8 00 00 00 00       	callq  36 <init_module+0x36>

	ret = pci_register_driver(&e1000_driver);
  36:	48 c7 c6 00 00 00 00 	mov    $0x0,%rsi
  3d:	48 c7 c2 00 00 00 00 	mov    $0x0,%rdx
  44:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
  4b:	e8 00 00 00 00       	callq  50 <init_module+0x50>
	if (copybreak != COPYBREAK_DEFAULT) {
  50:	8b 35 00 00 00 00    	mov    0x0(%rip),%esi        # 56 <init_module+0x56>
	int ret;
	pr_info("%s - version %s\n", e1000_driver_string, e1000_driver_version);

	pr_info("%s\n", e1000_copyright);

	ret = pci_register_driver(&e1000_driver);
  56:	89 c3                	mov    %eax,%ebx
	if (copybreak != COPYBREAK_DEFAULT) {
  58:	81 fe 00 01 00 00    	cmp    $0x100,%esi
  5e:	74 22                	je     82 <init_module+0x82>
		if (copybreak == 0)
  60:	85 f6                	test   %esi,%esi
  62:	75 10                	jne    74 <init_module+0x74>
			pr_info("copybreak disabled\n");
  64:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
  6b:	31 c0                	xor    %eax,%eax
  6d:	e8 00 00 00 00       	callq  72 <init_module+0x72>
  72:	eb 0e                	jmp    82 <init_module+0x82>
		else
			pr_info("copybreak enabled for "
  74:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
  7b:	31 c0                	xor    %eax,%eax
  7d:	e8 00 00 00 00       	callq  82 <init_module+0x82>
				   "packets <= %u bytes\n", copybreak);
	}
	return ret;
}
  82:	89 d8                	mov    %ebx,%eax
  84:	5b                   	pop    %rbx
  85:	5d                   	pop    %rbp
  86:	c3                   	retq   

Disassembly of section .exit.text:

0000000000000000 <cleanup_module>:
 *
 * e1000_exit_module is called just before the driver is removed
 * from memory.
 **/
static void __exit e1000_exit_module(void)
{
   0:	55                   	push   %rbp
	pci_unregister_driver(&e1000_driver);
   1:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
 *
 * e1000_exit_module is called just before the driver is removed
 * from memory.
 **/
static void __exit e1000_exit_module(void)
{
   8:	48 89 e5             	mov    %rsp,%rbp
	pci_unregister_driver(&e1000_driver);
   b:	e8 00 00 00 00       	callq  10 <cleanup_module+0x10>
}
  10:	5d                   	pop    %rbp
  11:	c3                   	retq   
